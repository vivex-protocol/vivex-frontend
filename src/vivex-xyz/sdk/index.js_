var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// ../node_modules/@mean-finance/sdk/dist/chains.js
var require_chains = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/chains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chainsUnion = exports.chainsIntersection = exports.getChainByKeyOrFail = exports.getChainByKey = exports.getAllChains = exports.Chains = void 0;
    exports.Chains = {
      ETHEREUM: {
        chainId: 1,
        name: "Ethereum",
        ids: ["ethereum", "mainnet", "homestead"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
        publicRPCs: [
          "https://rpc.ankr.com/eth",
          "https://eth-mainnet.gateway.pokt.network/v1/5f3453978e354ab992c4da79",
          "https://cloudflare-eth.com/",
          "https://main-light.eth.linkpool.io/",
          "https://api.mycryptoapi.com/eth"
        ],
        explorer: "https://etherscan.io/"
      },
      OPTIMISM: {
        chainId: 10,
        name: "Optimism",
        ids: ["optimism"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0x4200000000000000000000000000000000000006",
        publicRPCs: [
          "https://mainnet.optimism.io/",
          "https://1rpc.io/op",
          "https://optimism.api.onfinality.io/public",
          "https://endpoints.omniatech.io/v1/op/mainnet/public",
          "https://opt-mainnet.g.alchemy.com/v2/demo",
          "https://optimism.blockpi.network/v1/rpc/public",
          "https://optimism-mainnet.public.blastapi.io",
          "https://rpc.ankr.com/optimism	"
        ],
        explorer: "https://optimistic.etherscan.io/"
      },
      ARBITRUM: {
        chainId: 42161,
        name: "Arbitrum",
        ids: ["arbitrum"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
        publicRPCs: [
          "https://arb1.arbitrum.io/rpc",
          "https://arb-mainnet-public.unifra.io",
          "https://arbitrum-one.public.blastapi.io",
          "https://arb1.croswap.com/rpc",
          "https://endpoints.omniatech.io/v1/arbitrum/one/public",
          "https://arbitrum.blockpi.network/v1/rpc/public",
          "https://rpc.ankr.com/arbitrum"
        ],
        explorer: "https://arbiscan.io/"
      },
      ARBITRUM_NOVA: {
        chainId: 42170,
        name: "Arbitrum Nova",
        ids: ["nova"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0x722e8bdd2ce80a4422e880164f2079488e115365",
        publicRPCs: ["https://nova.arbitrum.io/rpc"],
        explorer: "https://nova.arbiscan.io/"
      },
      POLYGON: {
        chainId: 137,
        name: "Polygon",
        ids: ["polygon", "matic"],
        nativeCurrency: { symbol: "MATIC", name: "Matic" },
        wToken: "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270",
        publicRPCs: [
          "https://polygon-rpc.com",
          "https://polygon.llamarpc.com",
          "https://rpc-mainnet.maticvigil.com",
          "https://polygon-bor.publicnode.com",
          "https://poly-rpc.gateway.pokt.network",
          "https://polygon-mainnet.public.blastapi.io",
          "https://rpc.ankr.com/polygon",
          "https://rpc-mainnet.matic.quiknode.pro",
          "https://matic-mainnet.chainstacklabs.com"
        ],
        explorer: "https://polygonscan.com/"
      },
      BNB_CHAIN: {
        chainId: 56,
        name: "BNB Chain",
        ids: ["bsc", "bnb"],
        nativeCurrency: { symbol: "BNB", name: "BNB" },
        wToken: "0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c",
        publicRPCs: [
          "https://rpc.ankr.com/bsc",
          "https://bsc-dataseed.binance.org",
          "https://bsc-dataseed1.defibit.io",
          "https://bsc-dataseed1.ninicoin.io",
          "https://bsc-dataseed1.binance.org",
          "https://bsc-dataseed2.defibit.io",
          "https://bsc-dataseed2.ninicoin.io",
          "https://bsc-dataseed2.binance.org",
          "https://bsc-dataseed3.defibit.io",
          "https://bsc-dataseed3.binance.org",
          "https://bsc-dataseed3.ninicoin.io",
          "https://bsc-dataseed4.defibit.io",
          "https://bsc-dataseed4.binance.org",
          "https://bsc-dataseed4.ninicoin.io",
          "https://bsc.rpc.blxrbdn.com",
          "https://bsc.publicnode.com",
          "https://bsc.meowrpc.com",
          "https://bsc.blockpi.network/v1/rpc/public",
          "https://endpoints.omniatech.io/v1/bsc/mainnet/public",
          "https://1rpc.io/bnb",
          "https://bscrpc.com",
          "https://bsc-mainnet.public.blastapi.io",
          "https://bnb.api.onfinality.io/public"
        ],
        explorer: "https://bscscan.com/"
      },
      BASE: {
        chainId: 8453,
        name: "Base",
        ids: ["base"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0x4200000000000000000000000000000000000006",
        publicRPCs: ["https://mainnet.base.org", "https://base-mainnet.public.blastapi.io", "https://base.blockpi.network/v1/rpc/public"],
        explorer: "https://basescan.org/"
      },
      FANTOM: {
        chainId: 250,
        name: "Fantom",
        ids: ["fantom"],
        nativeCurrency: { symbol: "FTM", name: "Fantom" },
        wToken: "0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83",
        publicRPCs: ["https://rpc.fantom.network", "https://rpc.ftm.tools/", "https://rpc.ankr.com/fantom", "https://rpcapi.fantom.network"],
        explorer: "https://ftmscan.com/"
      },
      CELO: {
        chainId: 42220,
        name: "Celo",
        ids: ["celo"],
        nativeCurrency: { symbol: "CELO", name: "Celo" },
        wToken: "0x149d5bf28fbace2950b52d4aca1c79bfd9bbb6fc",
        publicRPCs: ["https://rpc.ankr.com/celo", "https://celo-mainnet-archive.allthatnode.com", "https://celo-mainnet-rpc.allthatnode.com"],
        explorer: "https://celoscan.io/"
      },
      AVALANCHE: {
        chainId: 43114,
        name: "Avalanche",
        ids: ["avalanche", "avax"],
        nativeCurrency: { symbol: "AVAX", name: "Avalanche" },
        wToken: "0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7",
        publicRPCs: ["https://api.avax.network/ext/bc/C/rpc", "https://rpc.ankr.com/avalanche"],
        explorer: "https://cchain.explorer.avax.network/"
      },
      HECO: {
        chainId: 128,
        name: "Heco",
        ids: ["heco"],
        nativeCurrency: { symbol: "HT", name: "Heco" },
        wToken: "0x5545153ccfca01fbd7dd11c0b23ba694d9509a6f",
        publicRPCs: ["https://http-mainnet.hecochain.com", "https://pub001.hg.network/rpc"],
        explorer: "https://scan.hecochain.com/"
      },
      OKC: {
        chainId: 66,
        name: "OKC",
        ids: ["okc", "okexchain"],
        nativeCurrency: { symbol: "OKT", name: "OKC Token" },
        wToken: "0x8f8526dbfd6e38e3d8307702ca8469bae6c56c15",
        publicRPCs: ["https://exchainrpc.okex.org", "https://okc-mainnet.gateway.pokt.network/v1/lb/6275309bea1b320039c893ff"],
        explorer: "https://www.oklink.com/en/okc/"
      },
      MOONRIVER: {
        chainId: 1285,
        name: "Moonriver",
        ids: ["moonriver"],
        nativeCurrency: { symbol: "MOVR", name: "Moonriver" },
        wToken: "0x98878b06940ae243284ca214f92bb71a2b032b8a",
        publicRPCs: ["https://rpc.api.moonriver.moonbeam.network/", "https://moonriver.api.onfinality.io/public"],
        explorer: "https://moonriver.moonscan.io/"
      },
      MOONBEAM: {
        chainId: 1284,
        name: "Moonbeam",
        ids: ["moonbeam"],
        nativeCurrency: { symbol: "GLMR", name: "Moonbeam" },
        wToken: "0xAcc15dC74880C9944775448304B263D191c6077F",
        publicRPCs: ["https://rpc.api.moonbeam.network"],
        explorer: "https://moonscan.io/"
      },
      FUSE: {
        chainId: 122,
        name: "Fuse",
        ids: ["fuse"],
        nativeCurrency: { symbol: "FUSE", name: "Fuse" },
        wToken: "0x0BE9e53fd7EDaC9F859882AfdDa116645287C629",
        publicRPCs: ["https://fuse-rpc.gateway.pokt.network", "https://fuse-mainnet.chainstacklabs.com", "https://rpc.fuse.io"],
        explorer: "https://explorer.fuse.io/"
      },
      VELAS: {
        chainId: 106,
        name: "Velas",
        ids: ["velas"],
        nativeCurrency: { symbol: "VLX", name: "Velas" },
        wToken: "0xc579D1f3CF86749E05CD06f7ADe17856c2CE3126",
        publicRPCs: ["https://evmexplorer.velas.com/api/eth-rpc", "https://explorer.velas.com/rpc"],
        explorer: "https://explorer.velas.com/"
      },
      GNOSIS: {
        chainId: 100,
        name: "Gnosis Chain",
        ids: ["gnosis", "xdai"],
        nativeCurrency: { symbol: "xDAI", name: "xDAI" },
        wToken: "0xe91d153e0b41518a2ce8dd3d7944fa863463a97d",
        publicRPCs: [
          "https://rpc.gnosischain.com/",
          "https://gnosischain-rpc.gateway.pokt.network",
          "https://xdai-rpc.gateway.pokt.network",
          "https://rpc.ankr.com/gnosis",
          "https://xdai-archive.blockscout.com",
          "https://gnosis-mainnet.public.blastapi.io",
          "https://gnosis.blockpi.network/v1/rpc/public",
          "https://rpc.gnosis.gateway.fm"
        ],
        explorer: "https://gnosisscan.io/"
      },
      CRONOS: {
        chainId: 25,
        name: "Cronos",
        ids: ["cronos"],
        nativeCurrency: { symbol: "CRO", name: "Cronos" },
        wToken: "0x5c7f8a570d578ed84e63fdfa7b1ee72deae1ae23",
        publicRPCs: ["https://cronosrpc-1.xstaking.sg", "https://evm.cronos.org", "https://rpc.vvs.finance", "https://evm-cronos.crypto.org"],
        explorer: "https://cronoscan.com/"
      },
      BOBA: {
        chainId: 288,
        name: "Boba Network",
        ids: ["boba"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000",
        publicRPCs: [
          "https://mainnet.boba.network/",
          "https://lightning-replica.boba.network",
          "https://boba-mainnet.gateway.pokt.network/v1/lb/623ad21b20354900396fed7f"
        ],
        explorer: "https://bobascan.com/"
      },
      ONTOLOGY: {
        chainId: 58,
        name: "Ontology",
        ids: ["ont", "ontology"],
        nativeCurrency: { symbol: "ONG", name: "Ontology Gas" },
        wToken: "0xd8bc24cfd45452ef2c8bc7618e32330b61f2691b",
        publicRPCs: [
          "https://dappnode1.ont.io:10339",
          "https://dappnode2.ont.io:10339",
          "https://dappnode3.ont.io:10339",
          "https://dappnode4.ont.io:10339"
        ],
        explorer: "https://explorer.ont.io/"
      },
      KLAYTN: {
        chainId: 8217,
        name: "Klaytn",
        ids: ["klaytn"],
        nativeCurrency: { symbol: "KLAY", name: "Klaytn" },
        wToken: "0xe4f05a66ec68b54a58b17c22107b02e0232cc817",
        publicRPCs: ["https://public-en-cypress.klaytn.net", "https://public-node-api.klaytnapi.com/v1/cypress"],
        explorer: "https://scope.klaytn.com/"
      },
      AURORA: {
        chainId: 1313161554,
        name: "Aurora",
        ids: ["aurora"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0xc9bdeed33cd01541e1eed10f90519d2c06fe3feb",
        publicRPCs: ["https://endpoints.omniatech.io/v1/aurora/mainnet/public", "https://mainnet.aurora.dev"],
        explorer: "https://explorer.mainnet.aurora.dev/"
      },
      ASTAR: {
        chainId: 592,
        name: "Astar",
        ids: ["astar"],
        nativeCurrency: { symbol: "ASTR", name: "Astar" },
        wToken: "0xaeaaf0e2c81af264101b9129c00f4440ccf0f720",
        publicRPCs: ["https://evm.astar.network/", "https://rpc.astar.network:8545", "https://astar.api.onfinality.io/public"],
        explorer: "https://astar.subscan.io/"
      },
      HARMONY_SHARD_0: {
        chainId: 16666e5,
        name: "Harmony",
        ids: ["harmony"],
        nativeCurrency: { symbol: "ONE", name: "Harmony" },
        wToken: "0xcf664087a5bb0237a0bad6742852ec6c8d69a27a",
        publicRPCs: ["https://api.harmony.one"],
        explorer: "https://explorer.harmony.one/"
      },
      BIT_TORRENT: {
        chainId: 199,
        name: "BitTorrent",
        ids: ["bittorrent"],
        nativeCurrency: { symbol: "BTT", name: "BitTorrent" },
        wToken: "0x23181f21dea5936e24163ffaba4ea3b316b57f3c",
        publicRPCs: ["https://rpc.bittorrentchain.io"],
        explorer: "https://bttcscan.com/"
      },
      OASIS_EMERALD: {
        chainId: 42262,
        name: "Oasis Emerald",
        ids: ["oasis", "emerald"],
        nativeCurrency: { symbol: "ROSE", name: "Oasis Network" },
        wToken: "0x21C718C22D52d0F3a789b752D4c2fD5908a8A733",
        publicRPCs: ["https://emerald.oasis.dev"],
        explorer: "https://explorer.emerald.oasis.dev/"
      },
      CANTO: {
        chainId: 7700,
        name: "Canto",
        ids: ["canto"],
        nativeCurrency: { symbol: "CANTO", name: "Canto" },
        wToken: "0x826551890Dc65655a0Aceca109aB11AbDbD7a07B",
        publicRPCs: ["https://mainnode.plexnode.org:8545", "https://canto.slingshot.finance"],
        explorer: "https://evm.explorer.canto.io/"
      },
      EVMOS: {
        chainId: 9001,
        name: "EVMOS",
        ids: ["evmos"],
        nativeCurrency: { symbol: "EVMOS", name: "Evmos" },
        wToken: "0xD4949664cD82660AaE99bEdc034a0deA8A0bd517",
        publicRPCs: ["https://evmos-evm.publicnode.com", "https://eth.bd.evmos.org:8545", "https://evmos-mainnet.public.blastapi.io"],
        explorer: "https://escan.live/"
      },
      ROOTSTOCK: {
        chainId: 30,
        name: "Rootstock",
        ids: ["rsk"],
        nativeCurrency: { symbol: "RBTC", name: "Rootstock RSK" },
        wToken: "0x542fda317318ebf1d3deaf76e0b632741a7e677d",
        publicRPCs: ["https://mycrypto.rsk.co", "https://public-node.rsk.co"],
        explorer: "https://explorer.rsk.co/"
      },
      POLYGON_ZKEVM: {
        chainId: 1101,
        name: "Polygon zkEVM",
        ids: ["polygon-zkevm"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0x4f9a0e7fd2bf6067db6994cf12e4495df938e6e9",
        publicRPCs: ["https://zkevm-rpc.com", "https://rpc.ankr.com/polygon_zkevm", "https://rpc.polygon-zkevm.gateway.fm"],
        explorer: "https://zkevm.polygonscan.com/"
      },
      KAVA: {
        chainId: 2222,
        name: "Kava",
        ids: ["kava"],
        nativeCurrency: { symbol: "KAVA", name: "Kava" },
        wToken: "0xc86c7c0efbd6a49b35e8714c5f59d99de09a225b",
        publicRPCs: ["https://evm.kava.io", "https://evm2.kava.io"],
        explorer: "https://explorer.kava.io/"
      },
      LINEA: {
        chainId: 59144,
        name: "Linea",
        ids: ["linea"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0xe5d7c2a44ffddf6b295a15c148167daaaf5cf34f",
        publicRPCs: ["https://rpc.linea.build", "https://1rpc.io/linea", "https://linea.blockpi.network/v1/rpc/public", "https://linea.drpc.org"],
        explorer: "https://lineascan.build/"
      },
      ETHEREUM_GOERLI: {
        chainId: 5,
        name: "Ethereum Goerli",
        ids: ["goerli"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6",
        publicRPCs: ["https://rpc.ankr.com/eth_goerli", "https://goerli.blockpi.network/v1/rpc/public"],
        explorer: "https://goerli.etherscan.io/",
        testnet: true
      },
      ETHEREUM_SEPOLIA: {
        chainId: 11155111,
        name: "Ethereum Sepolia",
        ids: ["sepolia"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0xf531b8f309be94191af87605cfbf600d71c2cfe0",
        publicRPCs: ["https://rpc.sepolia.org"],
        explorer: "https://sepolia.etherscan.io/",
        testnet: true
      },
      POLYGON_MUMBAI: {
        chainId: 80001,
        name: "Polygon Mumbai",
        ids: ["mumbai"],
        nativeCurrency: { symbol: "MATIC", name: "Matic" },
        wToken: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
        publicRPCs: ["https://rpc.ankr.com/polygon_mumbai", "https://polygon-mumbai.blockpi.network/v1/rpc/public"],
        explorer: "https://mumbai.polygonscan.com/",
        testnet: true
      },
      BASE_GOERLI: {
        chainId: 84531,
        name: "Base Goerli",
        ids: ["base-goerli"],
        nativeCurrency: { symbol: "ETH", name: "Ethereum" },
        wToken: "0x4200000000000000000000000000000000000006",
        publicRPCs: ["https://goerli.base.org", "https://base-goerli.public.blastapi.io"],
        explorer: "https://goerli.basescan.org/",
        testnet: true
      }
    };
    function getAllChains() {
      return Object.values(exports.Chains);
    }
    exports.getAllChains = getAllChains;
    function getChainByKey(key) {
      const toLower = `${key}`.toLowerCase();
      return getAllChains().find(({ chainId, ids }) => `${chainId}` === toLower || ids.includes(toLower));
    }
    exports.getChainByKey = getChainByKey;
    function getChainByKeyOrFail(key) {
      const chain = getChainByKey(key);
      if (!chain)
        throw new Error(`Failed to find a chain with key '${key}'`);
      return chain;
    }
    exports.getChainByKeyOrFail = getChainByKeyOrFail;
    function chainsIntersection(chains1, ...otherChains) {
      const chainSet = new Set(chains1);
      for (const chainList of otherChains) {
        const toCompare = new Set(chainList);
        for (const chainId of chainSet) {
          if (!toCompare.has(chainId)) {
            chainSet.delete(chainId);
          }
        }
      }
      return [...chainSet];
    }
    exports.chainsIntersection = chainsIntersection;
    function chainsUnion(chains) {
      const chainSet = /* @__PURE__ */ new Set();
      for (const chainList of chains) {
        for (const chain of chainList) {
          chainSet.add(chain);
        }
      }
      return [...chainSet];
    }
    exports.chainsUnion = chainsUnion;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/logs/utils.js
var require_utils = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/logs/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldPrintLog = void 0;
    function shouldPrintLog(logType, currentLevel) {
      return getLogPriority(logType) >= getLogPriority(currentLevel);
    }
    exports.shouldPrintLog = shouldPrintLog;
    function getLogPriority(level) {
      switch (level) {
        case "ALL":
          return 0;
        case "LOG":
        case "DEBUG":
          return 10;
        case "INFO":
          return 20;
        case "WARN":
          return 30;
        case "ERROR":
          return 40;
        case "OFF":
          return Infinity;
      }
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/logs/loggers/console-logger.js
var require_console_logger = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/logs/loggers/console-logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleLogger = void 0;
    var utils_1 = require_utils();
    var ConsoleLogger = class {
      constructor(name, level) {
        this.name = name;
        this.level = level;
      }
      log(message, ...optionalParams) {
        this.print("LOG", message, optionalParams);
      }
      debug(message, ...optionalParams) {
        this.print("DEBUG", message, optionalParams);
      }
      info(message, ...optionalParams) {
        this.print("INFO", message, optionalParams);
      }
      warn(message, ...optionalParams) {
        this.print("WARN", message, optionalParams);
      }
      error(message, ...optionalParams) {
        this.print("ERROR", message, optionalParams);
      }
      print(level, message, optionalParams) {
        if ((0, utils_1.shouldPrintLog)(level, this.level)) {
          if (optionalParams.length > 1) {
            return console.log(new Date().toISOString() + " [" + level + "] (" + this.name + "): " + (message ?? ""), ...optionalParams);
          } else {
            return console.log(new Date().toISOString() + " [" + level + "] (" + this.name + "): " + (message ?? ""));
          }
        }
      }
    };
    exports.ConsoleLogger = ConsoleLogger;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/logs/logs-service.js
var require_logs_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/logs/logs-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogsService = void 0;
    var console_logger_1 = require_console_logger();
    var LogsService = class {
      constructor(defaultLevel) {
        this.defaultLevel = defaultLevel;
      }
      getLogger({ name }) {
        return new console_logger_1.ConsoleLogger(name, this.defaultLevel);
      }
    };
    exports.LogsService = LogsService;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/logs-builder.js
var require_logs_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/logs-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildLogsService = void 0;
    var logs_service_1 = require_logs_service();
    function buildLogsService(params) {
      return new logs_service_1.LogsService(params?.level ?? "WARN");
    }
    exports.buildLogsService = buildLogsService;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/ms/dist/index.cjs
var require_dist = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/ms/dist/index.cjs"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    function ms(value, options) {
      try {
        if (typeof value === "string" && value.length > 0) {
          return parse(value);
        } else if (typeof value === "number" && isFinite(value)) {
          return options?.long ? fmtLong(value) : fmtShort(value);
        }
        throw new Error("Value is not a string or number.");
      } catch (error) {
        const message = isError(error) ? `${error.message}. value=${JSON.stringify(value)}` : "An unknown error has occured.";
        throw new Error(message);
      }
    }
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        throw new Error("Value exceeds the maximum length of 100 characters.");
      }
      const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return NaN;
      }
      const n = parseFloat(match[1]);
      const type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          throw new Error(`The unit ${type} was matched, but no matching case exists.`);
      }
    }
    exports.default = ms;
    function fmtShort(ms2) {
      const msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return `${Math.round(ms2 / d)}d`;
      }
      if (msAbs >= h) {
        return `${Math.round(ms2 / h)}h`;
      }
      if (msAbs >= m) {
        return `${Math.round(ms2 / m)}m`;
      }
      if (msAbs >= s) {
        return `${Math.round(ms2 / s)}s`;
      }
      return `${ms2}ms`;
    }
    function fmtLong(ms2) {
      const msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural(ms2, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return `${ms2} ms`;
    }
    function plural(ms2, msAbs, n, name) {
      const isPlural = msAbs >= n * 1.5;
      return `${Math.round(ms2 / n)} ${name}${isPlural ? "s" : ""}`;
    }
    function isError(error) {
      return typeof error === "object" && error !== null && "message" in error;
    }
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// ../node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "../node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof window.self !== "undefined" ? window.self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes4) {
            if (bytes4) {
              var split2 = bytes4.split("=");
              var name = split2.shift().replace(/\+/g, " ");
              var value = split2.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/timeouts.js
var require_timeouts = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/timeouts.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reduceTimeout = exports.timeoutPromise = exports.TimeoutError = void 0;
    var ms_1 = __importDefault(require_dist());
    var TimeoutError = class extends Error {
      constructor(description, timeout) {
        super(`${description} timeouted at ${timeout}`);
      }
    };
    exports.TimeoutError = TimeoutError;
    function timeoutPromise2(promise, timeout, options) {
      if (!timeout)
        return promise;
      const realTimeout = options?.reduceBy ? reduceTimeout(timeout, options.reduceBy) : timeout;
      return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
          reject(new TimeoutError(options?.description ?? "Promise", timeout));
        }, (0, ms_1.default)(realTimeout));
        promise.then(resolve).catch(reject).finally(() => clearTimeout(timer));
      });
    }
    exports.timeoutPromise = timeoutPromise2;
    function reduceTimeout(timeout, reduceBy) {
      if (!timeout)
        return void 0;
      const millisTimeout = (0, ms_1.default)(timeout);
      const millisToTakeOut = (0, ms_1.default)(reduceBy);
      return millisTimeout > millisToTakeOut ? (millisTimeout - millisToTakeOut).toString() : Math.floor(millisTimeout * 3 / 4).toString();
    }
    exports.reduceTimeout = reduceTimeout;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/fetch/fetch-service.js
var require_fetch_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/fetch/fetch-service.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchService = void 0;
    var ms_1 = __importDefault(require_dist());
    var cross_fetch_1 = __importDefault(require_browser_ponyfill());
    var timeouts_1 = require_timeouts();
    var FetchService = class {
      constructor(realFetch = cross_fetch_1.default) {
        this.realFetch = realFetch;
      }
      async fetch(url, init) {
        const { timeout: timeoutText, ...otherConfig } = init ?? {};
        const timeout = timeoutText ?? "5m";
        const controller = new AbortController();
        let timeouted = false;
        const timeoutId = setTimeout(() => {
          timeouted = true;
          controller.abort();
        }, (0, ms_1.default)(timeout));
        try {
          return await this.realFetch(url, { ...otherConfig, signal: controller.signal });
        } catch (e) {
          if (timeouted) {
            throw new timeouts_1.TimeoutError(`Request to ${url}`, timeout);
          }
          throw e;
        } finally {
          clearTimeout(timeoutId);
        }
      }
    };
    exports.FetchService = FetchService;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/fetch-builder.js
var require_fetch_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/fetch-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildFetchService = void 0;
    var fetch_service_1 = require_fetch_service();
    function buildFetchService(params) {
      return new fetch_service_1.FetchService(params?.fetch);
    }
    exports.buildFetchService = buildFetchService;
  }
});

// (disabled):../node_modules/buffer/index.js
var require_buffer = __commonJS({
  "(disabled):../node_modules/buffer/index.js"() {
  }
});

// ../node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "../node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number3, base, endian) {
        if (BN.isBN(number3)) {
          return number3;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number3 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number3 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number3, base, endian) {
        if (typeof number3 === "number") {
          return this._initNumber(number3, base, endian);
        }
        if (typeof number3 === "object") {
          return this._initArray(number3, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert2(base === (base | 0) && base >= 2 && base <= 36);
        number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number3.length) {
          if (base === 16) {
            this._parseHex(number3, start, endian);
          } else {
            this._parseBase(number3, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number3, base, endian) {
        if (number3 < 0) {
          this.negative = 1;
          number3 = -number3;
        }
        if (number3 < 67108864) {
          this.words = [number3 & 67108863];
          this.length = 1;
        } else if (number3 < 4503599627370496) {
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number3 < 9007199254740992);
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number3, base, endian) {
        assert2(typeof number3.length === "number");
        if (number3.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number3.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number3.length - 1, j = 0; i >= 0; i -= 3) {
            w = number3[i] | number3[i - 1] << 8 | number3[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number3.length; i += 3) {
            w = number3[i] | number3[i + 1] << 8 | number3[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index2) {
        var c = string.charCodeAt(index2);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert2(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index2) {
        var r = parseHex4Bits(string, index2);
        if (index2 - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index2 - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number3.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number3, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number3.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number3.length; i += 2) {
            w = parseHexByte(number3, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert2(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number3, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number3.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number3, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number3, i, number3.length, base);
          for (i = 0; i < mod2; i++) {
            pow3 *= base;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size3) {
        while (this.length < size3) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size3) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size3);
        }
        return new ArrayType(size3);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t = new Array(N2);
        var l = BN.prototype._countBits(N2) - 1;
        for (var i = 0; i < N2; i++) {
          t[i] = this.revBin(i, l, N2);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N2) {
        if (x === 0 || x === N2 - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i = 0; i < N2; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s = 1; s < N2; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N2; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N2 = Math.max(m, n) | 1;
        var odd = N2 & 1;
        var i = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1)
          return;
        for (var i = 0; i < N2 / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N2 - i - 1];
          rws[N2 - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N2 - i - 1];
          iws[N2 - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N2) {
        var carry = 0;
        for (var i = 0; i < N2 / 2; i++) {
          var w = Math.round(ws2[2 * i + 1] / N2) * 8192 + Math.round(ws2[2 * i] / N2) + carry;
          ws2[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N2) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws2[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N2; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i = 0; i < N2; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N2 = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N2);
        var _ = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x.words, x.length, rws, N2);
        this.convert13b(y.words, y.length, nrws, N2);
        this.transform(rws, _, rwst, iwst, N2, rbt);
        this.transform(nrws, _, nrwst, niwst, N2, rbt);
        for (var i = 0; i < N2; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _, N2, rbt);
        this.conjugate(rmws, _, N2);
        this.normalize13b(rmws, N2);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output3) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output3.words[i] = input.words[i];
        }
        output3.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output3.words[output3.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// ../node_modules/@ethersproject/logger/lib/_version.js
var require_version = __commonJS({
  "../node_modules/@ethersproject/logger/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "logger/5.7.0";
  }
});

// ../node_modules/@ethersproject/logger/lib/index.js
var require_lib = __commonJS({
  "../node_modules/@ethersproject/logger/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = exports.ErrorCode = exports.LogLevel = void 0;
    var _permanentCensorErrors3 = false;
    var _censorErrors3 = false;
    var LogLevels3 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    var _logLevel3 = LogLevels3["default"];
    var _version_1 = require_version();
    var _globalLogger3 = null;
    function _checkNormalize3() {
      try {
        var missing_1 = [];
        ["NFD", "NFC", "NFKD", "NFKC"].forEach(function(form) {
          try {
            if ("test".normalize(form) !== "test") {
              throw new Error("bad normalize");
            }
            ;
          } catch (error) {
            missing_1.push(form);
          }
        });
        if (missing_1.length) {
          throw new Error("missing " + missing_1.join(", "));
        }
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
          throw new Error("broken implementation");
        }
      } catch (error) {
        return error.message;
      }
      return null;
    }
    var _normalizeError3 = _checkNormalize3();
    var LogLevel3;
    (function(LogLevel4) {
      LogLevel4["DEBUG"] = "DEBUG";
      LogLevel4["INFO"] = "INFO";
      LogLevel4["WARNING"] = "WARNING";
      LogLevel4["ERROR"] = "ERROR";
      LogLevel4["OFF"] = "OFF";
    })(LogLevel3 = exports.LogLevel || (exports.LogLevel = {}));
    var ErrorCode3;
    (function(ErrorCode4) {
      ErrorCode4["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode4["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode4["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode4["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode4["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode4["TIMEOUT"] = "TIMEOUT";
      ErrorCode4["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode4["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode4["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode4["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode4["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode4["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode4["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode4["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode4["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode4["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode4["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode4["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode4["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode3 = exports.ErrorCode || (exports.ErrorCode = {}));
    var HEX3 = "0123456789abcdef";
    var Logger15 = function() {
      function Logger16(version11) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version11,
          writable: false
        });
      }
      Logger16.prototype._log = function(logLevel, args) {
        var level = logLevel.toLowerCase();
        if (LogLevels3[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel3 > LogLevels3[level]) {
          return;
        }
        console.log.apply(console, args);
      };
      Logger16.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._log(Logger16.levels.DEBUG, args);
      };
      Logger16.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._log(Logger16.levels.INFO, args);
      };
      Logger16.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._log(Logger16.levels.WARNING, args);
      };
      Logger16.prototype.makeError = function(message, code, params) {
        if (_censorErrors3) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = Logger16.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        var messageDetails = [];
        Object.keys(params).forEach(function(key) {
          var value = params[key];
          try {
            if (value instanceof Uint8Array) {
              var hex = "";
              for (var i = 0; i < value.length; i++) {
                hex += HEX3[value[i] >> 4];
                hex += HEX3[value[i] & 15];
              }
              messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
          }
        });
        messageDetails.push("code=" + code);
        messageDetails.push("version=" + this.version);
        var reason = message;
        var url = "";
        switch (code) {
          case ErrorCode3.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            var fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode3.CALL_EXCEPTION:
          case ErrorCode3.INSUFFICIENT_FUNDS:
          case ErrorCode3.MISSING_NEW:
          case ErrorCode3.NONCE_EXPIRED:
          case ErrorCode3.REPLACEMENT_UNDERPRICED:
          case ErrorCode3.TRANSACTION_REPLACED:
          case ErrorCode3.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        var error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key) {
          error[key] = params[key];
        });
        return error;
      };
      Logger16.prototype.throwError = function(message, code, params) {
        throw this.makeError(message, code, params);
      };
      Logger16.prototype.throwArgumentError = function(message, name, value) {
        return this.throwError(message, Logger16.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      };
      Logger16.prototype.assert = function(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      };
      Logger16.prototype.assertArgument = function(condition, message, name, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      };
      Logger16.prototype.checkNormalize = function(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError3) {
          this.throwError("platform missing String.prototype.normalize", Logger16.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError3
          });
        }
      };
      Logger16.prototype.checkSafeUint53 = function(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, Logger16.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, Logger16.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      };
      Logger16.prototype.checkArgumentCount = function(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, Logger16.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, Logger16.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      };
      Logger16.prototype.checkNew = function(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", Logger16.errors.MISSING_NEW, { name: kind.name });
        }
      };
      Logger16.prototype.checkAbstract = function(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger16.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", Logger16.errors.MISSING_NEW, { name: kind.name });
        }
      };
      Logger16.globalLogger = function() {
        if (!_globalLogger3) {
          _globalLogger3 = new Logger16(_version_1.version);
        }
        return _globalLogger3;
      };
      Logger16.setCensorship = function(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", Logger16.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors3) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", Logger16.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors3 = !!censorship;
        _permanentCensorErrors3 = !!permanent;
      };
      Logger16.setLogLevel = function(logLevel) {
        var level = LogLevels3[logLevel.toLowerCase()];
        if (level == null) {
          Logger16.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel3 = level;
      };
      Logger16.from = function(version11) {
        return new Logger16(version11);
      };
      Logger16.errors = ErrorCode3;
      Logger16.levels = LogLevel3;
      return Logger16;
    }();
    exports.Logger = Logger15;
  }
});

// ../node_modules/@ethersproject/bytes/lib/_version.js
var require_version2 = __commonJS({
  "../node_modules/@ethersproject/bytes/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "bytes/5.7.0";
  }
});

// ../node_modules/@ethersproject/bytes/lib/index.js
var require_lib2 = __commonJS({
  "../node_modules/@ethersproject/bytes/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version2();
    var logger15 = new logger_1.Logger(_version_1.version);
    function isHexable(value) {
      return !!value.toHexString;
    }
    function addSlice(array) {
      if (array.slice) {
        return array;
      }
      array.slice = function() {
        var args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
      };
      return array;
    }
    function isBytesLike2(value) {
      return isHexString5(value) && !(value.length % 2) || isBytes4(value);
    }
    exports.isBytesLike = isBytesLike2;
    function isInteger(value) {
      return typeof value === "number" && value == value && value % 1 === 0;
    }
    function isBytes4(value) {
      if (value == null) {
        return false;
      }
      if (value.constructor === Uint8Array) {
        return true;
      }
      if (typeof value === "string") {
        return false;
      }
      if (!isInteger(value.length) || value.length < 0) {
        return false;
      }
      for (var i = 0; i < value.length; i++) {
        var v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
          return false;
        }
      }
      return true;
    }
    exports.isBytes = isBytes4;
    function arrayify15(value, options) {
      if (!options) {
        options = {};
      }
      if (typeof value === "number") {
        logger15.checkSafeUint53(value, "invalid arrayify value");
        var result = [];
        while (value) {
          result.unshift(value & 255);
          value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
          result.push(0);
        }
        return addSlice(new Uint8Array(result));
      }
      if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexable(value)) {
        value = value.toHexString();
      }
      if (isHexString5(value)) {
        var hex = value.substring(2);
        if (hex.length % 2) {
          if (options.hexPad === "left") {
            hex = "0" + hex;
          } else if (options.hexPad === "right") {
            hex += "0";
          } else {
            logger15.throwArgumentError("hex data is odd-length", "value", value);
          }
        }
        var result = [];
        for (var i = 0; i < hex.length; i += 2) {
          result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
      }
      if (isBytes4(value)) {
        return addSlice(new Uint8Array(value));
      }
      return logger15.throwArgumentError("invalid arrayify value", "value", value);
    }
    exports.arrayify = arrayify15;
    function concat9(items) {
      var objects = items.map(function(item) {
        return arrayify15(item);
      });
      var length = objects.reduce(function(accum, item) {
        return accum + item.length;
      }, 0);
      var result = new Uint8Array(length);
      objects.reduce(function(offset, object) {
        result.set(object, offset);
        return offset + object.length;
      }, 0);
      return addSlice(result);
    }
    exports.concat = concat9;
    function stripZeros2(value) {
      var result = arrayify15(value);
      if (result.length === 0) {
        return result;
      }
      var start = 0;
      while (start < result.length && result[start] === 0) {
        start++;
      }
      if (start) {
        result = result.slice(start);
      }
      return result;
    }
    exports.stripZeros = stripZeros2;
    function zeroPad2(value, length) {
      value = arrayify15(value);
      if (value.length > length) {
        logger15.throwArgumentError("value out of range", "value", arguments[0]);
      }
      var result = new Uint8Array(length);
      result.set(value, length - value.length);
      return addSlice(result);
    }
    exports.zeroPad = zeroPad2;
    function isHexString5(value, length) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length && value.length !== 2 + 2 * length) {
        return false;
      }
      return true;
    }
    exports.isHexString = isHexString5;
    var HexCharacters = "0123456789abcdef";
    function hexlify11(value, options) {
      if (!options) {
        options = {};
      }
      if (typeof value === "number") {
        logger15.checkSafeUint53(value, "invalid hexlify value");
        var hex = "";
        while (value) {
          hex = HexCharacters[value & 15] + hex;
          value = Math.floor(value / 16);
        }
        if (hex.length) {
          if (hex.length % 2) {
            hex = "0" + hex;
          }
          return "0x" + hex;
        }
        return "0x00";
      }
      if (typeof value === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
          return "0x0" + value;
        }
        return "0x" + value;
      }
      if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexable(value)) {
        return value.toHexString();
      }
      if (isHexString5(value)) {
        if (value.length % 2) {
          if (options.hexPad === "left") {
            value = "0x0" + value.substring(2);
          } else if (options.hexPad === "right") {
            value += "0";
          } else {
            logger15.throwArgumentError("hex data is odd-length", "value", value);
          }
        }
        return value.toLowerCase();
      }
      if (isBytes4(value)) {
        var result = "0x";
        for (var i = 0; i < value.length; i++) {
          var v = value[i];
          result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
        }
        return result;
      }
      return logger15.throwArgumentError("invalid hexlify value", "value", value);
    }
    exports.hexlify = hexlify11;
    function hexDataLength2(data) {
      if (typeof data !== "string") {
        data = hexlify11(data);
      } else if (!isHexString5(data) || data.length % 2) {
        return null;
      }
      return (data.length - 2) / 2;
    }
    exports.hexDataLength = hexDataLength2;
    function hexDataSlice5(data, offset, endOffset) {
      if (typeof data !== "string") {
        data = hexlify11(data);
      } else if (!isHexString5(data) || data.length % 2) {
        logger15.throwArgumentError("invalid hexData", "value", data);
      }
      offset = 2 + 2 * offset;
      if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
      }
      return "0x" + data.substring(offset);
    }
    exports.hexDataSlice = hexDataSlice5;
    function hexConcat3(items) {
      var result = "0x";
      items.forEach(function(item) {
        result += hexlify11(item).substring(2);
      });
      return result;
    }
    exports.hexConcat = hexConcat3;
    function hexValue2(value) {
      var trimmed = hexStripZeros2(hexlify11(value, { hexPad: "left" }));
      if (trimmed === "0x") {
        return "0x0";
      }
      return trimmed;
    }
    exports.hexValue = hexValue2;
    function hexStripZeros2(value) {
      if (typeof value !== "string") {
        value = hexlify11(value);
      }
      if (!isHexString5(value)) {
        logger15.throwArgumentError("invalid hex string", "value", value);
      }
      value = value.substring(2);
      var offset = 0;
      while (offset < value.length && value[offset] === "0") {
        offset++;
      }
      return "0x" + value.substring(offset);
    }
    exports.hexStripZeros = hexStripZeros2;
    function hexZeroPad5(value, length) {
      if (typeof value !== "string") {
        value = hexlify11(value);
      } else if (!isHexString5(value)) {
        logger15.throwArgumentError("invalid hex string", "value", value);
      }
      if (value.length > 2 * length + 2) {
        logger15.throwArgumentError("value out of range", "value", arguments[1]);
      }
      while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
      }
      return value;
    }
    exports.hexZeroPad = hexZeroPad5;
    function splitSignature2(signature) {
      var result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
      };
      if (isBytesLike2(signature)) {
        var bytes4 = arrayify15(signature);
        if (bytes4.length === 64) {
          result.v = 27 + (bytes4[32] >> 7);
          bytes4[32] &= 127;
          result.r = hexlify11(bytes4.slice(0, 32));
          result.s = hexlify11(bytes4.slice(32, 64));
        } else if (bytes4.length === 65) {
          result.r = hexlify11(bytes4.slice(0, 32));
          result.s = hexlify11(bytes4.slice(32, 64));
          result.v = bytes4[64];
        } else {
          logger15.throwArgumentError("invalid signature string", "signature", signature);
        }
        if (result.v < 27) {
          if (result.v === 0 || result.v === 1) {
            result.v += 27;
          } else {
            logger15.throwArgumentError("signature invalid v byte", "signature", signature);
          }
        }
        result.recoveryParam = 1 - result.v % 2;
        if (result.recoveryParam) {
          bytes4[32] |= 128;
        }
        result._vs = hexlify11(bytes4.slice(32, 64));
      } else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        if (result._vs != null) {
          var vs_1 = zeroPad2(arrayify15(result._vs), 32);
          result._vs = hexlify11(vs_1);
          var recoveryParam = vs_1[0] >= 128 ? 1 : 0;
          if (result.recoveryParam == null) {
            result.recoveryParam = recoveryParam;
          } else if (result.recoveryParam !== recoveryParam) {
            logger15.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
          }
          vs_1[0] &= 127;
          var s = hexlify11(vs_1);
          if (result.s == null) {
            result.s = s;
          } else if (result.s !== s) {
            logger15.throwArgumentError("signature v mismatch _vs", "signature", signature);
          }
        }
        if (result.recoveryParam == null) {
          if (result.v == null) {
            logger15.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
          } else if (result.v === 0 || result.v === 1) {
            result.recoveryParam = result.v;
          } else {
            result.recoveryParam = 1 - result.v % 2;
          }
        } else {
          if (result.v == null) {
            result.v = 27 + result.recoveryParam;
          } else {
            var recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
            if (result.recoveryParam !== recId) {
              logger15.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
            }
          }
        }
        if (result.r == null || !isHexString5(result.r)) {
          logger15.throwArgumentError("signature missing or invalid r", "signature", signature);
        } else {
          result.r = hexZeroPad5(result.r, 32);
        }
        if (result.s == null || !isHexString5(result.s)) {
          logger15.throwArgumentError("signature missing or invalid s", "signature", signature);
        } else {
          result.s = hexZeroPad5(result.s, 32);
        }
        var vs = arrayify15(result.s);
        if (vs[0] >= 128) {
          logger15.throwArgumentError("signature s out of range", "signature", signature);
        }
        if (result.recoveryParam) {
          vs[0] |= 128;
        }
        var _vs = hexlify11(vs);
        if (result._vs) {
          if (!isHexString5(result._vs)) {
            logger15.throwArgumentError("signature invalid _vs", "signature", signature);
          }
          result._vs = hexZeroPad5(result._vs, 32);
        }
        if (result._vs == null) {
          result._vs = _vs;
        } else if (result._vs !== _vs) {
          logger15.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
        }
      }
      result.yParityAndS = result._vs;
      result.compact = result.r + result.yParityAndS.substring(2);
      return result;
    }
    exports.splitSignature = splitSignature2;
    function joinSignature3(signature) {
      signature = splitSignature2(signature);
      return hexlify11(concat9([
        signature.r,
        signature.s,
        signature.recoveryParam ? "0x1c" : "0x1b"
      ]));
    }
    exports.joinSignature = joinSignature3;
  }
});

// ../node_modules/@ethersproject/bignumber/lib/_version.js
var require_version3 = __commonJS({
  "../node_modules/@ethersproject/bignumber/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "bignumber/5.7.0";
  }
});

// ../node_modules/@ethersproject/bignumber/lib/bignumber.js
var require_bignumber = __commonJS({
  "../node_modules/@ethersproject/bignumber/lib/bignumber.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._base16To36 = exports._base36To16 = exports.BigNumber = exports.isBigNumberish = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var BN = bn_js_1.default.BN;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version3();
    var logger15 = new logger_1.Logger(_version_1.version);
    var _constructorGuard3 = {};
    var MAX_SAFE = 9007199254740991;
    function isBigNumberish(value) {
      return value != null && (BigNumber10.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0, bytes_1.isHexString)(value) || typeof value === "bigint" || (0, bytes_1.isBytes)(value));
    }
    exports.isBigNumberish = isBigNumberish;
    var _warnedToStringRadix = false;
    var BigNumber10 = function() {
      function BigNumber11(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard3) {
          logger15.throwError("cannot call constructor directly; use BigNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
      }
      BigNumber11.prototype.fromTwos = function(value) {
        return toBigNumber(toBN(this).fromTwos(value));
      };
      BigNumber11.prototype.toTwos = function(value) {
        return toBigNumber(toBN(this).toTwos(value));
      };
      BigNumber11.prototype.abs = function() {
        if (this._hex[0] === "-") {
          return BigNumber11.from(this._hex.substring(1));
        }
        return this;
      };
      BigNumber11.prototype.add = function(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
      };
      BigNumber11.prototype.sub = function(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
      };
      BigNumber11.prototype.div = function(other) {
        var o = BigNumber11.from(other);
        if (o.isZero()) {
          throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
      };
      BigNumber11.prototype.mul = function(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
      };
      BigNumber11.prototype.mod = function(other) {
        var value = toBN(other);
        if (value.isNeg()) {
          throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
      };
      BigNumber11.prototype.pow = function(other) {
        var value = toBN(other);
        if (value.isNeg()) {
          throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
      };
      BigNumber11.prototype.and = function(other) {
        var value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
      };
      BigNumber11.prototype.or = function(other) {
        var value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
      };
      BigNumber11.prototype.xor = function(other) {
        var value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
      };
      BigNumber11.prototype.mask = function(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
      };
      BigNumber11.prototype.shl = function(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
      };
      BigNumber11.prototype.shr = function(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
      };
      BigNumber11.prototype.eq = function(other) {
        return toBN(this).eq(toBN(other));
      };
      BigNumber11.prototype.lt = function(other) {
        return toBN(this).lt(toBN(other));
      };
      BigNumber11.prototype.lte = function(other) {
        return toBN(this).lte(toBN(other));
      };
      BigNumber11.prototype.gt = function(other) {
        return toBN(this).gt(toBN(other));
      };
      BigNumber11.prototype.gte = function(other) {
        return toBN(this).gte(toBN(other));
      };
      BigNumber11.prototype.isNegative = function() {
        return this._hex[0] === "-";
      };
      BigNumber11.prototype.isZero = function() {
        return toBN(this).isZero();
      };
      BigNumber11.prototype.toNumber = function() {
        try {
          return toBN(this).toNumber();
        } catch (error) {
          throwFault("overflow", "toNumber", this.toString());
        }
        return null;
      };
      BigNumber11.prototype.toBigInt = function() {
        try {
          return BigInt(this.toString());
        } catch (e) {
        }
        return logger15.throwError("this platform does not support BigInt", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        });
      };
      BigNumber11.prototype.toString = function() {
        if (arguments.length > 0) {
          if (arguments[0] === 10) {
            if (!_warnedToStringRadix) {
              _warnedToStringRadix = true;
              logger15.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
            }
          } else if (arguments[0] === 16) {
            logger15.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
          } else {
            logger15.throwError("BigNumber.toString does not accept parameters", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
          }
        }
        return toBN(this).toString(10);
      };
      BigNumber11.prototype.toHexString = function() {
        return this._hex;
      };
      BigNumber11.prototype.toJSON = function(key) {
        return { type: "BigNumber", hex: this.toHexString() };
      };
      BigNumber11.from = function(value) {
        if (value instanceof BigNumber11) {
          return value;
        }
        if (typeof value === "string") {
          if (value.match(/^-?0x[0-9a-f]+$/i)) {
            return new BigNumber11(_constructorGuard3, toHex3(value));
          }
          if (value.match(/^-?[0-9]+$/)) {
            return new BigNumber11(_constructorGuard3, toHex3(new BN(value)));
          }
          return logger15.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
          if (value % 1) {
            throwFault("underflow", "BigNumber.from", value);
          }
          if (value >= MAX_SAFE || value <= -MAX_SAFE) {
            throwFault("overflow", "BigNumber.from", value);
          }
          return BigNumber11.from(String(value));
        }
        var anyValue = value;
        if (typeof anyValue === "bigint") {
          return BigNumber11.from(anyValue.toString());
        }
        if ((0, bytes_1.isBytes)(anyValue)) {
          return BigNumber11.from((0, bytes_1.hexlify)(anyValue));
        }
        if (anyValue) {
          if (anyValue.toHexString) {
            var hex = anyValue.toHexString();
            if (typeof hex === "string") {
              return BigNumber11.from(hex);
            }
          } else {
            var hex = anyValue._hex;
            if (hex == null && anyValue.type === "BigNumber") {
              hex = anyValue.hex;
            }
            if (typeof hex === "string") {
              if ((0, bytes_1.isHexString)(hex) || hex[0] === "-" && (0, bytes_1.isHexString)(hex.substring(1))) {
                return BigNumber11.from(hex);
              }
            }
          }
        }
        return logger15.throwArgumentError("invalid BigNumber value", "value", value);
      };
      BigNumber11.isBigNumber = function(value) {
        return !!(value && value._isBigNumber);
      };
      return BigNumber11;
    }();
    exports.BigNumber = BigNumber10;
    function toHex3(value) {
      if (typeof value !== "string") {
        return toHex3(value.toString(16));
      }
      if (value[0] === "-") {
        value = value.substring(1);
        if (value[0] === "-") {
          logger15.throwArgumentError("invalid hex", "value", value);
        }
        value = toHex3(value);
        if (value === "0x00") {
          return value;
        }
        return "-" + value;
      }
      if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (value === "0x") {
        return "0x00";
      }
      if (value.length % 2) {
        value = "0x0" + value.substring(2);
      }
      while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
      }
      return value;
    }
    function toBigNumber(value) {
      return BigNumber10.from(toHex3(value));
    }
    function toBN(value) {
      var hex = BigNumber10.from(value).toHexString();
      if (hex[0] === "-") {
        return new BN("-" + hex.substring(3), 16);
      }
      return new BN(hex.substring(2), 16);
    }
    function throwFault(fault, operation, value) {
      var params = { fault, operation };
      if (value != null) {
        params.value = value;
      }
      return logger15.throwError(fault, logger_1.Logger.errors.NUMERIC_FAULT, params);
    }
    function _base36To16(value) {
      return new BN(value, 36).toString(16);
    }
    exports._base36To16 = _base36To16;
    function _base16To36(value) {
      return new BN(value, 16).toString(36);
    }
    exports._base16To36 = _base16To36;
  }
});

// ../node_modules/@ethersproject/bignumber/lib/fixednumber.js
var require_fixednumber = __commonJS({
  "../node_modules/@ethersproject/bignumber/lib/fixednumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FixedNumber = exports.FixedFormat = exports.parseFixed = exports.formatFixed = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version3();
    var logger15 = new logger_1.Logger(_version_1.version);
    var bignumber_1 = require_bignumber();
    var _constructorGuard3 = {};
    var Zero2 = bignumber_1.BigNumber.from(0);
    var NegativeOne2 = bignumber_1.BigNumber.from(-1);
    function throwFault(message, fault, operation, value) {
      var params = { fault, operation };
      if (value !== void 0) {
        params.value = value;
      }
      return logger15.throwError(message, logger_1.Logger.errors.NUMERIC_FAULT, params);
    }
    var zeros = "0";
    while (zeros.length < 256) {
      zeros += zeros;
    }
    function getMultiplier(decimals) {
      if (typeof decimals !== "number") {
        try {
          decimals = bignumber_1.BigNumber.from(decimals).toNumber();
        } catch (e) {
        }
      }
      if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
        return "1" + zeros.substring(0, decimals);
      }
      return logger15.throwArgumentError("invalid decimal size", "decimals", decimals);
    }
    function formatFixed2(value, decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      var multiplier = getMultiplier(decimals);
      value = bignumber_1.BigNumber.from(value);
      var negative = value.lt(Zero2);
      if (negative) {
        value = value.mul(NegativeOne2);
      }
      var fraction = value.mod(multiplier).toString();
      while (fraction.length < multiplier.length - 1) {
        fraction = "0" + fraction;
      }
      fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      var whole = value.div(multiplier).toString();
      if (multiplier.length === 1) {
        value = whole;
      } else {
        value = whole + "." + fraction;
      }
      if (negative) {
        value = "-" + value;
      }
      return value;
    }
    exports.formatFixed = formatFixed2;
    function parseFixed2(value, decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      var multiplier = getMultiplier(decimals);
      if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
        logger15.throwArgumentError("invalid decimal value", "value", value);
      }
      var negative = value.substring(0, 1) === "-";
      if (negative) {
        value = value.substring(1);
      }
      if (value === ".") {
        logger15.throwArgumentError("missing value", "value", value);
      }
      var comps = value.split(".");
      if (comps.length > 2) {
        logger15.throwArgumentError("too many decimal points", "value", value);
      }
      var whole = comps[0], fraction = comps[1];
      if (!whole) {
        whole = "0";
      }
      if (!fraction) {
        fraction = "0";
      }
      while (fraction[fraction.length - 1] === "0") {
        fraction = fraction.substring(0, fraction.length - 1);
      }
      if (fraction.length > multiplier.length - 1) {
        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
      }
      if (fraction === "") {
        fraction = "0";
      }
      while (fraction.length < multiplier.length - 1) {
        fraction += "0";
      }
      var wholeValue = bignumber_1.BigNumber.from(whole);
      var fractionValue = bignumber_1.BigNumber.from(fraction);
      var wei = wholeValue.mul(multiplier).add(fractionValue);
      if (negative) {
        wei = wei.mul(NegativeOne2);
      }
      return wei;
    }
    exports.parseFixed = parseFixed2;
    var FixedFormat = function() {
      function FixedFormat2(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard3) {
          logger15.throwError("cannot use FixedFormat constructor; use FixedFormat.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
      }
      FixedFormat2.from = function(value) {
        if (value instanceof FixedFormat2) {
          return value;
        }
        if (typeof value === "number") {
          value = "fixed128x" + value;
        }
        var signed = true;
        var width = 128;
        var decimals = 18;
        if (typeof value === "string") {
          if (value === "fixed") {
          } else if (value === "ufixed") {
            signed = false;
          } else {
            var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            if (!match) {
              logger15.throwArgumentError("invalid fixed format", "format", value);
            }
            signed = match[1] !== "u";
            width = parseInt(match[2]);
            decimals = parseInt(match[3]);
          }
        } else if (value) {
          var check = function(key, type, defaultValue) {
            if (value[key] == null) {
              return defaultValue;
            }
            if (typeof value[key] !== type) {
              logger15.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
            }
            return value[key];
          };
          signed = check("signed", "boolean", signed);
          width = check("width", "number", width);
          decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
          logger15.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
          logger15.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat2(_constructorGuard3, signed, width, decimals);
      };
      return FixedFormat2;
    }();
    exports.FixedFormat = FixedFormat;
    var FixedNumber = function() {
      function FixedNumber2(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard3) {
          logger15.throwError("cannot use FixedNumber constructor; use FixedNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
      }
      FixedNumber2.prototype._checkFormat = function(other) {
        if (this.format.name !== other.format.name) {
          logger15.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
      };
      FixedNumber2.prototype.addUnsafe = function(other) {
        this._checkFormat(other);
        var a = parseFixed2(this._value, this.format.decimals);
        var b = parseFixed2(other._value, other.format.decimals);
        return FixedNumber2.fromValue(a.add(b), this.format.decimals, this.format);
      };
      FixedNumber2.prototype.subUnsafe = function(other) {
        this._checkFormat(other);
        var a = parseFixed2(this._value, this.format.decimals);
        var b = parseFixed2(other._value, other.format.decimals);
        return FixedNumber2.fromValue(a.sub(b), this.format.decimals, this.format);
      };
      FixedNumber2.prototype.mulUnsafe = function(other) {
        this._checkFormat(other);
        var a = parseFixed2(this._value, this.format.decimals);
        var b = parseFixed2(other._value, other.format.decimals);
        return FixedNumber2.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
      };
      FixedNumber2.prototype.divUnsafe = function(other) {
        this._checkFormat(other);
        var a = parseFixed2(this._value, this.format.decimals);
        var b = parseFixed2(other._value, other.format.decimals);
        return FixedNumber2.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
      };
      FixedNumber2.prototype.floor = function() {
        var comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        var result = FixedNumber2.from(comps[0], this.format);
        var hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
          result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
      };
      FixedNumber2.prototype.ceiling = function() {
        var comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        var result = FixedNumber2.from(comps[0], this.format);
        var hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
          result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
      };
      FixedNumber2.prototype.round = function(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        var comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || decimals % 1) {
          logger15.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
          return this;
        }
        var factor = FixedNumber2.from("1" + zeros.substring(0, decimals), this.format);
        var bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
      };
      FixedNumber2.prototype.isZero = function() {
        return this._value === "0.0" || this._value === "0";
      };
      FixedNumber2.prototype.isNegative = function() {
        return this._value[0] === "-";
      };
      FixedNumber2.prototype.toString = function() {
        return this._value;
      };
      FixedNumber2.prototype.toHexString = function(width) {
        if (width == null) {
          return this._hex;
        }
        if (width % 8) {
          logger15.throwArgumentError("invalid byte width", "width", width);
        }
        var hex = bignumber_1.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return (0, bytes_1.hexZeroPad)(hex, width / 8);
      };
      FixedNumber2.prototype.toUnsafeFloat = function() {
        return parseFloat(this.toString());
      };
      FixedNumber2.prototype.toFormat = function(format) {
        return FixedNumber2.fromString(this._value, format);
      };
      FixedNumber2.fromValue = function(value, decimals, format) {
        if (format == null && decimals != null && !(0, bignumber_1.isBigNumberish)(decimals)) {
          format = decimals;
          decimals = null;
        }
        if (decimals == null) {
          decimals = 0;
        }
        if (format == null) {
          format = "fixed";
        }
        return FixedNumber2.fromString(formatFixed2(value, decimals), FixedFormat.from(format));
      };
      FixedNumber2.fromString = function(value, format) {
        if (format == null) {
          format = "fixed";
        }
        var fixedFormat = FixedFormat.from(format);
        var numeric = parseFixed2(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero2)) {
          throwFault("unsigned value cannot be negative", "overflow", "value", value);
        }
        var hex = null;
        if (fixedFormat.signed) {
          hex = numeric.toTwos(fixedFormat.width).toHexString();
        } else {
          hex = numeric.toHexString();
          hex = (0, bytes_1.hexZeroPad)(hex, fixedFormat.width / 8);
        }
        var decimal = formatFixed2(numeric, fixedFormat.decimals);
        return new FixedNumber2(_constructorGuard3, hex, decimal, fixedFormat);
      };
      FixedNumber2.fromBytes = function(value, format) {
        if (format == null) {
          format = "fixed";
        }
        var fixedFormat = FixedFormat.from(format);
        if ((0, bytes_1.arrayify)(value).length > fixedFormat.width / 8) {
          throw new Error("overflow");
        }
        var numeric = bignumber_1.BigNumber.from(value);
        if (fixedFormat.signed) {
          numeric = numeric.fromTwos(fixedFormat.width);
        }
        var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        var decimal = formatFixed2(numeric, fixedFormat.decimals);
        return new FixedNumber2(_constructorGuard3, hex, decimal, fixedFormat);
      };
      FixedNumber2.from = function(value, format) {
        if (typeof value === "string") {
          return FixedNumber2.fromString(value, format);
        }
        if ((0, bytes_1.isBytes)(value)) {
          return FixedNumber2.fromBytes(value, format);
        }
        try {
          return FixedNumber2.fromValue(value, 0, format);
        } catch (error) {
          if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT) {
            throw error;
          }
        }
        return logger15.throwArgumentError("invalid FixedNumber value", "value", value);
      };
      FixedNumber2.isFixedNumber = function(value) {
        return !!(value && value._isFixedNumber);
      };
      return FixedNumber2;
    }();
    exports.FixedNumber = FixedNumber;
    var ONE = FixedNumber.from(1);
    var BUMP = FixedNumber.from("0.5");
  }
});

// ../node_modules/@ethersproject/bignumber/lib/index.js
var require_lib3 = __commonJS({
  "../node_modules/@ethersproject/bignumber/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._base36To16 = exports._base16To36 = exports.parseFixed = exports.FixedNumber = exports.FixedFormat = exports.formatFixed = exports.BigNumber = void 0;
    var bignumber_1 = require_bignumber();
    Object.defineProperty(exports, "BigNumber", { enumerable: true, get: function() {
      return bignumber_1.BigNumber;
    } });
    var fixednumber_1 = require_fixednumber();
    Object.defineProperty(exports, "formatFixed", { enumerable: true, get: function() {
      return fixednumber_1.formatFixed;
    } });
    Object.defineProperty(exports, "FixedFormat", { enumerable: true, get: function() {
      return fixednumber_1.FixedFormat;
    } });
    Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function() {
      return fixednumber_1.FixedNumber;
    } });
    Object.defineProperty(exports, "parseFixed", { enumerable: true, get: function() {
      return fixednumber_1.parseFixed;
    } });
    var bignumber_2 = require_bignumber();
    Object.defineProperty(exports, "_base16To36", { enumerable: true, get: function() {
      return bignumber_2._base16To36;
    } });
    Object.defineProperty(exports, "_base36To16", { enumerable: true, get: function() {
      return bignumber_2._base36To16;
    } });
  }
});

// ../node_modules/@ethersproject/properties/lib/_version.js
var require_version4 = __commonJS({
  "../node_modules/@ethersproject/properties/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "properties/5.7.0";
  }
});

// ../node_modules/@ethersproject/properties/lib/index.js
var require_lib4 = __commonJS({
  "../node_modules/@ethersproject/properties/lib/index.js"(exports) {
    "use strict";
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Description = exports.deepCopy = exports.shallowCopy = exports.checkProperties = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version4();
    var logger15 = new logger_1.Logger(_version_1.version);
    function defineReadOnly10(object, name, value) {
      Object.defineProperty(object, name, {
        enumerable: true,
        value,
        writable: false
      });
    }
    exports.defineReadOnly = defineReadOnly10;
    function getStatic3(ctor, key) {
      for (var i = 0; i < 32; i++) {
        if (ctor[key]) {
          return ctor[key];
        }
        if (!ctor.prototype || typeof ctor.prototype !== "object") {
          break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
      }
      return null;
    }
    exports.getStatic = getStatic3;
    function resolveProperties4(object) {
      return __awaiter5(this, void 0, void 0, function() {
        var promises, results;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              promises = Object.keys(object).map(function(key) {
                var value = object[key];
                return Promise.resolve(value).then(function(v) {
                  return { key, value: v };
                });
              });
              return [4, Promise.all(promises)];
            case 1:
              results = _a.sent();
              return [2, results.reduce(function(accum, result) {
                accum[result.key] = result.value;
                return accum;
              }, {})];
          }
        });
      });
    }
    exports.resolveProperties = resolveProperties4;
    function checkProperties(object, properties) {
      if (!object || typeof object !== "object") {
        logger15.throwArgumentError("invalid object", "object", object);
      }
      Object.keys(object).forEach(function(key) {
        if (!properties[key]) {
          logger15.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
      });
    }
    exports.checkProperties = checkProperties;
    function shallowCopy2(object) {
      var result = {};
      for (var key in object) {
        result[key] = object[key];
      }
      return result;
    }
    exports.shallowCopy = shallowCopy2;
    var opaque2 = { bigint: true, boolean: true, "function": true, number: true, string: true };
    function _isFrozen2(object) {
      if (object === void 0 || object === null || opaque2[typeof object]) {
        return true;
      }
      if (Array.isArray(object) || typeof object === "object") {
        if (!Object.isFrozen(object)) {
          return false;
        }
        var keys = Object.keys(object);
        for (var i = 0; i < keys.length; i++) {
          var value = null;
          try {
            value = object[keys[i]];
          } catch (error) {
            continue;
          }
          if (!_isFrozen2(value)) {
            return false;
          }
        }
        return true;
      }
      return logger15.throwArgumentError("Cannot deepCopy " + typeof object, "object", object);
    }
    function _deepCopy2(object) {
      if (_isFrozen2(object)) {
        return object;
      }
      if (Array.isArray(object)) {
        return Object.freeze(object.map(function(item) {
          return deepCopy3(item);
        }));
      }
      if (typeof object === "object") {
        var result = {};
        for (var key in object) {
          var value = object[key];
          if (value === void 0) {
            continue;
          }
          defineReadOnly10(result, key, deepCopy3(value));
        }
        return result;
      }
      return logger15.throwArgumentError("Cannot deepCopy " + typeof object, "object", object);
    }
    function deepCopy3(object) {
      return _deepCopy2(object);
    }
    exports.deepCopy = deepCopy3;
    var Description4 = function() {
      function Description5(info) {
        for (var key in info) {
          this[key] = deepCopy3(info[key]);
        }
      }
      return Description5;
    }();
    exports.Description = Description4;
  }
});

// ../node_modules/@ethersproject/abstract-provider/lib/_version.js
var require_version5 = __commonJS({
  "../node_modules/@ethersproject/abstract-provider/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "abstract-provider/5.7.0";
  }
});

// ../node_modules/@ethersproject/abstract-provider/lib/index.js
var require_lib5 = __commonJS({
  "../node_modules/@ethersproject/abstract-provider/lib/index.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Provider = exports.TransactionOrderForkEvent = exports.TransactionForkEvent = exports.BlockForkEvent = exports.ForkEvent = void 0;
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version5();
    var logger15 = new logger_1.Logger(_version_1.version);
    var ForkEvent = function(_super) {
      __extends2(ForkEvent2, _super);
      function ForkEvent2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ForkEvent2.isForkEvent = function(value) {
        return !!(value && value._isForkEvent);
      };
      return ForkEvent2;
    }(properties_1.Description);
    exports.ForkEvent = ForkEvent;
    var BlockForkEvent = function(_super) {
      __extends2(BlockForkEvent2, _super);
      function BlockForkEvent2(blockHash, expiry) {
        var _this = this;
        if (!(0, bytes_1.isHexString)(blockHash, 32)) {
          logger15.throwArgumentError("invalid blockHash", "blockHash", blockHash);
        }
        _this = _super.call(this, {
          _isForkEvent: true,
          _isBlockForkEvent: true,
          expiry: expiry || 0,
          blockHash
        }) || this;
        return _this;
      }
      return BlockForkEvent2;
    }(ForkEvent);
    exports.BlockForkEvent = BlockForkEvent;
    var TransactionForkEvent = function(_super) {
      __extends2(TransactionForkEvent2, _super);
      function TransactionForkEvent2(hash4, expiry) {
        var _this = this;
        if (!(0, bytes_1.isHexString)(hash4, 32)) {
          logger15.throwArgumentError("invalid transaction hash", "hash", hash4);
        }
        _this = _super.call(this, {
          _isForkEvent: true,
          _isTransactionForkEvent: true,
          expiry: expiry || 0,
          hash: hash4
        }) || this;
        return _this;
      }
      return TransactionForkEvent2;
    }(ForkEvent);
    exports.TransactionForkEvent = TransactionForkEvent;
    var TransactionOrderForkEvent = function(_super) {
      __extends2(TransactionOrderForkEvent2, _super);
      function TransactionOrderForkEvent2(beforeHash, afterHash, expiry) {
        var _this = this;
        if (!(0, bytes_1.isHexString)(beforeHash, 32)) {
          logger15.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
        }
        if (!(0, bytes_1.isHexString)(afterHash, 32)) {
          logger15.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
        }
        _this = _super.call(this, {
          _isForkEvent: true,
          _isTransactionOrderForkEvent: true,
          expiry: expiry || 0,
          beforeHash,
          afterHash
        }) || this;
        return _this;
      }
      return TransactionOrderForkEvent2;
    }(ForkEvent);
    exports.TransactionOrderForkEvent = TransactionOrderForkEvent;
    var Provider4 = function() {
      function Provider5() {
        var _newTarget = this.constructor;
        logger15.checkAbstract(_newTarget, Provider5);
        (0, properties_1.defineReadOnly)(this, "_isProvider", true);
      }
      Provider5.prototype.getFeeData = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var _a, block, gasPrice, lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, (0, properties_1.resolveProperties)({
                  block: this.getBlock("latest"),
                  gasPrice: this.getGasPrice().catch(function(error) {
                    return null;
                  })
                })];
              case 1:
                _a = _b.sent(), block = _a.block, gasPrice = _a.gasPrice;
                lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
                if (block && block.baseFeePerGas) {
                  lastBaseFeePerGas = block.baseFeePerGas;
                  maxPriorityFeePerGas = bignumber_1.BigNumber.from("1500000000");
                  maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
                }
                return [2, { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice }];
            }
          });
        });
      };
      Provider5.prototype.addListener = function(eventName, listener) {
        return this.on(eventName, listener);
      };
      Provider5.prototype.removeListener = function(eventName, listener) {
        return this.off(eventName, listener);
      };
      Provider5.isProvider = function(value) {
        return !!(value && value._isProvider);
      };
      return Provider5;
    }();
    exports.Provider = Provider4;
  }
});

// ../node_modules/@ethersproject/networks/lib/_version.js
var require_version6 = __commonJS({
  "../node_modules/@ethersproject/networks/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "networks/5.7.1";
  }
});

// ../node_modules/@ethersproject/networks/lib/index.js
var require_lib6 = __commonJS({
  "../node_modules/@ethersproject/networks/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNetwork = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version6();
    var logger15 = new logger_1.Logger(_version_1.version);
    function isRenetworkable(value) {
      return value && typeof value.renetwork === "function";
    }
    function ethDefaultProvider(network) {
      var func = function(providers, options) {
        if (options == null) {
          options = {};
        }
        var providerList = [];
        if (providers.InfuraProvider && options.infura !== "-") {
          try {
            providerList.push(new providers.InfuraProvider(network, options.infura));
          } catch (error) {
          }
        }
        if (providers.EtherscanProvider && options.etherscan !== "-") {
          try {
            providerList.push(new providers.EtherscanProvider(network, options.etherscan));
          } catch (error) {
          }
        }
        if (providers.AlchemyProvider && options.alchemy !== "-") {
          try {
            providerList.push(new providers.AlchemyProvider(network, options.alchemy));
          } catch (error) {
          }
        }
        if (providers.PocketProvider && options.pocket !== "-") {
          var skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
          try {
            var provider = new providers.PocketProvider(network, options.pocket);
            if (provider.network && skip.indexOf(provider.network.name) === -1) {
              providerList.push(provider);
            }
          } catch (error) {
          }
        }
        if (providers.CloudflareProvider && options.cloudflare !== "-") {
          try {
            providerList.push(new providers.CloudflareProvider(network));
          } catch (error) {
          }
        }
        if (providers.AnkrProvider && options.ankr !== "-") {
          try {
            var skip = ["ropsten"];
            var provider = new providers.AnkrProvider(network, options.ankr);
            if (provider.network && skip.indexOf(provider.network.name) === -1) {
              providerList.push(provider);
            }
          } catch (error) {
          }
        }
        if (providerList.length === 0) {
          return null;
        }
        if (providers.FallbackProvider) {
          var quorum = 1;
          if (options.quorum != null) {
            quorum = options.quorum;
          } else if (network === "homestead") {
            quorum = 2;
          }
          return new providers.FallbackProvider(providerList, quorum);
        }
        return providerList[0];
      };
      func.renetwork = function(network2) {
        return ethDefaultProvider(network2);
      };
      return func;
    }
    function etcDefaultProvider(url, network) {
      var func = function(providers, options) {
        if (providers.JsonRpcProvider) {
          return new providers.JsonRpcProvider(url, network);
        }
        return null;
      };
      func.renetwork = function(network2) {
        return etcDefaultProvider(url, network2);
      };
      return func;
    }
    var homestead = {
      chainId: 1,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "homestead",
      _defaultProvider: ethDefaultProvider("homestead")
    };
    var ropsten = {
      chainId: 3,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "ropsten",
      _defaultProvider: ethDefaultProvider("ropsten")
    };
    var classicMordor = {
      chainId: 63,
      name: "classicMordor",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
    };
    var networks = {
      unspecified: { chainId: 0, name: "unspecified" },
      homestead,
      mainnet: homestead,
      morden: { chainId: 2, name: "morden" },
      ropsten,
      testnet: ropsten,
      rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: ethDefaultProvider("rinkeby")
      },
      kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: ethDefaultProvider("kovan")
      },
      goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: ethDefaultProvider("goerli")
      },
      kintsugi: { chainId: 1337702, name: "kintsugi" },
      sepolia: {
        chainId: 11155111,
        name: "sepolia",
        _defaultProvider: ethDefaultProvider("sepolia")
      },
      classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
      },
      classicMorden: { chainId: 62, name: "classicMorden" },
      classicMordor,
      classicTestnet: classicMordor,
      classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
      },
      xdai: { chainId: 100, name: "xdai" },
      matic: {
        chainId: 137,
        name: "matic",
        _defaultProvider: ethDefaultProvider("matic")
      },
      maticmum: { chainId: 80001, name: "maticmum" },
      optimism: {
        chainId: 10,
        name: "optimism",
        _defaultProvider: ethDefaultProvider("optimism")
      },
      "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
      "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
      arbitrum: { chainId: 42161, name: "arbitrum" },
      "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
      "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
      bnb: { chainId: 56, name: "bnb" },
      bnbt: { chainId: 97, name: "bnbt" }
    };
    function getNetwork3(network) {
      if (network == null) {
        return null;
      }
      if (typeof network === "number") {
        for (var name_1 in networks) {
          var standard_1 = networks[name_1];
          if (standard_1.chainId === network) {
            return {
              name: standard_1.name,
              chainId: standard_1.chainId,
              ensAddress: standard_1.ensAddress || null,
              _defaultProvider: standard_1._defaultProvider || null
            };
          }
        }
        return {
          chainId: network,
          name: "unknown"
        };
      }
      if (typeof network === "string") {
        var standard_2 = networks[network];
        if (standard_2 == null) {
          return null;
        }
        return {
          name: standard_2.name,
          chainId: standard_2.chainId,
          ensAddress: standard_2.ensAddress,
          _defaultProvider: standard_2._defaultProvider || null
        };
      }
      var standard = networks[network.name];
      if (!standard) {
        if (typeof network.chainId !== "number") {
          logger15.throwArgumentError("invalid network chainId", "network", network);
        }
        return network;
      }
      if (network.chainId !== 0 && network.chainId !== standard.chainId) {
        logger15.throwArgumentError("network chainId mismatch", "network", network);
      }
      var defaultProvider = network._defaultProvider || null;
      if (defaultProvider == null && standard._defaultProvider) {
        if (isRenetworkable(standard._defaultProvider)) {
          defaultProvider = standard._defaultProvider.renetwork(network);
        } else {
          defaultProvider = standard._defaultProvider;
        }
      }
      return {
        name: network.name,
        chainId: standard.chainId,
        ensAddress: network.ensAddress || standard.ensAddress || null,
        _defaultProvider: defaultProvider
      };
    }
    exports.getNetwork = getNetwork3;
  }
});

// ../node_modules/@ethersproject/base64/lib/browser-base64.js
var require_browser_base64 = __commonJS({
  "../node_modules/@ethersproject/base64/lib/browser-base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    var bytes_1 = require_lib2();
    function decode(textData) {
      textData = atob(textData);
      var data = [];
      for (var i = 0; i < textData.length; i++) {
        data.push(textData.charCodeAt(i));
      }
      return (0, bytes_1.arrayify)(data);
    }
    exports.decode = decode;
    function encode(data) {
      data = (0, bytes_1.arrayify)(data);
      var textData = "";
      for (var i = 0; i < data.length; i++) {
        textData += String.fromCharCode(data[i]);
      }
      return btoa(textData);
    }
    exports.encode = encode;
  }
});

// ../node_modules/@ethersproject/base64/lib/index.js
var require_lib7 = __commonJS({
  "../node_modules/@ethersproject/base64/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    var base64_1 = require_browser_base64();
    Object.defineProperty(exports, "decode", { enumerable: true, get: function() {
      return base64_1.decode;
    } });
    Object.defineProperty(exports, "encode", { enumerable: true, get: function() {
      return base64_1.encode;
    } });
  }
});

// ../node_modules/@ethersproject/basex/lib/index.js
var require_lib8 = __commonJS({
  "../node_modules/@ethersproject/basex/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Base58 = exports.Base32 = exports.BaseX = void 0;
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var BaseX = function() {
      function BaseX2(alphabet) {
        (0, properties_1.defineReadOnly)(this, "alphabet", alphabet);
        (0, properties_1.defineReadOnly)(this, "base", alphabet.length);
        (0, properties_1.defineReadOnly)(this, "_alphabetMap", {});
        (0, properties_1.defineReadOnly)(this, "_leader", alphabet.charAt(0));
        for (var i = 0; i < alphabet.length; i++) {
          this._alphabetMap[alphabet.charAt(i)] = i;
        }
      }
      BaseX2.prototype.encode = function(value) {
        var source = (0, bytes_1.arrayify)(value);
        if (source.length === 0) {
          return "";
        }
        var digits = [0];
        for (var i = 0; i < source.length; ++i) {
          var carry = source[i];
          for (var j = 0; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % this.base;
            carry = carry / this.base | 0;
          }
          while (carry > 0) {
            digits.push(carry % this.base);
            carry = carry / this.base | 0;
          }
        }
        var string = "";
        for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {
          string += this._leader;
        }
        for (var q = digits.length - 1; q >= 0; --q) {
          string += this.alphabet[digits[q]];
        }
        return string;
      };
      BaseX2.prototype.decode = function(value) {
        if (typeof value !== "string") {
          throw new TypeError("Expected String");
        }
        var bytes4 = [];
        if (value.length === 0) {
          return new Uint8Array(bytes4);
        }
        bytes4.push(0);
        for (var i = 0; i < value.length; i++) {
          var byte = this._alphabetMap[value[i]];
          if (byte === void 0) {
            throw new Error("Non-base" + this.base + " character");
          }
          var carry = byte;
          for (var j = 0; j < bytes4.length; ++j) {
            carry += bytes4[j] * this.base;
            bytes4[j] = carry & 255;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes4.push(carry & 255);
            carry >>= 8;
          }
        }
        for (var k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
          bytes4.push(0);
        }
        return (0, bytes_1.arrayify)(new Uint8Array(bytes4.reverse()));
      };
      return BaseX2;
    }();
    exports.BaseX = BaseX;
    var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
    exports.Base32 = Base32;
    var Base582 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.Base58 = Base582;
  }
});

// ../node_modules/@ethersproject/constants/lib/addresses.js
var require_addresses = __commonJS({
  "../node_modules/@ethersproject/constants/lib/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressZero = void 0;
    exports.AddressZero = "0x0000000000000000000000000000000000000000";
  }
});

// ../node_modules/@ethersproject/constants/lib/bignumbers.js
var require_bignumbers = __commonJS({
  "../node_modules/@ethersproject/constants/lib/bignumbers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = void 0;
    var bignumber_1 = require_lib3();
    var NegativeOne2 = /* @__PURE__ */ bignumber_1.BigNumber.from(-1);
    exports.NegativeOne = NegativeOne2;
    var Zero2 = /* @__PURE__ */ bignumber_1.BigNumber.from(0);
    exports.Zero = Zero2;
    var One2 = /* @__PURE__ */ bignumber_1.BigNumber.from(1);
    exports.One = One2;
    var Two = /* @__PURE__ */ bignumber_1.BigNumber.from(2);
    exports.Two = Two;
    var WeiPerEther = /* @__PURE__ */ bignumber_1.BigNumber.from("1000000000000000000");
    exports.WeiPerEther = WeiPerEther;
    var MaxUint2562 = /* @__PURE__ */ bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MaxUint256 = MaxUint2562;
    var MinInt256 = /* @__PURE__ */ bignumber_1.BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
    exports.MinInt256 = MinInt256;
    var MaxInt256 = /* @__PURE__ */ bignumber_1.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MaxInt256 = MaxInt256;
  }
});

// ../node_modules/@ethersproject/constants/lib/hashes.js
var require_hashes = __commonJS({
  "../node_modules/@ethersproject/constants/lib/hashes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashZero = void 0;
    exports.HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// ../node_modules/@ethersproject/constants/lib/strings.js
var require_strings = __commonJS({
  "../node_modules/@ethersproject/constants/lib/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherSymbol = void 0;
    exports.EtherSymbol = "\u039E";
  }
});

// ../node_modules/@ethersproject/constants/lib/index.js
var require_lib9 = __commonJS({
  "../node_modules/@ethersproject/constants/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherSymbol = exports.HashZero = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = exports.AddressZero = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports, "AddressZero", { enumerable: true, get: function() {
      return addresses_1.AddressZero;
    } });
    var bignumbers_1 = require_bignumbers();
    Object.defineProperty(exports, "NegativeOne", { enumerable: true, get: function() {
      return bignumbers_1.NegativeOne;
    } });
    Object.defineProperty(exports, "Zero", { enumerable: true, get: function() {
      return bignumbers_1.Zero;
    } });
    Object.defineProperty(exports, "One", { enumerable: true, get: function() {
      return bignumbers_1.One;
    } });
    Object.defineProperty(exports, "Two", { enumerable: true, get: function() {
      return bignumbers_1.Two;
    } });
    Object.defineProperty(exports, "WeiPerEther", { enumerable: true, get: function() {
      return bignumbers_1.WeiPerEther;
    } });
    Object.defineProperty(exports, "MaxUint256", { enumerable: true, get: function() {
      return bignumbers_1.MaxUint256;
    } });
    Object.defineProperty(exports, "MinInt256", { enumerable: true, get: function() {
      return bignumbers_1.MinInt256;
    } });
    Object.defineProperty(exports, "MaxInt256", { enumerable: true, get: function() {
      return bignumbers_1.MaxInt256;
    } });
    var hashes_1 = require_hashes();
    Object.defineProperty(exports, "HashZero", { enumerable: true, get: function() {
      return hashes_1.HashZero;
    } });
    var strings_1 = require_strings();
    Object.defineProperty(exports, "EtherSymbol", { enumerable: true, get: function() {
      return strings_1.EtherSymbol;
    } });
  }
});

// ../node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "../node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof window.self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = window.self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak2(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak2(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n, s) {
          return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s) {
          return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak2(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak2(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n, s) {
          if (!n && !s) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak2(bits2, padding, outputBits).bytepad([n, s], w);
          }
        };
        method.update = function(message, outputBits, n, s) {
          return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
        };
        method.update = function(key, message, outputBits, s) {
          return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak2(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak2.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s = this.s, i2, code;
        while (index2 < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
              blocks[i2 >> 2] |= message[index2] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index2 < length && i2 < byteCount; ++index2) {
              code = message.charCodeAt(index2);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak2.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes4 = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes4.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n;
        }
        if (right) {
          bytes4.push(n);
        } else {
          bytes4.unshift(n);
        }
        this.update(bytes4);
        return bytes4.length;
      };
      Keccak2.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes4 = 0, length = str.length;
        if (notString) {
          bytes4 = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes4 += 1;
            } else if (code < 2048) {
              bytes4 += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes4 += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes4 += 4;
            }
          }
        }
        bytes4 += this.encode(bytes4 * 8);
        this.update(str);
        return bytes4;
      };
      Keccak2.prototype.bytepad = function(strs, w) {
        var bytes4 = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes4 += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes4 % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak2.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f(s);
      };
      Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak2.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes4 = this.outputBits >> 3;
        var buffer2;
        if (extraBytes) {
          buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer2 = new ArrayBuffer(bytes4);
        }
        var array = new Uint32Array(buffer2);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer2 = buffer2.slice(0, bytes4);
        }
        return buffer2;
      };
      Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
      Keccak2.prototype.digest = Keccak2.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak2.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak2();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak2.prototype.finalize.call(this);
      };
      var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n = 0; n < 48; n += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n];
          s[1] ^= RC[n + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// ../node_modules/@ethersproject/keccak256/lib/index.js
var require_lib10 = __commonJS({
  "../node_modules/@ethersproject/keccak256/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak256 = void 0;
    var js_sha3_1 = __importDefault(require_sha3());
    var bytes_1 = require_lib2();
    function keccak2566(data) {
      return "0x" + js_sha3_1.default.keccak_256((0, bytes_1.arrayify)(data));
    }
    exports.keccak256 = keccak2566;
  }
});

// ../node_modules/@ethersproject/strings/lib/_version.js
var require_version7 = __commonJS({
  "../node_modules/@ethersproject/strings/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "strings/5.7.0";
  }
});

// ../node_modules/@ethersproject/strings/lib/utf8.js
var require_utf8 = __commonJS({
  "../node_modules/@ethersproject/strings/lib/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version7();
    var logger15 = new logger_1.Logger(_version_1.version);
    var UnicodeNormalizationForm4;
    (function(UnicodeNormalizationForm5) {
      UnicodeNormalizationForm5["current"] = "";
      UnicodeNormalizationForm5["NFC"] = "NFC";
      UnicodeNormalizationForm5["NFD"] = "NFD";
      UnicodeNormalizationForm5["NFKC"] = "NFKC";
      UnicodeNormalizationForm5["NFKD"] = "NFKD";
    })(UnicodeNormalizationForm4 = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));
    var Utf8ErrorReason2;
    (function(Utf8ErrorReason3) {
      Utf8ErrorReason3["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
      Utf8ErrorReason3["BAD_PREFIX"] = "bad codepoint prefix";
      Utf8ErrorReason3["OVERRUN"] = "string overrun";
      Utf8ErrorReason3["MISSING_CONTINUE"] = "missing continuation byte";
      Utf8ErrorReason3["OUT_OF_RANGE"] = "out of UTF-8 range";
      Utf8ErrorReason3["UTF16_SURROGATE"] = "UTF-16 surrogate";
      Utf8ErrorReason3["OVERLONG"] = "overlong representation";
    })(Utf8ErrorReason2 = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));
    function errorFunc2(reason, offset, bytes4, output3, badCodepoint) {
      return logger15.throwArgumentError("invalid codepoint at offset " + offset + "; " + reason, "bytes", bytes4);
    }
    function ignoreFunc2(reason, offset, bytes4, output3, badCodepoint) {
      if (reason === Utf8ErrorReason2.BAD_PREFIX || reason === Utf8ErrorReason2.UNEXPECTED_CONTINUE) {
        var i = 0;
        for (var o = offset + 1; o < bytes4.length; o++) {
          if (bytes4[o] >> 6 !== 2) {
            break;
          }
          i++;
        }
        return i;
      }
      if (reason === Utf8ErrorReason2.OVERRUN) {
        return bytes4.length - offset - 1;
      }
      return 0;
    }
    function replaceFunc2(reason, offset, bytes4, output3, badCodepoint) {
      if (reason === Utf8ErrorReason2.OVERLONG) {
        output3.push(badCodepoint);
        return 0;
      }
      output3.push(65533);
      return ignoreFunc2(reason, offset, bytes4, output3, badCodepoint);
    }
    exports.Utf8ErrorFuncs = Object.freeze({
      error: errorFunc2,
      ignore: ignoreFunc2,
      replace: replaceFunc2
    });
    function getUtf8CodePoints2(bytes4, onError) {
      if (onError == null) {
        onError = exports.Utf8ErrorFuncs.error;
      }
      bytes4 = (0, bytes_1.arrayify)(bytes4);
      var result = [];
      var i = 0;
      while (i < bytes4.length) {
        var c = bytes4[i++];
        if (c >> 7 === 0) {
          result.push(c);
          continue;
        }
        var extraLength = null;
        var overlongMask = null;
        if ((c & 224) === 192) {
          extraLength = 1;
          overlongMask = 127;
        } else if ((c & 240) === 224) {
          extraLength = 2;
          overlongMask = 2047;
        } else if ((c & 248) === 240) {
          extraLength = 3;
          overlongMask = 65535;
        } else {
          if ((c & 192) === 128) {
            i += onError(Utf8ErrorReason2.UNEXPECTED_CONTINUE, i - 1, bytes4, result);
          } else {
            i += onError(Utf8ErrorReason2.BAD_PREFIX, i - 1, bytes4, result);
          }
          continue;
        }
        if (i - 1 + extraLength >= bytes4.length) {
          i += onError(Utf8ErrorReason2.OVERRUN, i - 1, bytes4, result);
          continue;
        }
        var res = c & (1 << 8 - extraLength - 1) - 1;
        for (var j = 0; j < extraLength; j++) {
          var nextChar = bytes4[i];
          if ((nextChar & 192) != 128) {
            i += onError(Utf8ErrorReason2.MISSING_CONTINUE, i, bytes4, result);
            res = null;
            break;
          }
          ;
          res = res << 6 | nextChar & 63;
          i++;
        }
        if (res === null) {
          continue;
        }
        if (res > 1114111) {
          i += onError(Utf8ErrorReason2.OUT_OF_RANGE, i - 1 - extraLength, bytes4, result, res);
          continue;
        }
        if (res >= 55296 && res <= 57343) {
          i += onError(Utf8ErrorReason2.UTF16_SURROGATE, i - 1 - extraLength, bytes4, result, res);
          continue;
        }
        if (res <= overlongMask) {
          i += onError(Utf8ErrorReason2.OVERLONG, i - 1 - extraLength, bytes4, result, res);
          continue;
        }
        result.push(res);
      }
      return result;
    }
    function toUtf8Bytes6(str, form) {
      if (form === void 0) {
        form = UnicodeNormalizationForm4.current;
      }
      if (form != UnicodeNormalizationForm4.current) {
        logger15.checkNormalize();
        str = str.normalize(form);
      }
      var result = [];
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
          result.push(c);
        } else if (c < 2048) {
          result.push(c >> 6 | 192);
          result.push(c & 63 | 128);
        } else if ((c & 64512) == 55296) {
          i++;
          var c2 = str.charCodeAt(i);
          if (i >= str.length || (c2 & 64512) !== 56320) {
            throw new Error("invalid utf-8 string");
          }
          var pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
          result.push(pair >> 18 | 240);
          result.push(pair >> 12 & 63 | 128);
          result.push(pair >> 6 & 63 | 128);
          result.push(pair & 63 | 128);
        } else {
          result.push(c >> 12 | 224);
          result.push(c >> 6 & 63 | 128);
          result.push(c & 63 | 128);
        }
      }
      return (0, bytes_1.arrayify)(result);
    }
    exports.toUtf8Bytes = toUtf8Bytes6;
    function escapeChar(value) {
      var hex = "0000" + value.toString(16);
      return "\\u" + hex.substring(hex.length - 4);
    }
    function _toEscapedUtf8String(bytes4, onError) {
      return '"' + getUtf8CodePoints2(bytes4, onError).map(function(codePoint) {
        if (codePoint < 256) {
          switch (codePoint) {
            case 8:
              return "\\b";
            case 9:
              return "\\t";
            case 10:
              return "\\n";
            case 13:
              return "\\r";
            case 34:
              return '\\"';
            case 92:
              return "\\\\";
          }
          if (codePoint >= 32 && codePoint < 127) {
            return String.fromCharCode(codePoint);
          }
        }
        if (codePoint <= 65535) {
          return escapeChar(codePoint);
        }
        codePoint -= 65536;
        return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
      }).join("") + '"';
    }
    exports._toEscapedUtf8String = _toEscapedUtf8String;
    function _toUtf8String2(codePoints) {
      return codePoints.map(function(codePoint) {
        if (codePoint <= 65535) {
          return String.fromCharCode(codePoint);
        }
        codePoint -= 65536;
        return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
      }).join("");
    }
    exports._toUtf8String = _toUtf8String2;
    function toUtf8String3(bytes4, onError) {
      return _toUtf8String2(getUtf8CodePoints2(bytes4, onError));
    }
    exports.toUtf8String = toUtf8String3;
    function toUtf8CodePoints(str, form) {
      if (form === void 0) {
        form = UnicodeNormalizationForm4.current;
      }
      return getUtf8CodePoints2(toUtf8Bytes6(str, form));
    }
    exports.toUtf8CodePoints = toUtf8CodePoints;
  }
});

// ../node_modules/@ethersproject/strings/lib/bytes32.js
var require_bytes32 = __commonJS({
  "../node_modules/@ethersproject/strings/lib/bytes32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseBytes32String = exports.formatBytes32String = void 0;
    var constants_1 = require_lib9();
    var bytes_1 = require_lib2();
    var utf8_1 = require_utf8();
    function formatBytes32String(text) {
      var bytes4 = (0, utf8_1.toUtf8Bytes)(text);
      if (bytes4.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
      }
      return (0, bytes_1.hexlify)((0, bytes_1.concat)([bytes4, constants_1.HashZero]).slice(0, 32));
    }
    exports.formatBytes32String = formatBytes32String;
    function parseBytes32String(bytes4) {
      var data = (0, bytes_1.arrayify)(bytes4);
      if (data.length !== 32) {
        throw new Error("invalid bytes32 - not 32 bytes long");
      }
      if (data[31] !== 0) {
        throw new Error("invalid bytes32 string - no null terminator");
      }
      var length = 31;
      while (data[length - 1] === 0) {
        length--;
      }
      return (0, utf8_1.toUtf8String)(data.slice(0, length));
    }
    exports.parseBytes32String = parseBytes32String;
  }
});

// ../node_modules/@ethersproject/strings/lib/idna.js
var require_idna = __commonJS({
  "../node_modules/@ethersproject/strings/lib/idna.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nameprep = exports._nameprepTableC = exports._nameprepTableB2 = exports._nameprepTableA1 = void 0;
    var utf8_1 = require_utf8();
    function bytes22(data) {
      if (data.length % 4 !== 0) {
        throw new Error("bad data");
      }
      var result = [];
      for (var i = 0; i < data.length; i += 4) {
        result.push(parseInt(data.substring(i, i + 4), 16));
      }
      return result;
    }
    function createTable2(data, func) {
      if (!func) {
        func = function(value) {
          return [parseInt(value, 16)];
        };
      }
      var lo = 0;
      var result = {};
      data.split(",").forEach(function(pair) {
        var comps = pair.split(":");
        lo += parseInt(comps[0], 16);
        result[lo] = func(comps[1]);
      });
      return result;
    }
    function createRangeTable2(data) {
      var hi = 0;
      return data.split(",").map(function(v) {
        var comps = v.split("-");
        if (comps.length === 1) {
          comps[1] = "0";
        } else if (comps[1] === "") {
          comps[1] = "1";
        }
        var lo = hi + parseInt(comps[0], 16);
        hi = parseInt(comps[1], 16);
        return { l: lo, h: hi };
      });
    }
    function matchMap(value, ranges) {
      var lo = 0;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        lo += range.l;
        if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
          if (range.e && range.e.indexOf(value - lo) !== -1) {
            continue;
          }
          return range;
        }
      }
      return null;
    }
    var Table_A_1_ranges = createRangeTable2("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
    var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(function(v) {
      return parseInt(v, 16);
    });
    var Table_B_2_ranges = [
      { h: 25, s: 32, l: 65 },
      { h: 30, s: 32, e: [23], l: 127 },
      { h: 54, s: 1, e: [48], l: 64, d: 2 },
      { h: 14, s: 1, l: 57, d: 2 },
      { h: 44, s: 1, l: 17, d: 2 },
      { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
      { h: 16, s: 1, l: 68, d: 2 },
      { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
      { h: 26, s: 32, e: [17], l: 435 },
      { h: 22, s: 1, l: 71, d: 2 },
      { h: 15, s: 80, l: 40 },
      { h: 31, s: 32, l: 16 },
      { h: 32, s: 1, l: 80, d: 2 },
      { h: 52, s: 1, l: 42, d: 2 },
      { h: 12, s: 1, l: 55, d: 2 },
      { h: 40, s: 1, e: [38], l: 15, d: 2 },
      { h: 14, s: 1, l: 48, d: 2 },
      { h: 37, s: 48, l: 49 },
      { h: 148, s: 1, l: 6351, d: 2 },
      { h: 88, s: 1, l: 160, d: 2 },
      { h: 15, s: 16, l: 704 },
      { h: 25, s: 26, l: 854 },
      { h: 25, s: 32, l: 55915 },
      { h: 37, s: 40, l: 1247 },
      { h: 25, s: -119711, l: 53248 },
      { h: 25, s: -119763, l: 52 },
      { h: 25, s: -119815, l: 52 },
      { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
      { h: 25, s: -119919, l: 52 },
      { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
      { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
      { h: 25, s: -120075, l: 52 },
      { h: 25, s: -120127, l: 52 },
      { h: 25, s: -120179, l: 52 },
      { h: 25, s: -120231, l: 52 },
      { h: 25, s: -120283, l: 52 },
      { h: 25, s: -120335, l: 52 },
      { h: 24, s: -119543, e: [17], l: 56 },
      { h: 24, s: -119601, e: [17], l: 58 },
      { h: 24, s: -119659, e: [17], l: 58 },
      { h: 24, s: -119717, e: [17], l: 58 },
      { h: 24, s: -119775, e: [17], l: 58 }
    ];
    var Table_B_2_lut_abs = createTable2("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
    var Table_B_2_lut_rel = createTable2("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
    var Table_B_2_complex = createTable2("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes22);
    var Table_C_ranges = createRangeTable2("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
    function flatten(values) {
      return values.reduce(function(accum, value) {
        value.forEach(function(value2) {
          accum.push(value2);
        });
        return accum;
      }, []);
    }
    function _nameprepTableA1(codepoint) {
      return !!matchMap(codepoint, Table_A_1_ranges);
    }
    exports._nameprepTableA1 = _nameprepTableA1;
    function _nameprepTableB2(codepoint) {
      var range = matchMap(codepoint, Table_B_2_ranges);
      if (range) {
        return [codepoint + range.s];
      }
      var codes = Table_B_2_lut_abs[codepoint];
      if (codes) {
        return codes;
      }
      var shift = Table_B_2_lut_rel[codepoint];
      if (shift) {
        return [codepoint + shift[0]];
      }
      var complex = Table_B_2_complex[codepoint];
      if (complex) {
        return complex;
      }
      return null;
    }
    exports._nameprepTableB2 = _nameprepTableB2;
    function _nameprepTableC(codepoint) {
      return !!matchMap(codepoint, Table_C_ranges);
    }
    exports._nameprepTableC = _nameprepTableC;
    function nameprep(value) {
      if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
        return value.toLowerCase();
      }
      var codes = (0, utf8_1.toUtf8CodePoints)(value);
      codes = flatten(codes.map(function(code) {
        if (Table_B_1_flags.indexOf(code) >= 0) {
          return [];
        }
        if (code >= 65024 && code <= 65039) {
          return [];
        }
        var codesTableB2 = _nameprepTableB2(code);
        if (codesTableB2) {
          return codesTableB2;
        }
        return [code];
      }));
      codes = (0, utf8_1.toUtf8CodePoints)((0, utf8_1._toUtf8String)(codes), utf8_1.UnicodeNormalizationForm.NFKC);
      codes.forEach(function(code) {
        if (_nameprepTableC(code)) {
          throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
        }
      });
      codes.forEach(function(code) {
        if (_nameprepTableA1(code)) {
          throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
        }
      });
      var name = (0, utf8_1._toUtf8String)(codes);
      if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
        throw new Error("invalid hyphen");
      }
      return name;
    }
    exports.nameprep = nameprep;
  }
});

// ../node_modules/@ethersproject/strings/lib/index.js
var require_lib11 = __commonJS({
  "../node_modules/@ethersproject/strings/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nameprep = exports.parseBytes32String = exports.formatBytes32String = exports.UnicodeNormalizationForm = exports.Utf8ErrorReason = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = void 0;
    var bytes32_1 = require_bytes32();
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return bytes32_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return bytes32_1.parseBytes32String;
    } });
    var idna_1 = require_idna();
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return idna_1.nameprep;
    } });
    var utf8_1 = require_utf8();
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return utf8_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return utf8_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return utf8_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return utf8_1.toUtf8String;
    } });
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return utf8_1.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return utf8_1.Utf8ErrorFuncs;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return utf8_1.Utf8ErrorReason;
    } });
  }
});

// ../node_modules/@ethersproject/hash/lib/id.js
var require_id = __commonJS({
  "../node_modules/@ethersproject/hash/lib/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id = void 0;
    var keccak256_1 = require_lib10();
    var strings_1 = require_lib11();
    function id4(text) {
      return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(text));
    }
    exports.id = id4;
  }
});

// ../node_modules/@ethersproject/hash/lib/_version.js
var require_version8 = __commonJS({
  "../node_modules/@ethersproject/hash/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "hash/5.7.0";
  }
});

// ../node_modules/@ethersproject/hash/lib/ens-normalize/decoder.js
var require_decoder = __commonJS({
  "../node_modules/@ethersproject/hash/lib/ens-normalize/decoder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read_emoji_trie = exports.read_zero_terminated_array = exports.read_mapped_map = exports.read_member_array = exports.signed = exports.read_compressed_payload = exports.read_payload = exports.decode_arithmetic = void 0;
    function flat(array, depth) {
      if (depth == null) {
        depth = 1;
      }
      var result = [];
      var forEach = result.forEach;
      var flatDeep = function(arr, depth2) {
        forEach.call(arr, function(val) {
          if (depth2 > 0 && Array.isArray(val)) {
            flatDeep(val, depth2 - 1);
          } else {
            result.push(val);
          }
        });
      };
      flatDeep(array, depth);
      return result;
    }
    function fromEntries(array) {
      var result = {};
      for (var i = 0; i < array.length; i++) {
        var value = array[i];
        result[value[0]] = value[1];
      }
      return result;
    }
    function decode_arithmetic(bytes4) {
      var pos = 0;
      function u16() {
        return bytes4[pos++] << 8 | bytes4[pos++];
      }
      var symbol_count = u16();
      var total = 1;
      var acc = [0, 1];
      for (var i = 1; i < symbol_count; i++) {
        acc.push(total += u16());
      }
      var skip = u16();
      var pos_payload = pos;
      pos += skip;
      var read_width = 0;
      var read_buffer = 0;
      function read_bit() {
        if (read_width == 0) {
          read_buffer = read_buffer << 8 | bytes4[pos++];
          read_width = 8;
        }
        return read_buffer >> --read_width & 1;
      }
      var N2 = 31;
      var FULL = Math.pow(2, N2);
      var HALF = FULL >>> 1;
      var QRTR = HALF >> 1;
      var MASK = FULL - 1;
      var register = 0;
      for (var i = 0; i < N2; i++)
        register = register << 1 | read_bit();
      var symbols = [];
      var low = 0;
      var range = FULL;
      while (true) {
        var value = Math.floor(((register - low + 1) * total - 1) / range);
        var start = 0;
        var end = symbol_count;
        while (end - start > 1) {
          var mid = start + end >>> 1;
          if (value < acc[mid]) {
            end = mid;
          } else {
            start = mid;
          }
        }
        if (start == 0)
          break;
        symbols.push(start);
        var a = low + Math.floor(range * acc[start] / total);
        var b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while (((a ^ b) & HALF) == 0) {
          register = register << 1 & MASK | read_bit();
          a = a << 1 & MASK;
          b = b << 1 & MASK | 1;
        }
        while (a & ~b & QRTR) {
          register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
          a = a << 1 ^ HALF;
          b = (b ^ HALF) << 1 | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
      }
      var offset = symbol_count - 4;
      return symbols.map(function(x) {
        switch (x - offset) {
          case 3:
            return offset + 65792 + (bytes4[pos_payload++] << 16 | bytes4[pos_payload++] << 8 | bytes4[pos_payload++]);
          case 2:
            return offset + 256 + (bytes4[pos_payload++] << 8 | bytes4[pos_payload++]);
          case 1:
            return offset + bytes4[pos_payload++];
          default:
            return x - 1;
        }
      });
    }
    exports.decode_arithmetic = decode_arithmetic;
    function read_payload(v) {
      var pos = 0;
      return function() {
        return v[pos++];
      };
    }
    exports.read_payload = read_payload;
    function read_compressed_payload(bytes4) {
      return read_payload(decode_arithmetic(bytes4));
    }
    exports.read_compressed_payload = read_compressed_payload;
    function signed(i) {
      return i & 1 ? ~i >> 1 : i >> 1;
    }
    exports.signed = signed;
    function read_counts(n, next) {
      var v = Array(n);
      for (var i = 0; i < n; i++)
        v[i] = 1 + next();
      return v;
    }
    function read_ascending(n, next) {
      var v = Array(n);
      for (var i = 0, x = -1; i < n; i++)
        v[i] = x += 1 + next();
      return v;
    }
    function read_deltas(n, next) {
      var v = Array(n);
      for (var i = 0, x = 0; i < n; i++)
        v[i] = x += signed(next());
      return v;
    }
    function read_member_array(next, lookup) {
      var v = read_ascending(next(), next);
      var n = next();
      var vX = read_ascending(n, next);
      var vN = read_counts(n, next);
      for (var i = 0; i < n; i++) {
        for (var j = 0; j < vN[i]; j++) {
          v.push(vX[i] + j);
        }
      }
      return lookup ? v.map(function(x) {
        return lookup[x];
      }) : v;
    }
    exports.read_member_array = read_member_array;
    function read_mapped_map(next) {
      var ret = [];
      while (true) {
        var w = next();
        if (w == 0)
          break;
        ret.push(read_linear_table(w, next));
      }
      while (true) {
        var w = next() - 1;
        if (w < 0)
          break;
        ret.push(read_replacement_table(w, next));
      }
      return fromEntries(flat(ret));
    }
    exports.read_mapped_map = read_mapped_map;
    function read_zero_terminated_array(next) {
      var v = [];
      while (true) {
        var i = next();
        if (i == 0)
          break;
        v.push(i);
      }
      return v;
    }
    exports.read_zero_terminated_array = read_zero_terminated_array;
    function read_transposed(n, w, next) {
      var m = Array(n).fill(void 0).map(function() {
        return [];
      });
      for (var i = 0; i < w; i++) {
        read_deltas(n, next).forEach(function(x, j) {
          return m[j].push(x);
        });
      }
      return m;
    }
    function read_linear_table(w, next) {
      var dx = 1 + next();
      var dy = next();
      var vN = read_zero_terminated_array(next);
      var m = read_transposed(vN.length, 1 + w, next);
      return flat(m.map(function(v, i) {
        var x = v[0], ys = v.slice(1);
        return Array(vN[i]).fill(void 0).map(function(_, j) {
          var j_dy = j * dy;
          return [x + j * dx, ys.map(function(y) {
            return y + j_dy;
          })];
        });
      }));
    }
    function read_replacement_table(w, next) {
      var n = 1 + next();
      var m = read_transposed(n, 1 + w, next);
      return m.map(function(v) {
        return [v[0], v.slice(1)];
      });
    }
    function read_emoji_trie(next) {
      var sorted = read_member_array(next).sort(function(a, b) {
        return a - b;
      });
      return read();
      function read() {
        var branches = [];
        while (true) {
          var keys = read_member_array(next, sorted);
          if (keys.length == 0)
            break;
          branches.push({ set: new Set(keys), node: read() });
        }
        branches.sort(function(a, b) {
          return b.set.size - a.set.size;
        });
        var temp = next();
        var valid = temp % 3;
        temp = temp / 3 | 0;
        var fe0f = !!(temp & 1);
        temp >>= 1;
        var save = temp == 1;
        var check = temp == 2;
        return { branches, valid, fe0f, save, check };
      }
    }
    exports.read_emoji_trie = read_emoji_trie;
  }
});

// ../node_modules/@ethersproject/hash/lib/ens-normalize/include.js
var require_include = __commonJS({
  "../node_modules/@ethersproject/hash/lib/ens-normalize/include.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = void 0;
    var base64_1 = require_lib7();
    var decoder_js_1 = require_decoder();
    function getData() {
      return (0, decoder_js_1.read_compressed_payload)((0, base64_1.decode)("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
    }
    exports.getData = getData;
  }
});

// ../node_modules/@ethersproject/hash/lib/ens-normalize/lib.js
var require_lib12 = __commonJS({
  "../node_modules/@ethersproject/hash/lib/ens-normalize/lib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ens_normalize = exports.ens_normalize_post_check = void 0;
    var strings_1 = require_lib11();
    var include_js_1 = require_include();
    var r = (0, include_js_1.getData)();
    var decoder_js_1 = require_decoder();
    var VALID = new Set((0, decoder_js_1.read_member_array)(r));
    var IGNORED = new Set((0, decoder_js_1.read_member_array)(r));
    var MAPPED = (0, decoder_js_1.read_mapped_map)(r);
    var EMOJI_ROOT = (0, decoder_js_1.read_emoji_trie)(r);
    var HYPHEN = 45;
    var UNDERSCORE = 95;
    function explode_cp(name) {
      return (0, strings_1.toUtf8CodePoints)(name);
    }
    function filter_fe0f(cps) {
      return cps.filter(function(cp) {
        return cp != 65039;
      });
    }
    function ens_normalize_post_check(name) {
      for (var _i = 0, _a = name.split("."); _i < _a.length; _i++) {
        var label = _a[_i];
        var cps = explode_cp(label);
        try {
          for (var i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
            if (cps[i] !== UNDERSCORE) {
              throw new Error("underscore only allowed at start");
            }
          }
          if (cps.length >= 4 && cps.every(function(cp) {
            return cp < 128;
          }) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
            throw new Error("invalid label extension");
          }
        } catch (err) {
          throw new Error('Invalid label "' + label + '": ' + err.message);
        }
      }
      return name;
    }
    exports.ens_normalize_post_check = ens_normalize_post_check;
    function ens_normalize(name) {
      return ens_normalize_post_check(normalize(name, filter_fe0f));
    }
    exports.ens_normalize = ens_normalize;
    function normalize(name, emoji_filter) {
      var input = explode_cp(name).reverse();
      var output3 = [];
      while (input.length) {
        var emoji = consume_emoji_reversed(input);
        if (emoji) {
          output3.push.apply(output3, emoji_filter(emoji));
          continue;
        }
        var cp = input.pop();
        if (VALID.has(cp)) {
          output3.push(cp);
          continue;
        }
        if (IGNORED.has(cp)) {
          continue;
        }
        var cps = MAPPED[cp];
        if (cps) {
          output3.push.apply(output3, cps);
          continue;
        }
        throw new Error("Disallowed codepoint: 0x" + cp.toString(16).toUpperCase());
      }
      return ens_normalize_post_check(nfc(String.fromCodePoint.apply(String, output3)));
    }
    function nfc(s) {
      return s.normalize("NFC");
    }
    function consume_emoji_reversed(cps, eaten) {
      var _a;
      var node = EMOJI_ROOT;
      var emoji;
      var saved;
      var stack = [];
      var pos = cps.length;
      if (eaten)
        eaten.length = 0;
      var _loop_1 = function() {
        var cp = cps[--pos];
        node = (_a = node.branches.find(function(x) {
          return x.set.has(cp);
        })) === null || _a === void 0 ? void 0 : _a.node;
        if (!node)
          return "break";
        if (node.save) {
          saved = cp;
        } else if (node.check) {
          if (cp === saved)
            return "break";
        }
        stack.push(cp);
        if (node.fe0f) {
          stack.push(65039);
          if (pos > 0 && cps[pos - 1] == 65039)
            pos--;
        }
        if (node.valid) {
          emoji = stack.slice();
          if (node.valid == 2)
            emoji.splice(1, 1);
          if (eaten)
            eaten.push.apply(eaten, cps.slice(pos).reverse());
          cps.length = pos;
        }
      };
      while (pos) {
        var state_1 = _loop_1();
        if (state_1 === "break")
          break;
      }
      return emoji;
    }
  }
});

// ../node_modules/@ethersproject/hash/lib/namehash.js
var require_namehash = __commonJS({
  "../node_modules/@ethersproject/hash/lib/namehash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;
    var bytes_1 = require_lib2();
    var strings_1 = require_lib11();
    var keccak256_1 = require_lib10();
    var logger_1 = require_lib();
    var _version_1 = require_version8();
    var logger15 = new logger_1.Logger(_version_1.version);
    var lib_1 = require_lib12();
    var Zeros = new Uint8Array(32);
    Zeros.fill(0);
    function checkComponent(comp) {
      if (comp.length === 0) {
        throw new Error("invalid ENS name; empty component");
      }
      return comp;
    }
    function ensNameSplit(name) {
      var bytes4 = (0, strings_1.toUtf8Bytes)((0, lib_1.ens_normalize)(name));
      var comps = [];
      if (name.length === 0) {
        return comps;
      }
      var last = 0;
      for (var i = 0; i < bytes4.length; i++) {
        var d = bytes4[i];
        if (d === 46) {
          comps.push(checkComponent(bytes4.slice(last, i)));
          last = i + 1;
        }
      }
      if (last >= bytes4.length) {
        throw new Error("invalid ENS name; empty component");
      }
      comps.push(checkComponent(bytes4.slice(last)));
      return comps;
    }
    function ensNormalize(name) {
      return ensNameSplit(name).map(function(comp) {
        return (0, strings_1.toUtf8String)(comp);
      }).join(".");
    }
    exports.ensNormalize = ensNormalize;
    function isValidName2(name) {
      try {
        return ensNameSplit(name).length !== 0;
      } catch (error) {
      }
      return false;
    }
    exports.isValidName = isValidName2;
    function namehash3(name) {
      if (typeof name !== "string") {
        logger15.throwArgumentError("invalid ENS name; not a string", "name", name);
      }
      var result = Zeros;
      var comps = ensNameSplit(name);
      while (comps.length) {
        result = (0, keccak256_1.keccak256)((0, bytes_1.concat)([result, (0, keccak256_1.keccak256)(comps.pop())]));
      }
      return (0, bytes_1.hexlify)(result);
    }
    exports.namehash = namehash3;
    function dnsEncode2(name) {
      return (0, bytes_1.hexlify)((0, bytes_1.concat)(ensNameSplit(name).map(function(comp) {
        if (comp.length > 63) {
          throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        }
        var bytes4 = new Uint8Array(comp.length + 1);
        bytes4.set(comp, 1);
        bytes4[0] = bytes4.length - 1;
        return bytes4;
      }))) + "00";
    }
    exports.dnsEncode = dnsEncode2;
  }
});

// ../node_modules/@ethersproject/hash/lib/message.js
var require_message = __commonJS({
  "../node_modules/@ethersproject/hash/lib/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashMessage = exports.messagePrefix = void 0;
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib10();
    var strings_1 = require_lib11();
    exports.messagePrefix = "Ethereum Signed Message:\n";
    function hashMessage4(message) {
      if (typeof message === "string") {
        message = (0, strings_1.toUtf8Bytes)(message);
      }
      return (0, keccak256_1.keccak256)((0, bytes_1.concat)([
        (0, strings_1.toUtf8Bytes)(exports.messagePrefix),
        (0, strings_1.toUtf8Bytes)(String(message.length)),
        message
      ]));
    }
    exports.hashMessage = hashMessage4;
  }
});

// ../node_modules/@ethersproject/rlp/lib/_version.js
var require_version9 = __commonJS({
  "../node_modules/@ethersproject/rlp/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "rlp/5.7.0";
  }
});

// ../node_modules/@ethersproject/rlp/lib/index.js
var require_lib13 = __commonJS({
  "../node_modules/@ethersproject/rlp/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version9();
    var logger15 = new logger_1.Logger(_version_1.version);
    function arrayifyInteger(value) {
      var result = [];
      while (value) {
        result.unshift(value & 255);
        value >>= 8;
      }
      return result;
    }
    function unarrayifyInteger(data, offset, length) {
      var result = 0;
      for (var i = 0; i < length; i++) {
        result = result * 256 + data[offset + i];
      }
      return result;
    }
    function _encode(object) {
      if (Array.isArray(object)) {
        var payload_1 = [];
        object.forEach(function(child) {
          payload_1 = payload_1.concat(_encode(child));
        });
        if (payload_1.length <= 55) {
          payload_1.unshift(192 + payload_1.length);
          return payload_1;
        }
        var length_1 = arrayifyInteger(payload_1.length);
        length_1.unshift(247 + length_1.length);
        return length_1.concat(payload_1);
      }
      if (!(0, bytes_1.isBytesLike)(object)) {
        logger15.throwArgumentError("RLP object must be BytesLike", "object", object);
      }
      var data = Array.prototype.slice.call((0, bytes_1.arrayify)(object));
      if (data.length === 1 && data[0] <= 127) {
        return data;
      } else if (data.length <= 55) {
        data.unshift(128 + data.length);
        return data;
      }
      var length = arrayifyInteger(data.length);
      length.unshift(183 + length.length);
      return length.concat(data);
    }
    function encode(object) {
      return (0, bytes_1.hexlify)(_encode(object));
    }
    exports.encode = encode;
    function _decodeChildren(data, offset, childOffset, length) {
      var result = [];
      while (childOffset < offset + 1 + length) {
        var decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
          logger15.throwError("child data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
      }
      return { consumed: 1 + length, result };
    }
    function _decode(data, offset) {
      if (data.length === 0) {
        logger15.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
      }
      if (data[offset] >= 248) {
        var lengthLength = data[offset] - 247;
        if (offset + 1 + lengthLength > data.length) {
          logger15.throwError("data short segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length_2 > data.length) {
          logger15.throwError("data long segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);
      } else if (data[offset] >= 192) {
        var length_3 = data[offset] - 192;
        if (offset + 1 + length_3 > data.length) {
          logger15.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length_3);
      } else if (data[offset] >= 184) {
        var lengthLength = data[offset] - 183;
        if (offset + 1 + lengthLength > data.length) {
          logger15.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length_4 > data.length) {
          logger15.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var result = (0, bytes_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));
        return { consumed: 1 + lengthLength + length_4, result };
      } else if (data[offset] >= 128) {
        var length_5 = data[offset] - 128;
        if (offset + 1 + length_5 > data.length) {
          logger15.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
        }
        var result = (0, bytes_1.hexlify)(data.slice(offset + 1, offset + 1 + length_5));
        return { consumed: 1 + length_5, result };
      }
      return { consumed: 1, result: (0, bytes_1.hexlify)(data[offset]) };
    }
    function decode(data) {
      var bytes4 = (0, bytes_1.arrayify)(data);
      var decoded = _decode(bytes4, 0);
      if (decoded.consumed !== bytes4.length) {
        logger15.throwArgumentError("invalid rlp data", "data", data);
      }
      return decoded.result;
    }
    exports.decode = decode;
  }
});

// ../node_modules/@ethersproject/address/lib/_version.js
var require_version10 = __commonJS({
  "../node_modules/@ethersproject/address/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "address/5.7.0";
  }
});

// ../node_modules/@ethersproject/address/lib/index.js
var require_lib14 = __commonJS({
  "../node_modules/@ethersproject/address/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;
    var bytes_1 = require_lib2();
    var bignumber_1 = require_lib3();
    var keccak256_1 = require_lib10();
    var rlp_1 = require_lib13();
    var logger_1 = require_lib();
    var _version_1 = require_version10();
    var logger15 = new logger_1.Logger(_version_1.version);
    function getChecksumAddress(address) {
      if (!(0, bytes_1.isHexString)(address, 20)) {
        logger15.throwArgumentError("invalid address", "address", address);
      }
      address = address.toLowerCase();
      var chars = address.substring(2).split("");
      var expanded = new Uint8Array(40);
      for (var i2 = 0; i2 < 40; i2++) {
        expanded[i2] = chars[i2].charCodeAt(0);
      }
      var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));
      for (var i2 = 0; i2 < 40; i2 += 2) {
        if (hashed[i2 >> 1] >> 4 >= 8) {
          chars[i2] = chars[i2].toUpperCase();
        }
        if ((hashed[i2 >> 1] & 15) >= 8) {
          chars[i2 + 1] = chars[i2 + 1].toUpperCase();
        }
      }
      return "0x" + chars.join("");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function log10(x) {
      if (Math.log10) {
        return Math.log10(x);
      }
      return Math.log(x) / Math.LN10;
    }
    var ibanLookup = {};
    for (i = 0; i < 10; i++) {
      ibanLookup[String(i)] = String(i);
    }
    var i;
    for (i = 0; i < 26; i++) {
      ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
    }
    var i;
    var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
    function ibanChecksum(address) {
      address = address.toUpperCase();
      address = address.substring(4) + address.substring(0, 2) + "00";
      var expanded = address.split("").map(function(c) {
        return ibanLookup[c];
      }).join("");
      while (expanded.length >= safeDigits) {
        var block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
      }
      var checksum = String(98 - parseInt(expanded, 10) % 97);
      while (checksum.length < 2) {
        checksum = "0" + checksum;
      }
      return checksum;
    }
    function getAddress7(address) {
      var result = null;
      if (typeof address !== "string") {
        logger15.throwArgumentError("invalid address", "address", address);
      }
      if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        if (address.substring(0, 2) !== "0x") {
          address = "0x" + address;
        }
        result = getChecksumAddress(address);
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
          logger15.throwArgumentError("bad address checksum", "address", address);
        }
      } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        if (address.substring(2, 4) !== ibanChecksum(address)) {
          logger15.throwArgumentError("bad icap checksum", "address", address);
        }
        result = (0, bignumber_1._base36To16)(address.substring(4));
        while (result.length < 40) {
          result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
      } else {
        logger15.throwArgumentError("invalid address", "address", address);
      }
      return result;
    }
    exports.getAddress = getAddress7;
    function isAddress2(address) {
      try {
        getAddress7(address);
        return true;
      } catch (error) {
      }
      return false;
    }
    exports.isAddress = isAddress2;
    function getIcapAddress(address) {
      var base36 = (0, bignumber_1._base16To36)(getAddress7(address).substring(2)).toUpperCase();
      while (base36.length < 30) {
        base36 = "0" + base36;
      }
      return "XE" + ibanChecksum("XE00" + base36) + base36;
    }
    exports.getIcapAddress = getIcapAddress;
    function getContractAddress3(transaction) {
      var from = null;
      try {
        from = getAddress7(transaction.from);
      } catch (error) {
        logger15.throwArgumentError("missing from address", "transaction", transaction);
      }
      var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));
      return getAddress7((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));
    }
    exports.getContractAddress = getContractAddress3;
    function getCreate2Address(from, salt, initCodeHash) {
      if ((0, bytes_1.hexDataLength)(salt) !== 32) {
        logger15.throwArgumentError("salt must be 32 bytes", "salt", salt);
      }
      if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {
        logger15.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
      }
      return getAddress7((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)(["0xff", getAddress7(from), salt, initCodeHash])), 12));
    }
    exports.getCreate2Address = getCreate2Address;
  }
});

// ../node_modules/@ethersproject/hash/lib/typed-data.js
var require_typed_data = __commonJS({
  "../node_modules/@ethersproject/hash/lib/typed-data.js"(exports) {
    "use strict";
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypedDataEncoder = void 0;
    var address_1 = require_lib14();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var keccak256_1 = require_lib10();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version8();
    var logger15 = new logger_1.Logger(_version_1.version);
    var id_1 = require_id();
    var padding = new Uint8Array(32);
    padding.fill(0);
    var NegativeOne2 = bignumber_1.BigNumber.from(-1);
    var Zero2 = bignumber_1.BigNumber.from(0);
    var One2 = bignumber_1.BigNumber.from(1);
    var MaxUint2562 = bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    function hexPadRight(value) {
      var bytes4 = (0, bytes_1.arrayify)(value);
      var padOffset = bytes4.length % 32;
      if (padOffset) {
        return (0, bytes_1.hexConcat)([bytes4, padding.slice(padOffset)]);
      }
      return (0, bytes_1.hexlify)(bytes4);
    }
    var hexTrue = (0, bytes_1.hexZeroPad)(One2.toHexString(), 32);
    var hexFalse = (0, bytes_1.hexZeroPad)(Zero2.toHexString(), 32);
    var domainFieldTypes = {
      name: "string",
      version: "string",
      chainId: "uint256",
      verifyingContract: "address",
      salt: "bytes32"
    };
    var domainFieldNames = [
      "name",
      "version",
      "chainId",
      "verifyingContract",
      "salt"
    ];
    function checkString(key) {
      return function(value) {
        if (typeof value !== "string") {
          logger15.throwArgumentError("invalid domain value for " + JSON.stringify(key), "domain." + key, value);
        }
        return value;
      };
    }
    var domainChecks = {
      name: checkString("name"),
      version: checkString("version"),
      chainId: function(value) {
        try {
          return bignumber_1.BigNumber.from(value).toString();
        } catch (error) {
        }
        return logger15.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", value);
      },
      verifyingContract: function(value) {
        try {
          return (0, address_1.getAddress)(value).toLowerCase();
        } catch (error) {
        }
        return logger15.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", value);
      },
      salt: function(value) {
        try {
          var bytes4 = (0, bytes_1.arrayify)(value);
          if (bytes4.length !== 32) {
            throw new Error("bad length");
          }
          return (0, bytes_1.hexlify)(bytes4);
        } catch (error) {
        }
        return logger15.throwArgumentError('invalid domain value "salt"', "domain.salt", value);
      }
    };
    function getBaseEncoder(type) {
      {
        var match = type.match(/^(u?)int(\d*)$/);
        if (match) {
          var signed = match[1] === "";
          var width = parseInt(match[2] || "256");
          if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
            logger15.throwArgumentError("invalid numeric width", "type", type);
          }
          var boundsUpper_1 = MaxUint2562.mask(signed ? width - 1 : width);
          var boundsLower_1 = signed ? boundsUpper_1.add(One2).mul(NegativeOne2) : Zero2;
          return function(value) {
            var v = bignumber_1.BigNumber.from(value);
            if (v.lt(boundsLower_1) || v.gt(boundsUpper_1)) {
              logger15.throwArgumentError("value out-of-bounds for " + type, "value", value);
            }
            return (0, bytes_1.hexZeroPad)(v.toTwos(256).toHexString(), 32);
          };
        }
      }
      {
        var match = type.match(/^bytes(\d+)$/);
        if (match) {
          var width_1 = parseInt(match[1]);
          if (width_1 === 0 || width_1 > 32 || match[1] !== String(width_1)) {
            logger15.throwArgumentError("invalid bytes width", "type", type);
          }
          return function(value) {
            var bytes4 = (0, bytes_1.arrayify)(value);
            if (bytes4.length !== width_1) {
              logger15.throwArgumentError("invalid length for " + type, "value", value);
            }
            return hexPadRight(value);
          };
        }
      }
      switch (type) {
        case "address":
          return function(value) {
            return (0, bytes_1.hexZeroPad)((0, address_1.getAddress)(value), 32);
          };
        case "bool":
          return function(value) {
            return !value ? hexFalse : hexTrue;
          };
        case "bytes":
          return function(value) {
            return (0, keccak256_1.keccak256)(value);
          };
        case "string":
          return function(value) {
            return (0, id_1.id)(value);
          };
      }
      return null;
    }
    function encodeType2(name, fields) {
      return name + "(" + fields.map(function(_a) {
        var name2 = _a.name, type = _a.type;
        return type + " " + name2;
      }).join(",") + ")";
    }
    var TypedDataEncoder = function() {
      function TypedDataEncoder2(types) {
        (0, properties_1.defineReadOnly)(this, "types", Object.freeze((0, properties_1.deepCopy)(types)));
        (0, properties_1.defineReadOnly)(this, "_encoderCache", {});
        (0, properties_1.defineReadOnly)(this, "_types", {});
        var links = {};
        var parents = {};
        var subtypes = {};
        Object.keys(types).forEach(function(type) {
          links[type] = {};
          parents[type] = [];
          subtypes[type] = {};
        });
        var _loop_1 = function(name_12) {
          var uniqueNames = {};
          types[name_12].forEach(function(field) {
            if (uniqueNames[field.name]) {
              logger15.throwArgumentError("duplicate variable name " + JSON.stringify(field.name) + " in " + JSON.stringify(name_12), "types", types);
            }
            uniqueNames[field.name] = true;
            var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
            if (baseType === name_12) {
              logger15.throwArgumentError("circular type reference to " + JSON.stringify(baseType), "types", types);
            }
            var encoder3 = getBaseEncoder(baseType);
            if (encoder3) {
              return;
            }
            if (!parents[baseType]) {
              logger15.throwArgumentError("unknown type " + JSON.stringify(baseType), "types", types);
            }
            parents[baseType].push(name_12);
            links[name_12][baseType] = true;
          });
        };
        for (var name_1 in types) {
          _loop_1(name_1);
        }
        var primaryTypes = Object.keys(parents).filter(function(n) {
          return parents[n].length === 0;
        });
        if (primaryTypes.length === 0) {
          logger15.throwArgumentError("missing primary type", "types", types);
        } else if (primaryTypes.length > 1) {
          logger15.throwArgumentError("ambiguous primary types or unused types: " + primaryTypes.map(function(t) {
            return JSON.stringify(t);
          }).join(", "), "types", types);
        }
        (0, properties_1.defineReadOnly)(this, "primaryType", primaryTypes[0]);
        function checkCircular(type, found) {
          if (found[type]) {
            logger15.throwArgumentError("circular type reference to " + JSON.stringify(type), "types", types);
          }
          found[type] = true;
          Object.keys(links[type]).forEach(function(child) {
            if (!parents[child]) {
              return;
            }
            checkCircular(child, found);
            Object.keys(found).forEach(function(subtype) {
              subtypes[subtype][child] = true;
            });
          });
          delete found[type];
        }
        checkCircular(this.primaryType, {});
        for (var name_2 in subtypes) {
          var st = Object.keys(subtypes[name_2]);
          st.sort();
          this._types[name_2] = encodeType2(name_2, types[name_2]) + st.map(function(t) {
            return encodeType2(t, types[t]);
          }).join("");
        }
      }
      TypedDataEncoder2.prototype.getEncoder = function(type) {
        var encoder3 = this._encoderCache[type];
        if (!encoder3) {
          encoder3 = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder3;
      };
      TypedDataEncoder2.prototype._getEncoder = function(type) {
        var _this = this;
        {
          var encoder3 = getBaseEncoder(type);
          if (encoder3) {
            return encoder3;
          }
        }
        var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          var subtype_1 = match[1];
          var subEncoder_1 = this.getEncoder(subtype_1);
          var length_1 = parseInt(match[3]);
          return function(value) {
            if (length_1 >= 0 && value.length !== length_1) {
              logger15.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            var result = value.map(subEncoder_1);
            if (_this._types[subtype_1]) {
              result = result.map(keccak256_1.keccak256);
            }
            return (0, keccak256_1.keccak256)((0, bytes_1.hexConcat)(result));
          };
        }
        var fields = this.types[type];
        if (fields) {
          var encodedType_1 = (0, id_1.id)(this._types[type]);
          return function(value) {
            var values = fields.map(function(_a) {
              var name = _a.name, type2 = _a.type;
              var result = _this.getEncoder(type2)(value[name]);
              if (_this._types[type2]) {
                return (0, keccak256_1.keccak256)(result);
              }
              return result;
            });
            values.unshift(encodedType_1);
            return (0, bytes_1.hexConcat)(values);
          };
        }
        return logger15.throwArgumentError("unknown type: " + type, "type", type);
      };
      TypedDataEncoder2.prototype.encodeType = function(name) {
        var result = this._types[name];
        if (!result) {
          logger15.throwArgumentError("unknown type: " + JSON.stringify(name), "name", name);
        }
        return result;
      };
      TypedDataEncoder2.prototype.encodeData = function(type, value) {
        return this.getEncoder(type)(value);
      };
      TypedDataEncoder2.prototype.hashStruct = function(name, value) {
        return (0, keccak256_1.keccak256)(this.encodeData(name, value));
      };
      TypedDataEncoder2.prototype.encode = function(value) {
        return this.encodeData(this.primaryType, value);
      };
      TypedDataEncoder2.prototype.hash = function(value) {
        return this.hashStruct(this.primaryType, value);
      };
      TypedDataEncoder2.prototype._visit = function(type, value, callback) {
        var _this = this;
        {
          var encoder3 = getBaseEncoder(type);
          if (encoder3) {
            return callback(type, value);
          }
        }
        var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
          var subtype_2 = match[1];
          var length_2 = parseInt(match[3]);
          if (length_2 >= 0 && value.length !== length_2) {
            logger15.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
          }
          return value.map(function(v) {
            return _this._visit(subtype_2, v, callback);
          });
        }
        var fields = this.types[type];
        if (fields) {
          return fields.reduce(function(accum, _a) {
            var name = _a.name, type2 = _a.type;
            accum[name] = _this._visit(type2, value[name], callback);
            return accum;
          }, {});
        }
        return logger15.throwArgumentError("unknown type: " + type, "type", type);
      };
      TypedDataEncoder2.prototype.visit = function(value, callback) {
        return this._visit(this.primaryType, value, callback);
      };
      TypedDataEncoder2.from = function(types) {
        return new TypedDataEncoder2(types);
      };
      TypedDataEncoder2.getPrimaryType = function(types) {
        return TypedDataEncoder2.from(types).primaryType;
      };
      TypedDataEncoder2.hashStruct = function(name, types, value) {
        return TypedDataEncoder2.from(types).hashStruct(name, value);
      };
      TypedDataEncoder2.hashDomain = function(domain) {
        var domainFields = [];
        for (var name_3 in domain) {
          var type = domainFieldTypes[name_3];
          if (!type) {
            logger15.throwArgumentError("invalid typed-data domain key: " + JSON.stringify(name_3), "domain", domain);
          }
          domainFields.push({ name: name_3, type });
        }
        domainFields.sort(function(a, b) {
          return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder2.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
      };
      TypedDataEncoder2.encode = function(domain, types, value) {
        return (0, bytes_1.hexConcat)([
          "0x1901",
          TypedDataEncoder2.hashDomain(domain),
          TypedDataEncoder2.from(types).hash(value)
        ]);
      };
      TypedDataEncoder2.hash = function(domain, types, value) {
        return (0, keccak256_1.keccak256)(TypedDataEncoder2.encode(domain, types, value));
      };
      TypedDataEncoder2.resolveNames = function(domain, types, value, resolveName2) {
        return __awaiter5(this, void 0, void 0, function() {
          var ensCache, encoder3, _a, _b, _i, name_4, _c, _d;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                domain = (0, properties_1.shallowCopy)(domain);
                ensCache = {};
                if (domain.verifyingContract && !(0, bytes_1.isHexString)(domain.verifyingContract, 20)) {
                  ensCache[domain.verifyingContract] = "0x";
                }
                encoder3 = TypedDataEncoder2.from(types);
                encoder3.visit(value, function(type, value2) {
                  if (type === "address" && !(0, bytes_1.isHexString)(value2, 20)) {
                    ensCache[value2] = "0x";
                  }
                  return value2;
                });
                _a = [];
                for (_b in ensCache)
                  _a.push(_b);
                _i = 0;
                _e.label = 1;
              case 1:
                if (!(_i < _a.length))
                  return [3, 4];
                name_4 = _a[_i];
                _c = ensCache;
                _d = name_4;
                return [4, resolveName2(name_4)];
              case 2:
                _c[_d] = _e.sent();
                _e.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                  domain.verifyingContract = ensCache[domain.verifyingContract];
                }
                value = encoder3.visit(value, function(type, value2) {
                  if (type === "address" && ensCache[value2]) {
                    return ensCache[value2];
                  }
                  return value2;
                });
                return [2, { domain, value }];
            }
          });
        });
      };
      TypedDataEncoder2.getPayload = function(domain, types, value) {
        TypedDataEncoder2.hashDomain(domain);
        var domainValues = {};
        var domainTypes = [];
        domainFieldNames.forEach(function(name) {
          var value2 = domain[name];
          if (value2 == null) {
            return;
          }
          domainValues[name] = domainChecks[name](value2);
          domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        var encoder3 = TypedDataEncoder2.from(types);
        var typesWithDomain = (0, properties_1.shallowCopy)(types);
        if (typesWithDomain.EIP712Domain) {
          logger15.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        } else {
          typesWithDomain.EIP712Domain = domainTypes;
        }
        encoder3.encode(value);
        return {
          types: typesWithDomain,
          domain: domainValues,
          primaryType: encoder3.primaryType,
          message: encoder3.visit(value, function(type, value2) {
            if (type.match(/^bytes(\d*)/)) {
              return (0, bytes_1.hexlify)((0, bytes_1.arrayify)(value2));
            }
            if (type.match(/^u?int/)) {
              return bignumber_1.BigNumber.from(value2).toString();
            }
            switch (type) {
              case "address":
                return value2.toLowerCase();
              case "bool":
                return !!value2;
              case "string":
                if (typeof value2 !== "string") {
                  logger15.throwArgumentError("invalid string", "value", value2);
                }
                return value2;
            }
            return logger15.throwArgumentError("unsupported type", "type", type);
          })
        };
      };
      return TypedDataEncoder2;
    }();
    exports.TypedDataEncoder = TypedDataEncoder;
  }
});

// ../node_modules/@ethersproject/hash/lib/index.js
var require_lib15 = __commonJS({
  "../node_modules/@ethersproject/hash/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._TypedDataEncoder = exports.hashMessage = exports.messagePrefix = exports.ensNormalize = exports.isValidName = exports.namehash = exports.dnsEncode = exports.id = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return id_1.id;
    } });
    var namehash_1 = require_namehash();
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return namehash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return namehash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_1.namehash;
    } });
    var message_1 = require_message();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return message_1.hashMessage;
    } });
    Object.defineProperty(exports, "messagePrefix", { enumerable: true, get: function() {
      return message_1.messagePrefix;
    } });
    var namehash_2 = require_namehash();
    Object.defineProperty(exports, "ensNormalize", { enumerable: true, get: function() {
      return namehash_2.ensNormalize;
    } });
    var typed_data_1 = require_typed_data();
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return typed_data_1.TypedDataEncoder;
    } });
  }
});

// ../node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "../node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert2;
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert2.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// ../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../node_modules/hash.js/lib/hash/utils.js
var require_utils2 = __commonJS({
  "../node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert2 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports.toArray = toArray;
    function toHex3(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports.toHex = toHex3;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert2(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// ../node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "../node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils2();
    var assert2 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert2(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad2() {
      var len = this.pendingTotal;
      var bytes4 = this._delta8;
      var k = bytes4 - (len + this.padLength) % bytes4;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// ../node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "../node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils2();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// ../node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "../node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// ../node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "../node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var common = require_common();
    var shaCommon = require_common2();
    var assert2 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA2562() {
      if (!(this instanceof SHA2562))
        return new SHA2562();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA2562, BlockHash);
    module.exports = SHA2562;
    SHA2562.blockSize = 512;
    SHA2562.outSize = 256;
    SHA2562.hmacStrength = 192;
    SHA2562.padLength = 64;
    SHA2562.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert2(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA2562.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// ../node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "../node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var SHA2562 = require__2();
    function SHA2242() {
      if (!(this instanceof SHA2242))
        return new SHA2242();
      SHA2562.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA2242, SHA2562);
    module.exports = SHA2242;
    SHA2242.blockSize = 512;
    SHA2242.outSize = 224;
    SHA2242.hmacStrength = 192;
    SHA2242.padLength = 64;
    SHA2242.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// ../node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "../node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var common = require_common();
    var assert2 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert2(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// ../node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "../node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// ../node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "../node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// ../node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "../node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils2();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// ../node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "../node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var assert2 = require_minimalistic_assert();
    function Hmac(hash4, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash4, key, enc);
      this.Hash = hash4;
      this.blockSize = hash4.blockSize / 8;
      this.outSize = hash4.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert2(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// ../node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "../node_modules/hash.js/lib/hash.js"(exports) {
    var hash4 = exports;
    hash4.utils = require_utils2();
    hash4.common = require_common();
    hash4.sha = require_sha();
    hash4.ripemd = require_ripemd();
    hash4.hmac = require_hmac();
    hash4.sha1 = hash4.sha.sha1;
    hash4.sha256 = hash4.sha.sha256;
    hash4.sha224 = hash4.sha.sha224;
    hash4.sha384 = hash4.sha.sha384;
    hash4.sha512 = hash4.sha.sha512;
    hash4.ripemd160 = hash4.ripemd.ripemd160;
  }
});

// ../node_modules/@ethersproject/sha2/lib/types.js
var require_types = __commonJS({
  "../node_modules/@ethersproject/sha2/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupportedAlgorithm = void 0;
    var SupportedAlgorithm2;
    (function(SupportedAlgorithm3) {
      SupportedAlgorithm3["sha256"] = "sha256";
      SupportedAlgorithm3["sha512"] = "sha512";
    })(SupportedAlgorithm2 = exports.SupportedAlgorithm || (exports.SupportedAlgorithm = {}));
  }
});

// ../node_modules/@ethersproject/sha2/lib/_version.js
var require_version11 = __commonJS({
  "../node_modules/@ethersproject/sha2/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "sha2/5.7.0";
  }
});

// ../node_modules/@ethersproject/sha2/lib/browser-sha2.js
var require_browser_sha2 = __commonJS({
  "../node_modules/@ethersproject/sha2/lib/browser-sha2.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeHmac = exports.sha512 = exports.sha256 = exports.ripemd160 = void 0;
    var hash_js_1 = __importDefault(require_hash());
    var bytes_1 = require_lib2();
    var types_1 = require_types();
    var logger_1 = require_lib();
    var _version_1 = require_version11();
    var logger15 = new logger_1.Logger(_version_1.version);
    function ripemd1602(data) {
      return "0x" + hash_js_1.default.ripemd160().update((0, bytes_1.arrayify)(data)).digest("hex");
    }
    exports.ripemd160 = ripemd1602;
    function sha2563(data) {
      return "0x" + hash_js_1.default.sha256().update((0, bytes_1.arrayify)(data)).digest("hex");
    }
    exports.sha256 = sha2563;
    function sha512(data) {
      return "0x" + hash_js_1.default.sha512().update((0, bytes_1.arrayify)(data)).digest("hex");
    }
    exports.sha512 = sha512;
    function computeHmac3(algorithm, key, data) {
      if (!types_1.SupportedAlgorithm[algorithm]) {
        logger15.throwError("unsupported algorithm " + algorithm, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "hmac",
          algorithm
        });
      }
      return "0x" + hash_js_1.default.hmac(hash_js_1.default[algorithm], (0, bytes_1.arrayify)(key)).update((0, bytes_1.arrayify)(data)).digest("hex");
    }
    exports.computeHmac = computeHmac3;
  }
});

// ../node_modules/@ethersproject/sha2/lib/index.js
var require_lib16 = __commonJS({
  "../node_modules/@ethersproject/sha2/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SupportedAlgorithm = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.computeHmac = void 0;
    var sha2_1 = require_browser_sha2();
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return types_1.SupportedAlgorithm;
    } });
  }
});

// ../node_modules/@ethersproject/web/lib/_version.js
var require_version12 = __commonJS({
  "../node_modules/@ethersproject/web/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "web/5.7.1";
  }
});

// ../node_modules/@ethersproject/web/lib/browser-geturl.js
var require_browser_geturl = __commonJS({
  "../node_modules/@ethersproject/web/lib/browser-geturl.js"(exports) {
    "use strict";
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUrl = void 0;
    var bytes_1 = require_lib2();
    function getUrl2(href, options) {
      return __awaiter5(this, void 0, void 0, function() {
        var request, opts, response, body, headers;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (options == null) {
                options = {};
              }
              request = {
                method: options.method || "GET",
                headers: options.headers || {},
                body: options.body || void 0
              };
              if (options.skipFetchSetup !== true) {
                request.mode = "cors";
                request.cache = "no-cache";
                request.credentials = "same-origin";
                request.redirect = "follow";
                request.referrer = "client";
              }
              ;
              if (options.fetchOptions != null) {
                opts = options.fetchOptions;
                if (opts.mode) {
                  request.mode = opts.mode;
                }
                if (opts.cache) {
                  request.cache = opts.cache;
                }
                if (opts.credentials) {
                  request.credentials = opts.credentials;
                }
                if (opts.redirect) {
                  request.redirect = opts.redirect;
                }
                if (opts.referrer) {
                  request.referrer = opts.referrer;
                }
              }
              return [4, fetch(href, request)];
            case 1:
              response = _a.sent();
              return [4, response.arrayBuffer()];
            case 2:
              body = _a.sent();
              headers = {};
              if (response.headers.forEach) {
                response.headers.forEach(function(value, key) {
                  headers[key.toLowerCase()] = value;
                });
              } else {
                response.headers.keys().forEach(function(key) {
                  headers[key.toLowerCase()] = response.headers.get(key);
                });
              }
              return [2, {
                headers,
                statusCode: response.status,
                statusMessage: response.statusText,
                body: (0, bytes_1.arrayify)(new Uint8Array(body))
              }];
          }
        });
      });
    }
    exports.getUrl = getUrl2;
  }
});

// ../node_modules/@ethersproject/web/lib/index.js
var require_lib17 = __commonJS({
  "../node_modules/@ethersproject/web/lib/index.js"(exports) {
    "use strict";
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poll = exports.fetchJson = exports._fetchData = void 0;
    var base64_1 = require_lib7();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var strings_1 = require_lib11();
    var logger_1 = require_lib();
    var _version_1 = require_version12();
    var logger15 = new logger_1.Logger(_version_1.version);
    var geturl_1 = require_browser_geturl();
    function staller(duration) {
      return new Promise(function(resolve) {
        setTimeout(resolve, duration);
      });
    }
    function bodyify(value, type) {
      if (value == null) {
        return null;
      }
      if (typeof value === "string") {
        return value;
      }
      if ((0, bytes_1.isBytesLike)(value)) {
        if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
          try {
            return (0, strings_1.toUtf8String)(value);
          } catch (error) {
          }
          ;
        }
        return (0, bytes_1.hexlify)(value);
      }
      return value;
    }
    function unpercent(value) {
      return (0, strings_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, function(all, code) {
        return String.fromCharCode(parseInt(code, 16));
      }));
    }
    function _fetchData(connection, body, processFunc) {
      var attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
      logger15.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
      var throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
      var throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
      logger15.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
      var errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
      var headers = {};
      var url = null;
      var options = {
        method: "GET"
      };
      var allow304 = false;
      var timeout = 2 * 60 * 1e3;
      if (typeof connection === "string") {
        url = connection;
      } else if (typeof connection === "object") {
        if (connection == null || connection.url == null) {
          logger15.throwArgumentError("missing URL", "connection.url", connection);
        }
        url = connection.url;
        if (typeof connection.timeout === "number" && connection.timeout > 0) {
          timeout = connection.timeout;
        }
        if (connection.headers) {
          for (var key in connection.headers) {
            headers[key.toLowerCase()] = { key, value: String(connection.headers[key]) };
            if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
              allow304 = true;
            }
          }
        }
        options.allowGzip = !!connection.allowGzip;
        if (connection.user != null && connection.password != null) {
          if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
            logger15.throwError("basic authentication requires a secure https url", logger_1.Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
          }
          var authorization = connection.user + ":" + connection.password;
          headers["authorization"] = {
            key: "Authorization",
            value: "Basic " + (0, base64_1.encode)((0, strings_1.toUtf8Bytes)(authorization))
          };
        }
        if (connection.skipFetchSetup != null) {
          options.skipFetchSetup = !!connection.skipFetchSetup;
        }
        if (connection.fetchOptions != null) {
          options.fetchOptions = (0, properties_1.shallowCopy)(connection.fetchOptions);
        }
      }
      var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
      var dataMatch = url ? url.match(reData) : null;
      if (dataMatch) {
        try {
          var response = {
            statusCode: 200,
            statusMessage: "OK",
            headers: { "content-type": dataMatch[1] || "text/plain" },
            body: dataMatch[2] ? (0, base64_1.decode)(dataMatch[3]) : unpercent(dataMatch[3])
          };
          var result = response.body;
          if (processFunc) {
            result = processFunc(response.body, response);
          }
          return Promise.resolve(result);
        } catch (error) {
          logger15.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
            body: bodyify(dataMatch[1], dataMatch[2]),
            error,
            requestBody: null,
            requestMethod: "GET",
            url
          });
        }
      }
      if (body) {
        options.method = "POST";
        options.body = body;
        if (headers["content-type"] == null) {
          headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
        }
        if (headers["content-length"] == null) {
          headers["content-length"] = { key: "Content-Length", value: String(body.length) };
        }
      }
      var flatHeaders = {};
      Object.keys(headers).forEach(function(key2) {
        var header = headers[key2];
        flatHeaders[header.key] = header.value;
      });
      options.headers = flatHeaders;
      var runningTimeout = function() {
        var timer = null;
        var promise = new Promise(function(resolve, reject) {
          if (timeout) {
            timer = setTimeout(function() {
              if (timer == null) {
                return;
              }
              timer = null;
              reject(logger15.makeError("timeout", logger_1.Logger.errors.TIMEOUT, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                timeout,
                url
              }));
            }, timeout);
          }
        });
        var cancel = function() {
          if (timer == null) {
            return;
          }
          clearTimeout(timer);
          timer = null;
        };
        return { promise, cancel };
      }();
      var runningFetch = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var attempt, response2, location_1, tryAgain, stall, retryAfter, error_1, body_1, result2, error_2, tryAgain, timeout_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                attempt = 0;
                _a.label = 1;
              case 1:
                if (!(attempt < attemptLimit))
                  return [3, 20];
                response2 = null;
                _a.label = 2;
              case 2:
                _a.trys.push([2, 9, , 10]);
                return [4, (0, geturl_1.getUrl)(url, options)];
              case 3:
                response2 = _a.sent();
                if (!(attempt < attemptLimit))
                  return [3, 8];
                if (!(response2.statusCode === 301 || response2.statusCode === 302))
                  return [3, 4];
                location_1 = response2.headers.location || "";
                if (options.method === "GET" && location_1.match(/^https:/)) {
                  url = response2.headers.location;
                  return [3, 19];
                }
                return [3, 8];
              case 4:
                if (!(response2.statusCode === 429))
                  return [3, 8];
                tryAgain = true;
                if (!throttleCallback)
                  return [3, 6];
                return [4, throttleCallback(attempt, url)];
              case 5:
                tryAgain = _a.sent();
                _a.label = 6;
              case 6:
                if (!tryAgain)
                  return [3, 8];
                stall = 0;
                retryAfter = response2.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall = parseInt(retryAfter) * 1e3;
                } else {
                  stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                return [4, staller(stall)];
              case 7:
                _a.sent();
                return [3, 19];
              case 8:
                return [3, 10];
              case 9:
                error_1 = _a.sent();
                response2 = error_1.response;
                if (response2 == null) {
                  runningTimeout.cancel();
                  logger15.throwError("missing response", logger_1.Logger.errors.SERVER_ERROR, {
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    serverError: error_1,
                    url
                  });
                }
                return [3, 10];
              case 10:
                body_1 = response2.body;
                if (allow304 && response2.statusCode === 304) {
                  body_1 = null;
                } else if (!errorPassThrough && (response2.statusCode < 200 || response2.statusCode >= 300)) {
                  runningTimeout.cancel();
                  logger15.throwError("bad response", logger_1.Logger.errors.SERVER_ERROR, {
                    status: response2.statusCode,
                    headers: response2.headers,
                    body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    url
                  });
                }
                if (!processFunc)
                  return [3, 18];
                _a.label = 11;
              case 11:
                _a.trys.push([11, 13, , 18]);
                return [4, processFunc(body_1, response2)];
              case 12:
                result2 = _a.sent();
                runningTimeout.cancel();
                return [2, result2];
              case 13:
                error_2 = _a.sent();
                if (!(error_2.throttleRetry && attempt < attemptLimit))
                  return [3, 17];
                tryAgain = true;
                if (!throttleCallback)
                  return [3, 15];
                return [4, throttleCallback(attempt, url)];
              case 14:
                tryAgain = _a.sent();
                _a.label = 15;
              case 15:
                if (!tryAgain)
                  return [3, 17];
                timeout_1 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                return [4, staller(timeout_1)];
              case 16:
                _a.sent();
                return [3, 19];
              case 17:
                runningTimeout.cancel();
                logger15.throwError("processing response error", logger_1.Logger.errors.SERVER_ERROR, {
                  body: bodyify(body_1, response2.headers ? response2.headers["content-type"] : null),
                  error: error_2,
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  url
                });
                return [3, 18];
              case 18:
                runningTimeout.cancel();
                return [2, body_1];
              case 19:
                attempt++;
                return [3, 1];
              case 20:
                return [2, logger15.throwError("failed response", logger_1.Logger.errors.SERVER_ERROR, {
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  url
                })];
            }
          });
        });
      }();
      return Promise.race([runningTimeout.promise, runningFetch]);
    }
    exports._fetchData = _fetchData;
    function fetchJson2(connection, json, processFunc) {
      var processJsonFunc = function(value, response) {
        var result = null;
        if (value != null) {
          try {
            result = JSON.parse((0, strings_1.toUtf8String)(value));
          } catch (error) {
            logger15.throwError("invalid JSON", logger_1.Logger.errors.SERVER_ERROR, {
              body: value,
              error
            });
          }
        }
        if (processFunc) {
          result = processFunc(result, response);
        }
        return result;
      };
      var body = null;
      if (json != null) {
        body = (0, strings_1.toUtf8Bytes)(json);
        var updated = typeof connection === "string" ? { url: connection } : (0, properties_1.shallowCopy)(connection);
        if (updated.headers) {
          var hasContentType = Object.keys(updated.headers).filter(function(k) {
            return k.toLowerCase() === "content-type";
          }).length !== 0;
          if (!hasContentType) {
            updated.headers = (0, properties_1.shallowCopy)(updated.headers);
            updated.headers["content-type"] = "application/json";
          }
        } else {
          updated.headers = { "content-type": "application/json" };
        }
        connection = updated;
      }
      return _fetchData(connection, body, processJsonFunc);
    }
    exports.fetchJson = fetchJson2;
    function poll2(func, options) {
      if (!options) {
        options = {};
      }
      options = (0, properties_1.shallowCopy)(options);
      if (options.floor == null) {
        options.floor = 0;
      }
      if (options.ceiling == null) {
        options.ceiling = 1e4;
      }
      if (options.interval == null) {
        options.interval = 250;
      }
      return new Promise(function(resolve, reject) {
        var timer = null;
        var done = false;
        var cancel = function() {
          if (done) {
            return false;
          }
          done = true;
          if (timer) {
            clearTimeout(timer);
          }
          return true;
        };
        if (options.timeout) {
          timer = setTimeout(function() {
            if (cancel()) {
              reject(new Error("timeout"));
            }
          }, options.timeout);
        }
        var retryLimit = options.retryLimit;
        var attempt = 0;
        function check() {
          return func().then(function(result) {
            if (result !== void 0) {
              if (cancel()) {
                resolve(result);
              }
            } else if (options.oncePoll) {
              options.oncePoll.once("poll", check);
            } else if (options.onceBlock) {
              options.onceBlock.once("block", check);
            } else if (!done) {
              attempt++;
              if (attempt > retryLimit) {
                if (cancel()) {
                  reject(new Error("retry limit reached"));
                }
                return;
              }
              var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
              if (timeout < options.floor) {
                timeout = options.floor;
              }
              if (timeout > options.ceiling) {
                timeout = options.ceiling;
              }
              setTimeout(check, timeout);
            }
            return null;
          }, function(error) {
            if (cancel()) {
              reject(error);
            }
          });
        }
        check();
      });
    }
    exports.poll = poll2;
  }
});

// ../node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "../node_modules/bech32/index.js"(exports, module) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z = 0; z < ALPHABET.length; z++) {
      x = ALPHABET.charAt(z);
      if (ALPHABET_MAP[x] !== void 0)
        throw new TypeError(x + " is ambiguous");
      ALPHABET_MAP[x] = z;
    }
    var x;
    var z;
    function polymodStep(pre) {
      var b = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i = 0; i < prefix.length; ++i) {
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (i = 0; i < prefix.length; ++i) {
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function encode(prefix, words2, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words2.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i = 0; i < words2.length; ++i) {
        var x2 = words2[i];
        if (x2 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x2;
        result += ALPHABET.charAt(x2);
      }
      for (i = 0; i < 6; ++i) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i = 0; i < 6; ++i) {
        var v = chk >> (5 - i) * 5 & 31;
        result += ALPHABET.charAt(v);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split2 = str.lastIndexOf("1");
      if (split2 === -1)
        return "No separator character for " + str;
      if (split2 === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split2);
      var wordChars = str.slice(split2 + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words2 = [];
      for (var i = 0; i < wordChars.length; ++i) {
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === void 0)
          return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i + 6 >= wordChars.length)
          continue;
        words2.push(v);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words: words2 };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data, inBits, outBits, pad2) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i = 0; i < data.length; ++i) {
        value = value << inBits | data[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad2) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes4) {
      var res = convert(bytes4, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes4) {
      var res = convert(bytes4, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module.exports = {
      decodeUnsafe,
      decode,
      encode,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// ../node_modules/@ethersproject/providers/lib/_version.js
var require_version13 = __commonJS({
  "../node_modules/@ethersproject/providers/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "providers/5.7.2";
  }
});

// ../node_modules/elliptic/package.json
var require_package = __commonJS({
  "../node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// ../node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "../node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number3, base, endian) {
        if (BN.isBN(number3)) {
          return number3;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number3 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number3 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number3, base, endian) {
        if (typeof number3 === "number") {
          return this._initNumber(number3, base, endian);
        }
        if (typeof number3 === "object") {
          return this._initArray(number3, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert2(base === (base | 0) && base >= 2 && base <= 36);
        number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number3.length) {
          if (base === 16) {
            this._parseHex(number3, start, endian);
          } else {
            this._parseBase(number3, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number3, base, endian) {
        if (number3 < 0) {
          this.negative = 1;
          number3 = -number3;
        }
        if (number3 < 67108864) {
          this.words = [number3 & 67108863];
          this.length = 1;
        } else if (number3 < 4503599627370496) {
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number3 < 9007199254740992);
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number3, base, endian) {
        assert2(typeof number3.length === "number");
        if (number3.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number3.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number3.length - 1, j = 0; i >= 0; i -= 3) {
            w = number3[i] | number3[i - 1] << 8 | number3[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number3.length; i += 3) {
            w = number3[i] | number3[i + 1] << 8 | number3[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index2) {
        var c = string.charCodeAt(index2);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index2) {
        var r = parseHex4Bits(string, index2);
        if (index2 - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index2 - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number3.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number3, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number3.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number3.length; i += 2) {
            w = parseHexByte(number3, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number3, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number3.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number3, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number3, i, number3.length, base);
          for (i = 0; i < mod2; i++) {
            pow3 *= base;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size3) {
        while (this.length < size3) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t = new Array(N2);
        var l = BN.prototype._countBits(N2) - 1;
        for (var i = 0; i < N2; i++) {
          t[i] = this.revBin(i, l, N2);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N2) {
        if (x === 0 || x === N2 - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i = 0; i < N2; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s = 1; s < N2; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N2; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N2 = Math.max(m, n) | 1;
        var odd = N2 & 1;
        var i = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1)
          return;
        for (var i = 0; i < N2 / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N2 - i - 1];
          rws[N2 - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N2 - i - 1];
          iws[N2 - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N2) {
        var carry = 0;
        for (var i = 0; i < N2 / 2; i++) {
          var w = Math.round(ws2[2 * i + 1] / N2) * 8192 + Math.round(ws2[2 * i] / N2) + carry;
          ws2[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N2) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws2[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N2; ++i) {
          rws[i] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i = 0; i < N2; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N2 = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N2);
        var _ = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x.words, x.length, rws, N2);
        this.convert13b(y.words, y.length, nrws, N2);
        this.transform(rws, _, rwst, iwst, N2, rbt);
        this.transform(nrws, _, nrwst, niwst, N2, rbt);
        for (var i = 0; i < N2; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _, N2, rbt);
        this.conjugate(rmws, _, N2);
        this.normalize13b(rmws, N2);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output3) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output3.words[i] = input.words[i];
        }
        output3.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output3.words[output3.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// ../node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils3 = __commonJS({
  "../node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex3(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex3;
    utils.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex3(arr);
      else
        return arr;
    };
  }
});

// ../node_modules/elliptic/lib/elliptic/utils.js
var require_utils4 = __commonJS({
  "../node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn2();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils3();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws2 = 1 << w + 1;
      var k = num.clone();
      for (var i = 0; i < naf.length; i++) {
        var z;
        var mod2 = k.andln(ws2 - 1);
        if (k.isOdd()) {
          if (mod2 > (ws2 >> 1) - 1)
            z = (ws2 >> 1) - mod2;
          else
            z = mod2;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes4) {
      return typeof bytes4 === "string" ? utils.toArray(bytes4, "hex") : bytes4;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes4) {
      return new BN(bytes4, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// ../node_modules/brorand/index.js
var require_brorand = __commonJS({
  "../node_modules/brorand/index.js"(exports, module) {
    var r;
    module.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof window.self === "object") {
      if (window.self.crypto && window.self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          window.self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (window.self.msCrypto && window.self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          window.self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto2 = require_crypto();
        if (typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto2.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto2;
  }
});

// ../node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "../node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert2 = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert2(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert2(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max2 = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max2 = Math.max(naf[a].length, max2);
          max2 = Math.max(naf[b].length, max2);
          continue;
        }
        var comb = [
          points[a],
          null,
          null,
          points[b]
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index2 = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max2 = Math.max(jsf[0].length, max2);
        naf[a] = new Array(max2);
        naf[b] = new Array(max2);
        for (j = 0; j < max2; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index2[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max2; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes4, enc) {
      bytes4 = utils.toArray(bytes4, enc);
      var len = this.p.byteLength();
      if ((bytes4[0] === 4 || bytes4[0] === 6 || bytes4[0] === 7) && bytes4.length - 1 === 2 * len) {
        if (bytes4[0] === 6)
          assert2(bytes4[bytes4.length - 1] % 2 === 0);
        else if (bytes4[0] === 7)
          assert2(bytes4[bytes4.length - 1] % 2 === 1);
        var res = this.point(
          bytes4.slice(1, 1 + len),
          bytes4.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes4[0] === 2 || bytes4[0] === 3) && bytes4.length - 1 === len) {
        return this.pointFromX(bytes4.slice(1, 1 + len), bytes4[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max2 = (1 << wnd) - 1;
      var dbl = max2 === 1 ? null : this.dbl();
      for (var i = 1; i < max2; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// ../node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "../node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert2 = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split2 = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split2.k1.negative) {
          split2.k1.ineg();
          p = p.neg(true);
        }
        if (split2.k2.negative) {
          split2.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split2.k1;
        ncoeffs[i * 2 + 1] = split2.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point2(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point2, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point2(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point2.fromJSON(this, obj, red);
    };
    Point2.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point2.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point2.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point2.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point2.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point2.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point2.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point2.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point2.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point2.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point2.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow3) {
      if (pow3 === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow3)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow3; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow3; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow3)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// ../node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "../node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils4();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point2(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point2, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes4, enc) {
      return this.point(utils.toArray(bytes4, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point2(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point2.fromJSON(this, obj);
    };
    Point2.prototype.precompute = function precompute() {
    };
    Point2.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point2.fromJSON = function fromJSON(curve, obj) {
      return new Point2(curve, obj[0], obj[1] || curve.one);
    };
    Point2.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point2.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point2.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point2.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point2.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point2.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point2.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point2.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// ../node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "../node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var BN = require_bn2();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert2 = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert2(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point2(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point2, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point2.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point2(this, x, y, z, t);
    };
    Point2.fromJSON = function fromJSON(curve, obj) {
      return new Point2(curve, obj[0], obj[1], obj[2]);
    };
    Point2.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point2.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point2.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point2.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point2.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point2.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point2.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point2.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point2.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point2.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point2.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point2.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point2.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point2.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point2.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point2.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point2.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point2.prototype.toP = Point2.prototype.normalize;
    Point2.prototype.mixedAdd = Point2.prototype.add;
  }
});

// ../node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "../node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// ../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "../node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// ../node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "../node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash4 = require_hash();
    var curve = require_curve();
    var utils = require_utils4();
    var assert2 = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert2(this.g.validate(), "Invalid curve");
      assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash4.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash4.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash4.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash4.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// ../node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "../node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    var hash4 = require_hash();
    var utils = require_utils3();
    var assert2 = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert2(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac2() {
      return new hash4.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert2(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// ../node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "../node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert2 = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert2(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert2(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert2(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// ../node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "../node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert2 = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert2(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// ../node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "../node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils4();
    var curves = require_curves();
    var rand = require_brorand();
    var assert2 = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert2(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes4 = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes4));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes4 = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes4);
      var nonce = msg.toArray("be", bytes4);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert2((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// ../node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "../node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash4 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash4.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash4() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert2(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert2(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// ../node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "../node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var utils = require_utils4();
    var assert2 = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert2(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes4() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex3() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// ../node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "../node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash4 = require_hash();
    var curves = require_curves();
    var utils = require_utils4();
    var assert2 = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert2(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash4.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash5 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash5.update(arguments[i]);
      return utils.intFromLE(hash5.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes4) {
      bytes4 = utils.parseBytes(bytes4);
      var lastIx = bytes4.length - 1;
      var normed = bytes4.slice(0, lastIx).concat(bytes4[lastIx] & ~128);
      var xIsOdd = (bytes4[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes4) {
      return utils.intFromLE(bytes4);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// ../node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "../node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils4();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// ../node_modules/@ethersproject/signing-key/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "../node_modules/@ethersproject/signing-key/lib/elliptic.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EC = void 0;
    var elliptic_1 = __importDefault(require_elliptic());
    var EC = elliptic_1.default.ec;
    exports.EC = EC;
  }
});

// ../node_modules/@ethersproject/signing-key/lib/_version.js
var require_version14 = __commonJS({
  "../node_modules/@ethersproject/signing-key/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "signing-key/5.7.0";
  }
});

// ../node_modules/@ethersproject/signing-key/lib/index.js
var require_lib18 = __commonJS({
  "../node_modules/@ethersproject/signing-key/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computePublicKey = exports.recoverPublicKey = exports.SigningKey = void 0;
    var elliptic_1 = require_elliptic2();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version14();
    var logger15 = new logger_1.Logger(_version_1.version);
    var _curve = null;
    function getCurve() {
      if (!_curve) {
        _curve = new elliptic_1.EC("secp256k1");
      }
      return _curve;
    }
    var SigningKey3 = function() {
      function SigningKey4(privateKey) {
        (0, properties_1.defineReadOnly)(this, "curve", "secp256k1");
        (0, properties_1.defineReadOnly)(this, "privateKey", (0, bytes_1.hexlify)(privateKey));
        if ((0, bytes_1.hexDataLength)(this.privateKey) !== 32) {
          logger15.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        }
        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
        (0, properties_1.defineReadOnly)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        (0, properties_1.defineReadOnly)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        (0, properties_1.defineReadOnly)(this, "_isSigningKey", true);
      }
      SigningKey4.prototype._addPoint = function(other) {
        var p0 = getCurve().keyFromPublic((0, bytes_1.arrayify)(this.publicKey));
        var p1 = getCurve().keyFromPublic((0, bytes_1.arrayify)(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
      };
      SigningKey4.prototype.signDigest = function(digest) {
        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
        var digestBytes = (0, bytes_1.arrayify)(digest);
        if (digestBytes.length !== 32) {
          logger15.throwArgumentError("bad digest length", "digest", digest);
        }
        var signature = keyPair.sign(digestBytes, { canonical: true });
        return (0, bytes_1.splitSignature)({
          recoveryParam: signature.recoveryParam,
          r: (0, bytes_1.hexZeroPad)("0x" + signature.r.toString(16), 32),
          s: (0, bytes_1.hexZeroPad)("0x" + signature.s.toString(16), 32)
        });
      };
      SigningKey4.prototype.computeSharedSecret = function(otherKey) {
        var keyPair = getCurve().keyFromPrivate((0, bytes_1.arrayify)(this.privateKey));
        var otherKeyPair = getCurve().keyFromPublic((0, bytes_1.arrayify)(computePublicKey(otherKey)));
        return (0, bytes_1.hexZeroPad)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
      };
      SigningKey4.isSigningKey = function(value) {
        return !!(value && value._isSigningKey);
      };
      return SigningKey4;
    }();
    exports.SigningKey = SigningKey3;
    function recoverPublicKey(digest, signature) {
      var sig = (0, bytes_1.splitSignature)(signature);
      var rs = { r: (0, bytes_1.arrayify)(sig.r), s: (0, bytes_1.arrayify)(sig.s) };
      return "0x" + getCurve().recoverPubKey((0, bytes_1.arrayify)(digest), rs, sig.recoveryParam).encode("hex", false);
    }
    exports.recoverPublicKey = recoverPublicKey;
    function computePublicKey(key, compressed) {
      var bytes4 = (0, bytes_1.arrayify)(key);
      if (bytes4.length === 32) {
        var signingKey = new SigningKey3(bytes4);
        if (compressed) {
          return "0x" + getCurve().keyFromPrivate(bytes4).getPublic(true, "hex");
        }
        return signingKey.publicKey;
      } else if (bytes4.length === 33) {
        if (compressed) {
          return (0, bytes_1.hexlify)(bytes4);
        }
        return "0x" + getCurve().keyFromPublic(bytes4).getPublic(false, "hex");
      } else if (bytes4.length === 65) {
        if (!compressed) {
          return (0, bytes_1.hexlify)(bytes4);
        }
        return "0x" + getCurve().keyFromPublic(bytes4).getPublic(true, "hex");
      }
      return logger15.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
    }
    exports.computePublicKey = computePublicKey;
  }
});

// ../node_modules/@ethersproject/transactions/lib/_version.js
var require_version15 = __commonJS({
  "../node_modules/@ethersproject/transactions/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "transactions/5.7.0";
  }
});

// ../node_modules/@ethersproject/transactions/lib/index.js
var require_lib19 = __commonJS({
  "../node_modules/@ethersproject/transactions/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.serialize = exports.accessListify = exports.recoverAddress = exports.computeAddress = exports.TransactionTypes = void 0;
    var address_1 = require_lib14();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var constants_1 = require_lib9();
    var keccak256_1 = require_lib10();
    var properties_1 = require_lib4();
    var RLP = __importStar(require_lib13());
    var signing_key_1 = require_lib18();
    var logger_1 = require_lib();
    var _version_1 = require_version15();
    var logger15 = new logger_1.Logger(_version_1.version);
    var TransactionTypes;
    (function(TransactionTypes2) {
      TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
      TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
      TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
    })(TransactionTypes = exports.TransactionTypes || (exports.TransactionTypes = {}));
    function handleAddress(value) {
      if (value === "0x") {
        return null;
      }
      return (0, address_1.getAddress)(value);
    }
    function handleNumber(value) {
      if (value === "0x") {
        return constants_1.Zero;
      }
      return bignumber_1.BigNumber.from(value);
    }
    var transactionFields = [
      { name: "nonce", maxLength: 32, numeric: true },
      { name: "gasPrice", maxLength: 32, numeric: true },
      { name: "gasLimit", maxLength: 32, numeric: true },
      { name: "to", length: 20 },
      { name: "value", maxLength: 32, numeric: true },
      { name: "data" }
    ];
    var allowedTransactionKeys2 = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      type: true,
      value: true
    };
    function computeAddress4(key) {
      var publicKey = (0, signing_key_1.computePublicKey)(key);
      return (0, address_1.getAddress)((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.hexDataSlice)(publicKey, 1)), 12));
    }
    exports.computeAddress = computeAddress4;
    function recoverAddress2(digest, signature) {
      return computeAddress4((0, signing_key_1.recoverPublicKey)((0, bytes_1.arrayify)(digest), signature));
    }
    exports.recoverAddress = recoverAddress2;
    function formatNumber(value, name) {
      var result = (0, bytes_1.stripZeros)(bignumber_1.BigNumber.from(value).toHexString());
      if (result.length > 32) {
        logger15.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
      }
      return result;
    }
    function accessSetify(addr, storageKeys) {
      return {
        address: (0, address_1.getAddress)(addr),
        storageKeys: (storageKeys || []).map(function(storageKey, index2) {
          if ((0, bytes_1.hexDataLength)(storageKey) !== 32) {
            logger15.throwArgumentError("invalid access list storageKey", "accessList[" + addr + ":" + index2 + "]", storageKey);
          }
          return storageKey.toLowerCase();
        })
      };
    }
    function accessListify2(value) {
      if (Array.isArray(value)) {
        return value.map(function(set, index2) {
          if (Array.isArray(set)) {
            if (set.length > 2) {
              logger15.throwArgumentError("access list expected to be [ address, storageKeys[] ]", "value[" + index2 + "]", set);
            }
            return accessSetify(set[0], set[1]);
          }
          return accessSetify(set.address, set.storageKeys);
        });
      }
      var result = Object.keys(value).map(function(addr) {
        var storageKeys = value[addr].reduce(function(accum, storageKey) {
          accum[storageKey] = true;
          return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
      });
      result.sort(function(a, b) {
        return a.address.localeCompare(b.address);
      });
      return result;
    }
    exports.accessListify = accessListify2;
    function formatAccessList(value) {
      return accessListify2(value).map(function(set) {
        return [set.address, set.storageKeys];
      });
    }
    function _serializeEip1559(transaction, signature) {
      if (transaction.gasPrice != null) {
        var gasPrice = bignumber_1.BigNumber.from(transaction.gasPrice);
        var maxFeePerGas = bignumber_1.BigNumber.from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) {
          logger15.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
            gasPrice,
            maxFeePerGas
          });
        }
      }
      var fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, address_1.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
      ];
      if (signature) {
        var sig = (0, bytes_1.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, bytes_1.stripZeros)(sig.r));
        fields.push((0, bytes_1.stripZeros)(sig.s));
      }
      return (0, bytes_1.hexConcat)(["0x02", RLP.encode(fields)]);
    }
    function _serializeEip2930(transaction, signature) {
      var fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, address_1.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
      ];
      if (signature) {
        var sig = (0, bytes_1.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, bytes_1.stripZeros)(sig.r));
        fields.push((0, bytes_1.stripZeros)(sig.s));
      }
      return (0, bytes_1.hexConcat)(["0x01", RLP.encode(fields)]);
    }
    function _serialize(transaction, signature) {
      (0, properties_1.checkProperties)(transaction, allowedTransactionKeys2);
      var raw = [];
      transactionFields.forEach(function(fieldInfo) {
        var value = transaction[fieldInfo.name] || [];
        var options = {};
        if (fieldInfo.numeric) {
          options.hexPad = "left";
        }
        value = (0, bytes_1.arrayify)((0, bytes_1.hexlify)(value, options));
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
          logger15.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        }
        if (fieldInfo.maxLength) {
          value = (0, bytes_1.stripZeros)(value);
          if (value.length > fieldInfo.maxLength) {
            logger15.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
          }
        }
        raw.push((0, bytes_1.hexlify)(value));
      });
      var chainId = 0;
      if (transaction.chainId != null) {
        chainId = transaction.chainId;
        if (typeof chainId !== "number") {
          logger15.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
        }
      } else if (signature && !(0, bytes_1.isBytesLike)(signature) && signature.v > 28) {
        chainId = Math.floor((signature.v - 35) / 2);
      }
      if (chainId !== 0) {
        raw.push((0, bytes_1.hexlify)(chainId));
        raw.push("0x");
        raw.push("0x");
      }
      if (!signature) {
        return RLP.encode(raw);
      }
      var sig = (0, bytes_1.splitSignature)(signature);
      var v = 27 + sig.recoveryParam;
      if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v += chainId * 2 + 8;
        if (sig.v > 28 && sig.v !== v) {
          logger15.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
        }
      } else if (sig.v !== v) {
        logger15.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
      }
      raw.push((0, bytes_1.hexlify)(v));
      raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.r)));
      raw.push((0, bytes_1.stripZeros)((0, bytes_1.arrayify)(sig.s)));
      return RLP.encode(raw);
    }
    function serialize2(transaction, signature) {
      if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) {
          logger15.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        }
        return _serialize(transaction, signature);
      }
      switch (transaction.type) {
        case 1:
          return _serializeEip2930(transaction, signature);
        case 2:
          return _serializeEip1559(transaction, signature);
        default:
          break;
      }
      return logger15.throwError("unsupported transaction type: " + transaction.type, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
      });
    }
    exports.serialize = serialize2;
    function _parseEipSignature(tx, fields, serialize3) {
      try {
        var recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) {
          throw new Error("bad recid");
        }
        tx.v = recid;
      } catch (error) {
        logger15.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
      }
      tx.r = (0, bytes_1.hexZeroPad)(fields[1], 32);
      tx.s = (0, bytes_1.hexZeroPad)(fields[2], 32);
      try {
        var digest = (0, keccak256_1.keccak256)(serialize3(tx));
        tx.from = recoverAddress2(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
      } catch (error) {
      }
    }
    function _parseEip1559(payload) {
      var transaction = RLP.decode(payload.slice(1));
      if (transaction.length !== 9 && transaction.length !== 12) {
        logger15.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, bytes_1.hexlify)(payload));
      }
      var maxPriorityFeePerGas = handleNumber(transaction[2]);
      var maxFeePerGas = handleNumber(transaction[3]);
      var tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas,
        maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify2(transaction[8])
      };
      if (transaction.length === 9) {
        return tx;
      }
      tx.hash = (0, keccak256_1.keccak256)(payload);
      _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
      return tx;
    }
    function _parseEip2930(payload) {
      var transaction = RLP.decode(payload.slice(1));
      if (transaction.length !== 8 && transaction.length !== 11) {
        logger15.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, bytes_1.hexlify)(payload));
      }
      var tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify2(transaction[7])
      };
      if (transaction.length === 8) {
        return tx;
      }
      tx.hash = (0, keccak256_1.keccak256)(payload);
      _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
      return tx;
    }
    function _parse(rawTransaction) {
      var transaction = RLP.decode(rawTransaction);
      if (transaction.length !== 9 && transaction.length !== 6) {
        logger15.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
      }
      var tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
      };
      if (transaction.length === 6) {
        return tx;
      }
      try {
        tx.v = bignumber_1.BigNumber.from(transaction[6]).toNumber();
      } catch (error) {
        return tx;
      }
      tx.r = (0, bytes_1.hexZeroPad)(transaction[7], 32);
      tx.s = (0, bytes_1.hexZeroPad)(transaction[8], 32);
      if (bignumber_1.BigNumber.from(tx.r).isZero() && bignumber_1.BigNumber.from(tx.s).isZero()) {
        tx.chainId = tx.v;
        tx.v = 0;
      } else {
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) {
          tx.chainId = 0;
        }
        var recoveryParam = tx.v - 27;
        var raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
          raw.push((0, bytes_1.hexlify)(tx.chainId));
          raw.push("0x");
          raw.push("0x");
          recoveryParam -= tx.chainId * 2 + 8;
        }
        var digest = (0, keccak256_1.keccak256)(RLP.encode(raw));
        try {
          tx.from = recoverAddress2(digest, { r: (0, bytes_1.hexlify)(tx.r), s: (0, bytes_1.hexlify)(tx.s), recoveryParam });
        } catch (error) {
        }
        tx.hash = (0, keccak256_1.keccak256)(rawTransaction);
      }
      tx.type = null;
      return tx;
    }
    function parse(rawTransaction) {
      var payload = (0, bytes_1.arrayify)(rawTransaction);
      if (payload[0] > 127) {
        return _parse(payload);
      }
      switch (payload[0]) {
        case 1:
          return _parseEip2930(payload);
        case 2:
          return _parseEip1559(payload);
        default:
          break;
      }
      return logger15.throwError("unsupported transaction type: " + payload[0], logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
      });
    }
    exports.parse = parse;
  }
});

// ../node_modules/@ethersproject/providers/lib/formatter.js
var require_formatter = __commonJS({
  "../node_modules/@ethersproject/providers/lib/formatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.showThrottleMessage = exports.isCommunityResource = exports.isCommunityResourcable = exports.Formatter = void 0;
    var address_1 = require_lib14();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var constants_1 = require_lib9();
    var properties_1 = require_lib4();
    var transactions_1 = require_lib19();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var Formatter = function() {
      function Formatter2() {
        this.formats = this.getDefaultFormats();
      }
      Formatter2.prototype.getDefaultFormats = function() {
        var _this = this;
        var formats = {};
        var address = this.address.bind(this);
        var bigNumber = this.bigNumber.bind(this);
        var blockTag = this.blockTag.bind(this);
        var data = this.data.bind(this);
        var hash4 = this.hash.bind(this);
        var hex = this.hex.bind(this);
        var number3 = this.number.bind(this);
        var type = this.type.bind(this);
        var strictData = function(v) {
          return _this.data(v, true);
        };
        formats.transaction = {
          hash: hash4,
          type,
          accessList: Formatter2.allowNull(this.accessList.bind(this), null),
          blockHash: Formatter2.allowNull(hash4, null),
          blockNumber: Formatter2.allowNull(number3, null),
          transactionIndex: Formatter2.allowNull(number3, null),
          confirmations: Formatter2.allowNull(number3, null),
          from: address,
          gasPrice: Formatter2.allowNull(bigNumber),
          maxPriorityFeePerGas: Formatter2.allowNull(bigNumber),
          maxFeePerGas: Formatter2.allowNull(bigNumber),
          gasLimit: bigNumber,
          to: Formatter2.allowNull(address, null),
          value: bigNumber,
          nonce: number3,
          data,
          r: Formatter2.allowNull(this.uint256),
          s: Formatter2.allowNull(this.uint256),
          v: Formatter2.allowNull(number3),
          creates: Formatter2.allowNull(address, null),
          raw: Formatter2.allowNull(data)
        };
        formats.transactionRequest = {
          from: Formatter2.allowNull(address),
          nonce: Formatter2.allowNull(number3),
          gasLimit: Formatter2.allowNull(bigNumber),
          gasPrice: Formatter2.allowNull(bigNumber),
          maxPriorityFeePerGas: Formatter2.allowNull(bigNumber),
          maxFeePerGas: Formatter2.allowNull(bigNumber),
          to: Formatter2.allowNull(address),
          value: Formatter2.allowNull(bigNumber),
          data: Formatter2.allowNull(strictData),
          type: Formatter2.allowNull(number3),
          accessList: Formatter2.allowNull(this.accessList.bind(this), null)
        };
        formats.receiptLog = {
          transactionIndex: number3,
          blockNumber: number3,
          transactionHash: hash4,
          address,
          topics: Formatter2.arrayOf(hash4),
          data,
          logIndex: number3,
          blockHash: hash4
        };
        formats.receipt = {
          to: Formatter2.allowNull(this.address, null),
          from: Formatter2.allowNull(this.address, null),
          contractAddress: Formatter2.allowNull(address, null),
          transactionIndex: number3,
          root: Formatter2.allowNull(hex),
          gasUsed: bigNumber,
          logsBloom: Formatter2.allowNull(data),
          blockHash: hash4,
          transactionHash: hash4,
          logs: Formatter2.arrayOf(this.receiptLog.bind(this)),
          blockNumber: number3,
          confirmations: Formatter2.allowNull(number3, null),
          cumulativeGasUsed: bigNumber,
          effectiveGasPrice: Formatter2.allowNull(bigNumber),
          status: Formatter2.allowNull(number3),
          type
        };
        formats.block = {
          hash: Formatter2.allowNull(hash4),
          parentHash: hash4,
          number: number3,
          timestamp: number3,
          nonce: Formatter2.allowNull(hex),
          difficulty: this.difficulty.bind(this),
          gasLimit: bigNumber,
          gasUsed: bigNumber,
          miner: Formatter2.allowNull(address),
          extraData: data,
          transactions: Formatter2.allowNull(Formatter2.arrayOf(hash4)),
          baseFeePerGas: Formatter2.allowNull(bigNumber)
        };
        formats.blockWithTransactions = (0, properties_1.shallowCopy)(formats.block);
        formats.blockWithTransactions.transactions = Formatter2.allowNull(Formatter2.arrayOf(this.transactionResponse.bind(this)));
        formats.filter = {
          fromBlock: Formatter2.allowNull(blockTag, void 0),
          toBlock: Formatter2.allowNull(blockTag, void 0),
          blockHash: Formatter2.allowNull(hash4, void 0),
          address: Formatter2.allowNull(address, void 0),
          topics: Formatter2.allowNull(this.topics.bind(this), void 0)
        };
        formats.filterLog = {
          blockNumber: Formatter2.allowNull(number3),
          blockHash: Formatter2.allowNull(hash4),
          transactionIndex: number3,
          removed: Formatter2.allowNull(this.boolean.bind(this)),
          address,
          data: Formatter2.allowFalsish(data, "0x"),
          topics: Formatter2.arrayOf(hash4),
          transactionHash: hash4,
          logIndex: number3
        };
        return formats;
      };
      Formatter2.prototype.accessList = function(accessList) {
        return (0, transactions_1.accessListify)(accessList || []);
      };
      Formatter2.prototype.number = function(number3) {
        if (number3 === "0x") {
          return 0;
        }
        return bignumber_1.BigNumber.from(number3).toNumber();
      };
      Formatter2.prototype.type = function(number3) {
        if (number3 === "0x" || number3 == null) {
          return 0;
        }
        return bignumber_1.BigNumber.from(number3).toNumber();
      };
      Formatter2.prototype.bigNumber = function(value) {
        return bignumber_1.BigNumber.from(value);
      };
      Formatter2.prototype.boolean = function(value) {
        if (typeof value === "boolean") {
          return value;
        }
        if (typeof value === "string") {
          value = value.toLowerCase();
          if (value === "true") {
            return true;
          }
          if (value === "false") {
            return false;
          }
        }
        throw new Error("invalid boolean - " + value);
      };
      Formatter2.prototype.hex = function(value, strict) {
        if (typeof value === "string") {
          if (!strict && value.substring(0, 2) !== "0x") {
            value = "0x" + value;
          }
          if ((0, bytes_1.isHexString)(value)) {
            return value.toLowerCase();
          }
        }
        return logger15.throwArgumentError("invalid hash", "value", value);
      };
      Formatter2.prototype.data = function(value, strict) {
        var result = this.hex(value, strict);
        if (result.length % 2 !== 0) {
          throw new Error("invalid data; odd-length - " + value);
        }
        return result;
      };
      Formatter2.prototype.address = function(value) {
        return (0, address_1.getAddress)(value);
      };
      Formatter2.prototype.callAddress = function(value) {
        if (!(0, bytes_1.isHexString)(value, 32)) {
          return null;
        }
        var address = (0, address_1.getAddress)((0, bytes_1.hexDataSlice)(value, 12));
        return address === constants_1.AddressZero ? null : address;
      };
      Formatter2.prototype.contractAddress = function(value) {
        return (0, address_1.getContractAddress)(value);
      };
      Formatter2.prototype.blockTag = function(blockTag) {
        if (blockTag == null) {
          return "latest";
        }
        if (blockTag === "earliest") {
          return "0x0";
        }
        switch (blockTag) {
          case "earliest":
            return "0x0";
          case "latest":
          case "pending":
          case "safe":
          case "finalized":
            return blockTag;
        }
        if (typeof blockTag === "number" || (0, bytes_1.isHexString)(blockTag)) {
          return (0, bytes_1.hexValue)(blockTag);
        }
        throw new Error("invalid blockTag");
      };
      Formatter2.prototype.hash = function(value, strict) {
        var result = this.hex(value, strict);
        if ((0, bytes_1.hexDataLength)(result) !== 32) {
          return logger15.throwArgumentError("invalid hash", "value", value);
        }
        return result;
      };
      Formatter2.prototype.difficulty = function(value) {
        if (value == null) {
          return null;
        }
        var v = bignumber_1.BigNumber.from(value);
        try {
          return v.toNumber();
        } catch (error) {
        }
        return null;
      };
      Formatter2.prototype.uint256 = function(value) {
        if (!(0, bytes_1.isHexString)(value)) {
          throw new Error("invalid uint256");
        }
        return (0, bytes_1.hexZeroPad)(value, 32);
      };
      Formatter2.prototype._block = function(value, format) {
        if (value.author != null && value.miner == null) {
          value.miner = value.author;
        }
        var difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
        var result = Formatter2.check(format, value);
        result._difficulty = difficulty == null ? null : bignumber_1.BigNumber.from(difficulty);
        return result;
      };
      Formatter2.prototype.block = function(value) {
        return this._block(value, this.formats.block);
      };
      Formatter2.prototype.blockWithTransactions = function(value) {
        return this._block(value, this.formats.blockWithTransactions);
      };
      Formatter2.prototype.transactionRequest = function(value) {
        return Formatter2.check(this.formats.transactionRequest, value);
      };
      Formatter2.prototype.transactionResponse = function(transaction) {
        if (transaction.gas != null && transaction.gasLimit == null) {
          transaction.gasLimit = transaction.gas;
        }
        if (transaction.to && bignumber_1.BigNumber.from(transaction.to).isZero()) {
          transaction.to = "0x0000000000000000000000000000000000000000";
        }
        if (transaction.input != null && transaction.data == null) {
          transaction.data = transaction.input;
        }
        if (transaction.to == null && transaction.creates == null) {
          transaction.creates = this.contractAddress(transaction);
        }
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
          transaction.accessList = [];
        }
        var result = Formatter2.check(this.formats.transaction, transaction);
        if (transaction.chainId != null) {
          var chainId = transaction.chainId;
          if ((0, bytes_1.isHexString)(chainId)) {
            chainId = bignumber_1.BigNumber.from(chainId).toNumber();
          }
          result.chainId = chainId;
        } else {
          var chainId = transaction.networkId;
          if (chainId == null && result.v == null) {
            chainId = transaction.chainId;
          }
          if ((0, bytes_1.isHexString)(chainId)) {
            chainId = bignumber_1.BigNumber.from(chainId).toNumber();
          }
          if (typeof chainId !== "number" && result.v != null) {
            chainId = (result.v - 35) / 2;
            if (chainId < 0) {
              chainId = 0;
            }
            chainId = parseInt(chainId);
          }
          if (typeof chainId !== "number") {
            chainId = 0;
          }
          result.chainId = chainId;
        }
        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
          result.blockHash = null;
        }
        return result;
      };
      Formatter2.prototype.transaction = function(value) {
        return (0, transactions_1.parse)(value);
      };
      Formatter2.prototype.receiptLog = function(value) {
        return Formatter2.check(this.formats.receiptLog, value);
      };
      Formatter2.prototype.receipt = function(value) {
        var result = Formatter2.check(this.formats.receipt, value);
        if (result.root != null) {
          if (result.root.length <= 4) {
            var value_1 = bignumber_1.BigNumber.from(result.root).toNumber();
            if (value_1 === 0 || value_1 === 1) {
              if (result.status != null && result.status !== value_1) {
                logger15.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
              }
              result.status = value_1;
              delete result.root;
            } else {
              logger15.throwArgumentError("invalid alt-root-status", "value.root", result.root);
            }
          } else if (result.root.length !== 66) {
            logger15.throwArgumentError("invalid root hash", "value.root", result.root);
          }
        }
        if (result.status != null) {
          result.byzantium = true;
        }
        return result;
      };
      Formatter2.prototype.topics = function(value) {
        var _this = this;
        if (Array.isArray(value)) {
          return value.map(function(v) {
            return _this.topics(v);
          });
        } else if (value != null) {
          return this.hash(value, true);
        }
        return null;
      };
      Formatter2.prototype.filter = function(value) {
        return Formatter2.check(this.formats.filter, value);
      };
      Formatter2.prototype.filterLog = function(value) {
        return Formatter2.check(this.formats.filterLog, value);
      };
      Formatter2.check = function(format, object) {
        var result = {};
        for (var key in format) {
          try {
            var value = format[key](object[key]);
            if (value !== void 0) {
              result[key] = value;
            }
          } catch (error) {
            error.checkKey = key;
            error.checkValue = object[key];
            throw error;
          }
        }
        return result;
      };
      Formatter2.allowNull = function(format, nullValue) {
        return function(value) {
          if (value == null) {
            return nullValue;
          }
          return format(value);
        };
      };
      Formatter2.allowFalsish = function(format, replaceValue) {
        return function(value) {
          if (!value) {
            return replaceValue;
          }
          return format(value);
        };
      };
      Formatter2.arrayOf = function(format) {
        return function(array) {
          if (!Array.isArray(array)) {
            throw new Error("not an array");
          }
          var result = [];
          array.forEach(function(value) {
            result.push(format(value));
          });
          return result;
        };
      };
      return Formatter2;
    }();
    exports.Formatter = Formatter;
    function isCommunityResourcable(value) {
      return value && typeof value.isCommunityResource === "function";
    }
    exports.isCommunityResourcable = isCommunityResourcable;
    function isCommunityResource(value) {
      return isCommunityResourcable(value) && value.isCommunityResource();
    }
    exports.isCommunityResource = isCommunityResource;
    var throttleMessage = false;
    function showThrottleMessage() {
      if (throttleMessage) {
        return;
      }
      throttleMessage = true;
      console.log("========= NOTICE =========");
      console.log("Request-Rate Exceeded  (this message will not be repeated)");
      console.log("");
      console.log("The default API keys for each service are provided as a highly-throttled,");
      console.log("community resource for low-traffic projects and early prototyping.");
      console.log("");
      console.log("While your application will continue to function, we highly recommended");
      console.log("signing up for your own API keys to improve performance, increase your");
      console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
      console.log("");
      console.log("For more details: https://docs.ethers.io/api-keys/");
      console.log("==========================");
    }
    exports.showThrottleMessage = showThrottleMessage;
  }
});

// ../node_modules/@ethersproject/providers/lib/base-provider.js
var require_base_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/base-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseProvider = exports.Resolver = exports.Event = void 0;
    var abstract_provider_1 = require_lib5();
    var base64_1 = require_lib7();
    var basex_1 = require_lib8();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var constants_1 = require_lib9();
    var hash_1 = require_lib15();
    var networks_1 = require_lib6();
    var properties_1 = require_lib4();
    var sha2_1 = require_lib16();
    var strings_1 = require_lib11();
    var web_1 = require_lib17();
    var bech32_1 = __importDefault(require_bech32());
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var formatter_1 = require_formatter();
    var MAX_CCIP_REDIRECTS = 10;
    function checkTopic(topic) {
      if (topic == null) {
        return "null";
      }
      if ((0, bytes_1.hexDataLength)(topic) !== 32) {
        logger15.throwArgumentError("invalid topic", "topic", topic);
      }
      return topic.toLowerCase();
    }
    function serializeTopics(topics) {
      topics = topics.slice();
      while (topics.length > 0 && topics[topics.length - 1] == null) {
        topics.pop();
      }
      return topics.map(function(topic) {
        if (Array.isArray(topic)) {
          var unique_1 = {};
          topic.forEach(function(topic2) {
            unique_1[checkTopic(topic2)] = true;
          });
          var sorted = Object.keys(unique_1);
          sorted.sort();
          return sorted.join("|");
        } else {
          return checkTopic(topic);
        }
      }).join("&");
    }
    function deserializeTopics2(data) {
      if (data === "") {
        return [];
      }
      return data.split(/&/g).map(function(topic) {
        if (topic === "") {
          return [];
        }
        var comps = topic.split("|").map(function(topic2) {
          return topic2 === "null" ? null : topic2;
        });
        return comps.length === 1 ? comps[0] : comps;
      });
    }
    function getEventTag2(eventName) {
      if (typeof eventName === "string") {
        eventName = eventName.toLowerCase();
        if ((0, bytes_1.hexDataLength)(eventName) === 32) {
          return "tx:" + eventName;
        }
        if (eventName.indexOf(":") === -1) {
          return eventName;
        }
      } else if (Array.isArray(eventName)) {
        return "filter:*:" + serializeTopics(eventName);
      } else if (abstract_provider_1.ForkEvent.isForkEvent(eventName)) {
        logger15.warn("not implemented");
        throw new Error("not implemented");
      } else if (eventName && typeof eventName === "object") {
        return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
      }
      throw new Error("invalid event - " + eventName);
    }
    function getTime() {
      return new Date().getTime();
    }
    function stall(duration) {
      return new Promise(function(resolve) {
        setTimeout(resolve, duration);
      });
    }
    var PollableEvents = ["block", "network", "pending", "poll"];
    var Event2 = function() {
      function Event3(tag, listener, once) {
        (0, properties_1.defineReadOnly)(this, "tag", tag);
        (0, properties_1.defineReadOnly)(this, "listener", listener);
        (0, properties_1.defineReadOnly)(this, "once", once);
        this._lastBlockNumber = -2;
        this._inflight = false;
      }
      Object.defineProperty(Event3.prototype, "event", {
        get: function() {
          switch (this.type) {
            case "tx":
              return this.hash;
            case "filter":
              return this.filter;
          }
          return this.tag;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Event3.prototype, "type", {
        get: function() {
          return this.tag.split(":")[0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Event3.prototype, "hash", {
        get: function() {
          var comps = this.tag.split(":");
          if (comps[0] !== "tx") {
            return null;
          }
          return comps[1];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Event3.prototype, "filter", {
        get: function() {
          var comps = this.tag.split(":");
          if (comps[0] !== "filter") {
            return null;
          }
          var address = comps[1];
          var topics = deserializeTopics2(comps[2]);
          var filter = {};
          if (topics.length > 0) {
            filter.topics = topics;
          }
          if (address && address !== "*") {
            filter.address = address;
          }
          return filter;
        },
        enumerable: false,
        configurable: true
      });
      Event3.prototype.pollable = function() {
        return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
      };
      return Event3;
    }();
    exports.Event = Event2;
    var coinInfos = {
      "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
      "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
      "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
      "60": { symbol: "eth", ilk: "eth" },
      "61": { symbol: "etc", ilk: "eth" },
      "700": { symbol: "xdai", ilk: "eth" }
    };
    function bytes32ify(value) {
      return (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(value).toHexString(), 32);
    }
    function base58Encode(data) {
      return basex_1.Base58.encode((0, bytes_1.concat)([data, (0, bytes_1.hexDataSlice)((0, sha2_1.sha256)((0, sha2_1.sha256)(data)), 0, 4)]));
    }
    var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
    var matchers = [
      new RegExp("^(https)://(.*)$", "i"),
      new RegExp("^(data):(.*)$", "i"),
      matcherIpfs,
      new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
    ];
    function _parseString(result, start) {
      try {
        return (0, strings_1.toUtf8String)(_parseBytes(result, start));
      } catch (error) {
      }
      return null;
    }
    function _parseBytes(result, start) {
      if (result === "0x") {
        return null;
      }
      var offset = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, start, start + 32)).toNumber();
      var length = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(result, offset, offset + 32)).toNumber();
      return (0, bytes_1.hexDataSlice)(result, offset + 32, offset + 32 + length);
    }
    function getIpfsLink(link) {
      if (link.match(/^ipfs:\/\/ipfs\//i)) {
        link = link.substring(12);
      } else if (link.match(/^ipfs:\/\//i)) {
        link = link.substring(7);
      } else {
        logger15.throwArgumentError("unsupported IPFS format", "link", link);
      }
      return "https://gateway.ipfs.io/ipfs/" + link;
    }
    function numPad(value) {
      var result = (0, bytes_1.arrayify)(value);
      if (result.length > 32) {
        throw new Error("internal; should not happen");
      }
      var padded = new Uint8Array(32);
      padded.set(result, 32 - result.length);
      return padded;
    }
    function bytesPad(value) {
      if (value.length % 32 === 0) {
        return value;
      }
      var result = new Uint8Array(Math.ceil(value.length / 32) * 32);
      result.set(value);
      return result;
    }
    function encodeBytes2(datas) {
      var result = [];
      var byteCount = 0;
      for (var i = 0; i < datas.length; i++) {
        result.push(null);
        byteCount += 32;
      }
      for (var i = 0; i < datas.length; i++) {
        var data = (0, bytes_1.arrayify)(datas[i]);
        result[i] = numPad(byteCount);
        result.push(numPad(data.length));
        result.push(bytesPad(data));
        byteCount += 32 + Math.ceil(data.length / 32) * 32;
      }
      return (0, bytes_1.hexConcat)(result);
    }
    var Resolver = function() {
      function Resolver2(provider, address, name, resolvedAddress) {
        (0, properties_1.defineReadOnly)(this, "provider", provider);
        (0, properties_1.defineReadOnly)(this, "name", name);
        (0, properties_1.defineReadOnly)(this, "address", provider.formatter.address(address));
        (0, properties_1.defineReadOnly)(this, "_resolvedAddress", resolvedAddress);
      }
      Resolver2.prototype.supportsWildcard = function() {
        var _this = this;
        if (!this._supportsEip2544) {
          this._supportsEip2544 = this.provider.call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
          }).then(function(result) {
            return bignumber_1.BigNumber.from(result).eq(1);
          }).catch(function(error) {
            if (error.code === logger_1.Logger.errors.CALL_EXCEPTION) {
              return false;
            }
            _this._supportsEip2544 = null;
            throw error;
          });
        }
        return this._supportsEip2544;
      };
      Resolver2.prototype._fetch = function(selector, parameters) {
        return __awaiter5(this, void 0, void 0, function() {
          var tx, parseBytes, result, error_1;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                tx = {
                  to: this.address,
                  ccipReadEnabled: true,
                  data: (0, bytes_1.hexConcat)([selector, (0, hash_1.namehash)(this.name), parameters || "0x"])
                };
                parseBytes = false;
                return [4, this.supportsWildcard()];
              case 1:
                if (_a.sent()) {
                  parseBytes = true;
                  tx.data = (0, bytes_1.hexConcat)(["0x9061b923", encodeBytes2([(0, hash_1.dnsEncode)(this.name), tx.data])]);
                }
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.provider.call(tx)];
              case 3:
                result = _a.sent();
                if ((0, bytes_1.arrayify)(result).length % 32 === 4) {
                  logger15.throwError("resolver threw error", logger_1.Logger.errors.CALL_EXCEPTION, {
                    transaction: tx,
                    data: result
                  });
                }
                if (parseBytes) {
                  result = _parseBytes(result, 0);
                }
                return [2, result];
              case 4:
                error_1 = _a.sent();
                if (error_1.code === logger_1.Logger.errors.CALL_EXCEPTION) {
                  return [2, null];
                }
                throw error_1;
              case 5:
                return [2];
            }
          });
        });
      };
      Resolver2.prototype._fetchBytes = function(selector, parameters) {
        return __awaiter5(this, void 0, void 0, function() {
          var result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this._fetch(selector, parameters)];
              case 1:
                result = _a.sent();
                if (result != null) {
                  return [2, _parseBytes(result, 0)];
                }
                return [2, null];
            }
          });
        });
      };
      Resolver2.prototype._getAddress = function(coinType, hexBytes) {
        var coinInfo = coinInfos[String(coinType)];
        if (coinInfo == null) {
          logger15.throwError("unsupported coin type: " + coinType, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "getAddress(" + coinType + ")"
          });
        }
        if (coinInfo.ilk === "eth") {
          return this.provider.formatter.address(hexBytes);
        }
        var bytes4 = (0, bytes_1.arrayify)(hexBytes);
        if (coinInfo.p2pkh != null) {
          var p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
          if (p2pkh) {
            var length_1 = parseInt(p2pkh[1], 16);
            if (p2pkh[2].length === length_1 * 2 && length_1 >= 1 && length_1 <= 75) {
              return base58Encode((0, bytes_1.concat)([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
            }
          }
        }
        if (coinInfo.p2sh != null) {
          var p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
          if (p2sh) {
            var length_2 = parseInt(p2sh[1], 16);
            if (p2sh[2].length === length_2 * 2 && length_2 >= 1 && length_2 <= 75) {
              return base58Encode((0, bytes_1.concat)([[coinInfo.p2sh], "0x" + p2sh[2]]));
            }
          }
        }
        if (coinInfo.prefix != null) {
          var length_3 = bytes4[1];
          var version_1 = bytes4[0];
          if (version_1 === 0) {
            if (length_3 !== 20 && length_3 !== 32) {
              version_1 = -1;
            }
          } else {
            version_1 = -1;
          }
          if (version_1 >= 0 && bytes4.length === 2 + length_3 && length_3 >= 1 && length_3 <= 75) {
            var words2 = bech32_1.default.toWords(bytes4.slice(2));
            words2.unshift(version_1);
            return bech32_1.default.encode(coinInfo.prefix, words2);
          }
        }
        return null;
      };
      Resolver2.prototype.getAddress = function(coinType) {
        return __awaiter5(this, void 0, void 0, function() {
          var result, error_2, hexBytes, address;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (coinType == null) {
                  coinType = 60;
                }
                if (!(coinType === 60))
                  return [3, 4];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this._fetch("0x3b3b57de")];
              case 2:
                result = _a.sent();
                if (result === "0x" || result === constants_1.HashZero) {
                  return [2, null];
                }
                return [2, this.provider.formatter.callAddress(result)];
              case 3:
                error_2 = _a.sent();
                if (error_2.code === logger_1.Logger.errors.CALL_EXCEPTION) {
                  return [2, null];
                }
                throw error_2;
              case 4:
                return [4, this._fetchBytes("0xf1cb7e06", bytes32ify(coinType))];
              case 5:
                hexBytes = _a.sent();
                if (hexBytes == null || hexBytes === "0x") {
                  return [2, null];
                }
                address = this._getAddress(coinType, hexBytes);
                if (address == null) {
                  logger15.throwError("invalid or unsupported coin data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "getAddress(" + coinType + ")",
                    coinType,
                    data: hexBytes
                  });
                }
                return [2, address];
            }
          });
        });
      };
      Resolver2.prototype.getAvatar = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var linkage, avatar, i, match, scheme, _a, selector, owner, _b, comps, addr, tokenId, tokenOwner, _c, _d, balance, _e, _f, tx, metadataUrl, _g, metadata, imageUrl, ipfs, error_3;
          return __generator(this, function(_h) {
            switch (_h.label) {
              case 0:
                linkage = [{ type: "name", content: this.name }];
                _h.label = 1;
              case 1:
                _h.trys.push([1, 19, , 20]);
                return [4, this.getText("avatar")];
              case 2:
                avatar = _h.sent();
                if (avatar == null) {
                  return [2, null];
                }
                i = 0;
                _h.label = 3;
              case 3:
                if (!(i < matchers.length))
                  return [3, 18];
                match = avatar.match(matchers[i]);
                if (match == null) {
                  return [3, 17];
                }
                scheme = match[1].toLowerCase();
                _a = scheme;
                switch (_a) {
                  case "https":
                    return [3, 4];
                  case "data":
                    return [3, 5];
                  case "ipfs":
                    return [3, 6];
                  case "erc721":
                    return [3, 7];
                  case "erc1155":
                    return [3, 7];
                }
                return [3, 17];
              case 4:
                linkage.push({ type: "url", content: avatar });
                return [2, { linkage, url: avatar }];
              case 5:
                linkage.push({ type: "data", content: avatar });
                return [2, { linkage, url: avatar }];
              case 6:
                linkage.push({ type: "ipfs", content: avatar });
                return [2, { linkage, url: getIpfsLink(avatar) }];
              case 7:
                selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                linkage.push({ type: scheme, content: avatar });
                _b = this._resolvedAddress;
                if (_b)
                  return [3, 9];
                return [4, this.getAddress()];
              case 8:
                _b = _h.sent();
                _h.label = 9;
              case 9:
                owner = _b;
                comps = (match[2] || "").split("/");
                if (comps.length !== 2) {
                  return [2, null];
                }
                return [4, this.provider.formatter.address(comps[0])];
              case 10:
                addr = _h.sent();
                tokenId = (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(comps[1]).toHexString(), 32);
                if (!(scheme === "erc721"))
                  return [3, 12];
                _d = (_c = this.provider.formatter).callAddress;
                return [4, this.provider.call({
                  to: addr,
                  data: (0, bytes_1.hexConcat)(["0x6352211e", tokenId])
                })];
              case 11:
                tokenOwner = _d.apply(_c, [_h.sent()]);
                if (owner !== tokenOwner) {
                  return [2, null];
                }
                linkage.push({ type: "owner", content: tokenOwner });
                return [3, 14];
              case 12:
                if (!(scheme === "erc1155"))
                  return [3, 14];
                _f = (_e = bignumber_1.BigNumber).from;
                return [4, this.provider.call({
                  to: addr,
                  data: (0, bytes_1.hexConcat)(["0x00fdd58e", (0, bytes_1.hexZeroPad)(owner, 32), tokenId])
                })];
              case 13:
                balance = _f.apply(_e, [_h.sent()]);
                if (balance.isZero()) {
                  return [2, null];
                }
                linkage.push({ type: "balance", content: balance.toString() });
                _h.label = 14;
              case 14:
                tx = {
                  to: this.provider.formatter.address(comps[0]),
                  data: (0, bytes_1.hexConcat)([selector, tokenId])
                };
                _g = _parseString;
                return [4, this.provider.call(tx)];
              case 15:
                metadataUrl = _g.apply(void 0, [_h.sent(), 0]);
                if (metadataUrl == null) {
                  return [2, null];
                }
                linkage.push({ type: "metadata-url-base", content: metadataUrl });
                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                  linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
                }
                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink(metadataUrl);
                }
                linkage.push({ type: "metadata-url", content: metadataUrl });
                return [4, (0, web_1.fetchJson)(metadataUrl)];
              case 16:
                metadata = _h.sent();
                if (!metadata) {
                  return [2, null];
                }
                linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
                imageUrl = metadata.image;
                if (typeof imageUrl !== "string") {
                  return [2, null];
                }
                if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                } else {
                  ipfs = imageUrl.match(matcherIpfs);
                  if (ipfs == null) {
                    return [2, null];
                  }
                  linkage.push({ type: "url-ipfs", content: imageUrl });
                  imageUrl = getIpfsLink(imageUrl);
                }
                linkage.push({ type: "url", content: imageUrl });
                return [2, { linkage, url: imageUrl }];
              case 17:
                i++;
                return [3, 3];
              case 18:
                return [3, 20];
              case 19:
                error_3 = _h.sent();
                return [3, 20];
              case 20:
                return [2, null];
            }
          });
        });
      };
      Resolver2.prototype.getContentHash = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var hexBytes, ipfs, length_4, ipns, length_5, swarm, skynet, urlSafe_1, hash4;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this._fetchBytes("0xbc1c58d1")];
              case 1:
                hexBytes = _a.sent();
                if (hexBytes == null || hexBytes === "0x") {
                  return [2, null];
                }
                ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                if (ipfs) {
                  length_4 = parseInt(ipfs[3], 16);
                  if (ipfs[4].length === length_4 * 2) {
                    return [2, "ipfs://" + basex_1.Base58.encode("0x" + ipfs[1])];
                  }
                }
                ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                if (ipns) {
                  length_5 = parseInt(ipns[3], 16);
                  if (ipns[4].length === length_5 * 2) {
                    return [2, "ipns://" + basex_1.Base58.encode("0x" + ipns[1])];
                  }
                }
                swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
                if (swarm) {
                  if (swarm[1].length === 32 * 2) {
                    return [2, "bzz://" + swarm[1]];
                  }
                }
                skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
                if (skynet) {
                  if (skynet[1].length === 34 * 2) {
                    urlSafe_1 = { "=": "", "+": "-", "/": "_" };
                    hash4 = (0, base64_1.encode)("0x" + skynet[1]).replace(/[=+\/]/g, function(a) {
                      return urlSafe_1[a];
                    });
                    return [2, "sia://" + hash4];
                  }
                }
                return [2, logger15.throwError("invalid or unsupported content hash data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "getContentHash()",
                  data: hexBytes
                })];
            }
          });
        });
      };
      Resolver2.prototype.getText = function(key) {
        return __awaiter5(this, void 0, void 0, function() {
          var keyBytes, hexBytes;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                keyBytes = (0, strings_1.toUtf8Bytes)(key);
                keyBytes = (0, bytes_1.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
                if (keyBytes.length % 32 !== 0) {
                  keyBytes = (0, bytes_1.concat)([keyBytes, (0, bytes_1.hexZeroPad)("0x", 32 - key.length % 32)]);
                }
                return [4, this._fetchBytes("0x59d1d43c", (0, bytes_1.hexlify)(keyBytes))];
              case 1:
                hexBytes = _a.sent();
                if (hexBytes == null || hexBytes === "0x") {
                  return [2, null];
                }
                return [2, (0, strings_1.toUtf8String)(hexBytes)];
            }
          });
        });
      };
      return Resolver2;
    }();
    exports.Resolver = Resolver;
    var defaultFormatter = null;
    var nextPollId = 1;
    var BaseProvider = function(_super) {
      __extends2(BaseProvider2, _super);
      function BaseProvider2(network) {
        var _newTarget = this.constructor;
        var _this = _super.call(this) || this;
        _this._events = [];
        _this._emitted = { block: -2 };
        _this.disableCcipRead = false;
        _this.formatter = _newTarget.getFormatter();
        (0, properties_1.defineReadOnly)(_this, "anyNetwork", network === "any");
        if (_this.anyNetwork) {
          network = _this.detectNetwork();
        }
        if (network instanceof Promise) {
          _this._networkPromise = network;
          network.catch(function(error) {
          });
          _this._ready().catch(function(error) {
          });
        } else {
          var knownNetwork = (0, properties_1.getStatic)(_newTarget, "getNetwork")(network);
          if (knownNetwork) {
            (0, properties_1.defineReadOnly)(_this, "_network", knownNetwork);
            _this.emit("network", knownNetwork, null);
          } else {
            logger15.throwArgumentError("invalid network", "network", network);
          }
        }
        _this._maxInternalBlockNumber = -1024;
        _this._lastBlockNumber = -2;
        _this._maxFilterBlockRange = 10;
        _this._pollingInterval = 4e3;
        _this._fastQueryDate = 0;
        return _this;
      }
      BaseProvider2.prototype._ready = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var network, error_4;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(this._network == null))
                  return [3, 7];
                network = null;
                if (!this._networkPromise)
                  return [3, 4];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this._networkPromise];
              case 2:
                network = _a.sent();
                return [3, 4];
              case 3:
                error_4 = _a.sent();
                return [3, 4];
              case 4:
                if (!(network == null))
                  return [3, 6];
                return [4, this.detectNetwork()];
              case 5:
                network = _a.sent();
                _a.label = 6;
              case 6:
                if (!network) {
                  logger15.throwError("no network detected", logger_1.Logger.errors.UNKNOWN_ERROR, {});
                }
                if (this._network == null) {
                  if (this.anyNetwork) {
                    this._network = network;
                  } else {
                    (0, properties_1.defineReadOnly)(this, "_network", network);
                  }
                  this.emit("network", network, null);
                }
                _a.label = 7;
              case 7:
                return [2, this._network];
            }
          });
        });
      };
      Object.defineProperty(BaseProvider2.prototype, "ready", {
        get: function() {
          var _this = this;
          return (0, web_1.poll)(function() {
            return _this._ready().then(function(network) {
              return network;
            }, function(error) {
              if (error.code === logger_1.Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
                return void 0;
              }
              throw error;
            });
          });
        },
        enumerable: false,
        configurable: true
      });
      BaseProvider2.getFormatter = function() {
        if (defaultFormatter == null) {
          defaultFormatter = new formatter_1.Formatter();
        }
        return defaultFormatter;
      };
      BaseProvider2.getNetwork = function(network) {
        return (0, networks_1.getNetwork)(network == null ? "homestead" : network);
      };
      BaseProvider2.prototype.ccipReadFetch = function(tx, calldata, urls) {
        return __awaiter5(this, void 0, void 0, function() {
          var sender, data, errorMessages, i, url, href, json, result, errorMessage;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (this.disableCcipRead || urls.length === 0) {
                  return [2, null];
                }
                sender = tx.to.toLowerCase();
                data = calldata.toLowerCase();
                errorMessages = [];
                i = 0;
                _a.label = 1;
              case 1:
                if (!(i < urls.length))
                  return [3, 4];
                url = urls[i];
                href = url.replace("{sender}", sender).replace("{data}", data);
                json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data, sender });
                return [4, (0, web_1.fetchJson)({ url: href, errorPassThrough: true }, json, function(value, response) {
                  value.status = response.statusCode;
                  return value;
                })];
              case 2:
                result = _a.sent();
                if (result.data) {
                  return [2, result.data];
                }
                errorMessage = result.message || "unknown error";
                if (result.status >= 400 && result.status < 500) {
                  return [2, logger15.throwError("response not found during CCIP fetch: " + errorMessage, logger_1.Logger.errors.SERVER_ERROR, { url, errorMessage })];
                }
                errorMessages.push(errorMessage);
                _a.label = 3;
              case 3:
                i++;
                return [3, 1];
              case 4:
                return [2, logger15.throwError("error encountered during CCIP fetch: " + errorMessages.map(function(m) {
                  return JSON.stringify(m);
                }).join(", "), logger_1.Logger.errors.SERVER_ERROR, {
                  urls,
                  errorMessages
                })];
            }
          });
        });
      };
      BaseProvider2.prototype._getInternalBlockNumber = function(maxAge) {
        return __awaiter5(this, void 0, void 0, function() {
          var internalBlockNumber, result, error_5, reqTime, checkInternalBlockNumber;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this._ready()];
              case 1:
                _a.sent();
                if (!(maxAge > 0))
                  return [3, 7];
                _a.label = 2;
              case 2:
                if (!this._internalBlockNumber)
                  return [3, 7];
                internalBlockNumber = this._internalBlockNumber;
                _a.label = 3;
              case 3:
                _a.trys.push([3, 5, , 6]);
                return [4, internalBlockNumber];
              case 4:
                result = _a.sent();
                if (getTime() - result.respTime <= maxAge) {
                  return [2, result.blockNumber];
                }
                return [3, 7];
              case 5:
                error_5 = _a.sent();
                if (this._internalBlockNumber === internalBlockNumber) {
                  return [3, 7];
                }
                return [3, 6];
              case 6:
                return [3, 2];
              case 7:
                reqTime = getTime();
                checkInternalBlockNumber = (0, properties_1.resolveProperties)({
                  blockNumber: this.perform("getBlockNumber", {}),
                  networkError: this.getNetwork().then(function(network) {
                    return null;
                  }, function(error) {
                    return error;
                  })
                }).then(function(_a2) {
                  var blockNumber = _a2.blockNumber, networkError = _a2.networkError;
                  if (networkError) {
                    if (_this._internalBlockNumber === checkInternalBlockNumber) {
                      _this._internalBlockNumber = null;
                    }
                    throw networkError;
                  }
                  var respTime = getTime();
                  blockNumber = bignumber_1.BigNumber.from(blockNumber).toNumber();
                  if (blockNumber < _this._maxInternalBlockNumber) {
                    blockNumber = _this._maxInternalBlockNumber;
                  }
                  _this._maxInternalBlockNumber = blockNumber;
                  _this._setFastBlockNumber(blockNumber);
                  return { blockNumber, reqTime, respTime };
                });
                this._internalBlockNumber = checkInternalBlockNumber;
                checkInternalBlockNumber.catch(function(error) {
                  if (_this._internalBlockNumber === checkInternalBlockNumber) {
                    _this._internalBlockNumber = null;
                  }
                });
                return [4, checkInternalBlockNumber];
              case 8:
                return [2, _a.sent().blockNumber];
            }
          });
        });
      };
      BaseProvider2.prototype.poll = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var pollId, runners, blockNumber, error_6, i;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                pollId = nextPollId++;
                runners = [];
                blockNumber = null;
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this._getInternalBlockNumber(100 + this.pollingInterval / 2)];
              case 2:
                blockNumber = _a.sent();
                return [3, 4];
              case 3:
                error_6 = _a.sent();
                this.emit("error", error_6);
                return [2];
              case 4:
                this._setFastBlockNumber(blockNumber);
                this.emit("poll", pollId, blockNumber);
                if (blockNumber === this._lastBlockNumber) {
                  this.emit("didPoll", pollId);
                  return [2];
                }
                if (this._emitted.block === -2) {
                  this._emitted.block = blockNumber - 1;
                }
                if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
                  logger15.warn("network block skew detected; skipping block events (emitted=" + this._emitted.block + " blockNumber" + blockNumber + ")");
                  this.emit("error", logger15.makeError("network block skew detected", logger_1.Logger.errors.NETWORK_ERROR, {
                    blockNumber,
                    event: "blockSkew",
                    previousBlockNumber: this._emitted.block
                  }));
                  this.emit("block", blockNumber);
                } else {
                  for (i = this._emitted.block + 1; i <= blockNumber; i++) {
                    this.emit("block", i);
                  }
                }
                if (this._emitted.block !== blockNumber) {
                  this._emitted.block = blockNumber;
                  Object.keys(this._emitted).forEach(function(key) {
                    if (key === "block") {
                      return;
                    }
                    var eventBlockNumber = _this._emitted[key];
                    if (eventBlockNumber === "pending") {
                      return;
                    }
                    if (blockNumber - eventBlockNumber > 12) {
                      delete _this._emitted[key];
                    }
                  });
                }
                if (this._lastBlockNumber === -2) {
                  this._lastBlockNumber = blockNumber - 1;
                }
                this._events.forEach(function(event) {
                  switch (event.type) {
                    case "tx": {
                      var hash_2 = event.hash;
                      var runner = _this.getTransactionReceipt(hash_2).then(function(receipt) {
                        if (!receipt || receipt.blockNumber == null) {
                          return null;
                        }
                        _this._emitted["t:" + hash_2] = receipt.blockNumber;
                        _this.emit(hash_2, receipt);
                        return null;
                      }).catch(function(error) {
                        _this.emit("error", error);
                      });
                      runners.push(runner);
                      break;
                    }
                    case "filter": {
                      if (!event._inflight) {
                        event._inflight = true;
                        if (event._lastBlockNumber === -2) {
                          event._lastBlockNumber = blockNumber - 1;
                        }
                        var filter_1 = event.filter;
                        filter_1.fromBlock = event._lastBlockNumber + 1;
                        filter_1.toBlock = blockNumber;
                        var minFromBlock = filter_1.toBlock - _this._maxFilterBlockRange;
                        if (minFromBlock > filter_1.fromBlock) {
                          filter_1.fromBlock = minFromBlock;
                        }
                        if (filter_1.fromBlock < 0) {
                          filter_1.fromBlock = 0;
                        }
                        var runner = _this.getLogs(filter_1).then(function(logs) {
                          event._inflight = false;
                          if (logs.length === 0) {
                            return;
                          }
                          logs.forEach(function(log) {
                            if (log.blockNumber > event._lastBlockNumber) {
                              event._lastBlockNumber = log.blockNumber;
                            }
                            _this._emitted["b:" + log.blockHash] = log.blockNumber;
                            _this._emitted["t:" + log.transactionHash] = log.blockNumber;
                            _this.emit(filter_1, log);
                          });
                        }).catch(function(error) {
                          _this.emit("error", error);
                          event._inflight = false;
                        });
                        runners.push(runner);
                      }
                      break;
                    }
                  }
                });
                this._lastBlockNumber = blockNumber;
                Promise.all(runners).then(function() {
                  _this.emit("didPoll", pollId);
                }).catch(function(error) {
                  _this.emit("error", error);
                });
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.resetEventsBlock = function(blockNumber) {
        this._lastBlockNumber = blockNumber - 1;
        if (this.polling) {
          this.poll();
        }
      };
      Object.defineProperty(BaseProvider2.prototype, "network", {
        get: function() {
          return this._network;
        },
        enumerable: false,
        configurable: true
      });
      BaseProvider2.prototype.detectNetwork = function() {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, logger15.throwError("provider does not support network detection", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "provider.detectNetwork"
            })];
          });
        });
      };
      BaseProvider2.prototype.getNetwork = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var network, currentNetwork, error;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this._ready()];
              case 1:
                network = _a.sent();
                return [4, this.detectNetwork()];
              case 2:
                currentNetwork = _a.sent();
                if (!(network.chainId !== currentNetwork.chainId))
                  return [3, 5];
                if (!this.anyNetwork)
                  return [3, 4];
                this._network = currentNetwork;
                this._lastBlockNumber = -2;
                this._fastBlockNumber = null;
                this._fastBlockNumberPromise = null;
                this._fastQueryDate = 0;
                this._emitted.block = -2;
                this._maxInternalBlockNumber = -1024;
                this._internalBlockNumber = null;
                this.emit("network", currentNetwork, network);
                return [4, stall(0)];
              case 3:
                _a.sent();
                return [2, this._network];
              case 4:
                error = logger15.makeError("underlying network changed", logger_1.Logger.errors.NETWORK_ERROR, {
                  event: "changed",
                  network,
                  detectedNetwork: currentNetwork
                });
                this.emit("error", error);
                throw error;
              case 5:
                return [2, network];
            }
          });
        });
      };
      Object.defineProperty(BaseProvider2.prototype, "blockNumber", {
        get: function() {
          var _this = this;
          this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(function(blockNumber) {
            _this._setFastBlockNumber(blockNumber);
          }, function(error) {
          });
          return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseProvider2.prototype, "polling", {
        get: function() {
          return this._poller != null;
        },
        set: function(value) {
          var _this = this;
          if (value && !this._poller) {
            this._poller = setInterval(function() {
              _this.poll();
            }, this.pollingInterval);
            if (!this._bootstrapPoll) {
              this._bootstrapPoll = setTimeout(function() {
                _this.poll();
                _this._bootstrapPoll = setTimeout(function() {
                  if (!_this._poller) {
                    _this.poll();
                  }
                  _this._bootstrapPoll = null;
                }, _this.pollingInterval);
              }, 0);
            }
          } else if (!value && this._poller) {
            clearInterval(this._poller);
            this._poller = null;
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseProvider2.prototype, "pollingInterval", {
        get: function() {
          return this._pollingInterval;
        },
        set: function(value) {
          var _this = this;
          if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
            throw new Error("invalid polling interval");
          }
          this._pollingInterval = value;
          if (this._poller) {
            clearInterval(this._poller);
            this._poller = setInterval(function() {
              _this.poll();
            }, this._pollingInterval);
          }
        },
        enumerable: false,
        configurable: true
      });
      BaseProvider2.prototype._getFastBlockNumber = function() {
        var _this = this;
        var now = getTime();
        if (now - this._fastQueryDate > 2 * this._pollingInterval) {
          this._fastQueryDate = now;
          this._fastBlockNumberPromise = this.getBlockNumber().then(function(blockNumber) {
            if (_this._fastBlockNumber == null || blockNumber > _this._fastBlockNumber) {
              _this._fastBlockNumber = blockNumber;
            }
            return _this._fastBlockNumber;
          });
        }
        return this._fastBlockNumberPromise;
      };
      BaseProvider2.prototype._setFastBlockNumber = function(blockNumber) {
        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
          return;
        }
        this._fastQueryDate = getTime();
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
          this._fastBlockNumberPromise = Promise.resolve(blockNumber);
        }
      };
      BaseProvider2.prototype.waitForTransaction = function(transactionHash, confirmations, timeout) {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null)];
          });
        });
      };
      BaseProvider2.prototype._waitForTransaction = function(transactionHash, confirmations, timeout, replaceable) {
        return __awaiter5(this, void 0, void 0, function() {
          var receipt;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getTransactionReceipt(transactionHash)];
              case 1:
                receipt = _a.sent();
                if ((receipt ? receipt.confirmations : 0) >= confirmations) {
                  return [2, receipt];
                }
                return [2, new Promise(function(resolve, reject) {
                  var cancelFuncs = [];
                  var done = false;
                  var alreadyDone = function() {
                    if (done) {
                      return true;
                    }
                    done = true;
                    cancelFuncs.forEach(function(func) {
                      func();
                    });
                    return false;
                  };
                  var minedHandler = function(receipt2) {
                    if (receipt2.confirmations < confirmations) {
                      return;
                    }
                    if (alreadyDone()) {
                      return;
                    }
                    resolve(receipt2);
                  };
                  _this.on(transactionHash, minedHandler);
                  cancelFuncs.push(function() {
                    _this.removeListener(transactionHash, minedHandler);
                  });
                  if (replaceable) {
                    var lastBlockNumber_1 = replaceable.startBlock;
                    var scannedBlock_1 = null;
                    var replaceHandler_1 = function(blockNumber) {
                      return __awaiter5(_this, void 0, void 0, function() {
                        var _this2 = this;
                        return __generator(this, function(_a2) {
                          switch (_a2.label) {
                            case 0:
                              if (done) {
                                return [2];
                              }
                              return [4, stall(1e3)];
                            case 1:
                              _a2.sent();
                              this.getTransactionCount(replaceable.from).then(function(nonce) {
                                return __awaiter5(_this2, void 0, void 0, function() {
                                  var mined, block, ti, tx, receipt_1, reason;
                                  return __generator(this, function(_a3) {
                                    switch (_a3.label) {
                                      case 0:
                                        if (done) {
                                          return [2];
                                        }
                                        if (!(nonce <= replaceable.nonce))
                                          return [3, 1];
                                        lastBlockNumber_1 = blockNumber;
                                        return [3, 9];
                                      case 1:
                                        return [4, this.getTransaction(transactionHash)];
                                      case 2:
                                        mined = _a3.sent();
                                        if (mined && mined.blockNumber != null) {
                                          return [2];
                                        }
                                        if (scannedBlock_1 == null) {
                                          scannedBlock_1 = lastBlockNumber_1 - 3;
                                          if (scannedBlock_1 < replaceable.startBlock) {
                                            scannedBlock_1 = replaceable.startBlock;
                                          }
                                        }
                                        _a3.label = 3;
                                      case 3:
                                        if (!(scannedBlock_1 <= blockNumber))
                                          return [3, 9];
                                        if (done) {
                                          return [2];
                                        }
                                        return [4, this.getBlockWithTransactions(scannedBlock_1)];
                                      case 4:
                                        block = _a3.sent();
                                        ti = 0;
                                        _a3.label = 5;
                                      case 5:
                                        if (!(ti < block.transactions.length))
                                          return [3, 8];
                                        tx = block.transactions[ti];
                                        if (tx.hash === transactionHash) {
                                          return [2];
                                        }
                                        if (!(tx.from === replaceable.from && tx.nonce === replaceable.nonce))
                                          return [3, 7];
                                        if (done) {
                                          return [2];
                                        }
                                        return [4, this.waitForTransaction(tx.hash, confirmations)];
                                      case 6:
                                        receipt_1 = _a3.sent();
                                        if (alreadyDone()) {
                                          return [2];
                                        }
                                        reason = "replaced";
                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                                          reason = "repriced";
                                        } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                                          reason = "cancelled";
                                        }
                                        reject(logger15.makeError("transaction was replaced", logger_1.Logger.errors.TRANSACTION_REPLACED, {
                                          cancelled: reason === "replaced" || reason === "cancelled",
                                          reason,
                                          replacement: this._wrapTransaction(tx),
                                          hash: transactionHash,
                                          receipt: receipt_1
                                        }));
                                        return [2];
                                      case 7:
                                        ti++;
                                        return [3, 5];
                                      case 8:
                                        scannedBlock_1++;
                                        return [3, 3];
                                      case 9:
                                        if (done) {
                                          return [2];
                                        }
                                        this.once("block", replaceHandler_1);
                                        return [2];
                                    }
                                  });
                                });
                              }, function(error) {
                                if (done) {
                                  return;
                                }
                                _this2.once("block", replaceHandler_1);
                              });
                              return [2];
                          }
                        });
                      });
                    };
                    if (done) {
                      return;
                    }
                    _this.once("block", replaceHandler_1);
                    cancelFuncs.push(function() {
                      _this.removeListener("block", replaceHandler_1);
                    });
                  }
                  if (typeof timeout === "number" && timeout > 0) {
                    var timer_1 = setTimeout(function() {
                      if (alreadyDone()) {
                        return;
                      }
                      reject(logger15.makeError("timeout exceeded", logger_1.Logger.errors.TIMEOUT, { timeout }));
                    }, timeout);
                    if (timer_1.unref) {
                      timer_1.unref();
                    }
                    cancelFuncs.push(function() {
                      clearTimeout(timer_1);
                    });
                  }
                })];
            }
          });
        });
      };
      BaseProvider2.prototype.getBlockNumber = function() {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this._getInternalBlockNumber(0)];
          });
        });
      };
      BaseProvider2.prototype.getGasPrice = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, this.perform("getGasPrice", {})];
              case 2:
                result = _a.sent();
                try {
                  return [2, bignumber_1.BigNumber.from(result)];
                } catch (error) {
                  return [2, logger15.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getGasPrice",
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.getBalance = function(addressOrName, blockTag) {
        return __awaiter5(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag)
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getBalance", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, bignumber_1.BigNumber.from(result)];
                } catch (error) {
                  return [2, logger15.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getBalance",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.getTransactionCount = function(addressOrName, blockTag) {
        return __awaiter5(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag)
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getTransactionCount", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, bignumber_1.BigNumber.from(result).toNumber()];
                } catch (error) {
                  return [2, logger15.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.getCode = function(addressOrName, blockTag) {
        return __awaiter5(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag)
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getCode", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, (0, bytes_1.hexlify)(result)];
                } catch (error) {
                  return [2, logger15.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getCode",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.getStorageAt = function(addressOrName, position, blockTag) {
        return __awaiter5(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag),
                  position: Promise.resolve(position).then(function(p) {
                    return (0, bytes_1.hexValue)(p);
                  })
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getStorageAt", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, (0, bytes_1.hexlify)(result)];
                } catch (error) {
                  return [2, logger15.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype._wrapTransaction = function(tx, hash4, startBlock) {
        var _this = this;
        if (hash4 != null && (0, bytes_1.hexDataLength)(hash4) !== 32) {
          throw new Error("invalid response - sendTransaction");
        }
        var result = tx;
        if (hash4 != null && tx.hash !== hash4) {
          logger15.throwError("Transaction hash mismatch from Provider.sendTransaction.", logger_1.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash4 });
        }
        result.wait = function(confirms, timeout) {
          return __awaiter5(_this, void 0, void 0, function() {
            var replacement, receipt;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (confirms == null) {
                    confirms = 1;
                  }
                  if (timeout == null) {
                    timeout = 0;
                  }
                  replacement = void 0;
                  if (confirms !== 0 && startBlock != null) {
                    replacement = {
                      data: tx.data,
                      from: tx.from,
                      nonce: tx.nonce,
                      to: tx.to,
                      value: tx.value,
                      startBlock
                    };
                  }
                  return [4, this._waitForTransaction(tx.hash, confirms, timeout, replacement)];
                case 1:
                  receipt = _a.sent();
                  if (receipt == null && confirms === 0) {
                    return [2, null];
                  }
                  this._emitted["t:" + tx.hash] = receipt.blockNumber;
                  if (receipt.status === 0) {
                    logger15.throwError("transaction failed", logger_1.Logger.errors.CALL_EXCEPTION, {
                      transactionHash: tx.hash,
                      transaction: tx,
                      receipt
                    });
                  }
                  return [2, receipt];
              }
            });
          });
        };
        return result;
      };
      BaseProvider2.prototype.sendTransaction = function(signedTransaction) {
        return __awaiter5(this, void 0, void 0, function() {
          var hexTx, tx, blockNumber, hash4, error_7;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, Promise.resolve(signedTransaction).then(function(t) {
                  return (0, bytes_1.hexlify)(t);
                })];
              case 2:
                hexTx = _a.sent();
                tx = this.formatter.transaction(signedTransaction);
                if (tx.confirmations == null) {
                  tx.confirmations = 0;
                }
                return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
              case 3:
                blockNumber = _a.sent();
                _a.label = 4;
              case 4:
                _a.trys.push([4, 6, , 7]);
                return [4, this.perform("sendTransaction", { signedTransaction: hexTx })];
              case 5:
                hash4 = _a.sent();
                return [2, this._wrapTransaction(tx, hash4, blockNumber)];
              case 6:
                error_7 = _a.sent();
                error_7.transaction = tx;
                error_7.transactionHash = tx.hash;
                throw error_7;
              case 7:
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype._getTransactionRequest = function(transaction) {
        return __awaiter5(this, void 0, void 0, function() {
          var values, tx, _a, _b;
          var _this = this;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, transaction];
              case 1:
                values = _c.sent();
                tx = {};
                ["from", "to"].forEach(function(key) {
                  if (values[key] == null) {
                    return;
                  }
                  tx[key] = Promise.resolve(values[key]).then(function(v) {
                    return v ? _this._getAddress(v) : null;
                  });
                });
                ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(function(key) {
                  if (values[key] == null) {
                    return;
                  }
                  tx[key] = Promise.resolve(values[key]).then(function(v) {
                    return v ? bignumber_1.BigNumber.from(v) : null;
                  });
                });
                ["type"].forEach(function(key) {
                  if (values[key] == null) {
                    return;
                  }
                  tx[key] = Promise.resolve(values[key]).then(function(v) {
                    return v != null ? v : null;
                  });
                });
                if (values.accessList) {
                  tx.accessList = this.formatter.accessList(values.accessList);
                }
                ["data"].forEach(function(key) {
                  if (values[key] == null) {
                    return;
                  }
                  tx[key] = Promise.resolve(values[key]).then(function(v) {
                    return v ? (0, bytes_1.hexlify)(v) : null;
                  });
                });
                _b = (_a = this.formatter).transactionRequest;
                return [4, (0, properties_1.resolveProperties)(tx)];
              case 2:
                return [2, _b.apply(_a, [_c.sent()])];
            }
          });
        });
      };
      BaseProvider2.prototype._getFilter = function(filter) {
        return __awaiter5(this, void 0, void 0, function() {
          var result, _a, _b;
          var _this = this;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                return [4, filter];
              case 1:
                filter = _c.sent();
                result = {};
                if (filter.address != null) {
                  result.address = this._getAddress(filter.address);
                }
                ["blockHash", "topics"].forEach(function(key) {
                  if (filter[key] == null) {
                    return;
                  }
                  result[key] = filter[key];
                });
                ["fromBlock", "toBlock"].forEach(function(key) {
                  if (filter[key] == null) {
                    return;
                  }
                  result[key] = _this._getBlockTag(filter[key]);
                });
                _b = (_a = this.formatter).filter;
                return [4, (0, properties_1.resolveProperties)(result)];
              case 2:
                return [2, _b.apply(_a, [_c.sent()])];
            }
          });
        });
      };
      BaseProvider2.prototype._call = function(transaction, blockTag, attempt) {
        return __awaiter5(this, void 0, void 0, function() {
          var txSender, result, data, sender, urls, urlsOffset, urlsLength, urlsData, u, url, calldata, callbackSelector, extraData, ccipResult, tx, error_8;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (attempt >= MAX_CCIP_REDIRECTS) {
                  logger15.throwError("CCIP read exceeded maximum redirections", logger_1.Logger.errors.SERVER_ERROR, {
                    redirects: attempt,
                    transaction
                  });
                }
                txSender = transaction.to;
                return [4, this.perform("call", { transaction, blockTag })];
              case 1:
                result = _a.sent();
                if (!(attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && (0, bytes_1.hexDataLength)(result) % 32 === 4))
                  return [3, 5];
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                data = (0, bytes_1.hexDataSlice)(result, 4);
                sender = (0, bytes_1.hexDataSlice)(data, 0, 32);
                if (!bignumber_1.BigNumber.from(sender).eq(txSender)) {
                  logger15.throwError("CCIP Read sender did not match", logger_1.Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                  });
                }
                urls = [];
                urlsOffset = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, 32, 64)).toNumber();
                urlsLength = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();
                urlsData = (0, bytes_1.hexDataSlice)(data, urlsOffset + 32);
                for (u = 0; u < urlsLength; u++) {
                  url = _parseString(urlsData, u * 32);
                  if (url == null) {
                    logger15.throwError("CCIP Read contained corrupt URL string", logger_1.Logger.errors.CALL_EXCEPTION, {
                      name: "OffchainLookup",
                      signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      transaction,
                      data: result
                    });
                  }
                  urls.push(url);
                }
                calldata = _parseBytes(data, 64);
                if (!bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(data, 100, 128)).isZero()) {
                  logger15.throwError("CCIP Read callback selector included junk", logger_1.Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                  });
                }
                callbackSelector = (0, bytes_1.hexDataSlice)(data, 96, 100);
                extraData = _parseBytes(data, 128);
                return [4, this.ccipReadFetch(transaction, calldata, urls)];
              case 3:
                ccipResult = _a.sent();
                if (ccipResult == null) {
                  logger15.throwError("CCIP Read disabled or provided no URLs", logger_1.Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                  });
                }
                tx = {
                  to: txSender,
                  data: (0, bytes_1.hexConcat)([callbackSelector, encodeBytes2([ccipResult, extraData])])
                };
                return [2, this._call(tx, blockTag, attempt + 1)];
              case 4:
                error_8 = _a.sent();
                if (error_8.code === logger_1.Logger.errors.SERVER_ERROR) {
                  throw error_8;
                }
                return [3, 5];
              case 5:
                try {
                  return [2, (0, bytes_1.hexlify)(result)];
                } catch (error) {
                  return [2, logger15.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "call",
                    params: { transaction, blockTag },
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype.call = function(transaction, blockTag) {
        return __awaiter5(this, void 0, void 0, function() {
          var resolved;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  transaction: this._getTransactionRequest(transaction),
                  blockTag: this._getBlockTag(blockTag),
                  ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
                })];
              case 2:
                resolved = _a.sent();
                return [2, this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1)];
            }
          });
        });
      };
      BaseProvider2.prototype.estimateGas = function(transaction) {
        return __awaiter5(this, void 0, void 0, function() {
          var params, result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({
                  transaction: this._getTransactionRequest(transaction)
                })];
              case 2:
                params = _a.sent();
                return [4, this.perform("estimateGas", params)];
              case 3:
                result = _a.sent();
                try {
                  return [2, bignumber_1.BigNumber.from(result)];
                } catch (error) {
                  return [2, logger15.throwError("bad result from backend", logger_1.Logger.errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params,
                    result,
                    error
                  })];
                }
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype._getAddress = function(addressOrName) {
        return __awaiter5(this, void 0, void 0, function() {
          var address;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, addressOrName];
              case 1:
                addressOrName = _a.sent();
                if (typeof addressOrName !== "string") {
                  logger15.throwArgumentError("invalid address or ENS name", "name", addressOrName);
                }
                return [4, this.resolveName(addressOrName)];
              case 2:
                address = _a.sent();
                if (address == null) {
                  logger15.throwError("ENS name not configured", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "resolveName(" + JSON.stringify(addressOrName) + ")"
                  });
                }
                return [2, address];
            }
          });
        });
      };
      BaseProvider2.prototype._getBlock = function(blockHashOrBlockTag, includeTransactions) {
        return __awaiter5(this, void 0, void 0, function() {
          var blockNumber, params, _a, error_9;
          var _this = this;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _b.sent();
                return [4, blockHashOrBlockTag];
              case 2:
                blockHashOrBlockTag = _b.sent();
                blockNumber = -128;
                params = {
                  includeTransactions: !!includeTransactions
                };
                if (!(0, bytes_1.isHexString)(blockHashOrBlockTag, 32))
                  return [3, 3];
                params.blockHash = blockHashOrBlockTag;
                return [3, 6];
              case 3:
                _b.trys.push([3, 5, , 6]);
                _a = params;
                return [4, this._getBlockTag(blockHashOrBlockTag)];
              case 4:
                _a.blockTag = _b.sent();
                if ((0, bytes_1.isHexString)(params.blockTag)) {
                  blockNumber = parseInt(params.blockTag.substring(2), 16);
                }
                return [3, 6];
              case 5:
                error_9 = _b.sent();
                logger15.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
                return [3, 6];
              case 6:
                return [2, (0, web_1.poll)(function() {
                  return __awaiter5(_this, void 0, void 0, function() {
                    var block, blockNumber_1, i, tx, confirmations, blockWithTxs;
                    var _this2 = this;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          return [4, this.perform("getBlock", params)];
                        case 1:
                          block = _a2.sent();
                          if (block == null) {
                            if (params.blockHash != null) {
                              if (this._emitted["b:" + params.blockHash] == null) {
                                return [2, null];
                              }
                            }
                            if (params.blockTag != null) {
                              if (blockNumber > this._emitted.block) {
                                return [2, null];
                              }
                            }
                            return [2, void 0];
                          }
                          if (!includeTransactions)
                            return [3, 8];
                          blockNumber_1 = null;
                          i = 0;
                          _a2.label = 2;
                        case 2:
                          if (!(i < block.transactions.length))
                            return [3, 7];
                          tx = block.transactions[i];
                          if (!(tx.blockNumber == null))
                            return [3, 3];
                          tx.confirmations = 0;
                          return [3, 6];
                        case 3:
                          if (!(tx.confirmations == null))
                            return [3, 6];
                          if (!(blockNumber_1 == null))
                            return [3, 5];
                          return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                        case 4:
                          blockNumber_1 = _a2.sent();
                          _a2.label = 5;
                        case 5:
                          confirmations = blockNumber_1 - tx.blockNumber + 1;
                          if (confirmations <= 0) {
                            confirmations = 1;
                          }
                          tx.confirmations = confirmations;
                          _a2.label = 6;
                        case 6:
                          i++;
                          return [3, 2];
                        case 7:
                          blockWithTxs = this.formatter.blockWithTransactions(block);
                          blockWithTxs.transactions = blockWithTxs.transactions.map(function(tx2) {
                            return _this2._wrapTransaction(tx2);
                          });
                          return [2, blockWithTxs];
                        case 8:
                          return [2, this.formatter.block(block)];
                      }
                    });
                  });
                }, { oncePoll: this })];
            }
          });
        });
      };
      BaseProvider2.prototype.getBlock = function(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
      };
      BaseProvider2.prototype.getBlockWithTransactions = function(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
      };
      BaseProvider2.prototype.getTransaction = function(transactionHash) {
        return __awaiter5(this, void 0, void 0, function() {
          var params;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, transactionHash];
              case 2:
                transactionHash = _a.sent();
                params = { transactionHash: this.formatter.hash(transactionHash, true) };
                return [2, (0, web_1.poll)(function() {
                  return __awaiter5(_this, void 0, void 0, function() {
                    var result, tx, blockNumber, confirmations;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          return [4, this.perform("getTransaction", params)];
                        case 1:
                          result = _a2.sent();
                          if (result == null) {
                            if (this._emitted["t:" + transactionHash] == null) {
                              return [2, null];
                            }
                            return [2, void 0];
                          }
                          tx = this.formatter.transactionResponse(result);
                          if (!(tx.blockNumber == null))
                            return [3, 2];
                          tx.confirmations = 0;
                          return [3, 4];
                        case 2:
                          if (!(tx.confirmations == null))
                            return [3, 4];
                          return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                        case 3:
                          blockNumber = _a2.sent();
                          confirmations = blockNumber - tx.blockNumber + 1;
                          if (confirmations <= 0) {
                            confirmations = 1;
                          }
                          tx.confirmations = confirmations;
                          _a2.label = 4;
                        case 4:
                          return [2, this._wrapTransaction(tx)];
                      }
                    });
                  });
                }, { oncePoll: this })];
            }
          });
        });
      };
      BaseProvider2.prototype.getTransactionReceipt = function(transactionHash) {
        return __awaiter5(this, void 0, void 0, function() {
          var params;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, transactionHash];
              case 2:
                transactionHash = _a.sent();
                params = { transactionHash: this.formatter.hash(transactionHash, true) };
                return [2, (0, web_1.poll)(function() {
                  return __awaiter5(_this, void 0, void 0, function() {
                    var result, receipt, blockNumber, confirmations;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          return [4, this.perform("getTransactionReceipt", params)];
                        case 1:
                          result = _a2.sent();
                          if (result == null) {
                            if (this._emitted["t:" + transactionHash] == null) {
                              return [2, null];
                            }
                            return [2, void 0];
                          }
                          if (result.blockHash == null) {
                            return [2, void 0];
                          }
                          receipt = this.formatter.receipt(result);
                          if (!(receipt.blockNumber == null))
                            return [3, 2];
                          receipt.confirmations = 0;
                          return [3, 4];
                        case 2:
                          if (!(receipt.confirmations == null))
                            return [3, 4];
                          return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
                        case 3:
                          blockNumber = _a2.sent();
                          confirmations = blockNumber - receipt.blockNumber + 1;
                          if (confirmations <= 0) {
                            confirmations = 1;
                          }
                          receipt.confirmations = confirmations;
                          _a2.label = 4;
                        case 4:
                          return [2, receipt];
                      }
                    });
                  });
                }, { oncePoll: this })];
            }
          });
        });
      };
      BaseProvider2.prototype.getLogs = function(filter) {
        return __awaiter5(this, void 0, void 0, function() {
          var params, logs;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [4, (0, properties_1.resolveProperties)({ filter: this._getFilter(filter) })];
              case 2:
                params = _a.sent();
                return [4, this.perform("getLogs", params)];
              case 3:
                logs = _a.sent();
                logs.forEach(function(log) {
                  if (log.removed == null) {
                    log.removed = false;
                  }
                });
                return [2, formatter_1.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)];
            }
          });
        });
      };
      BaseProvider2.prototype.getEtherPrice = function() {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.getNetwork()];
              case 1:
                _a.sent();
                return [2, this.perform("getEtherPrice", {})];
            }
          });
        });
      };
      BaseProvider2.prototype._getBlockTag = function(blockTag) {
        return __awaiter5(this, void 0, void 0, function() {
          var blockNumber;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, blockTag];
              case 1:
                blockTag = _a.sent();
                if (!(typeof blockTag === "number" && blockTag < 0))
                  return [3, 3];
                if (blockTag % 1) {
                  logger15.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
                }
                return [4, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];
              case 2:
                blockNumber = _a.sent();
                blockNumber += blockTag;
                if (blockNumber < 0) {
                  blockNumber = 0;
                }
                return [2, this.formatter.blockTag(blockNumber)];
              case 3:
                return [2, this.formatter.blockTag(blockTag)];
            }
          });
        });
      };
      BaseProvider2.prototype.getResolver = function(name) {
        return __awaiter5(this, void 0, void 0, function() {
          var currentName, addr, resolver, _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                currentName = name;
                _b.label = 1;
              case 1:
                if (false)
                  return [3, 6];
                if (currentName === "" || currentName === ".") {
                  return [2, null];
                }
                if (name !== "eth" && currentName === "eth") {
                  return [2, null];
                }
                return [4, this._getResolver(currentName, "getResolver")];
              case 2:
                addr = _b.sent();
                if (!(addr != null))
                  return [3, 5];
                resolver = new Resolver(this, addr, name);
                _a = currentName !== name;
                if (!_a)
                  return [3, 4];
                return [4, resolver.supportsWildcard()];
              case 3:
                _a = !_b.sent();
                _b.label = 4;
              case 4:
                if (_a) {
                  return [2, null];
                }
                return [2, resolver];
              case 5:
                currentName = currentName.split(".").slice(1).join(".");
                return [3, 1];
              case 6:
                return [2];
            }
          });
        });
      };
      BaseProvider2.prototype._getResolver = function(name, operation) {
        return __awaiter5(this, void 0, void 0, function() {
          var network, addrData, error_10;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (operation == null) {
                  operation = "ENS";
                }
                return [4, this.getNetwork()];
              case 1:
                network = _a.sent();
                if (!network.ensAddress) {
                  logger15.throwError("network does not support ENS", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
                }
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.call({
                  to: network.ensAddress,
                  data: "0x0178b8bf" + (0, hash_1.namehash)(name).substring(2)
                })];
              case 3:
                addrData = _a.sent();
                return [2, this.formatter.callAddress(addrData)];
              case 4:
                error_10 = _a.sent();
                return [3, 5];
              case 5:
                return [2, null];
            }
          });
        });
      };
      BaseProvider2.prototype.resolveName = function(name) {
        return __awaiter5(this, void 0, void 0, function() {
          var resolver;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, name];
              case 1:
                name = _a.sent();
                try {
                  return [2, Promise.resolve(this.formatter.address(name))];
                } catch (error) {
                  if ((0, bytes_1.isHexString)(name)) {
                    throw error;
                  }
                }
                if (typeof name !== "string") {
                  logger15.throwArgumentError("invalid ENS name", "name", name);
                }
                return [4, this.getResolver(name)];
              case 2:
                resolver = _a.sent();
                if (!resolver) {
                  return [2, null];
                }
                return [4, resolver.getAddress()];
              case 3:
                return [2, _a.sent()];
            }
          });
        });
      };
      BaseProvider2.prototype.lookupAddress = function(address) {
        return __awaiter5(this, void 0, void 0, function() {
          var node, resolverAddr, name, _a, addr;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, address];
              case 1:
                address = _b.sent();
                address = this.formatter.address(address);
                node = address.substring(2).toLowerCase() + ".addr.reverse";
                return [4, this._getResolver(node, "lookupAddress")];
              case 2:
                resolverAddr = _b.sent();
                if (resolverAddr == null) {
                  return [2, null];
                }
                _a = _parseString;
                return [4, this.call({
                  to: resolverAddr,
                  data: "0x691f3431" + (0, hash_1.namehash)(node).substring(2)
                })];
              case 3:
                name = _a.apply(void 0, [_b.sent(), 0]);
                return [4, this.resolveName(name)];
              case 4:
                addr = _b.sent();
                if (addr != address) {
                  return [2, null];
                }
                return [2, name];
            }
          });
        });
      };
      BaseProvider2.prototype.getAvatar = function(nameOrAddress) {
        return __awaiter5(this, void 0, void 0, function() {
          var resolver, address, node, resolverAddress, avatar_1, error_11, name_1, _a, error_12, avatar;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                resolver = null;
                if (!(0, bytes_1.isHexString)(nameOrAddress))
                  return [3, 10];
                address = this.formatter.address(nameOrAddress);
                node = address.substring(2).toLowerCase() + ".addr.reverse";
                return [4, this._getResolver(node, "getAvatar")];
              case 1:
                resolverAddress = _b.sent();
                if (!resolverAddress) {
                  return [2, null];
                }
                resolver = new Resolver(this, resolverAddress, node);
                _b.label = 2;
              case 2:
                _b.trys.push([2, 4, , 5]);
                return [4, resolver.getAvatar()];
              case 3:
                avatar_1 = _b.sent();
                if (avatar_1) {
                  return [2, avatar_1.url];
                }
                return [3, 5];
              case 4:
                error_11 = _b.sent();
                if (error_11.code !== logger_1.Logger.errors.CALL_EXCEPTION) {
                  throw error_11;
                }
                return [3, 5];
              case 5:
                _b.trys.push([5, 8, , 9]);
                _a = _parseString;
                return [4, this.call({
                  to: resolverAddress,
                  data: "0x691f3431" + (0, hash_1.namehash)(node).substring(2)
                })];
              case 6:
                name_1 = _a.apply(void 0, [_b.sent(), 0]);
                return [4, this.getResolver(name_1)];
              case 7:
                resolver = _b.sent();
                return [3, 9];
              case 8:
                error_12 = _b.sent();
                if (error_12.code !== logger_1.Logger.errors.CALL_EXCEPTION) {
                  throw error_12;
                }
                return [2, null];
              case 9:
                return [3, 12];
              case 10:
                return [4, this.getResolver(nameOrAddress)];
              case 11:
                resolver = _b.sent();
                if (!resolver) {
                  return [2, null];
                }
                _b.label = 12;
              case 12:
                return [4, resolver.getAvatar()];
              case 13:
                avatar = _b.sent();
                if (avatar == null) {
                  return [2, null];
                }
                return [2, avatar.url];
            }
          });
        });
      };
      BaseProvider2.prototype.perform = function(method, params) {
        return logger15.throwError(method + " not implemented", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });
      };
      BaseProvider2.prototype._startEvent = function(event) {
        this.polling = this._events.filter(function(e) {
          return e.pollable();
        }).length > 0;
      };
      BaseProvider2.prototype._stopEvent = function(event) {
        this.polling = this._events.filter(function(e) {
          return e.pollable();
        }).length > 0;
      };
      BaseProvider2.prototype._addEventListener = function(eventName, listener, once) {
        var event = new Event2(getEventTag2(eventName), listener, once);
        this._events.push(event);
        this._startEvent(event);
        return this;
      };
      BaseProvider2.prototype.on = function(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
      };
      BaseProvider2.prototype.once = function(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
      };
      BaseProvider2.prototype.emit = function(eventName) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var result = false;
        var stopped = [];
        var eventTag = getEventTag2(eventName);
        this._events = this._events.filter(function(event) {
          if (event.tag !== eventTag) {
            return true;
          }
          setTimeout(function() {
            event.listener.apply(_this, args);
          }, 0);
          result = true;
          if (event.once) {
            stopped.push(event);
            return false;
          }
          return true;
        });
        stopped.forEach(function(event) {
          _this._stopEvent(event);
        });
        return result;
      };
      BaseProvider2.prototype.listenerCount = function(eventName) {
        if (!eventName) {
          return this._events.length;
        }
        var eventTag = getEventTag2(eventName);
        return this._events.filter(function(event) {
          return event.tag === eventTag;
        }).length;
      };
      BaseProvider2.prototype.listeners = function(eventName) {
        if (eventName == null) {
          return this._events.map(function(event) {
            return event.listener;
          });
        }
        var eventTag = getEventTag2(eventName);
        return this._events.filter(function(event) {
          return event.tag === eventTag;
        }).map(function(event) {
          return event.listener;
        });
      };
      BaseProvider2.prototype.off = function(eventName, listener) {
        var _this = this;
        if (listener == null) {
          return this.removeAllListeners(eventName);
        }
        var stopped = [];
        var found = false;
        var eventTag = getEventTag2(eventName);
        this._events = this._events.filter(function(event) {
          if (event.tag !== eventTag || event.listener != listener) {
            return true;
          }
          if (found) {
            return true;
          }
          found = true;
          stopped.push(event);
          return false;
        });
        stopped.forEach(function(event) {
          _this._stopEvent(event);
        });
        return this;
      };
      BaseProvider2.prototype.removeAllListeners = function(eventName) {
        var _this = this;
        var stopped = [];
        if (eventName == null) {
          stopped = this._events;
          this._events = [];
        } else {
          var eventTag_1 = getEventTag2(eventName);
          this._events = this._events.filter(function(event) {
            if (event.tag !== eventTag_1) {
              return true;
            }
            stopped.push(event);
            return false;
          });
        }
        stopped.forEach(function(event) {
          _this._stopEvent(event);
        });
        return this;
      };
      return BaseProvider2;
    }(abstract_provider_1.Provider);
    exports.BaseProvider = BaseProvider;
  }
});

// ../node_modules/@ethersproject/abstract-signer/lib/_version.js
var require_version16 = __commonJS({
  "../node_modules/@ethersproject/abstract-signer/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "abstract-signer/5.7.0";
  }
});

// ../node_modules/@ethersproject/abstract-signer/lib/index.js
var require_lib20 = __commonJS({
  "../node_modules/@ethersproject/abstract-signer/lib/index.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoidSigner = exports.Signer = void 0;
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version16();
    var logger15 = new logger_1.Logger(_version_1.version);
    var allowedTransactionKeys2 = [
      "accessList",
      "ccipReadEnabled",
      "chainId",
      "customData",
      "data",
      "from",
      "gasLimit",
      "gasPrice",
      "maxFeePerGas",
      "maxPriorityFeePerGas",
      "nonce",
      "to",
      "type",
      "value"
    ];
    var forwardErrors = [
      logger_1.Logger.errors.INSUFFICIENT_FUNDS,
      logger_1.Logger.errors.NONCE_EXPIRED,
      logger_1.Logger.errors.REPLACEMENT_UNDERPRICED
    ];
    var Signer3 = function() {
      function Signer4() {
        var _newTarget = this.constructor;
        logger15.checkAbstract(_newTarget, Signer4);
        (0, properties_1.defineReadOnly)(this, "_isSigner", true);
      }
      Signer4.prototype.getBalance = function(blockTag) {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getBalance");
                return [4, this.provider.getBalance(this.getAddress(), blockTag)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer4.prototype.getTransactionCount = function(blockTag) {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getTransactionCount");
                return [4, this.provider.getTransactionCount(this.getAddress(), blockTag)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer4.prototype.estimateGas = function(transaction) {
        return __awaiter5(this, void 0, void 0, function() {
          var tx;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("estimateGas");
                return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
              case 1:
                tx = _a.sent();
                return [4, this.provider.estimateGas(tx)];
              case 2:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer4.prototype.call = function(transaction, blockTag) {
        return __awaiter5(this, void 0, void 0, function() {
          var tx;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("call");
                return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
              case 1:
                tx = _a.sent();
                return [4, this.provider.call(tx, blockTag)];
              case 2:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer4.prototype.sendTransaction = function(transaction) {
        return __awaiter5(this, void 0, void 0, function() {
          var tx, signedTx;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("sendTransaction");
                return [4, this.populateTransaction(transaction)];
              case 1:
                tx = _a.sent();
                return [4, this.signTransaction(tx)];
              case 2:
                signedTx = _a.sent();
                return [4, this.provider.sendTransaction(signedTx)];
              case 3:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer4.prototype.getChainId = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var network;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getChainId");
                return [4, this.provider.getNetwork()];
              case 1:
                network = _a.sent();
                return [2, network.chainId];
            }
          });
        });
      };
      Signer4.prototype.getGasPrice = function() {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getGasPrice");
                return [4, this.provider.getGasPrice()];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer4.prototype.getFeeData = function() {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("getFeeData");
                return [4, this.provider.getFeeData()];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer4.prototype.resolveName = function(name) {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this._checkProvider("resolveName");
                return [4, this.provider.resolveName(name)];
              case 1:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer4.prototype.checkTransaction = function(transaction) {
        for (var key in transaction) {
          if (allowedTransactionKeys2.indexOf(key) === -1) {
            logger15.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
          }
        }
        var tx = (0, properties_1.shallowCopy)(transaction);
        if (tx.from == null) {
          tx.from = this.getAddress();
        } else {
          tx.from = Promise.all([
            Promise.resolve(tx.from),
            this.getAddress()
          ]).then(function(result) {
            if (result[0].toLowerCase() !== result[1].toLowerCase()) {
              logger15.throwArgumentError("from address mismatch", "transaction", transaction);
            }
            return result[0];
          });
        }
        return tx;
      };
      Signer4.prototype.populateTransaction = function(transaction) {
        return __awaiter5(this, void 0, void 0, function() {
          var tx, hasEip1559, feeData, gasPrice;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, (0, properties_1.resolveProperties)(this.checkTransaction(transaction))];
              case 1:
                tx = _a.sent();
                if (tx.to != null) {
                  tx.to = Promise.resolve(tx.to).then(function(to) {
                    return __awaiter5(_this, void 0, void 0, function() {
                      var address;
                      return __generator(this, function(_a2) {
                        switch (_a2.label) {
                          case 0:
                            if (to == null) {
                              return [2, null];
                            }
                            return [4, this.resolveName(to)];
                          case 1:
                            address = _a2.sent();
                            if (address == null) {
                              logger15.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                            }
                            return [2, address];
                        }
                      });
                    });
                  });
                  tx.to.catch(function(error) {
                  });
                }
                hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
                if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                  logger15.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
                } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                  logger15.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
                }
                if (!((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)))
                  return [3, 2];
                tx.type = 2;
                return [3, 5];
              case 2:
                if (!(tx.type === 0 || tx.type === 1))
                  return [3, 3];
                if (tx.gasPrice == null) {
                  tx.gasPrice = this.getGasPrice();
                }
                return [3, 5];
              case 3:
                return [4, this.getFeeData()];
              case 4:
                feeData = _a.sent();
                if (tx.type == null) {
                  if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                    tx.type = 2;
                    if (tx.gasPrice != null) {
                      gasPrice = tx.gasPrice;
                      delete tx.gasPrice;
                      tx.maxFeePerGas = gasPrice;
                      tx.maxPriorityFeePerGas = gasPrice;
                    } else {
                      if (tx.maxFeePerGas == null) {
                        tx.maxFeePerGas = feeData.maxFeePerGas;
                      }
                      if (tx.maxPriorityFeePerGas == null) {
                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                      }
                    }
                  } else if (feeData.gasPrice != null) {
                    if (hasEip1559) {
                      logger15.throwError("network does not support EIP-1559", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "populateTransaction"
                      });
                    }
                    if (tx.gasPrice == null) {
                      tx.gasPrice = feeData.gasPrice;
                    }
                    tx.type = 0;
                  } else {
                    logger15.throwError("failed to get consistent fee data", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
                      operation: "signer.getFeeData"
                    });
                  }
                } else if (tx.type === 2) {
                  if (tx.maxFeePerGas == null) {
                    tx.maxFeePerGas = feeData.maxFeePerGas;
                  }
                  if (tx.maxPriorityFeePerGas == null) {
                    tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                  }
                }
                _a.label = 5;
              case 5:
                if (tx.nonce == null) {
                  tx.nonce = this.getTransactionCount("pending");
                }
                if (tx.gasLimit == null) {
                  tx.gasLimit = this.estimateGas(tx).catch(function(error) {
                    if (forwardErrors.indexOf(error.code) >= 0) {
                      throw error;
                    }
                    return logger15.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                      error,
                      tx
                    });
                  });
                }
                if (tx.chainId == null) {
                  tx.chainId = this.getChainId();
                } else {
                  tx.chainId = Promise.all([
                    Promise.resolve(tx.chainId),
                    this.getChainId()
                  ]).then(function(results) {
                    if (results[1] !== 0 && results[0] !== results[1]) {
                      logger15.throwArgumentError("chainId address mismatch", "transaction", transaction);
                    }
                    return results[0];
                  });
                }
                return [4, (0, properties_1.resolveProperties)(tx)];
              case 6:
                return [2, _a.sent()];
            }
          });
        });
      };
      Signer4.prototype._checkProvider = function(operation) {
        if (!this.provider) {
          logger15.throwError("missing provider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: operation || "_checkProvider"
          });
        }
      };
      Signer4.isSigner = function(value) {
        return !!(value && value._isSigner);
      };
      return Signer4;
    }();
    exports.Signer = Signer3;
    var VoidSigner2 = function(_super) {
      __extends2(VoidSigner3, _super);
      function VoidSigner3(address, provider) {
        var _this = _super.call(this) || this;
        (0, properties_1.defineReadOnly)(_this, "address", address);
        (0, properties_1.defineReadOnly)(_this, "provider", provider || null);
        return _this;
      }
      VoidSigner3.prototype.getAddress = function() {
        return Promise.resolve(this.address);
      };
      VoidSigner3.prototype._fail = function(message, operation) {
        return Promise.resolve().then(function() {
          logger15.throwError(message, logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation });
        });
      };
      VoidSigner3.prototype.signMessage = function(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
      };
      VoidSigner3.prototype.signTransaction = function(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
      };
      VoidSigner3.prototype._signTypedData = function(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
      };
      VoidSigner3.prototype.connect = function(provider) {
        return new VoidSigner3(this.address, provider);
      };
      return VoidSigner3;
    }(Signer3);
    exports.VoidSigner = VoidSigner2;
  }
});

// ../node_modules/@ethersproject/providers/lib/json-rpc-provider.js
var require_json_rpc_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/json-rpc-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcProvider = exports.JsonRpcSigner = void 0;
    var abstract_signer_1 = require_lib20();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var hash_1 = require_lib15();
    var properties_1 = require_lib4();
    var strings_1 = require_lib11();
    var transactions_1 = require_lib19();
    var web_1 = require_lib17();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var base_provider_1 = require_base_provider();
    var errorGas = ["call", "estimateGas"];
    function spelunk(value, requireData) {
      if (value == null) {
        return null;
      }
      if (typeof value.message === "string" && value.message.match("reverted")) {
        var data = (0, bytes_1.isHexString)(value.data) ? value.data : null;
        if (!requireData || data) {
          return { message: value.message, data };
        }
      }
      if (typeof value === "object") {
        for (var key in value) {
          var result = spelunk(value[key], requireData);
          if (result) {
            return result;
          }
        }
        return null;
      }
      if (typeof value === "string") {
        try {
          return spelunk(JSON.parse(value), requireData);
        } catch (error) {
        }
      }
      return null;
    }
    function checkError(method, error, params) {
      var transaction = params.transaction || params.signedTransaction;
      if (method === "call") {
        var result = spelunk(error, true);
        if (result) {
          return result.data;
        }
        logger15.throwError("missing revert data in call exception; Transaction reverted without a reason string", logger_1.Logger.errors.CALL_EXCEPTION, {
          data: "0x",
          transaction,
          error
        });
      }
      if (method === "estimateGas") {
        var result = spelunk(error.body, false);
        if (result == null) {
          result = spelunk(error, false);
        }
        if (result) {
          logger15.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            reason: result.message,
            method,
            transaction,
            error
          });
        }
      }
      var message = error.message;
      if (error.code === logger_1.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
        message = error.error.message;
      } else if (typeof error.body === "string") {
        message = error.body;
      } else if (typeof error.responseText === "string") {
        message = error.responseText;
      }
      message = (message || "").toLowerCase();
      if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
        logger15.throwError("insufficient funds for intrinsic transaction cost", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/nonce (is )?too low/i)) {
        logger15.throwError("nonce has already been used", logger_1.Logger.errors.NONCE_EXPIRED, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
        logger15.throwError("replacement fee too low", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/only replay-protected/i)) {
        logger15.throwError("legacy pre-eip-155 transactions not supported", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          error,
          method,
          transaction
        });
      }
      if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
        logger15.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          error,
          method,
          transaction
        });
      }
      throw error;
    }
    function timer(timeout) {
      return new Promise(function(resolve) {
        setTimeout(resolve, timeout);
      });
    }
    function getResult2(payload) {
      if (payload.error) {
        var error = new Error(payload.error.message);
        error.code = payload.error.code;
        error.data = payload.error.data;
        throw error;
      }
      return payload.result;
    }
    function getLowerCase(value) {
      if (value) {
        return value.toLowerCase();
      }
      return value;
    }
    var _constructorGuard3 = {};
    var JsonRpcSigner = function(_super) {
      __extends2(JsonRpcSigner2, _super);
      function JsonRpcSigner2(constructorGuard, provider, addressOrIndex) {
        var _this = _super.call(this) || this;
        if (constructorGuard !== _constructorGuard3) {
          throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        }
        (0, properties_1.defineReadOnly)(_this, "provider", provider);
        if (addressOrIndex == null) {
          addressOrIndex = 0;
        }
        if (typeof addressOrIndex === "string") {
          (0, properties_1.defineReadOnly)(_this, "_address", _this.provider.formatter.address(addressOrIndex));
          (0, properties_1.defineReadOnly)(_this, "_index", null);
        } else if (typeof addressOrIndex === "number") {
          (0, properties_1.defineReadOnly)(_this, "_index", addressOrIndex);
          (0, properties_1.defineReadOnly)(_this, "_address", null);
        } else {
          logger15.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
        }
        return _this;
      }
      JsonRpcSigner2.prototype.connect = function(provider) {
        return logger15.throwError("cannot alter JSON-RPC Signer connection", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "connect"
        });
      };
      JsonRpcSigner2.prototype.connectUnchecked = function() {
        return new UncheckedJsonRpcSigner(_constructorGuard3, this.provider, this._address || this._index);
      };
      JsonRpcSigner2.prototype.getAddress = function() {
        var _this = this;
        if (this._address) {
          return Promise.resolve(this._address);
        }
        return this.provider.send("eth_accounts", []).then(function(accounts) {
          if (accounts.length <= _this._index) {
            logger15.throwError("unknown account #" + _this._index, logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "getAddress"
            });
          }
          return _this.provider.formatter.address(accounts[_this._index]);
        });
      };
      JsonRpcSigner2.prototype.sendUncheckedTransaction = function(transaction) {
        var _this = this;
        transaction = (0, properties_1.shallowCopy)(transaction);
        var fromAddress = this.getAddress().then(function(address) {
          if (address) {
            address = address.toLowerCase();
          }
          return address;
        });
        if (transaction.gasLimit == null) {
          var estimate = (0, properties_1.shallowCopy)(transaction);
          estimate.from = fromAddress;
          transaction.gasLimit = this.provider.estimateGas(estimate);
        }
        if (transaction.to != null) {
          transaction.to = Promise.resolve(transaction.to).then(function(to) {
            return __awaiter5(_this, void 0, void 0, function() {
              var address;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (to == null) {
                      return [2, null];
                    }
                    return [4, this.provider.resolveName(to)];
                  case 1:
                    address = _a.sent();
                    if (address == null) {
                      logger15.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                    }
                    return [2, address];
                }
              });
            });
          });
        }
        return (0, properties_1.resolveProperties)({
          tx: (0, properties_1.resolveProperties)(transaction),
          sender: fromAddress
        }).then(function(_a) {
          var tx = _a.tx, sender = _a.sender;
          if (tx.from != null) {
            if (tx.from.toLowerCase() !== sender) {
              logger15.throwArgumentError("from address mismatch", "transaction", transaction);
            }
          } else {
            tx.from = sender;
          }
          var hexTx = _this.provider.constructor.hexlifyTransaction(tx, { from: true });
          return _this.provider.send("eth_sendTransaction", [hexTx]).then(function(hash4) {
            return hash4;
          }, function(error) {
            if (typeof error.message === "string" && error.message.match(/user denied/i)) {
              logger15.throwError("user rejected transaction", logger_1.Logger.errors.ACTION_REJECTED, {
                action: "sendTransaction",
                transaction: tx
              });
            }
            return checkError("sendTransaction", error, hexTx);
          });
        });
      };
      JsonRpcSigner2.prototype.signTransaction = function(transaction) {
        return logger15.throwError("signing transactions is unsupported", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "signTransaction"
        });
      };
      JsonRpcSigner2.prototype.sendTransaction = function(transaction) {
        return __awaiter5(this, void 0, void 0, function() {
          var blockNumber, hash4, error_1;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval)];
              case 1:
                blockNumber = _a.sent();
                return [4, this.sendUncheckedTransaction(transaction)];
              case 2:
                hash4 = _a.sent();
                _a.label = 3;
              case 3:
                _a.trys.push([3, 5, , 6]);
                return [4, (0, web_1.poll)(function() {
                  return __awaiter5(_this, void 0, void 0, function() {
                    var tx;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          return [4, this.provider.getTransaction(hash4)];
                        case 1:
                          tx = _a2.sent();
                          if (tx === null) {
                            return [2, void 0];
                          }
                          return [2, this.provider._wrapTransaction(tx, hash4, blockNumber)];
                      }
                    });
                  });
                }, { oncePoll: this.provider })];
              case 4:
                return [2, _a.sent()];
              case 5:
                error_1 = _a.sent();
                error_1.transactionHash = hash4;
                throw error_1;
              case 6:
                return [2];
            }
          });
        });
      };
      JsonRpcSigner2.prototype.signMessage = function(message) {
        return __awaiter5(this, void 0, void 0, function() {
          var data, address, error_2;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                data = typeof message === "string" ? (0, strings_1.toUtf8Bytes)(message) : message;
                return [4, this.getAddress()];
              case 1:
                address = _a.sent();
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.provider.send("personal_sign", [(0, bytes_1.hexlify)(data), address.toLowerCase()])];
              case 3:
                return [2, _a.sent()];
              case 4:
                error_2 = _a.sent();
                if (typeof error_2.message === "string" && error_2.message.match(/user denied/i)) {
                  logger15.throwError("user rejected signing", logger_1.Logger.errors.ACTION_REJECTED, {
                    action: "signMessage",
                    from: address,
                    messageData: message
                  });
                }
                throw error_2;
              case 5:
                return [2];
            }
          });
        });
      };
      JsonRpcSigner2.prototype._legacySignMessage = function(message) {
        return __awaiter5(this, void 0, void 0, function() {
          var data, address, error_3;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                data = typeof message === "string" ? (0, strings_1.toUtf8Bytes)(message) : message;
                return [4, this.getAddress()];
              case 1:
                address = _a.sent();
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 5]);
                return [4, this.provider.send("eth_sign", [address.toLowerCase(), (0, bytes_1.hexlify)(data)])];
              case 3:
                return [2, _a.sent()];
              case 4:
                error_3 = _a.sent();
                if (typeof error_3.message === "string" && error_3.message.match(/user denied/i)) {
                  logger15.throwError("user rejected signing", logger_1.Logger.errors.ACTION_REJECTED, {
                    action: "_legacySignMessage",
                    from: address,
                    messageData: message
                  });
                }
                throw error_3;
              case 5:
                return [2];
            }
          });
        });
      };
      JsonRpcSigner2.prototype._signTypedData = function(domain, types, value) {
        return __awaiter5(this, void 0, void 0, function() {
          var populated, address, error_4;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, hash_1._TypedDataEncoder.resolveNames(domain, types, value, function(name) {
                  return _this.provider.resolveName(name);
                })];
              case 1:
                populated = _a.sent();
                return [4, this.getAddress()];
              case 2:
                address = _a.sent();
                _a.label = 3;
              case 3:
                _a.trys.push([3, 5, , 6]);
                return [4, this.provider.send("eth_signTypedData_v4", [
                  address.toLowerCase(),
                  JSON.stringify(hash_1._TypedDataEncoder.getPayload(populated.domain, types, populated.value))
                ])];
              case 4:
                return [2, _a.sent()];
              case 5:
                error_4 = _a.sent();
                if (typeof error_4.message === "string" && error_4.message.match(/user denied/i)) {
                  logger15.throwError("user rejected signing", logger_1.Logger.errors.ACTION_REJECTED, {
                    action: "_signTypedData",
                    from: address,
                    messageData: { domain: populated.domain, types, value: populated.value }
                  });
                }
                throw error_4;
              case 6:
                return [2];
            }
          });
        });
      };
      JsonRpcSigner2.prototype.unlock = function(password) {
        return __awaiter5(this, void 0, void 0, function() {
          var provider, address;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                provider = this.provider;
                return [4, this.getAddress()];
              case 1:
                address = _a.sent();
                return [2, provider.send("personal_unlockAccount", [address.toLowerCase(), password, null])];
            }
          });
        });
      };
      return JsonRpcSigner2;
    }(abstract_signer_1.Signer);
    exports.JsonRpcSigner = JsonRpcSigner;
    var UncheckedJsonRpcSigner = function(_super) {
      __extends2(UncheckedJsonRpcSigner2, _super);
      function UncheckedJsonRpcSigner2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      UncheckedJsonRpcSigner2.prototype.sendTransaction = function(transaction) {
        var _this = this;
        return this.sendUncheckedTransaction(transaction).then(function(hash4) {
          return {
            hash: hash4,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: function(confirmations) {
              return _this.provider.waitForTransaction(hash4, confirmations);
            }
          };
        });
      };
      return UncheckedJsonRpcSigner2;
    }(JsonRpcSigner);
    var allowedTransactionKeys2 = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true
    };
    var JsonRpcProvider2 = function(_super) {
      __extends2(JsonRpcProvider3, _super);
      function JsonRpcProvider3(url, network) {
        var _this = this;
        var networkOrReady = network;
        if (networkOrReady == null) {
          networkOrReady = new Promise(function(resolve, reject) {
            setTimeout(function() {
              _this.detectNetwork().then(function(network2) {
                resolve(network2);
              }, function(error) {
                reject(error);
              });
            }, 0);
          });
        }
        _this = _super.call(this, networkOrReady) || this;
        if (!url) {
          url = (0, properties_1.getStatic)(_this.constructor, "defaultUrl")();
        }
        if (typeof url === "string") {
          (0, properties_1.defineReadOnly)(_this, "connection", Object.freeze({
            url
          }));
        } else {
          (0, properties_1.defineReadOnly)(_this, "connection", Object.freeze((0, properties_1.shallowCopy)(url)));
        }
        _this._nextId = 42;
        return _this;
      }
      Object.defineProperty(JsonRpcProvider3.prototype, "_cache", {
        get: function() {
          if (this._eventLoopCache == null) {
            this._eventLoopCache = {};
          }
          return this._eventLoopCache;
        },
        enumerable: false,
        configurable: true
      });
      JsonRpcProvider3.defaultUrl = function() {
        return "http://localhost:8545";
      };
      JsonRpcProvider3.prototype.detectNetwork = function() {
        var _this = this;
        if (!this._cache["detectNetwork"]) {
          this._cache["detectNetwork"] = this._uncachedDetectNetwork();
          setTimeout(function() {
            _this._cache["detectNetwork"] = null;
          }, 0);
        }
        return this._cache["detectNetwork"];
      };
      JsonRpcProvider3.prototype._uncachedDetectNetwork = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var chainId, error_5, error_6, getNetwork3;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, timer(0)];
              case 1:
                _a.sent();
                chainId = null;
                _a.label = 2;
              case 2:
                _a.trys.push([2, 4, , 9]);
                return [4, this.send("eth_chainId", [])];
              case 3:
                chainId = _a.sent();
                return [3, 9];
              case 4:
                error_5 = _a.sent();
                _a.label = 5;
              case 5:
                _a.trys.push([5, 7, , 8]);
                return [4, this.send("net_version", [])];
              case 6:
                chainId = _a.sent();
                return [3, 8];
              case 7:
                error_6 = _a.sent();
                return [3, 8];
              case 8:
                return [3, 9];
              case 9:
                if (chainId != null) {
                  getNetwork3 = (0, properties_1.getStatic)(this.constructor, "getNetwork");
                  try {
                    return [2, getNetwork3(bignumber_1.BigNumber.from(chainId).toNumber())];
                  } catch (error) {
                    return [2, logger15.throwError("could not detect network", logger_1.Logger.errors.NETWORK_ERROR, {
                      chainId,
                      event: "invalidNetwork",
                      serverError: error
                    })];
                  }
                }
                return [2, logger15.throwError("could not detect network", logger_1.Logger.errors.NETWORK_ERROR, {
                  event: "noNetwork"
                })];
            }
          });
        });
      };
      JsonRpcProvider3.prototype.getSigner = function(addressOrIndex) {
        return new JsonRpcSigner(_constructorGuard3, this, addressOrIndex);
      };
      JsonRpcProvider3.prototype.getUncheckedSigner = function(addressOrIndex) {
        return this.getSigner(addressOrIndex).connectUnchecked();
      };
      JsonRpcProvider3.prototype.listAccounts = function() {
        var _this = this;
        return this.send("eth_accounts", []).then(function(accounts) {
          return accounts.map(function(a) {
            return _this.formatter.address(a);
          });
        });
      };
      JsonRpcProvider3.prototype.send = function(method, params) {
        var _this = this;
        var request = {
          method,
          params,
          id: this._nextId++,
          jsonrpc: "2.0"
        };
        this.emit("debug", {
          action: "request",
          request: (0, properties_1.deepCopy)(request),
          provider: this
        });
        var cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
        if (cache && this._cache[method]) {
          return this._cache[method];
        }
        var result = (0, web_1.fetchJson)(this.connection, JSON.stringify(request), getResult2).then(function(result2) {
          _this.emit("debug", {
            action: "response",
            request,
            response: result2,
            provider: _this
          });
          return result2;
        }, function(error) {
          _this.emit("debug", {
            action: "response",
            error,
            request,
            provider: _this
          });
          throw error;
        });
        if (cache) {
          this._cache[method] = result;
          setTimeout(function() {
            _this._cache[method] = null;
          }, 0);
        }
        return result;
      };
      JsonRpcProvider3.prototype.prepareRequest = function(method, params) {
        switch (method) {
          case "getBlockNumber":
            return ["eth_blockNumber", []];
          case "getGasPrice":
            return ["eth_gasPrice", []];
          case "getBalance":
            return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
          case "getTransactionCount":
            return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
          case "getCode":
            return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
          case "getStorageAt":
            return ["eth_getStorageAt", [getLowerCase(params.address), (0, bytes_1.hexZeroPad)(params.position, 32), params.blockTag]];
          case "sendTransaction":
            return ["eth_sendRawTransaction", [params.signedTransaction]];
          case "getBlock":
            if (params.blockTag) {
              return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
            } else if (params.blockHash) {
              return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
            }
            return null;
          case "getTransaction":
            return ["eth_getTransactionByHash", [params.transactionHash]];
          case "getTransactionReceipt":
            return ["eth_getTransactionReceipt", [params.transactionHash]];
          case "call": {
            var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, "hexlifyTransaction");
            return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
          }
          case "estimateGas": {
            var hexlifyTransaction = (0, properties_1.getStatic)(this.constructor, "hexlifyTransaction");
            return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
          }
          case "getLogs":
            if (params.filter && params.filter.address != null) {
              params.filter.address = getLowerCase(params.filter.address);
            }
            return ["eth_getLogs", [params.filter]];
          default:
            break;
        }
        return null;
      };
      JsonRpcProvider3.prototype.perform = function(method, params) {
        return __awaiter5(this, void 0, void 0, function() {
          var tx, feeData, args, error_7;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(method === "call" || method === "estimateGas"))
                  return [3, 2];
                tx = params.transaction;
                if (!(tx && tx.type != null && bignumber_1.BigNumber.from(tx.type).isZero()))
                  return [3, 2];
                if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null))
                  return [3, 2];
                return [4, this.getFeeData()];
              case 1:
                feeData = _a.sent();
                if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                  params = (0, properties_1.shallowCopy)(params);
                  params.transaction = (0, properties_1.shallowCopy)(tx);
                  delete params.transaction.type;
                }
                _a.label = 2;
              case 2:
                args = this.prepareRequest(method, params);
                if (args == null) {
                  logger15.throwError(method + " not implemented", logger_1.Logger.errors.NOT_IMPLEMENTED, { operation: method });
                }
                _a.label = 3;
              case 3:
                _a.trys.push([3, 5, , 6]);
                return [4, this.send(args[0], args[1])];
              case 4:
                return [2, _a.sent()];
              case 5:
                error_7 = _a.sent();
                return [2, checkError(method, error_7, params)];
              case 6:
                return [2];
            }
          });
        });
      };
      JsonRpcProvider3.prototype._startEvent = function(event) {
        if (event.tag === "pending") {
          this._startPending();
        }
        _super.prototype._startEvent.call(this, event);
      };
      JsonRpcProvider3.prototype._startPending = function() {
        if (this._pendingFilter != null) {
          return;
        }
        var self2 = this;
        var pendingFilter = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = pendingFilter;
        pendingFilter.then(function(filterId) {
          function poll2() {
            self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
              if (self2._pendingFilter != pendingFilter) {
                return null;
              }
              var seq = Promise.resolve();
              hashes.forEach(function(hash4) {
                self2._emitted["t:" + hash4.toLowerCase()] = "pending";
                seq = seq.then(function() {
                  return self2.getTransaction(hash4).then(function(tx) {
                    self2.emit("pending", tx);
                    return null;
                  });
                });
              });
              return seq.then(function() {
                return timer(1e3);
              });
            }).then(function() {
              if (self2._pendingFilter != pendingFilter) {
                self2.send("eth_uninstallFilter", [filterId]);
                return;
              }
              setTimeout(function() {
                poll2();
              }, 0);
              return null;
            }).catch(function(error) {
            });
          }
          poll2();
          return filterId;
        }).catch(function(error) {
        });
      };
      JsonRpcProvider3.prototype._stopEvent = function(event) {
        if (event.tag === "pending" && this.listenerCount("pending") === 0) {
          this._pendingFilter = null;
        }
        _super.prototype._stopEvent.call(this, event);
      };
      JsonRpcProvider3.hexlifyTransaction = function(transaction, allowExtra) {
        var allowed = (0, properties_1.shallowCopy)(allowedTransactionKeys2);
        if (allowExtra) {
          for (var key in allowExtra) {
            if (allowExtra[key]) {
              allowed[key] = true;
            }
          }
        }
        (0, properties_1.checkProperties)(transaction, allowed);
        var result = {};
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
          if (transaction[key2] == null) {
            return;
          }
          var value = (0, bytes_1.hexValue)(bignumber_1.BigNumber.from(transaction[key2]));
          if (key2 === "gasLimit") {
            key2 = "gas";
          }
          result[key2] = value;
        });
        ["from", "to", "data"].forEach(function(key2) {
          if (transaction[key2] == null) {
            return;
          }
          result[key2] = (0, bytes_1.hexlify)(transaction[key2]);
        });
        if (transaction.accessList) {
          result["accessList"] = (0, transactions_1.accessListify)(transaction.accessList);
        }
        return result;
      };
      return JsonRpcProvider3;
    }(base_provider_1.BaseProvider);
    exports.JsonRpcProvider = JsonRpcProvider2;
  }
});

// ../node_modules/@ethersproject/providers/lib/browser-ws.js
var require_browser_ws = __commonJS({
  "../node_modules/@ethersproject/providers/lib/browser-ws.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocket = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var WS = null;
    exports.WebSocket = WS;
    try {
      exports.WebSocket = WS = WebSocket;
      if (WS == null) {
        throw new Error("inject please");
      }
    } catch (error) {
      logger_2 = new logger_1.Logger(_version_1.version);
      exports.WebSocket = WS = function() {
        logger_2.throwError("WebSockets not supported in this environment", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new WebSocket()"
        });
      };
    }
    var logger_2;
  }
});

// ../node_modules/@ethersproject/providers/lib/websocket-provider.js
var require_websocket_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/websocket-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketProvider = void 0;
    var bignumber_1 = require_lib3();
    var properties_1 = require_lib4();
    var json_rpc_provider_1 = require_json_rpc_provider();
    var ws_1 = require_browser_ws();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var NextId = 1;
    var WebSocketProvider2 = function(_super) {
      __extends2(WebSocketProvider3, _super);
      function WebSocketProvider3(url, network) {
        var _this = this;
        if (network === "any") {
          logger15.throwError("WebSocketProvider does not support 'any' network yet", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "network:any"
          });
        }
        if (typeof url === "string") {
          _this = _super.call(this, url, network) || this;
        } else {
          _this = _super.call(this, "_websocket", network) || this;
        }
        _this._pollingInterval = -1;
        _this._wsReady = false;
        if (typeof url === "string") {
          (0, properties_1.defineReadOnly)(_this, "_websocket", new ws_1.WebSocket(_this.connection.url));
        } else {
          (0, properties_1.defineReadOnly)(_this, "_websocket", url);
        }
        (0, properties_1.defineReadOnly)(_this, "_requests", {});
        (0, properties_1.defineReadOnly)(_this, "_subs", {});
        (0, properties_1.defineReadOnly)(_this, "_subIds", {});
        (0, properties_1.defineReadOnly)(_this, "_detectNetwork", _super.prototype.detectNetwork.call(_this));
        _this.websocket.onopen = function() {
          _this._wsReady = true;
          Object.keys(_this._requests).forEach(function(id4) {
            _this.websocket.send(_this._requests[id4].payload);
          });
        };
        _this.websocket.onmessage = function(messageEvent) {
          var data = messageEvent.data;
          var result = JSON.parse(data);
          if (result.id != null) {
            var id4 = String(result.id);
            var request = _this._requests[id4];
            delete _this._requests[id4];
            if (result.result !== void 0) {
              request.callback(null, result.result);
              _this.emit("debug", {
                action: "response",
                request: JSON.parse(request.payload),
                response: result.result,
                provider: _this
              });
            } else {
              var error = null;
              if (result.error) {
                error = new Error(result.error.message || "unknown error");
                (0, properties_1.defineReadOnly)(error, "code", result.error.code || null);
                (0, properties_1.defineReadOnly)(error, "response", data);
              } else {
                error = new Error("unknown error");
              }
              request.callback(error, void 0);
              _this.emit("debug", {
                action: "response",
                error,
                request: JSON.parse(request.payload),
                provider: _this
              });
            }
          } else if (result.method === "eth_subscription") {
            var sub = _this._subs[result.params.subscription];
            if (sub) {
              sub.processFunc(result.params.result);
            }
          } else {
            console.warn("this should not happen");
          }
        };
        var fauxPoll = setInterval(function() {
          _this.emit("poll");
        }, 1e3);
        if (fauxPoll.unref) {
          fauxPoll.unref();
        }
        return _this;
      }
      Object.defineProperty(WebSocketProvider3.prototype, "websocket", {
        get: function() {
          return this._websocket;
        },
        enumerable: false,
        configurable: true
      });
      WebSocketProvider3.prototype.detectNetwork = function() {
        return this._detectNetwork;
      };
      Object.defineProperty(WebSocketProvider3.prototype, "pollingInterval", {
        get: function() {
          return 0;
        },
        set: function(value) {
          logger15.throwError("cannot set polling interval on WebSocketProvider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setPollingInterval"
          });
        },
        enumerable: false,
        configurable: true
      });
      WebSocketProvider3.prototype.resetEventsBlock = function(blockNumber) {
        logger15.throwError("cannot reset events block on WebSocketProvider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "resetEventBlock"
        });
      };
      WebSocketProvider3.prototype.poll = function() {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, null];
          });
        });
      };
      Object.defineProperty(WebSocketProvider3.prototype, "polling", {
        set: function(value) {
          if (!value) {
            return;
          }
          logger15.throwError("cannot set polling on WebSocketProvider", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setPolling"
          });
        },
        enumerable: false,
        configurable: true
      });
      WebSocketProvider3.prototype.send = function(method, params) {
        var _this = this;
        var rid = NextId++;
        return new Promise(function(resolve, reject) {
          function callback(error, result) {
            if (error) {
              return reject(error);
            }
            return resolve(result);
          }
          var payload = JSON.stringify({
            method,
            params,
            id: rid,
            jsonrpc: "2.0"
          });
          _this.emit("debug", {
            action: "request",
            request: JSON.parse(payload),
            provider: _this
          });
          _this._requests[String(rid)] = { callback, payload };
          if (_this._wsReady) {
            _this.websocket.send(payload);
          }
        });
      };
      WebSocketProvider3.defaultUrl = function() {
        return "ws://localhost:8546";
      };
      WebSocketProvider3.prototype._subscribe = function(tag, param, processFunc) {
        return __awaiter5(this, void 0, void 0, function() {
          var subIdPromise, subId;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                subIdPromise = this._subIds[tag];
                if (subIdPromise == null) {
                  subIdPromise = Promise.all(param).then(function(param2) {
                    return _this.send("eth_subscribe", param2);
                  });
                  this._subIds[tag] = subIdPromise;
                }
                return [4, subIdPromise];
              case 1:
                subId = _a.sent();
                this._subs[subId] = { tag, processFunc };
                return [2];
            }
          });
        });
      };
      WebSocketProvider3.prototype._startEvent = function(event) {
        var _this = this;
        switch (event.type) {
          case "block":
            this._subscribe("block", ["newHeads"], function(result) {
              var blockNumber = bignumber_1.BigNumber.from(result.number).toNumber();
              _this._emitted.block = blockNumber;
              _this.emit("block", blockNumber);
            });
            break;
          case "pending":
            this._subscribe("pending", ["newPendingTransactions"], function(result) {
              _this.emit("pending", result);
            });
            break;
          case "filter":
            this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], function(result) {
              if (result.removed == null) {
                result.removed = false;
              }
              _this.emit(event.filter, _this.formatter.filterLog(result));
            });
            break;
          case "tx": {
            var emitReceipt_1 = function(event2) {
              var hash4 = event2.hash;
              _this.getTransactionReceipt(hash4).then(function(receipt) {
                if (!receipt) {
                  return;
                }
                _this.emit(hash4, receipt);
              });
            };
            emitReceipt_1(event);
            this._subscribe("tx", ["newHeads"], function(result) {
              _this._events.filter(function(e) {
                return e.type === "tx";
              }).forEach(emitReceipt_1);
            });
            break;
          }
          case "debug":
          case "poll":
          case "willPoll":
          case "didPoll":
          case "error":
            break;
          default:
            console.log("unhandled:", event);
            break;
        }
      };
      WebSocketProvider3.prototype._stopEvent = function(event) {
        var _this = this;
        var tag = event.tag;
        if (event.type === "tx") {
          if (this._events.filter(function(e) {
            return e.type === "tx";
          }).length) {
            return;
          }
          tag = "tx";
        } else if (this.listenerCount(event.event)) {
          return;
        }
        var subId = this._subIds[tag];
        if (!subId) {
          return;
        }
        delete this._subIds[tag];
        subId.then(function(subId2) {
          if (!_this._subs[subId2]) {
            return;
          }
          delete _this._subs[subId2];
          _this.send("eth_unsubscribe", [subId2]);
        });
      };
      WebSocketProvider3.prototype.destroy = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(this.websocket.readyState === ws_1.WebSocket.CONNECTING))
                  return [3, 2];
                return [4, new Promise(function(resolve) {
                  _this.websocket.onopen = function() {
                    resolve(true);
                  };
                  _this.websocket.onerror = function() {
                    resolve(false);
                  };
                })];
              case 1:
                _a.sent();
                _a.label = 2;
              case 2:
                this.websocket.close(1e3);
                return [2];
            }
          });
        });
      };
      return WebSocketProvider3;
    }(json_rpc_provider_1.JsonRpcProvider);
    exports.WebSocketProvider = WebSocketProvider2;
  }
});

// ../node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js
var require_url_json_rpc_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/url-json-rpc-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlJsonRpcProvider = exports.StaticJsonRpcProvider = void 0;
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var json_rpc_provider_1 = require_json_rpc_provider();
    var StaticJsonRpcProvider = function(_super) {
      __extends2(StaticJsonRpcProvider2, _super);
      function StaticJsonRpcProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      StaticJsonRpcProvider2.prototype.detectNetwork = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var network;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                network = this.network;
                if (!(network == null))
                  return [3, 2];
                return [4, _super.prototype.detectNetwork.call(this)];
              case 1:
                network = _a.sent();
                if (!network) {
                  logger15.throwError("no network detected", logger_1.Logger.errors.UNKNOWN_ERROR, {});
                }
                if (this._network == null) {
                  (0, properties_1.defineReadOnly)(this, "_network", network);
                  this.emit("network", network, null);
                }
                _a.label = 2;
              case 2:
                return [2, network];
            }
          });
        });
      };
      return StaticJsonRpcProvider2;
    }(json_rpc_provider_1.JsonRpcProvider);
    exports.StaticJsonRpcProvider = StaticJsonRpcProvider;
    var UrlJsonRpcProvider = function(_super) {
      __extends2(UrlJsonRpcProvider2, _super);
      function UrlJsonRpcProvider2(network, apiKey) {
        var _newTarget = this.constructor;
        var _this = this;
        logger15.checkAbstract(_newTarget, UrlJsonRpcProvider2);
        network = (0, properties_1.getStatic)(_newTarget, "getNetwork")(network);
        apiKey = (0, properties_1.getStatic)(_newTarget, "getApiKey")(apiKey);
        var connection = (0, properties_1.getStatic)(_newTarget, "getUrl")(network, apiKey);
        _this = _super.call(this, connection, network) || this;
        if (typeof apiKey === "string") {
          (0, properties_1.defineReadOnly)(_this, "apiKey", apiKey);
        } else if (apiKey != null) {
          Object.keys(apiKey).forEach(function(key) {
            (0, properties_1.defineReadOnly)(_this, key, apiKey[key]);
          });
        }
        return _this;
      }
      UrlJsonRpcProvider2.prototype._startPending = function() {
        logger15.warn("WARNING: API provider does not support pending filters");
      };
      UrlJsonRpcProvider2.prototype.isCommunityResource = function() {
        return false;
      };
      UrlJsonRpcProvider2.prototype.getSigner = function(address) {
        return logger15.throwError("API provider does not support signing", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
      };
      UrlJsonRpcProvider2.prototype.listAccounts = function() {
        return Promise.resolve([]);
      };
      UrlJsonRpcProvider2.getApiKey = function(apiKey) {
        return apiKey;
      };
      UrlJsonRpcProvider2.getUrl = function(network, apiKey) {
        return logger15.throwError("not implemented; sub-classes must override getUrl", logger_1.Logger.errors.NOT_IMPLEMENTED, {
          operation: "getUrl"
        });
      };
      return UrlJsonRpcProvider2;
    }(StaticJsonRpcProvider);
    exports.UrlJsonRpcProvider = UrlJsonRpcProvider;
  }
});

// ../node_modules/@ethersproject/providers/lib/alchemy-provider.js
var require_alchemy_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/alchemy-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlchemyProvider = exports.AlchemyWebSocketProvider = void 0;
    var properties_1 = require_lib4();
    var formatter_1 = require_formatter();
    var websocket_provider_1 = require_websocket_provider();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
    var AlchemyWebSocketProvider2 = function(_super) {
      __extends2(AlchemyWebSocketProvider3, _super);
      function AlchemyWebSocketProvider3(network, apiKey) {
        var _this = this;
        var provider = new AlchemyProvider2(network, apiKey);
        var url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
        _this = _super.call(this, url, provider.network) || this;
        (0, properties_1.defineReadOnly)(_this, "apiKey", provider.apiKey);
        return _this;
      }
      AlchemyWebSocketProvider3.prototype.isCommunityResource = function() {
        return this.apiKey === defaultApiKey;
      };
      return AlchemyWebSocketProvider3;
    }(websocket_provider_1.WebSocketProvider);
    exports.AlchemyWebSocketProvider = AlchemyWebSocketProvider2;
    var AlchemyProvider2 = function(_super) {
      __extends2(AlchemyProvider3, _super);
      function AlchemyProvider3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AlchemyProvider3.getWebSocketProvider = function(network, apiKey) {
        return new AlchemyWebSocketProvider2(network, apiKey);
      };
      AlchemyProvider3.getApiKey = function(apiKey) {
        if (apiKey == null) {
          return defaultApiKey;
        }
        if (apiKey && typeof apiKey !== "string") {
          logger15.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey;
      };
      AlchemyProvider3.getUrl = function(network, apiKey) {
        var host = null;
        switch (network.name) {
          case "homestead":
            host = "eth-mainnet.alchemyapi.io/v2/";
            break;
          case "goerli":
            host = "eth-goerli.g.alchemy.com/v2/";
            break;
          case "matic":
            host = "polygon-mainnet.g.alchemy.com/v2/";
            break;
          case "maticmum":
            host = "polygon-mumbai.g.alchemy.com/v2/";
            break;
          case "arbitrum":
            host = "arb-mainnet.g.alchemy.com/v2/";
            break;
          case "arbitrum-goerli":
            host = "arb-goerli.g.alchemy.com/v2/";
            break;
          case "optimism":
            host = "opt-mainnet.g.alchemy.com/v2/";
            break;
          case "optimism-goerli":
            host = "opt-goerli.g.alchemy.com/v2/";
            break;
          default:
            logger15.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return {
          allowGzip: true,
          url: "https://" + host + apiKey,
          throttleCallback: function(attempt, url) {
            if (apiKey === defaultApiKey) {
              (0, formatter_1.showThrottleMessage)();
            }
            return Promise.resolve(true);
          }
        };
      };
      AlchemyProvider3.prototype.isCommunityResource = function() {
        return this.apiKey === defaultApiKey;
      };
      return AlchemyProvider3;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.AlchemyProvider = AlchemyProvider2;
  }
});

// ../node_modules/@ethersproject/providers/lib/ankr-provider.js
var require_ankr_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/ankr-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnkrProvider = void 0;
    var formatter_1 = require_formatter();
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
    function getHost(name) {
      switch (name) {
        case "homestead":
          return "rpc.ankr.com/eth/";
        case "ropsten":
          return "rpc.ankr.com/eth_ropsten/";
        case "rinkeby":
          return "rpc.ankr.com/eth_rinkeby/";
        case "goerli":
          return "rpc.ankr.com/eth_goerli/";
        case "matic":
          return "rpc.ankr.com/polygon/";
        case "arbitrum":
          return "rpc.ankr.com/arbitrum/";
      }
      return logger15.throwArgumentError("unsupported network", "name", name);
    }
    var AnkrProvider = function(_super) {
      __extends2(AnkrProvider2, _super);
      function AnkrProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnkrProvider2.prototype.isCommunityResource = function() {
        return this.apiKey === defaultApiKey;
      };
      AnkrProvider2.getApiKey = function(apiKey) {
        if (apiKey == null) {
          return defaultApiKey;
        }
        return apiKey;
      };
      AnkrProvider2.getUrl = function(network, apiKey) {
        if (apiKey == null) {
          apiKey = defaultApiKey;
        }
        var connection = {
          allowGzip: true,
          url: "https://" + getHost(network.name) + apiKey,
          throttleCallback: function(attempt, url) {
            if (apiKey.apiKey === defaultApiKey) {
              (0, formatter_1.showThrottleMessage)();
            }
            return Promise.resolve(true);
          }
        };
        if (apiKey.projectSecret != null) {
          connection.user = "";
          connection.password = apiKey.projectSecret;
        }
        return connection;
      };
      return AnkrProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.AnkrProvider = AnkrProvider;
  }
});

// ../node_modules/@ethersproject/providers/lib/cloudflare-provider.js
var require_cloudflare_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/cloudflare-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CloudflareProvider = void 0;
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var CloudflareProvider = function(_super) {
      __extends2(CloudflareProvider2, _super);
      function CloudflareProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CloudflareProvider2.getApiKey = function(apiKey) {
        if (apiKey != null) {
          logger15.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
        }
        return null;
      };
      CloudflareProvider2.getUrl = function(network, apiKey) {
        var host = null;
        switch (network.name) {
          case "homestead":
            host = "https://cloudflare-eth.com/";
            break;
          default:
            logger15.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host;
      };
      CloudflareProvider2.prototype.perform = function(method, params) {
        return __awaiter5(this, void 0, void 0, function() {
          var block;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(method === "getBlockNumber"))
                  return [3, 2];
                return [4, _super.prototype.perform.call(this, "getBlock", { blockTag: "latest" })];
              case 1:
                block = _a.sent();
                return [2, block.number];
              case 2:
                return [2, _super.prototype.perform.call(this, method, params)];
            }
          });
        });
      };
      return CloudflareProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.CloudflareProvider = CloudflareProvider;
  }
});

// ../node_modules/@ethersproject/providers/lib/etherscan-provider.js
var require_etherscan_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/etherscan-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherscanProvider = void 0;
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var transactions_1 = require_lib19();
    var web_1 = require_lib17();
    var formatter_1 = require_formatter();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var base_provider_1 = require_base_provider();
    function getTransactionPostData(transaction) {
      var result = {};
      for (var key in transaction) {
        if (transaction[key] == null) {
          continue;
        }
        var value = transaction[key];
        if (key === "type" && value === 0) {
          continue;
        }
        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
          value = (0, bytes_1.hexValue)((0, bytes_1.hexlify)(value));
        } else if (key === "accessList") {
          value = "[" + (0, transactions_1.accessListify)(value).map(function(set) {
            return '{address:"' + set.address + '",storageKeys:["' + set.storageKeys.join('","') + '"]}';
          }).join(",") + "]";
        } else {
          value = (0, bytes_1.hexlify)(value);
        }
        result[key] = value;
      }
      return result;
    }
    function getResult2(result) {
      if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        return result.result;
      }
      if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
        var error = new Error("invalid response");
        error.result = JSON.stringify(result);
        if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
          error.throttleRetry = true;
        }
        throw error;
      }
      return result.result;
    }
    function getJsonResult(result) {
      if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        var error = new Error("throttled response");
        error.result = JSON.stringify(result);
        error.throttleRetry = true;
        throw error;
      }
      if (result.jsonrpc != "2.0") {
        var error = new Error("invalid response");
        error.result = JSON.stringify(result);
        throw error;
      }
      if (result.error) {
        var error = new Error(result.error.message || "unknown error");
        if (result.error.code) {
          error.code = result.error.code;
        }
        if (result.error.data) {
          error.data = result.error.data;
        }
        throw error;
      }
      return result.result;
    }
    function checkLogTag(blockTag) {
      if (blockTag === "pending") {
        throw new Error("pending not supported");
      }
      if (blockTag === "latest") {
        return blockTag;
      }
      return parseInt(blockTag.substring(2), 16);
    }
    function checkError(method, error, transaction) {
      if (method === "call" && error.code === logger_1.Logger.errors.SERVER_ERROR) {
        var e = error.error;
        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
          var data = e.data;
          if (data) {
            data = "0x" + data.replace(/^.*0x/i, "");
          }
          if ((0, bytes_1.isHexString)(data)) {
            return data;
          }
          logger15.throwError("missing revert data in call exception", logger_1.Logger.errors.CALL_EXCEPTION, {
            error,
            data: "0x"
          });
        }
      }
      var message = error.message;
      if (error.code === logger_1.Logger.errors.SERVER_ERROR) {
        if (error.error && typeof error.error.message === "string") {
          message = error.error.message;
        } else if (typeof error.body === "string") {
          message = error.body;
        } else if (typeof error.responseText === "string") {
          message = error.responseText;
        }
      }
      message = (message || "").toLowerCase();
      if (message.match(/insufficient funds/)) {
        logger15.throwError("insufficient funds for intrinsic transaction cost", logger_1.Logger.errors.INSUFFICIENT_FUNDS, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
        logger15.throwError("nonce has already been used", logger_1.Logger.errors.NONCE_EXPIRED, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/another transaction with same nonce/)) {
        logger15.throwError("replacement fee too low", logger_1.Logger.errors.REPLACEMENT_UNDERPRICED, {
          error,
          method,
          transaction
        });
      }
      if (message.match(/execution failed due to an exception|execution reverted/)) {
        logger15.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          error,
          method,
          transaction
        });
      }
      throw error;
    }
    var EtherscanProvider = function(_super) {
      __extends2(EtherscanProvider2, _super);
      function EtherscanProvider2(network, apiKey) {
        var _this = _super.call(this, network) || this;
        (0, properties_1.defineReadOnly)(_this, "baseUrl", _this.getBaseUrl());
        (0, properties_1.defineReadOnly)(_this, "apiKey", apiKey || null);
        return _this;
      }
      EtherscanProvider2.prototype.getBaseUrl = function() {
        switch (this.network ? this.network.name : "invalid") {
          case "homestead":
            return "https://api.etherscan.io";
          case "goerli":
            return "https://api-goerli.etherscan.io";
          case "sepolia":
            return "https://api-sepolia.etherscan.io";
          case "matic":
            return "https://api.polygonscan.com";
          case "maticmum":
            return "https://api-testnet.polygonscan.com";
          case "arbitrum":
            return "https://api.arbiscan.io";
          case "arbitrum-goerli":
            return "https://api-goerli.arbiscan.io";
          case "optimism":
            return "https://api-optimistic.etherscan.io";
          case "optimism-goerli":
            return "https://api-goerli-optimistic.etherscan.io";
          default:
        }
        return logger15.throwArgumentError("unsupported network", "network", this.network.name);
      };
      EtherscanProvider2.prototype.getUrl = function(module2, params) {
        var query = Object.keys(params).reduce(function(accum, key) {
          var value = params[key];
          if (value != null) {
            accum += "&" + key + "=" + value;
          }
          return accum;
        }, "");
        var apiKey = this.apiKey ? "&apikey=" + this.apiKey : "";
        return this.baseUrl + "/api?module=" + module2 + query + apiKey;
      };
      EtherscanProvider2.prototype.getPostUrl = function() {
        return this.baseUrl + "/api";
      };
      EtherscanProvider2.prototype.getPostData = function(module2, params) {
        params.module = module2;
        params.apikey = this.apiKey;
        return params;
      };
      EtherscanProvider2.prototype.fetch = function(module2, params, post) {
        return __awaiter5(this, void 0, void 0, function() {
          var url, payload, procFunc, connection, payloadStr, result;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                url = post ? this.getPostUrl() : this.getUrl(module2, params);
                payload = post ? this.getPostData(module2, params) : null;
                procFunc = module2 === "proxy" ? getJsonResult : getResult2;
                this.emit("debug", {
                  action: "request",
                  request: url,
                  provider: this
                });
                connection = {
                  url,
                  throttleSlotInterval: 1e3,
                  throttleCallback: function(attempt, url2) {
                    if (_this.isCommunityResource()) {
                      (0, formatter_1.showThrottleMessage)();
                    }
                    return Promise.resolve(true);
                  }
                };
                payloadStr = null;
                if (payload) {
                  connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
                  payloadStr = Object.keys(payload).map(function(key) {
                    return key + "=" + payload[key];
                  }).join("&");
                }
                return [4, (0, web_1.fetchJson)(connection, payloadStr, procFunc || getJsonResult)];
              case 1:
                result = _a.sent();
                this.emit("debug", {
                  action: "response",
                  request: url,
                  response: (0, properties_1.deepCopy)(result),
                  provider: this
                });
                return [2, result];
            }
          });
        });
      };
      EtherscanProvider2.prototype.detectNetwork = function() {
        return __awaiter5(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.network];
          });
        });
      };
      EtherscanProvider2.prototype.perform = function(method, params) {
        return __awaiter5(this, void 0, void 0, function() {
          var _a, postData, error_1, postData, error_2, args, topic0, logs, blocks, i, log, block, _b;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                _a = method;
                switch (_a) {
                  case "getBlockNumber":
                    return [3, 1];
                  case "getGasPrice":
                    return [3, 2];
                  case "getBalance":
                    return [3, 3];
                  case "getTransactionCount":
                    return [3, 4];
                  case "getCode":
                    return [3, 5];
                  case "getStorageAt":
                    return [3, 6];
                  case "sendTransaction":
                    return [3, 7];
                  case "getBlock":
                    return [3, 8];
                  case "getTransaction":
                    return [3, 9];
                  case "getTransactionReceipt":
                    return [3, 10];
                  case "call":
                    return [3, 11];
                  case "estimateGas":
                    return [3, 15];
                  case "getLogs":
                    return [3, 19];
                  case "getEtherPrice":
                    return [3, 26];
                }
                return [3, 28];
              case 1:
                return [2, this.fetch("proxy", { action: "eth_blockNumber" })];
              case 2:
                return [2, this.fetch("proxy", { action: "eth_gasPrice" })];
              case 3:
                return [2, this.fetch("account", {
                  action: "balance",
                  address: params.address,
                  tag: params.blockTag
                })];
              case 4:
                return [2, this.fetch("proxy", {
                  action: "eth_getTransactionCount",
                  address: params.address,
                  tag: params.blockTag
                })];
              case 5:
                return [2, this.fetch("proxy", {
                  action: "eth_getCode",
                  address: params.address,
                  tag: params.blockTag
                })];
              case 6:
                return [2, this.fetch("proxy", {
                  action: "eth_getStorageAt",
                  address: params.address,
                  position: params.position,
                  tag: params.blockTag
                })];
              case 7:
                return [2, this.fetch("proxy", {
                  action: "eth_sendRawTransaction",
                  hex: params.signedTransaction
                }, true).catch(function(error) {
                  return checkError("sendTransaction", error, params.signedTransaction);
                })];
              case 8:
                if (params.blockTag) {
                  return [2, this.fetch("proxy", {
                    action: "eth_getBlockByNumber",
                    tag: params.blockTag,
                    boolean: params.includeTransactions ? "true" : "false"
                  })];
                }
                throw new Error("getBlock by blockHash not implemented");
              case 9:
                return [2, this.fetch("proxy", {
                  action: "eth_getTransactionByHash",
                  txhash: params.transactionHash
                })];
              case 10:
                return [2, this.fetch("proxy", {
                  action: "eth_getTransactionReceipt",
                  txhash: params.transactionHash
                })];
              case 11:
                if (params.blockTag !== "latest") {
                  throw new Error("EtherscanProvider does not support blockTag for call");
                }
                postData = getTransactionPostData(params.transaction);
                postData.module = "proxy";
                postData.action = "eth_call";
                _c.label = 12;
              case 12:
                _c.trys.push([12, 14, , 15]);
                return [4, this.fetch("proxy", postData, true)];
              case 13:
                return [2, _c.sent()];
              case 14:
                error_1 = _c.sent();
                return [2, checkError("call", error_1, params.transaction)];
              case 15:
                postData = getTransactionPostData(params.transaction);
                postData.module = "proxy";
                postData.action = "eth_estimateGas";
                _c.label = 16;
              case 16:
                _c.trys.push([16, 18, , 19]);
                return [4, this.fetch("proxy", postData, true)];
              case 17:
                return [2, _c.sent()];
              case 18:
                error_2 = _c.sent();
                return [2, checkError("estimateGas", error_2, params.transaction)];
              case 19:
                args = { action: "getLogs" };
                if (params.filter.fromBlock) {
                  args.fromBlock = checkLogTag(params.filter.fromBlock);
                }
                if (params.filter.toBlock) {
                  args.toBlock = checkLogTag(params.filter.toBlock);
                }
                if (params.filter.address) {
                  args.address = params.filter.address;
                }
                if (params.filter.topics && params.filter.topics.length > 0) {
                  if (params.filter.topics.length > 1) {
                    logger15.throwError("unsupported topic count", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                  }
                  if (params.filter.topics.length === 1) {
                    topic0 = params.filter.topics[0];
                    if (typeof topic0 !== "string" || topic0.length !== 66) {
                      logger15.throwError("unsupported topic format", logger_1.Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
                    }
                    args.topic0 = topic0;
                  }
                }
                return [4, this.fetch("logs", args)];
              case 20:
                logs = _c.sent();
                blocks = {};
                i = 0;
                _c.label = 21;
              case 21:
                if (!(i < logs.length))
                  return [3, 25];
                log = logs[i];
                if (log.blockHash != null) {
                  return [3, 24];
                }
                if (!(blocks[log.blockNumber] == null))
                  return [3, 23];
                return [4, this.getBlock(log.blockNumber)];
              case 22:
                block = _c.sent();
                if (block) {
                  blocks[log.blockNumber] = block.hash;
                }
                _c.label = 23;
              case 23:
                log.blockHash = blocks[log.blockNumber];
                _c.label = 24;
              case 24:
                i++;
                return [3, 21];
              case 25:
                return [2, logs];
              case 26:
                if (this.network.name !== "homestead") {
                  return [2, 0];
                }
                _b = parseFloat;
                return [4, this.fetch("stats", { action: "ethprice" })];
              case 27:
                return [2, _b.apply(void 0, [_c.sent().ethusd])];
              case 28:
                return [3, 29];
              case 29:
                return [2, _super.prototype.perform.call(this, method, params)];
            }
          });
        });
      };
      EtherscanProvider2.prototype.getHistory = function(addressOrName, startBlock, endBlock) {
        return __awaiter5(this, void 0, void 0, function() {
          var params, result;
          var _a;
          var _this = this;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _a = {
                  action: "txlist"
                };
                return [4, this.resolveName(addressOrName)];
              case 1:
                params = (_a.address = _b.sent(), _a.startblock = startBlock == null ? 0 : startBlock, _a.endblock = endBlock == null ? 99999999 : endBlock, _a.sort = "asc", _a);
                return [4, this.fetch("account", params)];
              case 2:
                result = _b.sent();
                return [2, result.map(function(tx) {
                  ["contractAddress", "to"].forEach(function(key) {
                    if (tx[key] == "") {
                      delete tx[key];
                    }
                  });
                  if (tx.creates == null && tx.contractAddress != null) {
                    tx.creates = tx.contractAddress;
                  }
                  var item = _this.formatter.transactionResponse(tx);
                  if (tx.timeStamp) {
                    item.timestamp = parseInt(tx.timeStamp);
                  }
                  return item;
                })];
            }
          });
        });
      };
      EtherscanProvider2.prototype.isCommunityResource = function() {
        return this.apiKey == null;
      };
      return EtherscanProvider2;
    }(base_provider_1.BaseProvider);
    exports.EtherscanProvider = EtherscanProvider;
  }
});

// ../node_modules/@ethersproject/random/lib/_version.js
var require_version17 = __commonJS({
  "../node_modules/@ethersproject/random/lib/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "random/5.7.0";
  }
});

// ../node_modules/@ethersproject/random/lib/browser-random.js
var require_browser_random = __commonJS({
  "../node_modules/@ethersproject/random/lib/browser-random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = void 0;
    var bytes_1 = require_lib2();
    var logger_1 = require_lib();
    var _version_1 = require_version17();
    var logger15 = new logger_1.Logger(_version_1.version);
    function getGlobal() {
      if (typeof window.self !== "undefined") {
        return window.self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    }
    var anyGlobal = getGlobal();
    var crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;
    if (!crypto2 || !crypto2.getRandomValues) {
      logger15.warn("WARNING: Missing strong random number source");
      crypto2 = {
        getRandomValues: function(buffer2) {
          return logger15.throwError("no secure random source avaialble", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "crypto.getRandomValues"
          });
        }
      };
    }
    function randomBytes4(length) {
      if (length <= 0 || length > 1024 || length % 1 || length != length) {
        logger15.throwArgumentError("invalid length", "length", length);
      }
      var result = new Uint8Array(length);
      crypto2.getRandomValues(result);
      return (0, bytes_1.arrayify)(result);
    }
    exports.randomBytes = randomBytes4;
  }
});

// ../node_modules/@ethersproject/random/lib/shuffle.js
var require_shuffle = __commonJS({
  "../node_modules/@ethersproject/random/lib/shuffle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shuffled = void 0;
    function shuffled(array) {
      array = array.slice();
      for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
      }
      return array;
    }
    exports.shuffled = shuffled;
  }
});

// ../node_modules/@ethersproject/random/lib/index.js
var require_lib21 = __commonJS({
  "../node_modules/@ethersproject/random/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shuffled = exports.randomBytes = void 0;
    var random_1 = require_browser_random();
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    var shuffle_1 = require_shuffle();
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return shuffle_1.shuffled;
    } });
  }
});

// ../node_modules/@ethersproject/providers/lib/fallback-provider.js
var require_fallback_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/fallback-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FallbackProvider = void 0;
    var abstract_provider_1 = require_lib5();
    var bignumber_1 = require_lib3();
    var bytes_1 = require_lib2();
    var properties_1 = require_lib4();
    var random_1 = require_lib21();
    var web_1 = require_lib17();
    var base_provider_1 = require_base_provider();
    var formatter_1 = require_formatter();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    function now() {
      return new Date().getTime();
    }
    function checkNetworks(networks) {
      var result = null;
      for (var i = 0; i < networks.length; i++) {
        var network = networks[i];
        if (network == null) {
          return null;
        }
        if (result) {
          if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
            logger15.throwArgumentError("provider mismatch", "networks", networks);
          }
        } else {
          result = network;
        }
      }
      return result;
    }
    function median(values, maxDelta) {
      values = values.slice().sort();
      var middle = Math.floor(values.length / 2);
      if (values.length % 2) {
        return values[middle];
      }
      var a = values[middle - 1], b = values[middle];
      if (maxDelta != null && Math.abs(a - b) > maxDelta) {
        return null;
      }
      return (a + b) / 2;
    }
    function serialize2(value) {
      if (value === null) {
        return "null";
      } else if (typeof value === "number" || typeof value === "boolean") {
        return JSON.stringify(value);
      } else if (typeof value === "string") {
        return value;
      } else if (bignumber_1.BigNumber.isBigNumber(value)) {
        return value.toString();
      } else if (Array.isArray(value)) {
        return JSON.stringify(value.map(function(i) {
          return serialize2(i);
        }));
      } else if (typeof value === "object") {
        var keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map(function(key) {
          var v = value[key];
          if (typeof v === "function") {
            v = "[function]";
          } else {
            v = serialize2(v);
          }
          return JSON.stringify(key) + ":" + v;
        }).join(",") + "}";
      }
      throw new Error("unknown value type: " + typeof value);
    }
    var nextRid = 1;
    function stall(duration) {
      var cancel = null;
      var timer = null;
      var promise = new Promise(function(resolve) {
        cancel = function() {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          resolve();
        };
        timer = setTimeout(cancel, duration);
      });
      var wait2 = function(func) {
        promise = promise.then(func);
        return promise;
      };
      function getPromise() {
        return promise;
      }
      return { cancel, getPromise, wait: wait2 };
    }
    var ForwardErrors = [
      logger_1.Logger.errors.CALL_EXCEPTION,
      logger_1.Logger.errors.INSUFFICIENT_FUNDS,
      logger_1.Logger.errors.NONCE_EXPIRED,
      logger_1.Logger.errors.REPLACEMENT_UNDERPRICED,
      logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT
    ];
    var ForwardProperties = [
      "address",
      "args",
      "errorArgs",
      "errorSignature",
      "method",
      "transaction"
    ];
    function exposeDebugConfig(config2, now2) {
      var result = {
        weight: config2.weight
      };
      Object.defineProperty(result, "provider", { get: function() {
        return config2.provider;
      } });
      if (config2.start) {
        result.start = config2.start;
      }
      if (now2) {
        result.duration = now2 - config2.start;
      }
      if (config2.done) {
        if (config2.error) {
          result.error = config2.error;
        } else {
          result.result = config2.result || null;
        }
      }
      return result;
    }
    function normalizedTally(normalize, quorum) {
      return function(configs) {
        var tally = {};
        configs.forEach(function(c) {
          var value = normalize(c.result);
          if (!tally[value]) {
            tally[value] = { count: 0, result: c.result };
          }
          tally[value].count++;
        });
        var keys = Object.keys(tally);
        for (var i = 0; i < keys.length; i++) {
          var check = tally[keys[i]];
          if (check.count >= quorum) {
            return check.result;
          }
        }
        return void 0;
      };
    }
    function getProcessFunc(provider, method, params) {
      var normalize = serialize2;
      switch (method) {
        case "getBlockNumber":
          return function(configs) {
            var values = configs.map(function(c) {
              return c.result;
            });
            var blockNumber = median(configs.map(function(c) {
              return c.result;
            }), 2);
            if (blockNumber == null) {
              return void 0;
            }
            blockNumber = Math.ceil(blockNumber);
            if (values.indexOf(blockNumber + 1) >= 0) {
              blockNumber++;
            }
            if (blockNumber >= provider._highestBlockNumber) {
              provider._highestBlockNumber = blockNumber;
            }
            return provider._highestBlockNumber;
          };
        case "getGasPrice":
          return function(configs) {
            var values = configs.map(function(c) {
              return c.result;
            });
            values.sort();
            return values[Math.floor(values.length / 2)];
          };
        case "getEtherPrice":
          return function(configs) {
            return median(configs.map(function(c) {
              return c.result;
            }));
          };
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorageAt":
        case "call":
        case "estimateGas":
        case "getLogs":
          break;
        case "getTransaction":
        case "getTransactionReceipt":
          normalize = function(tx) {
            if (tx == null) {
              return null;
            }
            tx = (0, properties_1.shallowCopy)(tx);
            tx.confirmations = -1;
            return serialize2(tx);
          };
          break;
        case "getBlock":
          if (params.includeTransactions) {
            normalize = function(block) {
              if (block == null) {
                return null;
              }
              block = (0, properties_1.shallowCopy)(block);
              block.transactions = block.transactions.map(function(tx) {
                tx = (0, properties_1.shallowCopy)(tx);
                tx.confirmations = -1;
                return tx;
              });
              return serialize2(block);
            };
          } else {
            normalize = function(block) {
              if (block == null) {
                return null;
              }
              return serialize2(block);
            };
          }
          break;
        default:
          throw new Error("unknown method: " + method);
      }
      return normalizedTally(normalize, provider.quorum);
    }
    function waitForSync(config2, blockNumber) {
      return __awaiter5(this, void 0, void 0, function() {
        var provider;
        return __generator(this, function(_a) {
          provider = config2.provider;
          if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
            return [2, provider];
          }
          return [2, (0, web_1.poll)(function() {
            return new Promise(function(resolve, reject) {
              setTimeout(function() {
                if (provider.blockNumber >= blockNumber) {
                  return resolve(provider);
                }
                if (config2.cancelled) {
                  return resolve(null);
                }
                return resolve(void 0);
              }, 0);
            });
          }, { oncePoll: provider })];
        });
      });
    }
    function getRunner(config2, currentBlockNumber, method, params) {
      return __awaiter5(this, void 0, void 0, function() {
        var provider, _a, filter;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              provider = config2.provider;
              _a = method;
              switch (_a) {
                case "getBlockNumber":
                  return [3, 1];
                case "getGasPrice":
                  return [3, 1];
                case "getEtherPrice":
                  return [3, 2];
                case "getBalance":
                  return [3, 3];
                case "getTransactionCount":
                  return [3, 3];
                case "getCode":
                  return [3, 3];
                case "getStorageAt":
                  return [3, 6];
                case "getBlock":
                  return [3, 9];
                case "call":
                  return [3, 12];
                case "estimateGas":
                  return [3, 12];
                case "getTransaction":
                  return [3, 15];
                case "getTransactionReceipt":
                  return [3, 15];
                case "getLogs":
                  return [3, 16];
              }
              return [3, 19];
            case 1:
              return [2, provider[method]()];
            case 2:
              if (provider.getEtherPrice) {
                return [2, provider.getEtherPrice()];
              }
              return [3, 19];
            case 3:
              if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag)))
                return [3, 5];
              return [4, waitForSync(config2, currentBlockNumber)];
            case 4:
              provider = _b.sent();
              _b.label = 5;
            case 5:
              return [2, provider[method](params.address, params.blockTag || "latest")];
            case 6:
              if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag)))
                return [3, 8];
              return [4, waitForSync(config2, currentBlockNumber)];
            case 7:
              provider = _b.sent();
              _b.label = 8;
            case 8:
              return [2, provider.getStorageAt(params.address, params.position, params.blockTag || "latest")];
            case 9:
              if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag)))
                return [3, 11];
              return [4, waitForSync(config2, currentBlockNumber)];
            case 10:
              provider = _b.sent();
              _b.label = 11;
            case 11:
              return [2, provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash)];
            case 12:
              if (!(params.blockTag && (0, bytes_1.isHexString)(params.blockTag)))
                return [3, 14];
              return [4, waitForSync(config2, currentBlockNumber)];
            case 13:
              provider = _b.sent();
              _b.label = 14;
            case 14:
              if (method === "call" && params.blockTag) {
                return [2, provider[method](params.transaction, params.blockTag)];
              }
              return [2, provider[method](params.transaction)];
            case 15:
              return [2, provider[method](params.transactionHash)];
            case 16:
              filter = params.filter;
              if (!(filter.fromBlock && (0, bytes_1.isHexString)(filter.fromBlock) || filter.toBlock && (0, bytes_1.isHexString)(filter.toBlock)))
                return [3, 18];
              return [4, waitForSync(config2, currentBlockNumber)];
            case 17:
              provider = _b.sent();
              _b.label = 18;
            case 18:
              return [2, provider.getLogs(filter)];
            case 19:
              return [2, logger15.throwError("unknown method error", logger_1.Logger.errors.UNKNOWN_ERROR, {
                method,
                params
              })];
          }
        });
      });
    }
    var FallbackProvider = function(_super) {
      __extends2(FallbackProvider2, _super);
      function FallbackProvider2(providers, quorum) {
        var _this = this;
        if (providers.length === 0) {
          logger15.throwArgumentError("missing providers", "providers", providers);
        }
        var providerConfigs = providers.map(function(configOrProvider, index2) {
          if (abstract_provider_1.Provider.isProvider(configOrProvider)) {
            var stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2e3 : 750;
            var priority = 1;
            return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
          }
          var config2 = (0, properties_1.shallowCopy)(configOrProvider);
          if (config2.priority == null) {
            config2.priority = 1;
          }
          if (config2.stallTimeout == null) {
            config2.stallTimeout = (0, formatter_1.isCommunityResource)(configOrProvider) ? 2e3 : 750;
          }
          if (config2.weight == null) {
            config2.weight = 1;
          }
          var weight = config2.weight;
          if (weight % 1 || weight > 512 || weight < 1) {
            logger15.throwArgumentError("invalid weight; must be integer in [1, 512]", "providers[" + index2 + "].weight", weight);
          }
          return Object.freeze(config2);
        });
        var total = providerConfigs.reduce(function(accum, c) {
          return accum + c.weight;
        }, 0);
        if (quorum == null) {
          quorum = total / 2;
        } else if (quorum > total) {
          logger15.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
        }
        var networkOrReady = checkNetworks(providerConfigs.map(function(c) {
          return c.provider.network;
        }));
        if (networkOrReady == null) {
          networkOrReady = new Promise(function(resolve, reject) {
            setTimeout(function() {
              _this.detectNetwork().then(resolve, reject);
            }, 0);
          });
        }
        _this = _super.call(this, networkOrReady) || this;
        (0, properties_1.defineReadOnly)(_this, "providerConfigs", Object.freeze(providerConfigs));
        (0, properties_1.defineReadOnly)(_this, "quorum", quorum);
        _this._highestBlockNumber = -1;
        return _this;
      }
      FallbackProvider2.prototype.detectNetwork = function() {
        return __awaiter5(this, void 0, void 0, function() {
          var networks;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, Promise.all(this.providerConfigs.map(function(c) {
                  return c.provider.getNetwork();
                }))];
              case 1:
                networks = _a.sent();
                return [2, checkNetworks(networks)];
            }
          });
        });
      };
      FallbackProvider2.prototype.perform = function(method, params) {
        return __awaiter5(this, void 0, void 0, function() {
          var results, i_1, result, processFunc, configs, currentBlockNumber, i, first, _loop_1, this_1, state_1;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!(method === "sendTransaction"))
                  return [3, 2];
                return [4, Promise.all(this.providerConfigs.map(function(c) {
                  return c.provider.sendTransaction(params.signedTransaction).then(function(result2) {
                    return result2.hash;
                  }, function(error) {
                    return error;
                  });
                }))];
              case 1:
                results = _a.sent();
                for (i_1 = 0; i_1 < results.length; i_1++) {
                  result = results[i_1];
                  if (typeof result === "string") {
                    return [2, result];
                  }
                }
                throw results[0];
              case 2:
                if (!(this._highestBlockNumber === -1 && method !== "getBlockNumber"))
                  return [3, 4];
                return [4, this.getBlockNumber()];
              case 3:
                _a.sent();
                _a.label = 4;
              case 4:
                processFunc = getProcessFunc(this, method, params);
                configs = (0, random_1.shuffled)(this.providerConfigs.map(properties_1.shallowCopy));
                configs.sort(function(a, b) {
                  return a.priority - b.priority;
                });
                currentBlockNumber = this._highestBlockNumber;
                i = 0;
                first = true;
                _loop_1 = function() {
                  var t0, inflightWeight, _loop_2, waiting, results2, result2, errors;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        t0 = now();
                        inflightWeight = configs.filter(function(c) {
                          return c.runner && t0 - c.start < c.stallTimeout;
                        }).reduce(function(accum, c) {
                          return accum + c.weight;
                        }, 0);
                        _loop_2 = function() {
                          var config2 = configs[i++];
                          var rid = nextRid++;
                          config2.start = now();
                          config2.staller = stall(config2.stallTimeout);
                          config2.staller.wait(function() {
                            config2.staller = null;
                          });
                          config2.runner = getRunner(config2, currentBlockNumber, method, params).then(function(result3) {
                            config2.done = true;
                            config2.result = result3;
                            if (_this.listenerCount("debug")) {
                              _this.emit("debug", {
                                action: "request",
                                rid,
                                backend: exposeDebugConfig(config2, now()),
                                request: { method, params: (0, properties_1.deepCopy)(params) },
                                provider: _this
                              });
                            }
                          }, function(error) {
                            config2.done = true;
                            config2.error = error;
                            if (_this.listenerCount("debug")) {
                              _this.emit("debug", {
                                action: "request",
                                rid,
                                backend: exposeDebugConfig(config2, now()),
                                request: { method, params: (0, properties_1.deepCopy)(params) },
                                provider: _this
                              });
                            }
                          });
                          if (this_1.listenerCount("debug")) {
                            this_1.emit("debug", {
                              action: "request",
                              rid,
                              backend: exposeDebugConfig(config2, null),
                              request: { method, params: (0, properties_1.deepCopy)(params) },
                              provider: this_1
                            });
                          }
                          inflightWeight += config2.weight;
                        };
                        while (inflightWeight < this_1.quorum && i < configs.length) {
                          _loop_2();
                        }
                        waiting = [];
                        configs.forEach(function(c) {
                          if (c.done || !c.runner) {
                            return;
                          }
                          waiting.push(c.runner);
                          if (c.staller) {
                            waiting.push(c.staller.getPromise());
                          }
                        });
                        if (!waiting.length)
                          return [3, 2];
                        return [4, Promise.race(waiting)];
                      case 1:
                        _b.sent();
                        _b.label = 2;
                      case 2:
                        results2 = configs.filter(function(c) {
                          return c.done && c.error == null;
                        });
                        if (!(results2.length >= this_1.quorum))
                          return [3, 5];
                        result2 = processFunc(results2);
                        if (result2 !== void 0) {
                          configs.forEach(function(c) {
                            if (c.staller) {
                              c.staller.cancel();
                            }
                            c.cancelled = true;
                          });
                          return [2, { value: result2 }];
                        }
                        if (!!first)
                          return [3, 4];
                        return [4, stall(100).getPromise()];
                      case 3:
                        _b.sent();
                        _b.label = 4;
                      case 4:
                        first = false;
                        _b.label = 5;
                      case 5:
                        errors = configs.reduce(function(accum, c) {
                          if (!c.done || c.error == null) {
                            return accum;
                          }
                          var code = c.error.code;
                          if (ForwardErrors.indexOf(code) >= 0) {
                            if (!accum[code]) {
                              accum[code] = { error: c.error, weight: 0 };
                            }
                            accum[code].weight += c.weight;
                          }
                          return accum;
                        }, {});
                        Object.keys(errors).forEach(function(errorCode) {
                          var tally = errors[errorCode];
                          if (tally.weight < _this.quorum) {
                            return;
                          }
                          configs.forEach(function(c) {
                            if (c.staller) {
                              c.staller.cancel();
                            }
                            c.cancelled = true;
                          });
                          var e = tally.error;
                          var props = {};
                          ForwardProperties.forEach(function(name) {
                            if (e[name] == null) {
                              return;
                            }
                            props[name] = e[name];
                          });
                          logger15.throwError(e.reason || e.message, errorCode, props);
                        });
                        if (configs.filter(function(c) {
                          return !c.done;
                        }).length === 0) {
                          return [2, "break"];
                        }
                        return [2];
                    }
                  });
                };
                this_1 = this;
                _a.label = 5;
              case 5:
                if (false)
                  return [3, 7];
                return [5, _loop_1()];
              case 6:
                state_1 = _a.sent();
                if (typeof state_1 === "object")
                  return [2, state_1.value];
                if (state_1 === "break")
                  return [3, 7];
                return [3, 5];
              case 7:
                configs.forEach(function(c) {
                  if (c.staller) {
                    c.staller.cancel();
                  }
                  c.cancelled = true;
                });
                return [2, logger15.throwError("failed to meet quorum", logger_1.Logger.errors.SERVER_ERROR, {
                  method,
                  params,
                  results: configs.map(function(c) {
                    return exposeDebugConfig(c);
                  }),
                  provider: this
                })];
            }
          });
        });
      };
      return FallbackProvider2;
    }(base_provider_1.BaseProvider);
    exports.FallbackProvider = FallbackProvider;
  }
});

// ../node_modules/@ethersproject/providers/lib/browser-ipc-provider.js
var require_browser_ipc_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/browser-ipc-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IpcProvider = void 0;
    var IpcProvider = null;
    exports.IpcProvider = IpcProvider;
  }
});

// ../node_modules/@ethersproject/providers/lib/infura-provider.js
var require_infura_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/infura-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;
    var properties_1 = require_lib4();
    var websocket_provider_1 = require_websocket_provider();
    var formatter_1 = require_formatter();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var defaultProjectId = "84842078b09946638c03157f83405213";
    var InfuraWebSocketProvider = function(_super) {
      __extends2(InfuraWebSocketProvider2, _super);
      function InfuraWebSocketProvider2(network, apiKey) {
        var _this = this;
        var provider = new InfuraProvider(network, apiKey);
        var connection = provider.connection;
        if (connection.password) {
          logger15.throwError("INFURA WebSocket project secrets unsupported", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "InfuraProvider.getWebSocketProvider()"
          });
        }
        var url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        _this = _super.call(this, url, network) || this;
        (0, properties_1.defineReadOnly)(_this, "apiKey", provider.projectId);
        (0, properties_1.defineReadOnly)(_this, "projectId", provider.projectId);
        (0, properties_1.defineReadOnly)(_this, "projectSecret", provider.projectSecret);
        return _this;
      }
      InfuraWebSocketProvider2.prototype.isCommunityResource = function() {
        return this.projectId === defaultProjectId;
      };
      return InfuraWebSocketProvider2;
    }(websocket_provider_1.WebSocketProvider);
    exports.InfuraWebSocketProvider = InfuraWebSocketProvider;
    var InfuraProvider = function(_super) {
      __extends2(InfuraProvider2, _super);
      function InfuraProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      InfuraProvider2.getWebSocketProvider = function(network, apiKey) {
        return new InfuraWebSocketProvider(network, apiKey);
      };
      InfuraProvider2.getApiKey = function(apiKey) {
        var apiKeyObj = {
          apiKey: defaultProjectId,
          projectId: defaultProjectId,
          projectSecret: null
        };
        if (apiKey == null) {
          return apiKeyObj;
        }
        if (typeof apiKey === "string") {
          apiKeyObj.projectId = apiKey;
        } else if (apiKey.projectSecret != null) {
          logger15.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
          logger15.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
          apiKeyObj.projectId = apiKey.projectId;
          apiKeyObj.projectSecret = apiKey.projectSecret;
        } else if (apiKey.projectId) {
          apiKeyObj.projectId = apiKey.projectId;
        }
        apiKeyObj.apiKey = apiKeyObj.projectId;
        return apiKeyObj;
      };
      InfuraProvider2.getUrl = function(network, apiKey) {
        var host = null;
        switch (network ? network.name : "unknown") {
          case "homestead":
            host = "mainnet.infura.io";
            break;
          case "goerli":
            host = "goerli.infura.io";
            break;
          case "sepolia":
            host = "sepolia.infura.io";
            break;
          case "matic":
            host = "polygon-mainnet.infura.io";
            break;
          case "maticmum":
            host = "polygon-mumbai.infura.io";
            break;
          case "optimism":
            host = "optimism-mainnet.infura.io";
            break;
          case "optimism-goerli":
            host = "optimism-goerli.infura.io";
            break;
          case "arbitrum":
            host = "arbitrum-mainnet.infura.io";
            break;
          case "arbitrum-goerli":
            host = "arbitrum-goerli.infura.io";
            break;
          default:
            logger15.throwError("unsupported network", logger_1.Logger.errors.INVALID_ARGUMENT, {
              argument: "network",
              value: network
            });
        }
        var connection = {
          allowGzip: true,
          url: "https://" + host + "/v3/" + apiKey.projectId,
          throttleCallback: function(attempt, url) {
            if (apiKey.projectId === defaultProjectId) {
              (0, formatter_1.showThrottleMessage)();
            }
            return Promise.resolve(true);
          }
        };
        if (apiKey.projectSecret != null) {
          connection.user = "";
          connection.password = apiKey.projectSecret;
        }
        return connection;
      };
      InfuraProvider2.prototype.isCommunityResource = function() {
        return this.projectId === defaultProjectId;
      };
      return InfuraProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.InfuraProvider = InfuraProvider;
  }
});

// ../node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js
var require_json_rpc_batch_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/json-rpc-batch-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcBatchProvider = void 0;
    var properties_1 = require_lib4();
    var web_1 = require_lib17();
    var json_rpc_provider_1 = require_json_rpc_provider();
    var JsonRpcBatchProvider = function(_super) {
      __extends2(JsonRpcBatchProvider2, _super);
      function JsonRpcBatchProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      JsonRpcBatchProvider2.prototype.send = function(method, params) {
        var _this = this;
        var request = {
          method,
          params,
          id: this._nextId++,
          jsonrpc: "2.0"
        };
        if (this._pendingBatch == null) {
          this._pendingBatch = [];
        }
        var inflightRequest = { request, resolve: null, reject: null };
        var promise = new Promise(function(resolve, reject) {
          inflightRequest.resolve = resolve;
          inflightRequest.reject = reject;
        });
        this._pendingBatch.push(inflightRequest);
        if (!this._pendingBatchAggregator) {
          this._pendingBatchAggregator = setTimeout(function() {
            var batch = _this._pendingBatch;
            _this._pendingBatch = null;
            _this._pendingBatchAggregator = null;
            var request2 = batch.map(function(inflight) {
              return inflight.request;
            });
            _this.emit("debug", {
              action: "requestBatch",
              request: (0, properties_1.deepCopy)(request2),
              provider: _this
            });
            return (0, web_1.fetchJson)(_this.connection, JSON.stringify(request2)).then(function(result) {
              _this.emit("debug", {
                action: "response",
                request: request2,
                response: result,
                provider: _this
              });
              batch.forEach(function(inflightRequest2, index2) {
                var payload = result[index2];
                if (payload.error) {
                  var error = new Error(payload.error.message);
                  error.code = payload.error.code;
                  error.data = payload.error.data;
                  inflightRequest2.reject(error);
                } else {
                  inflightRequest2.resolve(payload.result);
                }
              });
            }, function(error) {
              _this.emit("debug", {
                action: "response",
                error,
                request: request2,
                provider: _this
              });
              batch.forEach(function(inflightRequest2) {
                inflightRequest2.reject(error);
              });
            });
          }, 10);
        }
        return promise;
      };
      return JsonRpcBatchProvider2;
    }(json_rpc_provider_1.JsonRpcProvider);
    exports.JsonRpcBatchProvider = JsonRpcBatchProvider;
  }
});

// ../node_modules/@ethersproject/providers/lib/nodesmith-provider.js
var require_nodesmith_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/nodesmith-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodesmithProvider = void 0;
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var defaultApiKey = "ETHERS_JS_SHARED";
    var NodesmithProvider = function(_super) {
      __extends2(NodesmithProvider2, _super);
      function NodesmithProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NodesmithProvider2.getApiKey = function(apiKey) {
        if (apiKey && typeof apiKey !== "string") {
          logger15.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey || defaultApiKey;
      };
      NodesmithProvider2.getUrl = function(network, apiKey) {
        logger15.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        var host = null;
        switch (network.name) {
          case "homestead":
            host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
            break;
          case "ropsten":
            host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
            break;
          case "rinkeby":
            host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
            break;
          case "goerli":
            host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
            break;
          case "kovan":
            host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
            break;
          default:
            logger15.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host + "?apiKey=" + apiKey;
      };
      return NodesmithProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.NodesmithProvider = NodesmithProvider;
  }
});

// ../node_modules/@ethersproject/providers/lib/pocket-provider.js
var require_pocket_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/pocket-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PocketProvider = void 0;
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
    var PocketProvider = function(_super) {
      __extends2(PocketProvider2, _super);
      function PocketProvider2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PocketProvider2.getApiKey = function(apiKey) {
        var apiKeyObj = {
          applicationId: null,
          loadBalancer: true,
          applicationSecretKey: null
        };
        if (apiKey == null) {
          apiKeyObj.applicationId = defaultApplicationId;
        } else if (typeof apiKey === "string") {
          apiKeyObj.applicationId = apiKey;
        } else if (apiKey.applicationSecretKey != null) {
          apiKeyObj.applicationId = apiKey.applicationId;
          apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
        } else if (apiKey.applicationId) {
          apiKeyObj.applicationId = apiKey.applicationId;
        } else {
          logger15.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
        }
        return apiKeyObj;
      };
      PocketProvider2.getUrl = function(network, apiKey) {
        var host = null;
        switch (network ? network.name : "unknown") {
          case "goerli":
            host = "eth-goerli.gateway.pokt.network";
            break;
          case "homestead":
            host = "eth-mainnet.gateway.pokt.network";
            break;
          case "kovan":
            host = "poa-kovan.gateway.pokt.network";
            break;
          case "matic":
            host = "poly-mainnet.gateway.pokt.network";
            break;
          case "maticmum":
            host = "polygon-mumbai-rpc.gateway.pokt.network";
            break;
          case "rinkeby":
            host = "eth-rinkeby.gateway.pokt.network";
            break;
          case "ropsten":
            host = "eth-ropsten.gateway.pokt.network";
            break;
          default:
            logger15.throwError("unsupported network", logger_1.Logger.errors.INVALID_ARGUMENT, {
              argument: "network",
              value: network
            });
        }
        var url = "https://" + host + "/v1/lb/" + apiKey.applicationId;
        var connection = { headers: {}, url };
        if (apiKey.applicationSecretKey != null) {
          connection.user = "";
          connection.password = apiKey.applicationSecretKey;
        }
        return connection;
      };
      PocketProvider2.prototype.isCommunityResource = function() {
        return this.applicationId === defaultApplicationId;
      };
      return PocketProvider2;
    }(url_json_rpc_provider_1.UrlJsonRpcProvider);
    exports.PocketProvider = PocketProvider;
  }
});

// ../node_modules/@ethersproject/providers/lib/web3-provider.js
var require_web3_provider = __commonJS({
  "../node_modules/@ethersproject/providers/lib/web3-provider.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics2(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Provider = void 0;
    var properties_1 = require_lib4();
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    var json_rpc_provider_1 = require_json_rpc_provider();
    var _nextId = 1;
    function buildWeb3LegacyFetcher(provider, sendFunc) {
      var fetcher = "Web3LegacyFetcher";
      return function(method, params) {
        var _this = this;
        var request = {
          method,
          params,
          id: _nextId++,
          jsonrpc: "2.0"
        };
        return new Promise(function(resolve, reject) {
          _this.emit("debug", {
            action: "request",
            fetcher,
            request: (0, properties_1.deepCopy)(request),
            provider: _this
          });
          sendFunc(request, function(error, response) {
            if (error) {
              _this.emit("debug", {
                action: "response",
                fetcher,
                error,
                request,
                provider: _this
              });
              return reject(error);
            }
            _this.emit("debug", {
              action: "response",
              fetcher,
              request,
              response,
              provider: _this
            });
            if (response.error) {
              var error_1 = new Error(response.error.message);
              error_1.code = response.error.code;
              error_1.data = response.error.data;
              return reject(error_1);
            }
            resolve(response.result);
          });
        });
      };
    }
    function buildEip1193Fetcher(provider) {
      return function(method, params) {
        var _this = this;
        if (params == null) {
          params = [];
        }
        var request = { method, params };
        this.emit("debug", {
          action: "request",
          fetcher: "Eip1193Fetcher",
          request: (0, properties_1.deepCopy)(request),
          provider: this
        });
        return provider.request(request).then(function(response) {
          _this.emit("debug", {
            action: "response",
            fetcher: "Eip1193Fetcher",
            request,
            response,
            provider: _this
          });
          return response;
        }, function(error) {
          _this.emit("debug", {
            action: "response",
            fetcher: "Eip1193Fetcher",
            request,
            error,
            provider: _this
          });
          throw error;
        });
      };
    }
    var Web3Provider = function(_super) {
      __extends2(Web3Provider2, _super);
      function Web3Provider2(provider, network) {
        var _this = this;
        if (provider == null) {
          logger15.throwArgumentError("missing provider", "provider", provider);
        }
        var path = null;
        var jsonRpcFetchFunc = null;
        var subprovider = null;
        if (typeof provider === "function") {
          path = "unknown:";
          jsonRpcFetchFunc = provider;
        } else {
          path = provider.host || provider.path || "";
          if (!path && provider.isMetaMask) {
            path = "metamask";
          }
          subprovider = provider;
          if (provider.request) {
            if (path === "") {
              path = "eip-1193:";
            }
            jsonRpcFetchFunc = buildEip1193Fetcher(provider);
          } else if (provider.sendAsync) {
            jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
          } else if (provider.send) {
            jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
          } else {
            logger15.throwArgumentError("unsupported provider", "provider", provider);
          }
          if (!path) {
            path = "unknown:";
          }
        }
        _this = _super.call(this, path, network) || this;
        (0, properties_1.defineReadOnly)(_this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
        (0, properties_1.defineReadOnly)(_this, "provider", subprovider);
        return _this;
      }
      Web3Provider2.prototype.send = function(method, params) {
        return this.jsonRpcFetchFunc(method, params);
      };
      return Web3Provider2;
    }(json_rpc_provider_1.JsonRpcProvider);
    exports.Web3Provider = Web3Provider;
  }
});

// ../node_modules/@ethersproject/providers/lib/index.js
var require_lib22 = __commonJS({
  "../node_modules/@ethersproject/providers/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Formatter = exports.showThrottleMessage = exports.isCommunityResourcable = exports.isCommunityResource = exports.getNetwork = exports.getDefaultProvider = exports.JsonRpcSigner = exports.IpcProvider = exports.WebSocketProvider = exports.Web3Provider = exports.StaticJsonRpcProvider = exports.PocketProvider = exports.NodesmithProvider = exports.JsonRpcBatchProvider = exports.JsonRpcProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyWebSocketProvider = exports.AlchemyProvider = exports.FallbackProvider = exports.UrlJsonRpcProvider = exports.Resolver = exports.BaseProvider = exports.Provider = void 0;
    var abstract_provider_1 = require_lib5();
    Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
      return abstract_provider_1.Provider;
    } });
    var networks_1 = require_lib6();
    Object.defineProperty(exports, "getNetwork", { enumerable: true, get: function() {
      return networks_1.getNetwork;
    } });
    var base_provider_1 = require_base_provider();
    Object.defineProperty(exports, "BaseProvider", { enumerable: true, get: function() {
      return base_provider_1.BaseProvider;
    } });
    Object.defineProperty(exports, "Resolver", { enumerable: true, get: function() {
      return base_provider_1.Resolver;
    } });
    var alchemy_provider_1 = require_alchemy_provider();
    Object.defineProperty(exports, "AlchemyProvider", { enumerable: true, get: function() {
      return alchemy_provider_1.AlchemyProvider;
    } });
    Object.defineProperty(exports, "AlchemyWebSocketProvider", { enumerable: true, get: function() {
      return alchemy_provider_1.AlchemyWebSocketProvider;
    } });
    var ankr_provider_1 = require_ankr_provider();
    Object.defineProperty(exports, "AnkrProvider", { enumerable: true, get: function() {
      return ankr_provider_1.AnkrProvider;
    } });
    var cloudflare_provider_1 = require_cloudflare_provider();
    Object.defineProperty(exports, "CloudflareProvider", { enumerable: true, get: function() {
      return cloudflare_provider_1.CloudflareProvider;
    } });
    var etherscan_provider_1 = require_etherscan_provider();
    Object.defineProperty(exports, "EtherscanProvider", { enumerable: true, get: function() {
      return etherscan_provider_1.EtherscanProvider;
    } });
    var fallback_provider_1 = require_fallback_provider();
    Object.defineProperty(exports, "FallbackProvider", { enumerable: true, get: function() {
      return fallback_provider_1.FallbackProvider;
    } });
    var ipc_provider_1 = require_browser_ipc_provider();
    Object.defineProperty(exports, "IpcProvider", { enumerable: true, get: function() {
      return ipc_provider_1.IpcProvider;
    } });
    var infura_provider_1 = require_infura_provider();
    Object.defineProperty(exports, "InfuraProvider", { enumerable: true, get: function() {
      return infura_provider_1.InfuraProvider;
    } });
    Object.defineProperty(exports, "InfuraWebSocketProvider", { enumerable: true, get: function() {
      return infura_provider_1.InfuraWebSocketProvider;
    } });
    var json_rpc_provider_1 = require_json_rpc_provider();
    Object.defineProperty(exports, "JsonRpcProvider", { enumerable: true, get: function() {
      return json_rpc_provider_1.JsonRpcProvider;
    } });
    Object.defineProperty(exports, "JsonRpcSigner", { enumerable: true, get: function() {
      return json_rpc_provider_1.JsonRpcSigner;
    } });
    var json_rpc_batch_provider_1 = require_json_rpc_batch_provider();
    Object.defineProperty(exports, "JsonRpcBatchProvider", { enumerable: true, get: function() {
      return json_rpc_batch_provider_1.JsonRpcBatchProvider;
    } });
    var nodesmith_provider_1 = require_nodesmith_provider();
    Object.defineProperty(exports, "NodesmithProvider", { enumerable: true, get: function() {
      return nodesmith_provider_1.NodesmithProvider;
    } });
    var pocket_provider_1 = require_pocket_provider();
    Object.defineProperty(exports, "PocketProvider", { enumerable: true, get: function() {
      return pocket_provider_1.PocketProvider;
    } });
    var url_json_rpc_provider_1 = require_url_json_rpc_provider();
    Object.defineProperty(exports, "StaticJsonRpcProvider", { enumerable: true, get: function() {
      return url_json_rpc_provider_1.StaticJsonRpcProvider;
    } });
    Object.defineProperty(exports, "UrlJsonRpcProvider", { enumerable: true, get: function() {
      return url_json_rpc_provider_1.UrlJsonRpcProvider;
    } });
    var web3_provider_1 = require_web3_provider();
    Object.defineProperty(exports, "Web3Provider", { enumerable: true, get: function() {
      return web3_provider_1.Web3Provider;
    } });
    var websocket_provider_1 = require_websocket_provider();
    Object.defineProperty(exports, "WebSocketProvider", { enumerable: true, get: function() {
      return websocket_provider_1.WebSocketProvider;
    } });
    var formatter_1 = require_formatter();
    Object.defineProperty(exports, "Formatter", { enumerable: true, get: function() {
      return formatter_1.Formatter;
    } });
    Object.defineProperty(exports, "isCommunityResourcable", { enumerable: true, get: function() {
      return formatter_1.isCommunityResourcable;
    } });
    Object.defineProperty(exports, "isCommunityResource", { enumerable: true, get: function() {
      return formatter_1.isCommunityResource;
    } });
    Object.defineProperty(exports, "showThrottleMessage", { enumerable: true, get: function() {
      return formatter_1.showThrottleMessage;
    } });
    var logger_1 = require_lib();
    var _version_1 = require_version13();
    var logger15 = new logger_1.Logger(_version_1.version);
    function getDefaultProvider(network, options) {
      if (network == null) {
        network = "homestead";
      }
      if (typeof network === "string") {
        var match = network.match(/^(ws|http)s?:/i);
        if (match) {
          switch (match[1].toLowerCase()) {
            case "http":
            case "https":
              return new json_rpc_provider_1.JsonRpcProvider(network);
            case "ws":
            case "wss":
              return new websocket_provider_1.WebSocketProvider(network);
            default:
              logger15.throwArgumentError("unsupported URL scheme", "network", network);
          }
        }
      }
      var n = (0, networks_1.getNetwork)(network);
      if (!n || !n._defaultProvider) {
        logger15.throwError("unsupported getDefaultProvider network", logger_1.Logger.errors.NETWORK_ERROR, {
          operation: "getDefaultProvider",
          network
        });
      }
      return n._defaultProvider({
        FallbackProvider: fallback_provider_1.FallbackProvider,
        AlchemyProvider: alchemy_provider_1.AlchemyProvider,
        AnkrProvider: ankr_provider_1.AnkrProvider,
        CloudflareProvider: cloudflare_provider_1.CloudflareProvider,
        EtherscanProvider: etherscan_provider_1.EtherscanProvider,
        InfuraProvider: infura_provider_1.InfuraProvider,
        JsonRpcProvider: json_rpc_provider_1.JsonRpcProvider,
        NodesmithProvider: nodesmith_provider_1.NodesmithProvider,
        PocketProvider: pocket_provider_1.PocketProvider,
        Web3Provider: web3_provider_1.Web3Provider,
        IpcProvider: ipc_provider_1.IpcProvider
      }, options);
    }
    exports.getDefaultProvider = getDefaultProvider;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/eip1993-provider.js
var require_eip1993_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/eip1993-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EIP1993ProviderSource = void 0;
    var providers_1 = require_lib22();
    var EIP1993ProviderSource = class {
      constructor(provider) {
        this.ethersProvider = new providers_1.Web3Provider(provider);
      }
      supportedClients() {
        return { [this.ethersProvider.network.chainId]: { ethers: true, viem: false } };
      }
      getEthersProvider({ chainId }) {
        return this.ethersProvider;
      }
      getViemTransport({ chainId }) {
        throw new Error("We do not support EIP-1993 providers for viem at the moment");
      }
    };
    exports.EIP1993ProviderSource = EIP1993ProviderSource;
  }
});

// ../node_modules/abitype/dist/cjs/version.js
var require_version18 = __commonJS({
  "../node_modules/abitype/dist/cjs/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.8.7";
  }
});

// ../node_modules/abitype/dist/cjs/errors.js
var require_errors = __commonJS({
  "../node_modules/abitype/dist/cjs/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseError = void 0;
    var version_js_1 = require_version18();
    var BaseError2 = class extends Error {
      constructor(shortMessage, args = {}) {
        const details = args.cause instanceof BaseError2 ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath4 = args.cause instanceof BaseError2 ? args.cause.docsPath || args.docsPath : args.docsPath;
        const message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath4 ? [`Docs: https://abitype.dev${docsPath4}`] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: abitype@${version_js_1.version}`
        ].join("\n");
        super(message);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiTypeError"
        });
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath4;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
    };
    exports.BaseError = BaseError2;
  }
});

// ../node_modules/abitype/dist/cjs/narrow.js
var require_narrow = __commonJS({
  "../node_modules/abitype/dist/cjs/narrow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.narrow = void 0;
    function narrow(value) {
      return value;
    }
    exports.narrow = narrow;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js
var require_abiItem = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownSolidityTypeError = exports.UnknownTypeError = exports.InvalidAbiItemError = void 0;
    var errors_js_1 = require_errors();
    var InvalidAbiItemError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Failed to parse ABI item.", {
          details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
          docsPath: "/api/human.html#parseabiitem-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiItemError"
        });
      }
    };
    exports.InvalidAbiItemError = InvalidAbiItemError;
    var UnknownTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [
            `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownTypeError"
        });
      }
    };
    exports.UnknownTypeError = UnknownTypeError;
    var UnknownSolidityTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [`Type "${type}" is not a valid ABI type.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSolidityTypeError"
        });
      }
    };
    exports.UnknownSolidityTypeError = UnknownSolidityTypeError;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js
var require_abiParameter = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidAbiTypeParameterError = exports.InvalidFunctionModifierError = exports.InvalidModifierError = exports.SolidityProtectedKeywordError = exports.InvalidParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = void 0;
    var errors_js_1 = require_errors();
    var InvalidAbiParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Failed to parse ABI parameter.", {
          details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameter-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParameterError"
        });
      }
    };
    exports.InvalidAbiParameterError = InvalidAbiParameterError;
    var InvalidAbiParametersError = class extends errors_js_1.BaseError {
      constructor({ params }) {
        super("Failed to parse ABI parameters.", {
          details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameters-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParametersError"
        });
      }
    };
    exports.InvalidAbiParametersError = InvalidAbiParametersError;
    var InvalidParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Invalid ABI parameter.", {
          details: param
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParameterError"
        });
      }
    };
    exports.InvalidParameterError = InvalidParameterError;
    var SolidityProtectedKeywordError = class extends errors_js_1.BaseError {
      constructor({ param, name }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SolidityProtectedKeywordError"
        });
      }
    };
    exports.SolidityProtectedKeywordError = SolidityProtectedKeywordError;
    var InvalidModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidModifierError"
        });
      }
    };
    exports.InvalidModifierError = InvalidModifierError;
    var InvalidFunctionModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
            `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidFunctionModifierError"
        });
      }
    };
    exports.InvalidFunctionModifierError = InvalidFunctionModifierError;
    var InvalidAbiTypeParameterError = class extends errors_js_1.BaseError {
      constructor({ abiParameter }) {
        super("Invalid ABI parameter.", {
          details: JSON.stringify(abiParameter, null, 2),
          metaMessages: ["ABI parameter type is invalid."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiTypeParameterError"
        });
      }
    };
    exports.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/errors/signature.js
var require_signature3 = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/errors/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidStructSignatureError = exports.UnknownSignatureError = exports.InvalidSignatureError = void 0;
    var errors_js_1 = require_errors();
    var InvalidSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature, type }) {
        super(`Invalid ${type} signature.`, {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSignatureError"
        });
      }
    };
    exports.InvalidSignatureError = InvalidSignatureError;
    var UnknownSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Unknown signature.", {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSignatureError"
        });
      }
    };
    exports.UnknownSignatureError = UnknownSignatureError;
    var InvalidStructSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Invalid struct signature.", {
          details: signature,
          metaMessages: ["No properties exist."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStructSignatureError"
        });
      }
    };
    exports.InvalidStructSignatureError = InvalidStructSignatureError;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js
var require_splitParameters = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidParenthesisError = void 0;
    var errors_js_1 = require_errors();
    var InvalidParenthesisError = class extends errors_js_1.BaseError {
      constructor({ current, depth }) {
        super("Unbalanced parentheses.", {
          metaMessages: [
            `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
          ],
          details: `Depth "${depth}"`
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParenthesisError"
        });
      }
    };
    exports.InvalidParenthesisError = InvalidParenthesisError;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/errors/struct.js
var require_struct = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/errors/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularReferenceError = void 0;
    var errors_js_1 = require_errors();
    var CircularReferenceError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Circular reference detected.", {
          metaMessages: [`Struct "${type}" is a circular reference.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CircularReferenceError"
        });
      }
    };
    exports.CircularReferenceError = CircularReferenceError;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/errors/index.js
var require_errors2 = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/errors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularReferenceError = exports.InvalidParenthesisError = exports.UnknownSignatureError = exports.InvalidSignatureError = exports.InvalidStructSignatureError = exports.InvalidAbiParameterError = exports.InvalidAbiParametersError = exports.InvalidParameterError = exports.SolidityProtectedKeywordError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.UnknownSolidityTypeError = exports.InvalidAbiItemError = exports.UnknownTypeError = void 0;
    var abiItem_js_1 = require_abiItem();
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abiItem_js_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "UnknownSolidityTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownSolidityTypeError;
    } });
    var abiParameter_js_1 = require_abiParameter();
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abiParameter_js_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParameterError;
    } });
    var signature_js_1 = require_signature3();
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return signature_js_1.UnknownSignatureError;
    } });
    var splitParameters_js_1 = require_splitParameters();
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return splitParameters_js_1.InvalidParenthesisError;
    } });
    var struct_js_1 = require_struct();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return struct_js_1.CircularReferenceError;
    } });
  }
});

// ../node_modules/abitype/dist/cjs/regex.js
var require_regex = __commonJS({
  "../node_modules/abitype/dist/cjs/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTupleRegex = exports.integerRegex = exports.bytesRegex = exports.execTyped = void 0;
    function execTyped(regex, string) {
      const match = regex.exec(string);
      return match?.groups;
    }
    exports.execTyped = execTyped;
    exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    exports.isTupleRegex = /^\(.+?\).*?$/;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js
var require_signatures = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.functionModifiers = exports.eventModifiers = exports.modifiers = exports.isReceiveSignature = exports.isFallbackSignature = exports.execConstructorSignature = exports.isConstructorSignature = exports.execStructSignature = exports.isStructSignature = exports.execFunctionSignature = exports.isFunctionSignature = exports.execEventSignature = exports.isEventSignature = exports.execErrorSignature = exports.isErrorSignature = void 0;
    var regex_js_1 = require_regex();
    var errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\((?<parameters>.*?)\)$/;
    function isErrorSignature(signature) {
      return errorSignatureRegex.test(signature);
    }
    exports.isErrorSignature = isErrorSignature;
    function execErrorSignature(signature) {
      return (0, regex_js_1.execTyped)(errorSignatureRegex, signature);
    }
    exports.execErrorSignature = execErrorSignature;
    var eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\((?<parameters>.*?)\)$/;
    function isEventSignature(signature) {
      return eventSignatureRegex.test(signature);
    }
    exports.isEventSignature = isEventSignature;
    function execEventSignature(signature) {
      return (0, regex_js_1.execTyped)(eventSignatureRegex, signature);
    }
    exports.execEventSignature = execEventSignature;
    var functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
    function isFunctionSignature(signature) {
      return functionSignatureRegex.test(signature);
    }
    exports.isFunctionSignature = isFunctionSignature;
    function execFunctionSignature(signature) {
      return (0, regex_js_1.execTyped)(functionSignatureRegex, signature);
    }
    exports.execFunctionSignature = execFunctionSignature;
    var structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;
    function isStructSignature(signature) {
      return structSignatureRegex.test(signature);
    }
    exports.isStructSignature = isStructSignature;
    function execStructSignature(signature) {
      return (0, regex_js_1.execTyped)(structSignatureRegex, signature);
    }
    exports.execStructSignature = execStructSignature;
    var constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
    function isConstructorSignature(signature) {
      return constructorSignatureRegex.test(signature);
    }
    exports.isConstructorSignature = isConstructorSignature;
    function execConstructorSignature(signature) {
      return (0, regex_js_1.execTyped)(constructorSignatureRegex, signature);
    }
    exports.execConstructorSignature = execConstructorSignature;
    var fallbackSignatureRegex = /^fallback\(\)$/;
    function isFallbackSignature(signature) {
      return fallbackSignatureRegex.test(signature);
    }
    exports.isFallbackSignature = isFallbackSignature;
    var receiveSignatureRegex = /^receive\(\) external payable$/;
    function isReceiveSignature(signature) {
      return receiveSignatureRegex.test(signature);
    }
    exports.isReceiveSignature = isReceiveSignature;
    exports.modifiers = /* @__PURE__ */ new Set([
      "memory",
      "indexed",
      "storage",
      "calldata"
    ]);
    exports.eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
    exports.functionModifiers = /* @__PURE__ */ new Set([
      "calldata",
      "memory",
      "storage"
    ]);
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/runtime/cache.js
var require_cache = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/runtime/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parameterCache = exports.getParameterCacheKey = void 0;
    function getParameterCacheKey(param, type) {
      if (type)
        return `${type}:${param}`;
      return param;
    }
    exports.getParameterCacheKey = getParameterCacheKey;
    exports.parameterCache = /* @__PURE__ */ new Map([
      ["address", { type: "address" }],
      ["bool", { type: "bool" }],
      ["bytes", { type: "bytes" }],
      ["bytes32", { type: "bytes32" }],
      ["int", { type: "int256" }],
      ["int256", { type: "int256" }],
      ["string", { type: "string" }],
      ["uint", { type: "uint256" }],
      ["uint8", { type: "uint8" }],
      ["uint16", { type: "uint16" }],
      ["uint24", { type: "uint24" }],
      ["uint32", { type: "uint32" }],
      ["uint64", { type: "uint64" }],
      ["uint96", { type: "uint96" }],
      ["uint112", { type: "uint112" }],
      ["uint160", { type: "uint160" }],
      ["uint192", { type: "uint192" }],
      ["uint256", { type: "uint256" }],
      ["address owner", { type: "address", name: "owner" }],
      ["address to", { type: "address", name: "to" }],
      ["bool approved", { type: "bool", name: "approved" }],
      ["bytes _data", { type: "bytes", name: "_data" }],
      ["bytes data", { type: "bytes", name: "data" }],
      ["bytes signature", { type: "bytes", name: "signature" }],
      ["bytes32 hash", { type: "bytes32", name: "hash" }],
      ["bytes32 r", { type: "bytes32", name: "r" }],
      ["bytes32 root", { type: "bytes32", name: "root" }],
      ["bytes32 s", { type: "bytes32", name: "s" }],
      ["string name", { type: "string", name: "name" }],
      ["string symbol", { type: "string", name: "symbol" }],
      ["string tokenURI", { type: "string", name: "tokenURI" }],
      ["uint tokenId", { type: "uint256", name: "tokenId" }],
      ["uint8 v", { type: "uint8", name: "v" }],
      ["uint256 balance", { type: "uint256", name: "balance" }],
      ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
      ["uint256 value", { type: "uint256", name: "value" }],
      [
        "event:address indexed from",
        { type: "address", name: "from", indexed: true }
      ],
      ["event:address indexed to", { type: "address", name: "to", indexed: true }],
      [
        "event:uint indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ],
      [
        "event:uint256 indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ]
    ]);
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js
var require_utils5 = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/runtime/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidDataLocation = exports.isSolidityKeyword = exports.isSolidityType = exports.splitParameters = exports.parseAbiParameter = exports.parseSignature = void 0;
    var regex_js_1 = require_regex();
    var index_js_1 = require_errors2();
    var index_js_2 = require_errors2();
    var cache_js_1 = require_cache();
    var signatures_js_1 = require_signatures();
    function parseSignature(signature, structs = {}) {
      if ((0, signatures_js_1.isFunctionSignature)(signature)) {
        const match = (0, signatures_js_1.execFunctionSignature)(signature);
        if (!match)
          throw new index_js_1.InvalidSignatureError({ signature, type: "function" });
        const inputParams = splitParameters(match.parameters);
        const inputs = [];
        const inputLength = inputParams.length;
        for (let i = 0; i < inputLength; i++) {
          inputs.push(parseAbiParameter(inputParams[i], {
            modifiers: signatures_js_1.functionModifiers,
            structs,
            type: "function"
          }));
        }
        const outputs = [];
        if (match.returns) {
          const outputParams = splitParameters(match.returns);
          const outputLength = outputParams.length;
          for (let i = 0; i < outputLength; i++) {
            outputs.push(parseAbiParameter(outputParams[i], {
              modifiers: signatures_js_1.functionModifiers,
              structs,
              type: "function"
            }));
          }
        }
        return {
          name: match.name,
          type: "function",
          stateMutability: match.stateMutability ?? "nonpayable",
          inputs,
          outputs
        };
      }
      if ((0, signatures_js_1.isEventSignature)(signature)) {
        const match = (0, signatures_js_1.execEventSignature)(signature);
        if (!match)
          throw new index_js_1.InvalidSignatureError({ signature, type: "event" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], {
            modifiers: signatures_js_1.eventModifiers,
            structs,
            type: "event"
          }));
        }
        return { name: match.name, type: "event", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isErrorSignature)(signature)) {
        const match = (0, signatures_js_1.execErrorSignature)(signature);
        if (!match)
          throw new index_js_1.InvalidSignatureError({ signature, type: "error" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
        }
        return { name: match.name, type: "error", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isConstructorSignature)(signature)) {
        const match = (0, signatures_js_1.execConstructorSignature)(signature);
        if (!match)
          throw new index_js_1.InvalidSignatureError({ signature, type: "constructor" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
        }
        return {
          type: "constructor",
          stateMutability: match.stateMutability ?? "nonpayable",
          inputs: abiParameters
        };
      }
      if ((0, signatures_js_1.isFallbackSignature)(signature))
        return { type: "fallback" };
      if ((0, signatures_js_1.isReceiveSignature)(signature))
        return {
          type: "receive",
          stateMutability: "payable"
        };
      throw new index_js_1.UnknownSignatureError({ signature });
    }
    exports.parseSignature = parseSignature;
    var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
    var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
    var dynamicIntegerRegex = /^u?int$/;
    function parseAbiParameter(param, options) {
      const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);
      if (cache_js_1.parameterCache.has(parameterCacheKey))
        return cache_js_1.parameterCache.get(parameterCacheKey);
      const isTuple = regex_js_1.isTupleRegex.test(param);
      const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
      if (!match)
        throw new index_js_1.InvalidParameterError({ param });
      if (match.name && isSolidityKeyword(match.name))
        throw new index_js_1.SolidityProtectedKeywordError({ param, name: match.name });
      const name = match.name ? { name: match.name } : {};
      const indexed = match.modifier === "indexed" ? { indexed: true } : {};
      const structs = options?.structs ?? {};
      let type;
      let components = {};
      if (isTuple) {
        type = "tuple";
        const params = splitParameters(match.type);
        const components_ = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          components_.push(parseAbiParameter(params[i], { structs }));
        }
        components = { components: components_ };
      } else if (match.type in structs) {
        type = "tuple";
        components = { components: structs[match.type] };
      } else if (dynamicIntegerRegex.test(match.type)) {
        type = `${match.type}256`;
      } else {
        type = match.type;
        if (!(options?.type === "struct") && !isSolidityType(type))
          throw new index_js_1.UnknownSolidityTypeError({ type });
      }
      if (match.modifier) {
        if (!options?.modifiers?.has?.(match.modifier))
          throw new index_js_1.InvalidModifierError({
            param,
            type: options?.type,
            modifier: match.modifier
          });
        if (signatures_js_1.functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
          throw new index_js_1.InvalidFunctionModifierError({
            param,
            type: options?.type,
            modifier: match.modifier
          });
      }
      const abiParameter = {
        type: `${type}${match.array ?? ""}`,
        ...name,
        ...indexed,
        ...components
      };
      cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);
      return abiParameter;
    }
    exports.parseAbiParameter = parseAbiParameter;
    function splitParameters(params, result = [], current = "", depth = 0) {
      if (params === "") {
        if (current === "")
          return result;
        if (depth !== 0)
          throw new index_js_2.InvalidParenthesisError({ current, depth });
        result.push(current.trim());
        return result;
      }
      const length = params.length;
      for (let i = 0; i < length; i++) {
        const char = params[i];
        const tail = params.slice(i + 1);
        switch (char) {
          case ",":
            return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
          case "(":
            return splitParameters(tail, result, `${current}${char}`, depth + 1);
          case ")":
            return splitParameters(tail, result, `${current}${char}`, depth - 1);
          default:
            return splitParameters(tail, result, `${current}${char}`, depth);
        }
      }
      return [];
    }
    exports.splitParameters = splitParameters;
    function isSolidityType(type) {
      return type === "address" || type === "bool" || type === "function" || type === "string" || regex_js_1.bytesRegex.test(type) || regex_js_1.integerRegex.test(type);
    }
    exports.isSolidityType = isSolidityType;
    var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    function isSolidityKeyword(name) {
      return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || regex_js_1.bytesRegex.test(name) || regex_js_1.integerRegex.test(name) || protectedKeywordsRegex.test(name);
    }
    exports.isSolidityKeyword = isSolidityKeyword;
    function isValidDataLocation(type, isArray) {
      return isArray || type === "bytes" || type === "string" || type === "tuple";
    }
    exports.isValidDataLocation = isValidDataLocation;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/runtime/structs.js
var require_structs = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/runtime/structs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseStructs = void 0;
    var regex_js_1 = require_regex();
    var index_js_1 = require_errors2();
    var index_js_2 = require_errors2();
    var signatures_js_1 = require_signatures();
    var utils_js_1 = require_utils5();
    function parseStructs(signatures) {
      const shallowStructs = {};
      const signaturesLength = signatures.length;
      for (let i = 0; i < signaturesLength; i++) {
        const signature = signatures[i];
        if (!(0, signatures_js_1.isStructSignature)(signature))
          continue;
        const match = (0, signatures_js_1.execStructSignature)(signature);
        if (!match)
          throw new index_js_2.InvalidSignatureError({ signature, type: "struct" });
        const properties = match.properties.split(";");
        const components = [];
        const propertiesLength = properties.length;
        for (let k = 0; k < propertiesLength; k++) {
          const property = properties[k];
          const trimmed = property.trim();
          if (!trimmed)
            continue;
          const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {
            type: "struct"
          });
          components.push(abiParameter);
        }
        if (!components.length)
          throw new index_js_2.InvalidStructSignatureError({ signature });
        shallowStructs[match.name] = components;
      }
      const resolvedStructs = {};
      const entries = Object.entries(shallowStructs);
      const entriesLength = entries.length;
      for (let i = 0; i < entriesLength; i++) {
        const [name, parameters] = entries[i];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
      }
      return resolvedStructs;
    }
    exports.parseStructs = parseStructs;
    var typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;
    function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
      const components = [];
      const length = abiParameters.length;
      for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);
        if (isTuple)
          components.push(abiParameter);
        else {
          const match = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);
          if (!match?.type)
            throw new index_js_2.InvalidAbiTypeParameterError({ abiParameter });
          const { array, type } = match;
          if (type in structs) {
            if (ancestors.has(type))
              throw new index_js_2.CircularReferenceError({ type });
            components.push({
              ...abiParameter,
              type: `tuple${array ?? ""}`,
              components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
            });
          } else {
            if ((0, utils_js_1.isSolidityType)(type))
              components.push(abiParameter);
            else
              throw new index_js_1.UnknownTypeError({ type });
          }
        }
      }
      return components;
    }
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/runtime/index.js
var require_runtime = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/runtime/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitParameters = exports.parseSignature = exports.parseAbiParameter = exports.parseStructs = exports.modifiers = exports.isStructSignature = exports.functionModifiers = exports.eventModifiers = void 0;
    var signatures_js_1 = require_signatures();
    Object.defineProperty(exports, "eventModifiers", { enumerable: true, get: function() {
      return signatures_js_1.eventModifiers;
    } });
    Object.defineProperty(exports, "functionModifiers", { enumerable: true, get: function() {
      return signatures_js_1.functionModifiers;
    } });
    Object.defineProperty(exports, "isStructSignature", { enumerable: true, get: function() {
      return signatures_js_1.isStructSignature;
    } });
    Object.defineProperty(exports, "modifiers", { enumerable: true, get: function() {
      return signatures_js_1.modifiers;
    } });
    var structs_js_1 = require_structs();
    Object.defineProperty(exports, "parseStructs", { enumerable: true, get: function() {
      return structs_js_1.parseStructs;
    } });
    var utils_js_1 = require_utils5();
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return utils_js_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseSignature", { enumerable: true, get: function() {
      return utils_js_1.parseSignature;
    } });
    Object.defineProperty(exports, "splitParameters", { enumerable: true, get: function() {
      return utils_js_1.splitParameters;
    } });
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/parseAbi.js
var require_parseAbi = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/parseAbi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbi = void 0;
    var index_js_1 = require_runtime();
    function parseAbi(signatures) {
      const structs = (0, index_js_1.parseStructs)(signatures);
      const abi = [];
      const length = signatures.length;
      for (let i = 0; i < length; i++) {
        const signature = signatures[i];
        if ((0, index_js_1.isStructSignature)(signature))
          continue;
        abi.push((0, index_js_1.parseSignature)(signature, structs));
      }
      return abi;
    }
    exports.parseAbi = parseAbi;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js
var require_parseAbiItem = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiItem = void 0;
    var index_js_1 = require_errors2();
    var index_js_2 = require_runtime();
    function parseAbiItem(signature) {
      let abiItem;
      if (typeof signature === "string")
        abiItem = (0, index_js_2.parseSignature)(signature);
      else {
        const structs = (0, index_js_2.parseStructs)(signature);
        const length = signature.length;
        for (let i = 0; i < length; i++) {
          const signature_ = signature[i];
          if ((0, index_js_2.isStructSignature)(signature_))
            continue;
          abiItem = (0, index_js_2.parseSignature)(signature_, structs);
          break;
        }
      }
      if (!abiItem)
        throw new index_js_1.InvalidAbiItemError({ signature });
      return abiItem;
    }
    exports.parseAbiItem = parseAbiItem;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js
var require_parseAbiParameter = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiParameter = void 0;
    var index_js_1 = require_errors2();
    var index_js_2 = require_runtime();
    function parseAbiParameter(param) {
      let abiParameter;
      if (typeof param === "string")
        abiParameter = (0, index_js_2.parseAbiParameter)(param, {
          modifiers: index_js_2.modifiers
        });
      else {
        const structs = (0, index_js_2.parseStructs)(param);
        const length = param.length;
        for (let i = 0; i < length; i++) {
          const signature = param[i];
          if ((0, index_js_2.isStructSignature)(signature))
            continue;
          abiParameter = (0, index_js_2.parseAbiParameter)(signature, { modifiers: index_js_2.modifiers, structs });
          break;
        }
      }
      if (!abiParameter)
        throw new index_js_1.InvalidAbiParameterError({ param });
      return abiParameter;
    }
    exports.parseAbiParameter = parseAbiParameter;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js
var require_parseAbiParameters = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiParameters = void 0;
    var index_js_1 = require_errors2();
    var index_js_2 = require_runtime();
    function parseAbiParameters(params) {
      const abiParameters = [];
      if (typeof params === "string") {
        const parameters = (0, index_js_2.splitParameters)(params);
        const length = parameters.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push((0, index_js_2.parseAbiParameter)(parameters[i], { modifiers: index_js_2.modifiers }));
        }
      } else {
        const structs = (0, index_js_2.parseStructs)(params);
        const length = params.length;
        for (let i = 0; i < length; i++) {
          const signature = params[i];
          if ((0, index_js_2.isStructSignature)(signature))
            continue;
          const parameters = (0, index_js_2.splitParameters)(signature);
          const length2 = parameters.length;
          for (let k = 0; k < length2; k++) {
            abiParameters.push((0, index_js_2.parseAbiParameter)(parameters[k], { modifiers: index_js_2.modifiers, structs }));
          }
        }
      }
      if (abiParameters.length === 0)
        throw new index_js_1.InvalidAbiParametersError({ params });
      return abiParameters;
    }
    exports.parseAbiParameters = parseAbiParameters;
  }
});

// ../node_modules/abitype/dist/cjs/human-readable/index.js
var require_human_readable = __commonJS({
  "../node_modules/abitype/dist/cjs/human-readable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.UnknownTypeError = exports.InvalidAbiItemError = exports.InvalidAbiTypeParameterError = exports.InvalidFunctionModifierError = exports.InvalidModifierError = exports.SolidityProtectedKeywordError = exports.InvalidParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.UnknownSignatureError = exports.InvalidParenthesisError = exports.CircularReferenceError = void 0;
    var index_js_1 = require_errors2();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return index_js_1.CircularReferenceError;
    } });
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return index_js_1.InvalidParenthesisError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return index_js_1.UnknownSignatureError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return index_js_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return index_js_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return index_js_1.InvalidAbiParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return index_js_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return index_js_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return index_js_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return index_js_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return index_js_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return index_js_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return index_js_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return index_js_1.UnknownTypeError;
    } });
    var parseAbi_js_1 = require_parseAbi();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return parseAbi_js_1.parseAbi;
    } });
    var parseAbiItem_js_1 = require_parseAbiItem();
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return parseAbiItem_js_1.parseAbiItem;
    } });
    var parseAbiParameter_js_1 = require_parseAbiParameter();
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return parseAbiParameter_js_1.parseAbiParameter;
    } });
    var parseAbiParameters_js_1 = require_parseAbiParameters();
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return parseAbiParameters_js_1.parseAbiParameters;
    } });
  }
});

// ../node_modules/abitype/dist/cjs/index.js
var require_cjs = __commonJS({
  "../node_modules/abitype/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownTypeError = exports.InvalidAbiItemError = exports.InvalidAbiTypeParameterError = exports.InvalidFunctionModifierError = exports.InvalidModifierError = exports.SolidityProtectedKeywordError = exports.InvalidParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.UnknownSignatureError = exports.InvalidParenthesisError = exports.CircularReferenceError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.narrow = exports.BaseError = void 0;
    var errors_js_1 = require_errors();
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return errors_js_1.BaseError;
    } });
    var narrow_js_1 = require_narrow();
    Object.defineProperty(exports, "narrow", { enumerable: true, get: function() {
      return narrow_js_1.narrow;
    } });
    var index_js_1 = require_human_readable();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return index_js_1.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return index_js_1.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return index_js_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return index_js_1.parseAbiParameters;
    } });
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return index_js_1.CircularReferenceError;
    } });
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return index_js_1.InvalidParenthesisError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return index_js_1.UnknownSignatureError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return index_js_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return index_js_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return index_js_1.InvalidAbiParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return index_js_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return index_js_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return index_js_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return index_js_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return index_js_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return index_js_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return index_js_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return index_js_1.UnknownTypeError;
    } });
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/formatAbiItem.js
var require_formatAbiItem = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/formatAbiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiParams = exports.formatAbiItem = void 0;
    var abi_js_1 = require_abi();
    function formatAbiItem2(abiItem, { includeName = false } = {}) {
      if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
        throw new abi_js_1.InvalidDefinitionTypeError(abiItem.type);
      return `${abiItem.name}(${formatAbiParams2(abiItem.inputs, { includeName })})`;
    }
    exports.formatAbiItem = formatAbiItem2;
    function formatAbiParams2(params, { includeName = false } = {}) {
      if (!params)
        return "";
      return params.map((param) => formatAbiParam2(param, { includeName })).join(includeName ? ", " : ",");
    }
    exports.formatAbiParams = formatAbiParams2;
    function formatAbiParam2(param, { includeName }) {
      if (param.type.startsWith("tuple")) {
        return `(${formatAbiParams2(param.components, { includeName })})${param.type.slice("tuple".length)}`;
      }
      return param.type + (includeName && param.name ? ` ${param.name}` : "");
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/isHex.js
var require_isHex = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/isHex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHex = void 0;
    function isHex3(value, { strict = true } = {}) {
      if (!value)
        return false;
      if (typeof value !== "string")
        return false;
      return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
    }
    exports.isHex = isHex3;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/size.js
var require_size = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/size.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.size = void 0;
    var isHex_js_1 = require_isHex();
    function size3(value) {
      if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return Math.ceil((value.length - 2) / 2);
      return value.length;
    }
    exports.size = size3;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/version.js
var require_version19 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "1.2.0";
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/utils.js
var require_utils6 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getVersion = exports.getUrl = exports.getContractAddress = void 0;
    var version_js_1 = require_version19();
    var getContractAddress3 = (address) => address;
    exports.getContractAddress = getContractAddress3;
    var getUrl2 = (url) => url;
    exports.getUrl = getUrl2;
    var getVersion2 = () => `viem@${version_js_1.version}`;
    exports.getVersion = getVersion2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/base.js
var require_base2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseError = void 0;
    var utils_js_1 = require_utils6();
    var BaseError2 = class extends Error {
      constructor(shortMessage, args = {}) {
        super();
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ViemError"
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (0, utils_js_1.getVersion)()
        });
        const details = args.cause instanceof BaseError2 ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath4 = args.cause instanceof BaseError2 ? args.cause.docsPath || args.docsPath : args.docsPath;
        this.message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath4 ? [
            `Docs: https://viem.sh${docsPath4}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
          ] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: ${this.version}`
        ].join("\n");
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath4;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
      walk(fn) {
        return walk2(this, fn);
      }
    };
    exports.BaseError = BaseError2;
    function walk2(err, fn) {
      if (fn?.(err))
        return err;
      if (err.cause)
        return walk2(err.cause, fn);
      return err;
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/abi.js
var require_abi = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/abi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiDecodingTypeError = exports.InvalidAbiEncodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = void 0;
    var formatAbiItem_js_1 = require_formatAbiItem();
    var size_js_1 = require_size();
    var base_js_1 = require_base2();
    var AbiConstructorNotFoundError2 = class extends base_js_1.BaseError {
      constructor({ docsPath: docsPath4 }) {
        super([
          "A constructor was not found on the ABI.",
          "Make sure you are using the correct ABI and that the constructor exists on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorNotFoundError"
        });
      }
    };
    exports.AbiConstructorNotFoundError = AbiConstructorNotFoundError2;
    var AbiConstructorParamsNotFoundError2 = class extends base_js_1.BaseError {
      constructor({ docsPath: docsPath4 }) {
        super([
          "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
          "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorParamsNotFoundError"
        });
      }
    };
    exports.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError2;
    var AbiDecodingDataSizeInvalidError = class extends base_js_1.BaseError {
      constructor({ data, size: size3 }) {
        super([
          `Data size of ${size3} bytes is invalid.`,
          "Size must be in increments of 32 bytes (size % 32 === 0)."
        ].join("\n"), { metaMessages: [`Data: ${data} (${size3} bytes)`] });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingDataSizeInvalidError"
        });
      }
    };
    exports.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError;
    var AbiDecodingDataSizeTooSmallError2 = class extends base_js_1.BaseError {
      constructor({ data, params, size: size3 }) {
        super([`Data size of ${size3} bytes is too small for given parameters.`].join("\n"), {
          metaMessages: [
            `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
            `Data:   ${data} (${size3} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingDataSizeTooSmallError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
        this.params = params;
        this.size = size3;
      }
    };
    exports.AbiDecodingDataSizeTooSmallError = AbiDecodingDataSizeTooSmallError2;
    var AbiDecodingZeroDataError2 = class extends base_js_1.BaseError {
      constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingZeroDataError"
        });
      }
    };
    exports.AbiDecodingZeroDataError = AbiDecodingZeroDataError2;
    var AbiEncodingArrayLengthMismatchError2 = class extends base_js_1.BaseError {
      constructor({ expectedLength, givenLength, type }) {
        super([
          `ABI encoding array length mismatch for type ${type}.`,
          `Expected length: ${expectedLength}`,
          `Given length: ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingArrayLengthMismatchError"
        });
      }
    };
    exports.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError2;
    var AbiEncodingBytesSizeMismatchError2 = class extends base_js_1.BaseError {
      constructor({ expectedSize, value }) {
        super(`Size of bytes "${value}" (bytes${(0, size_js_1.size)(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingBytesSizeMismatchError"
        });
      }
    };
    exports.AbiEncodingBytesSizeMismatchError = AbiEncodingBytesSizeMismatchError2;
    var AbiEncodingLengthMismatchError2 = class extends base_js_1.BaseError {
      constructor({ expectedLength, givenLength }) {
        super([
          "ABI encoding params/values length mismatch.",
          `Expected length (params): ${expectedLength}`,
          `Given length (values): ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingLengthMismatchError"
        });
      }
    };
    exports.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError2;
    var AbiErrorInputsNotFoundError = class extends base_js_1.BaseError {
      constructor(errorName, { docsPath: docsPath4 }) {
        super([
          `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
          "Cannot encode error result without knowing what the parameter types are.",
          "Make sure you are using the correct ABI and that the inputs exist on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorInputsNotFoundError"
        });
      }
    };
    exports.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError;
    var AbiErrorNotFoundError = class extends base_js_1.BaseError {
      constructor(errorName, { docsPath: docsPath4 } = {}) {
        super([
          `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorNotFoundError"
        });
      }
    };
    exports.AbiErrorNotFoundError = AbiErrorNotFoundError;
    var AbiErrorSignatureNotFoundError2 = class extends base_js_1.BaseError {
      constructor(signature, { docsPath: docsPath4 }) {
        super([
          `Encoded error signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorSignatureNotFoundError"
        });
      }
    };
    exports.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError2;
    var AbiEventSignatureEmptyTopicsError2 = class extends base_js_1.BaseError {
      constructor({ docsPath: docsPath4 }) {
        super("Cannot extract event signature from empty topics.", {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureEmptyTopicsError"
        });
      }
    };
    exports.AbiEventSignatureEmptyTopicsError = AbiEventSignatureEmptyTopicsError2;
    var AbiEventSignatureNotFoundError2 = class extends base_js_1.BaseError {
      constructor(signature, { docsPath: docsPath4 }) {
        super([
          `Encoded event signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureNotFoundError"
        });
      }
    };
    exports.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError2;
    var AbiEventNotFoundError2 = class extends base_js_1.BaseError {
      constructor(eventName, { docsPath: docsPath4 } = {}) {
        super([
          `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventNotFoundError"
        });
      }
    };
    exports.AbiEventNotFoundError = AbiEventNotFoundError2;
    var AbiFunctionNotFoundError2 = class extends base_js_1.BaseError {
      constructor(functionName, { docsPath: docsPath4 } = {}) {
        super([
          `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionNotFoundError"
        });
      }
    };
    exports.AbiFunctionNotFoundError = AbiFunctionNotFoundError2;
    var AbiFunctionOutputsNotFoundError2 = class extends base_js_1.BaseError {
      constructor(functionName, { docsPath: docsPath4 }) {
        super([
          `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
          "Cannot decode function result without knowing what the parameter types are.",
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionOutputsNotFoundError"
        });
      }
    };
    exports.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError2;
    var AbiFunctionSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath: docsPath4 }) {
        super([
          `Encoded function signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionSignatureNotFoundError"
        });
      }
    };
    exports.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError;
    var BytesSizeMismatchError2 = class extends base_js_1.BaseError {
      constructor({ expectedSize, givenSize }) {
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BytesSizeMismatchError"
        });
      }
    };
    exports.BytesSizeMismatchError = BytesSizeMismatchError2;
    var DecodeLogDataMismatch2 = class extends base_js_1.BaseError {
      constructor({ abiItem, data, params, size: size3 }) {
        super([
          `Data size of ${size3} bytes is too small for non-indexed event parameters.`
        ].join("\n"), {
          metaMessages: [
            `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
            `Data:   ${data} (${size3} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogDataMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
        this.data = data;
        this.params = params;
        this.size = size3;
      }
    };
    exports.DecodeLogDataMismatch = DecodeLogDataMismatch2;
    var DecodeLogTopicsMismatch2 = class extends base_js_1.BaseError {
      constructor({ abiItem, param }) {
        super([
          `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${(0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })}".`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogTopicsMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
      }
    };
    exports.DecodeLogTopicsMismatch = DecodeLogTopicsMismatch2;
    var InvalidAbiEncodingTypeError2 = class extends base_js_1.BaseError {
      constructor(type, { docsPath: docsPath4 }) {
        super([
          `Type "${type}" is not a valid encoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath: docsPath4 });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiEncodingType"
        });
      }
    };
    exports.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError2;
    var InvalidAbiDecodingTypeError2 = class extends base_js_1.BaseError {
      constructor(type, { docsPath: docsPath4 }) {
        super([
          `Type "${type}" is not a valid decoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath: docsPath4 });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiDecodingType"
        });
      }
    };
    exports.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError2;
    var InvalidArrayError2 = class extends base_js_1.BaseError {
      constructor(value) {
        super([`Value "${value}" is not a valid array.`].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidArrayError"
        });
      }
    };
    exports.InvalidArrayError = InvalidArrayError2;
    var InvalidDefinitionTypeError2 = class extends base_js_1.BaseError {
      constructor(type) {
        super([
          `"${type}" is not a valid definition type.`,
          'Valid types: "function", "event", "error"'
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidDefinitionTypeError"
        });
      }
    };
    exports.InvalidDefinitionTypeError = InvalidDefinitionTypeError2;
    var UnsupportedPackedAbiType = class extends base_js_1.BaseError {
      constructor(type) {
        super(`Type "${type}" is not supported for packed encoding.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnsupportedPackedAbiType"
        });
      }
    };
    exports.UnsupportedPackedAbiType = UnsupportedPackedAbiType;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/log.js
var require_log = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterTypeNotSupportedError = void 0;
    var base_js_1 = require_base2();
    var FilterTypeNotSupportedError2 = class extends base_js_1.BaseError {
      constructor(type) {
        super(`Filter type "${type}" is not supported.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FilterTypeNotSupportedError"
        });
      }
    };
    exports.FilterTypeNotSupportedError = FilterTypeNotSupportedError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/data.js
var require_data = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = void 0;
    var base_js_1 = require_base2();
    var SliceOffsetOutOfBoundsError2 = class extends base_js_1.BaseError {
      constructor({ offset, position, size: size3 }) {
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size3}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SliceOffsetOutOfBoundsError"
        });
      }
    };
    exports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError2;
    var SizeExceedsPaddingSizeError2 = class extends base_js_1.BaseError {
      constructor({ size: size3, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size3}) exceeds padding size (${targetSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeExceedsPaddingSizeError"
        });
      }
    };
    exports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/pad.js
var require_pad = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/pad.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.padBytes = exports.padHex = exports.pad = void 0;
    var data_js_1 = require_data();
    function pad2(hexOrBytes, { dir, size: size3 = 32 } = {}) {
      if (typeof hexOrBytes === "string")
        return padHex2(hexOrBytes, { dir, size: size3 });
      return padBytes2(hexOrBytes, { dir, size: size3 });
    }
    exports.pad = pad2;
    function padHex2(hex_, { dir, size: size3 = 32 } = {}) {
      if (size3 === null)
        return hex_;
      const hex = hex_.replace("0x", "");
      if (hex.length > size3 * 2)
        throw new data_js_1.SizeExceedsPaddingSizeError({
          size: Math.ceil(hex.length / 2),
          targetSize: size3,
          type: "hex"
        });
      return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size3 * 2, "0")}`;
    }
    exports.padHex = padHex2;
    function padBytes2(bytes4, { dir, size: size3 = 32 } = {}) {
      if (size3 === null)
        return bytes4;
      if (bytes4.length > size3)
        throw new data_js_1.SizeExceedsPaddingSizeError({
          size: bytes4.length,
          targetSize: size3,
          type: "bytes"
        });
      const paddedBytes = new Uint8Array(size3);
      for (let i = 0; i < size3; i++) {
        const padEnd = dir === "right";
        paddedBytes[padEnd ? i : size3 - i - 1] = bytes4[padEnd ? i : bytes4.length - i - 1];
      }
      return paddedBytes;
    }
    exports.padBytes = padBytes2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/encoding.js
var require_encoding = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SizeOverflowError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.IntegerOutOfRangeError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = void 0;
    var base_js_1 = require_base2();
    var DataLengthTooLongError = class extends base_js_1.BaseError {
      constructor({ consumed, length }) {
        super(`Consumed bytes (${consumed}) is shorter than data length (${length - 1}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DataLengthTooLongError"
        });
      }
    };
    exports.DataLengthTooLongError = DataLengthTooLongError;
    var DataLengthTooShortError = class extends base_js_1.BaseError {
      constructor({ length, dataLength }) {
        super(`Data length (${dataLength - 1}) is shorter than prefix length (${length - 1}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DataLengthTooShortError"
        });
      }
    };
    exports.DataLengthTooShortError = DataLengthTooShortError;
    var IntegerOutOfRangeError2 = class extends base_js_1.BaseError {
      constructor({ max: max2, min: min2, signed, size: size3, value }) {
        super(`Number "${value}" is not in safe ${size3 ? `${size3 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max2 ? `(${min2} to ${max2})` : `(above ${min2})`}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntegerOutOfRangeError"
        });
      }
    };
    exports.IntegerOutOfRangeError = IntegerOutOfRangeError2;
    var InvalidBytesBooleanError = class extends base_js_1.BaseError {
      constructor(bytes4) {
        super(`Bytes value "${bytes4}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidBytesBooleanError"
        });
      }
    };
    exports.InvalidBytesBooleanError = InvalidBytesBooleanError;
    var InvalidHexBooleanError2 = class extends base_js_1.BaseError {
      constructor(hex) {
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidHexBooleanError"
        });
      }
    };
    exports.InvalidHexBooleanError = InvalidHexBooleanError2;
    var InvalidHexValueError = class extends base_js_1.BaseError {
      constructor(value) {
        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidHexValueError"
        });
      }
    };
    exports.InvalidHexValueError = InvalidHexValueError;
    var OffsetOutOfBoundsError = class extends base_js_1.BaseError {
      constructor({ nextOffset, offset }) {
        super(`Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffsetOutOfBoundsError"
        });
      }
    };
    exports.OffsetOutOfBoundsError = OffsetOutOfBoundsError;
    var SizeOverflowError2 = class extends base_js_1.BaseError {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeOverflowError"
        });
      }
    };
    exports.SizeOverflowError = SizeOverflowError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/trim.js
var require_trim = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/trim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trim = void 0;
    function trim2(hexOrBytes, { dir = "left" } = {}) {
      let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
      let sliceLength = 0;
      for (let i = 0; i < data.length - 1; i++) {
        if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
          sliceLength++;
        else
          break;
      }
      data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
      if (typeof hexOrBytes === "string") {
        if (data.length === 1 && dir === "right")
          data = `${data}0`;
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
      }
      return data;
    }
    exports.trim = trim2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/fromHex.js
var require_fromHex = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/fromHex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.assertSize = void 0;
    var encoding_js_1 = require_encoding();
    var size_js_1 = require_size();
    var trim_js_1 = require_trim();
    var toBytes_js_1 = require_toBytes();
    function assertSize2(hexOrBytes, { size: size3 }) {
      if ((0, size_js_1.size)(hexOrBytes) > size3)
        throw new encoding_js_1.SizeOverflowError({
          givenSize: (0, size_js_1.size)(hexOrBytes),
          maxSize: size3
        });
    }
    exports.assertSize = assertSize2;
    function fromHex3(hex, toOrOpts) {
      const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
      const to = opts.to;
      if (to === "number")
        return hexToNumber3(hex, opts);
      if (to === "bigint")
        return hexToBigInt2(hex, opts);
      if (to === "string")
        return hexToString2(hex, opts);
      if (to === "boolean")
        return hexToBool2(hex, opts);
      return (0, toBytes_js_1.hexToBytes)(hex, opts);
    }
    exports.fromHex = fromHex3;
    function hexToBigInt2(hex, opts = {}) {
      const { signed } = opts;
      if (opts.size)
        assertSize2(hex, { size: opts.size });
      const value = BigInt(hex);
      if (!signed)
        return value;
      const size3 = (hex.length - 2) / 2;
      const max2 = (1n << BigInt(size3) * 8n - 1n) - 1n;
      if (value <= max2)
        return value;
      return value - BigInt(`0x${"f".padStart(size3 * 2, "f")}`) - 1n;
    }
    exports.hexToBigInt = hexToBigInt2;
    function hexToBool2(hex_, opts = {}) {
      let hex = hex_;
      if (opts.size) {
        assertSize2(hex, { size: opts.size });
        hex = (0, trim_js_1.trim)(hex);
      }
      if ((0, trim_js_1.trim)(hex) === "0x00")
        return false;
      if ((0, trim_js_1.trim)(hex) === "0x01")
        return true;
      throw new encoding_js_1.InvalidHexBooleanError(hex);
    }
    exports.hexToBool = hexToBool2;
    function hexToNumber3(hex, opts = {}) {
      return Number(hexToBigInt2(hex, opts));
    }
    exports.hexToNumber = hexToNumber3;
    function hexToString2(hex, opts = {}) {
      let bytes4 = (0, toBytes_js_1.hexToBytes)(hex);
      if (opts.size) {
        assertSize2(bytes4, { size: opts.size });
        bytes4 = (0, trim_js_1.trim)(bytes4, { dir: "right" });
      }
      return new TextDecoder().decode(bytes4);
    }
    exports.hexToString = hexToString2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/toHex.js
var require_toHex = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/toHex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toHex = void 0;
    var encoding_js_1 = require_encoding();
    var pad_js_1 = require_pad();
    var fromHex_js_1 = require_fromHex();
    var hexes4 = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
    function toHex3(value, opts = {}) {
      if (typeof value === "number" || typeof value === "bigint")
        return numberToHex2(value, opts);
      if (typeof value === "string") {
        return stringToHex2(value, opts);
      }
      if (typeof value === "boolean")
        return boolToHex2(value, opts);
      return bytesToHex3(value, opts);
    }
    exports.toHex = toHex3;
    function boolToHex2(value, opts = {}) {
      const hex = `0x${Number(value)}`;
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { size: opts.size });
      }
      return hex;
    }
    exports.boolToHex = boolToHex2;
    function bytesToHex3(value, opts = {}) {
      let hexString = "";
      for (let i = 0; i < value.length; i++) {
        hexString += hexes4[value[i]];
      }
      const hex = `0x${hexString}`;
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex3;
    function numberToHex2(value_, opts = {}) {
      const { signed, size: size3 } = opts;
      const value = BigInt(value_);
      let maxValue;
      if (size3) {
        if (signed)
          maxValue = (1n << BigInt(size3) * 8n - 1n) - 1n;
        else
          maxValue = 2n ** (BigInt(size3) * 8n) - 1n;
      } else if (typeof value_ === "number") {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
      }
      const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
      if (maxValue && value > maxValue || value < minValue) {
        const suffix = typeof value_ === "bigint" ? "n" : "";
        throw new encoding_js_1.IntegerOutOfRangeError({
          max: maxValue ? `${maxValue}${suffix}` : void 0,
          min: `${minValue}${suffix}`,
          signed,
          size: size3,
          value: `${value_}${suffix}`
        });
      }
      const hex = `0x${(signed && value < 0 ? (1n << BigInt(size3 * 8)) + BigInt(value) : value).toString(16)}`;
      if (size3)
        return (0, pad_js_1.pad)(hex, { size: size3 });
      return hex;
    }
    exports.numberToHex = numberToHex2;
    var encoder3 = new TextEncoder();
    function stringToHex2(value_, opts = {}) {
      const value = encoder3.encode(value_);
      return bytesToHex3(value, opts);
    }
    exports.stringToHex = stringToHex2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/toBytes.js
var require_toBytes = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/toBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.toBytes = void 0;
    var base_js_1 = require_base2();
    var isHex_js_1 = require_isHex();
    var pad_js_1 = require_pad();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    var encoder3 = new TextEncoder();
    function toBytes4(value, opts = {}) {
      if (typeof value === "number" || typeof value === "bigint")
        return numberToBytes2(value, opts);
      if (typeof value === "boolean")
        return boolToBytes2(value, opts);
      if ((0, isHex_js_1.isHex)(value))
        return hexToBytes3(value, opts);
      return stringToBytes2(value, opts);
    }
    exports.toBytes = toBytes4;
    function boolToBytes2(value, opts = {}) {
      const bytes4 = new Uint8Array(1);
      bytes4[0] = Number(value);
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(bytes4, { size: opts.size });
        return (0, pad_js_1.pad)(bytes4, { size: opts.size });
      }
      return bytes4;
    }
    exports.boolToBytes = boolToBytes2;
    function hexToBytes3(hex_, opts = {}) {
      let hex = hex_;
      if (opts.size) {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        hex = (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
      }
      let hexString = hex.slice(2);
      if (hexString.length % 2)
        hexString = `0${hexString}`;
      const bytes4 = new Uint8Array(hexString.length / 2);
      for (let index2 = 0; index2 < bytes4.length; index2++) {
        const start = index2 * 2;
        const hexByte = hexString.slice(start, start + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new base_js_1.BaseError(`Invalid byte sequence ("${hexByte}" in "${hexString}").`);
        bytes4[index2] = byte;
      }
      return bytes4;
    }
    exports.hexToBytes = hexToBytes3;
    function numberToBytes2(value, opts) {
      const hex = (0, toHex_js_1.numberToHex)(value, opts);
      return hexToBytes3(hex);
    }
    exports.numberToBytes = numberToBytes2;
    function stringToBytes2(value, opts = {}) {
      const bytes4 = encoder3.encode(value);
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(bytes4, { size: opts.size });
        return (0, pad_js_1.pad)(bytes4, { dir: "right", size: opts.size });
      }
      return bytes4;
    }
    exports.stringToBytes = stringToBytes2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/contract/extractFunctionParts.js
var require_extractFunctionParts = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/contract/extractFunctionParts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.extractFunctionParts = void 0;
    var paramsRegex2 = /((function|event)\s)?(.*)(\((.*)\))/;
    function extractFunctionParts2(def) {
      const parts = def.match(paramsRegex2);
      const type = parts?.[2] || void 0;
      const name = parts?.[3];
      const params = parts?.[5] || void 0;
      return { type, name, params };
    }
    exports.extractFunctionParts = extractFunctionParts2;
    function extractFunctionName2(def) {
      return extractFunctionParts2(def).name;
    }
    exports.extractFunctionName = extractFunctionName2;
    function extractFunctionParams2(def) {
      const params = extractFunctionParts2(def).params;
      const splitParams = params?.split(",").map((x) => x.trim().split(" "));
      return splitParams?.map((param) => ({
        type: param[0],
        name: param[1] === "indexed" ? param[2] : param[1],
        ...param[1] === "indexed" ? { indexed: true } : {}
      }));
    }
    exports.extractFunctionParams = extractFunctionParams2;
    function extractFunctionType(def) {
      return extractFunctionParts2(def).type;
    }
    exports.extractFunctionType = extractFunctionType;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number3(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number3;
    function bool2(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool2;
    function bytes4(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes4;
    function hash4(hash5) {
      if (typeof hash5 !== "function" || typeof hash5.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number3(hash5.outputLen);
      number3(hash5.blockLen);
    }
    exports.hash = hash4;
    function exists3(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists3;
    function output3(out, instance) {
      bytes4(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
      }
    }
    exports.output = output3;
    var assert2 = {
      number: number3,
      bool: bool2,
      bytes: bytes4,
      hash: hash4,
      exists: exists3,
      output: output3
    };
    exports.default = assert2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK642 = BigInt(2 ** 32 - 1);
    var _32n2 = BigInt(32);
    function fromBig2(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
      return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
    }
    exports.fromBig = fromBig2;
    function split2(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig2(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split2;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, l, s) => h >>> s;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    var rotr32H = (h, l) => l;
    var rotr32L = (h, l) => h;
    var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
    var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
    var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
    var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u64 = {
      fromBig: fromBig2,
      split: split2,
      toBig: exports.toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH: rotlSH2,
      rotlSL: rotlSL2,
      rotlBH: rotlBH2,
      rotlBL: rotlBL2,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/utils.js
var require_utils7 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto2();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u322;
    var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView2;
    var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr2;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes4 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex3(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += hexes4[uint8a[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex3;
    function hexToBytes3(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes3;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes4(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes4;
    function toBytes4(data) {
      if (typeof data === "string")
        data = utf8ToBytes4(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports.toBytes = toBytes4;
    function concatBytes4(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad2 = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad2);
        pad2 += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes4;
    var Hash3 = class {
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash3;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor3(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes4(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor3;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes4(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function randomBytes4(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes4;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/sha3.js
var require_sha32 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils7();
    var [SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2] = [[], [], []];
    var _0n8 = BigInt(0);
    var _1n8 = BigInt(1);
    var _2n7 = BigInt(2);
    var _7n2 = BigInt(7);
    var _256n2 = BigInt(256);
    var _0x71n2 = BigInt(113);
    for (let round = 0, R = _1n8, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI2.push(2 * (5 * y + x));
      SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n8;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n8 ^ (R >> _7n2) * _0x71n2) % _256n2;
        if (R & _2n7)
          t ^= _1n8 << (_1n8 << BigInt(j)) - _1n8;
      }
      _SHA3_IOTA2.push(t);
    }
    var [SHA3_IOTA_H2, SHA3_IOTA_L2] = _u64_js_1.default.split(_SHA3_IOTA2, true);
    var rotlH2 = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
    var rotlL2 = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
    function keccakP2(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH2(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL2[t];
          const Th = rotlH2(curH, curL, shift);
          const Tl = rotlL2(curH, curL, shift);
          const PI = SHA3_PI2[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H2[round];
        s[1] ^= SHA3_IOTA_L2[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP2;
    var Keccak2 = class extends utils_js_1.Hash {
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.number(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP2(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes4) {
        _assert_js_1.default.number(bytes4);
        return this.xofInto(new Uint8Array(bytes4));
      }
      digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak2;
    var gen2 = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak2(blockLen, suffix, outputLen));
    exports.sha3_224 = gen2(6, 144, 224 / 8);
    exports.sha3_256 = gen2(6, 136, 256 / 8);
    exports.sha3_384 = gen2(6, 104, 384 / 8);
    exports.sha3_512 = gen2(6, 72, 512 / 8);
    exports.keccak_224 = gen2(1, 144, 224 / 8);
    exports.keccak_256 = gen2(1, 136, 256 / 8);
    exports.keccak_384 = gen2(1, 104, 384 / 8);
    exports.keccak_512 = gen2(1, 72, 512 / 8);
    var genShake2 = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake2(31, 168, 128 / 8);
    exports.shake256 = genShake2(31, 136, 256 / 8);
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/keccak256.js
var require_keccak256 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/keccak256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak256 = void 0;
    var sha3_1 = require_sha32();
    var isHex_js_1 = require_isHex();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function keccak2566(value, to_) {
      const to = to_ || "hex";
      const bytes4 = (0, sha3_1.keccak_256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
      if (to === "bytes")
        return bytes4;
      return (0, toHex_js_1.toHex)(bytes4);
    }
    exports.keccak256 = keccak2566;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/hashFunction.js
var require_hashFunction = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/hashFunction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashAbiItem = exports.hashFunction = void 0;
    var extractFunctionParts_js_1 = require_extractFunctionParts();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    var hash4 = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
    function hashFunction(def) {
      const name = (0, extractFunctionParts_js_1.extractFunctionName)(def);
      const params = (0, extractFunctionParts_js_1.extractFunctionParams)(def) || [];
      return hash4(`${name}(${params.map(({ type }) => type).join(",")})`);
    }
    exports.hashFunction = hashFunction;
    function hashAbiItem(def) {
      return hash4(`${def.name}(${def.inputs.map(({ type }) => type).join(",")})`);
    }
    exports.hashAbiItem = hashAbiItem;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/getEventSelector.js
var require_getEventSelector = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/getEventSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventSelector = void 0;
    var hashFunction_js_1 = require_hashFunction();
    var getEventSelector2 = (event) => {
      if (typeof event === "string")
        return (0, hashFunction_js_1.hashFunction)(event);
      return (0, hashFunction_js_1.hashAbiItem)(event);
    };
    exports.getEventSelector = getEventSelector2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/address.js
var require_address = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidAddressError = void 0;
    var base_js_1 = require_base2();
    var InvalidAddressError2 = class extends base_js_1.BaseError {
      constructor({ address }) {
        super(`Address "${address}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAddressError"
        });
      }
    };
    exports.InvalidAddressError = InvalidAddressError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/address/isAddress.js
var require_isAddress = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/address/isAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAddress = void 0;
    var addressRegex2 = /^0x[a-fA-F0-9]{40}$/;
    function isAddress2(address) {
      return addressRegex2.test(address);
    }
    exports.isAddress = isAddress2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/concat.js
var require_concat = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatHex = exports.concatBytes = exports.concat = void 0;
    function concat9(values) {
      if (typeof values[0] === "string")
        return concatHex2(values);
      return concatBytes4(values);
    }
    exports.concat = concat9;
    function concatBytes4(values) {
      let length = 0;
      for (const arr of values) {
        length += arr.length;
      }
      const result = new Uint8Array(length);
      let offset = 0;
      for (const arr of values) {
        result.set(arr, offset);
        offset += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes4;
    function concatHex2(values) {
      return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
    }
    exports.concatHex = concatHex2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/slice.js
var require_slice = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/slice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sliceHex = exports.sliceBytes = exports.slice = void 0;
    var data_js_1 = require_data();
    var isHex_js_1 = require_isHex();
    var size_js_1 = require_size();
    function slice2(value, start, end, { strict } = {}) {
      if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return sliceHex2(value, start, end, {
          strict
        });
      return sliceBytes2(value, start, end, {
        strict
      });
    }
    exports.slice = slice2;
    function assertStartOffset2(value, start) {
      if (typeof start === "number" && start > 0 && start > (0, size_js_1.size)(value) - 1)
        throw new data_js_1.SliceOffsetOutOfBoundsError({
          offset: start,
          position: "start",
          size: (0, size_js_1.size)(value)
        });
    }
    function assertEndOffset2(value, start, end) {
      if (typeof start === "number" && typeof end === "number" && (0, size_js_1.size)(value) !== end - start) {
        throw new data_js_1.SliceOffsetOutOfBoundsError({
          offset: end,
          position: "end",
          size: (0, size_js_1.size)(value)
        });
      }
    }
    function sliceBytes2(value_, start, end, { strict } = {}) {
      assertStartOffset2(value_, start);
      const value = value_.slice(start, end);
      if (strict)
        assertEndOffset2(value, start, end);
      return value;
    }
    exports.sliceBytes = sliceBytes2;
    function sliceHex2(value_, start, end, { strict } = {}) {
      assertStartOffset2(value_, start);
      const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
      if (strict)
        assertEndOffset2(value, start, end);
      return value;
    }
    exports.sliceHex = sliceHex2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeAbiParameters.js
var require_encodeAbiParameters = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeAbiParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getArrayComponents = exports.encodeAbiParameters = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var pad_js_1 = require_pad();
    var size_js_1 = require_size();
    var slice_js_1 = require_slice();
    var toHex_js_1 = require_toHex();
    function encodeAbiParameters2(params, values) {
      if (params.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
          expectedLength: params.length,
          givenLength: values.length
        });
      const preparedParams = prepareParams2({
        params,
        values
      });
      const data = encodeParams2(preparedParams);
      if (data.length === 0)
        return "0x";
      return data;
    }
    exports.encodeAbiParameters = encodeAbiParameters2;
    function prepareParams2({ params, values }) {
      const preparedParams = [];
      for (let i = 0; i < params.length; i++) {
        preparedParams.push(prepareParam2({ param: params[i], value: values[i] }));
      }
      return preparedParams;
    }
    function prepareParam2({ param, value }) {
      const arrayComponents = getArrayComponents2(param.type);
      if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray2(value, { length, param: { ...param, type } });
      }
      if (param.type === "tuple") {
        return encodeTuple2(value, {
          param
        });
      }
      if (param.type === "address") {
        return encodeAddress2(value);
      }
      if (param.type === "bool") {
        return encodeBool2(value);
      }
      if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        const signed = param.type.startsWith("int");
        return encodeNumber2(value, { signed });
      }
      if (param.type.startsWith("bytes")) {
        return encodeBytes2(value, { param });
      }
      if (param.type === "string") {
        return encodeString2(value);
      }
      throw new abi_js_1.InvalidAbiEncodingTypeError(param.type, {
        docsPath: "/docs/contract/encodeAbiParameters"
      });
    }
    function encodeParams2(preparedParams) {
      let staticSize = 0;
      for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic)
          staticSize += 32;
        else
          staticSize += (0, size_js_1.size)(encoded);
      }
      const staticParams = [];
      const dynamicParams = [];
      let dynamicSize = 0;
      for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
          staticParams.push((0, toHex_js_1.numberToHex)(staticSize + dynamicSize, { size: 32 }));
          dynamicParams.push(encoded);
          dynamicSize += (0, size_js_1.size)(encoded);
        } else {
          staticParams.push(encoded);
        }
      }
      return (0, concat_js_1.concat)([...staticParams, ...dynamicParams]);
    }
    function encodeAddress2(value) {
      if (!(0, isAddress_js_1.isAddress)(value))
        throw new address_js_1.InvalidAddressError({ address: value });
      return { dynamic: false, encoded: (0, pad_js_1.padHex)(value.toLowerCase()) };
    }
    function encodeArray2(value, { length, param }) {
      const dynamic = length === null;
      if (!Array.isArray(value))
        throw new abi_js_1.InvalidArrayError(value);
      if (!dynamic && value.length !== length)
        throw new abi_js_1.AbiEncodingArrayLengthMismatchError({
          expectedLength: length,
          givenLength: value.length,
          type: `${param.type}[${length}]`
        });
      let dynamicChild = false;
      const preparedParams = [];
      for (let i = 0; i < value.length; i++) {
        const preparedParam = prepareParam2({ param, value: value[i] });
        if (preparedParam.dynamic)
          dynamicChild = true;
        preparedParams.push(preparedParam);
      }
      if (dynamic || dynamicChild) {
        const data = encodeParams2(preparedParams);
        if (dynamic) {
          const length2 = (0, toHex_js_1.numberToHex)(preparedParams.length, { size: 32 });
          return {
            dynamic: true,
            encoded: preparedParams.length > 0 ? (0, concat_js_1.concat)([length2, data]) : length2
          };
        }
        if (dynamicChild)
          return { dynamic: true, encoded: data };
      }
      return {
        dynamic: false,
        encoded: (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
      };
    }
    function encodeBytes2(value, { param }) {
      const [_, size_] = param.type.split("bytes");
      if (!size_) {
        const partsLength = Math.ceil((0, size_js_1.size)(value) / 32);
        const parts = [];
        for (let i = 0; i < partsLength; i++) {
          parts.push((0, pad_js_1.padHex)((0, slice_js_1.slice)(value, i * 32, (i + 1) * 32), {
            dir: "right"
          }));
        }
        return {
          dynamic: true,
          encoded: (0, concat_js_1.concat)([
            (0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)((0, size_js_1.size)(value), { size: 32 })),
            ...parts
          ])
        };
      }
      if ((0, size_js_1.size)(value) !== parseInt(size_))
        throw new abi_js_1.AbiEncodingBytesSizeMismatchError({
          expectedSize: parseInt(size_),
          value
        });
      return { dynamic: false, encoded: (0, pad_js_1.padHex)(value, { dir: "right" }) };
    }
    function encodeBool2(value) {
      return { dynamic: false, encoded: (0, pad_js_1.padHex)((0, toHex_js_1.boolToHex)(value)) };
    }
    function encodeNumber2(value, { signed }) {
      return {
        dynamic: false,
        encoded: (0, toHex_js_1.numberToHex)(value, {
          size: 32,
          signed
        })
      };
    }
    function encodeString2(value) {
      const hexValue2 = (0, toHex_js_1.stringToHex)(value);
      const partsLength = Math.ceil((0, size_js_1.size)(hexValue2) / 32);
      const parts = [];
      for (let i = 0; i < partsLength; i++) {
        parts.push((0, pad_js_1.padHex)((0, slice_js_1.slice)(hexValue2, i * 32, (i + 1) * 32), {
          dir: "right"
        }));
      }
      return {
        dynamic: true,
        encoded: (0, concat_js_1.concat)([
          (0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)((0, size_js_1.size)(hexValue2), { size: 32 })),
          ...parts
        ])
      };
    }
    function encodeTuple2(value, { param }) {
      let dynamic = false;
      const preparedParams = [];
      for (let i = 0; i < param.components.length; i++) {
        const param_ = param.components[i];
        const index2 = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParam2({
          param: param_,
          value: value[index2]
        });
        preparedParams.push(preparedParam);
        if (preparedParam.dynamic)
          dynamic = true;
      }
      return {
        dynamic,
        encoded: dynamic ? encodeParams2(preparedParams) : (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
      };
    }
    function getArrayComponents2(type) {
      const matches = type.match(/^(.*)\[(\d+)?\]$/);
      return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : void 0;
    }
    exports.getArrayComponents = getArrayComponents2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/getAbiItem.js
var require_getAbiItem = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/getAbiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArgOfType = exports.getAbiItem = void 0;
    var isAddress_js_1 = require_isAddress();
    function getAbiItem2({ abi, args = [], name }) {
      const abiItems = abi.filter((x) => "name" in x && x.name === name);
      if (abiItems.length === 0)
        return void 0;
      if (abiItems.length === 1)
        return abiItems[0];
      for (const abiItem of abiItems) {
        if (!("inputs" in abiItem))
          continue;
        if (!args || args.length === 0) {
          if (!abiItem.inputs || abiItem.inputs.length === 0)
            return abiItem;
          continue;
        }
        if (!abiItem.inputs)
          continue;
        if (abiItem.inputs.length === 0)
          continue;
        if (abiItem.inputs.length !== args.length)
          continue;
        const matched = args.every((arg, index2) => {
          const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
          if (!abiParameter)
            return false;
          return isArgOfType2(arg, abiParameter);
        });
        if (matched)
          return abiItem;
      }
      return abiItems[0];
    }
    exports.getAbiItem = getAbiItem2;
    function isArgOfType2(arg, abiParameter) {
      const argType = typeof arg;
      const abiParameterType = abiParameter.type;
      switch (abiParameterType) {
        case "address":
          return (0, isAddress_js_1.isAddress)(arg);
        case "bool":
          return argType === "boolean";
        case "function":
          return argType === "string";
        case "string":
          return argType === "string";
        default: {
          if (abiParameterType === "tuple" && "components" in abiParameter)
            return Object.values(abiParameter.components).every((component, index2) => {
              return isArgOfType2(Object.values(arg)[index2], component);
            });
          if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
            return argType === "number" || argType === "bigint";
          if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
            return argType === "string" || arg instanceof Uint8Array;
          if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
            return Array.isArray(arg) && arg.every((x) => isArgOfType2(x, {
              ...abiParameter,
              type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
            }));
          }
          return false;
        }
      }
    }
    exports.isArgOfType = isArgOfType2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeEventTopics.js
var require_encodeEventTopics = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeEventTopics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeEventTopics = void 0;
    var abi_js_1 = require_abi();
    var log_js_1 = require_log();
    var toBytes_js_1 = require_toBytes();
    var getEventSelector_js_1 = require_getEventSelector();
    var keccak256_js_1 = require_keccak256();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    var getAbiItem_js_1 = require_getAbiItem();
    function encodeEventTopics2({ abi, eventName, args }) {
      let abiItem = abi[0];
      if (eventName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: eventName
        });
        if (!abiItem)
          throw new abi_js_1.AbiEventNotFoundError(eventName, {
            docsPath: "/docs/contract/encodeEventTopics"
          });
      }
      if (abiItem.type !== "event")
        throw new abi_js_1.AbiEventNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeEventTopics"
        });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getEventSelector_js_1.getEventSelector)(definition);
      let topics = [];
      if (args && "inputs" in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
        const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
        if (args_.length > 0) {
          topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg2({ param, value: args_[i][j] })) : args_[i] ? encodeArg2({ param, value: args_[i] }) : null) ?? [];
        }
      }
      return [signature, ...topics];
    }
    exports.encodeEventTopics = encodeEventTopics2;
    function encodeArg2({ param, value }) {
      if (param.type === "string" || param.type === "bytes")
        return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
      if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        throw new log_js_1.FilterTypeNotSupportedError(param.type);
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/filters/createFilterRequestScope.js
var require_createFilterRequestScope = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/filters/createFilterRequestScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFilterRequestScope = void 0;
    function createFilterRequestScope2(client, { method }) {
      const requestMap = {};
      if (client.transport.type === "fallback")
        client.transport.onResponse?.(({ method: method_, response: id4, status, transport }) => {
          if (status === "success" && method === method_)
            requestMap[id4] = transport.request;
        });
      return (id4) => requestMap[id4] || client.request;
    }
    exports.createFilterRequestScope = createFilterRequestScope2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/createContractEventFilter.js
var require_createContractEventFilter = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/createContractEventFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createContractEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createContractEventFilter2(client, { address, abi, args, eventName, fromBlock, strict, toBlock }) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
        abi,
        args,
        eventName
      }) : void 0;
      const id4 = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            topics
          }
        ]
      });
      return {
        abi,
        args,
        eventName,
        id: id4,
        request: getRequest(id4),
        strict,
        type: "event"
      };
    }
    exports.createContractEventFilter = createContractEventFilter2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/accounts/utils/parseAccount.js
var require_parseAccount = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/accounts/utils/parseAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAccount = void 0;
    function parseAccount2(account) {
      if (typeof account === "string")
        return { address: account, type: "json-rpc" };
      return account;
    }
    exports.parseAccount = parseAccount2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/getFunctionSelector.js
var require_getFunctionSelector = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/getFunctionSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctionSelector = void 0;
    var slice_js_1 = require_slice();
    var hashFunction_js_1 = require_hashFunction();
    var getFunctionSelector2 = (fn) => {
      if (typeof fn === "string")
        return (0, slice_js_1.slice)((0, hashFunction_js_1.hashFunction)(fn), 0, 4);
      return (0, slice_js_1.slice)((0, hashFunction_js_1.hashAbiItem)(fn), 0, 4);
    };
    exports.getFunctionSelector = getFunctionSelector2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeFunctionData.js
var require_encodeFunctionData = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeFunctionData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFunctionData = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    var getAbiItem_js_1 = require_getAbiItem();
    function encodeFunctionData2({ abi, args, functionName }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
            docsPath: "/docs/contract/encodeFunctionData"
          });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeFunctionData"
        });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
      const data = "inputs" in abiItem && abiItem.inputs ? (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args ?? []) : void 0;
      return (0, concat_js_1.concatHex)([signature, data ?? "0x"]);
    }
    exports.encodeFunctionData = encodeFunctionData2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/solidity.js
var require_solidity = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/solidity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.solidityPanic = exports.solidityError = exports.panicReasons = void 0;
    exports.panicReasons = {
      1: "An `assert` condition failed.",
      17: "Arithmic operation resulted in underflow or overflow.",
      18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
      33: "Attempted to convert to an invalid type.",
      34: "Attempted to access a storage byte array that is incorrectly encoded.",
      49: "Performed `.pop()` on an empty array",
      50: "Array index is out of bounds.",
      65: "Allocated too much memory or created an array which is too large.",
      81: "Attempted to call a zero-initialized variable of internal function type."
    };
    exports.solidityError = {
      inputs: [
        {
          name: "message",
          type: "string"
        }
      ],
      name: "Error",
      type: "error"
    };
    exports.solidityPanic = {
      inputs: [
        {
          name: "reason",
          type: "uint256"
        }
      ],
      name: "Panic",
      type: "error"
    };
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/address/getAddress.js
var require_getAddress = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/address/getAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddress = exports.checksumAddress = void 0;
    var address_js_1 = require_address();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    var isAddress_js_1 = require_isAddress();
    function checksumAddress2(address_, chainId) {
      const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
      const hash4 = (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(hexAddress), "bytes");
      const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
      for (let i = 0; i < 40; i += 2) {
        if (hash4[i >> 1] >> 4 >= 8 && address[i]) {
          address[i] = address[i].toUpperCase();
        }
        if ((hash4[i >> 1] & 15) >= 8 && address[i + 1]) {
          address[i + 1] = address[i + 1].toUpperCase();
        }
      }
      return `0x${address.join("")}`;
    }
    exports.checksumAddress = checksumAddress2;
    function getAddress7(address, chainId) {
      if (!(0, isAddress_js_1.isAddress)(address))
        throw new address_js_1.InvalidAddressError({ address });
      return checksumAddress2(address, chainId);
    }
    exports.getAddress = getAddress7;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeAbiParameters.js
var require_decodeAbiParameters = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeAbiParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeAbiParameters = void 0;
    var abi_js_1 = require_abi();
    var getAddress_js_1 = require_getAddress();
    var size_js_1 = require_size();
    var slice_js_1 = require_slice();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    function decodeAbiParameters2(params, data) {
      if (data === "0x" && params.length > 0)
        throw new abi_js_1.AbiDecodingZeroDataError();
      if ((0, size_js_1.size)(data) && (0, size_js_1.size)(data) < 32)
        throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
          data,
          params,
          size: (0, size_js_1.size)(data)
        });
      return decodeParams2({
        data,
        params
      });
    }
    exports.decodeAbiParameters = decodeAbiParameters2;
    function decodeParams2({ data, params }) {
      const decodedValues = [];
      let position = 0;
      for (let i = 0; i < params.length; i++) {
        if (position >= (0, size_js_1.size)(data))
          throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
            data,
            params,
            size: (0, size_js_1.size)(data)
          });
        const param = params[i];
        const { consumed, value } = decodeParam2({ data, param, position });
        decodedValues.push(value);
        position += consumed;
      }
      return decodedValues;
    }
    function decodeParam2({ data, param, position }) {
      const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
      if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray2(data, {
          length,
          param: { ...param, type },
          position
        });
      }
      if (param.type === "tuple") {
        return decodeTuple2(data, { param, position });
      }
      if (param.type === "string") {
        return decodeString2(data, { position });
      }
      if (param.type.startsWith("bytes")) {
        return decodeBytes2(data, { param, position });
      }
      const value = (0, slice_js_1.slice)(data, position, position + 32, { strict: true });
      if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        return decodeNumber2(value, { param });
      }
      if (param.type === "address") {
        return decodeAddress2(value);
      }
      if (param.type === "bool") {
        return decodeBool2(value);
      }
      throw new abi_js_1.InvalidAbiDecodingTypeError(param.type, {
        docsPath: "/docs/contract/decodeAbiParameters"
      });
    }
    function decodeAddress2(value) {
      return { consumed: 32, value: (0, getAddress_js_1.checksumAddress)((0, slice_js_1.slice)(value, -20)) };
    }
    function decodeArray2(data, { param, length, position }) {
      if (!length) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length2 = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        let consumed2 = 0;
        const value2 = [];
        for (let i = 0; i < length2; ++i) {
          const decodedChild = decodeParam2({
            data: (0, slice_js_1.slice)(data, offset + 32),
            param,
            position: consumed2
          });
          consumed2 += decodedChild.consumed;
          value2.push(decodedChild.value);
        }
        return { value: value2, consumed: 32 };
      }
      if (hasDynamicChild2(param)) {
        const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
        const dynamicChild = !arrayComponents?.[0];
        let consumed2 = 0;
        const value2 = [];
        for (let i = 0; i < length; ++i) {
          const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
          const decodedChild = decodeParam2({
            data: (0, slice_js_1.slice)(data, offset),
            param,
            position: dynamicChild ? consumed2 : i * 32
          });
          consumed2 += decodedChild.consumed;
          value2.push(decodedChild.value);
        }
        return { value: value2, consumed: 32 };
      }
      let consumed = 0;
      const value = [];
      for (let i = 0; i < length; ++i) {
        const decodedChild = decodeParam2({
          data,
          param,
          position: position + consumed
        });
        consumed += decodedChild.consumed;
        value.push(decodedChild.value);
      }
      return { value, consumed };
    }
    function decodeBool2(value) {
      return { consumed: 32, value: (0, fromHex_js_1.hexToBool)(value) };
    }
    function decodeBytes2(data, { param, position }) {
      const [_, size3] = param.type.split("bytes");
      if (!size3) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        if (length === 0)
          return { consumed: 32, value: "0x" };
        const value2 = (0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, {
          strict: true
        });
        return { consumed: 32, value: value2 };
      }
      const value = (0, slice_js_1.slice)(data, position, position + parseInt(size3), {
        strict: true
      });
      return { consumed: 32, value };
    }
    function decodeNumber2(value, { param }) {
      const signed = param.type.startsWith("int");
      const size3 = parseInt(param.type.split("int")[1] || "256");
      return {
        consumed: 32,
        value: size3 > 48 ? (0, fromHex_js_1.hexToBigInt)(value, { signed }) : (0, fromHex_js_1.hexToNumber)(value, { signed })
      };
    }
    function decodeString2(data, { position }) {
      const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
      const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
      if (length === 0)
        return { consumed: 32, value: "" };
      const value = (0, fromHex_js_1.hexToString)((0, trim_js_1.trim)((0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, { strict: true })));
      return { consumed: 32, value };
    }
    function decodeTuple2(data, { param, position }) {
      const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
      const value = hasUnnamedChild ? [] : {};
      let consumed = 0;
      if (hasDynamicChild2(param)) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        for (let i = 0; i < param.components.length; ++i) {
          const component = param.components[i];
          const decodedChild = decodeParam2({
            data: (0, slice_js_1.slice)(data, offset),
            param: component,
            position: consumed
          });
          consumed += decodedChild.consumed;
          value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
        }
        return { consumed: 32, value };
      }
      for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        const decodedChild = decodeParam2({
          data,
          param: component,
          position: position + consumed
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
      }
      return { consumed, value };
    }
    function hasDynamicChild2(param) {
      const { type } = param;
      if (type === "string")
        return true;
      if (type === "bytes")
        return true;
      if (type.endsWith("[]"))
        return true;
      if (type === "tuple")
        return param.components?.some(hasDynamicChild2);
      const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
      if (arrayComponents && hasDynamicChild2({ ...param, type: arrayComponents[1] }))
        return true;
      return false;
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeErrorResult.js
var require_decodeErrorResult = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeErrorResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeErrorResult = void 0;
    var solidity_js_1 = require_solidity();
    var abi_js_1 = require_abi();
    var slice_js_1 = require_slice();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    function decodeErrorResult2({ abi, data }) {
      const signature = (0, slice_js_1.slice)(data, 0, 4);
      if (signature === "0x")
        throw new abi_js_1.AbiDecodingZeroDataError();
      const abi_ = [...abi || [], solidity_js_1.solidityError, solidity_js_1.solidityPanic];
      const abiItem = abi_.find((x) => x.type === "error" && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!abiItem)
        throw new abi_js_1.AbiErrorSignatureNotFoundError(signature, {
          docsPath: "/docs/contract/decodeErrorResult"
        });
      return {
        abiItem,
        args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.inputs, (0, slice_js_1.slice)(data, 4)) : void 0,
        errorName: abiItem.name
      };
    }
    exports.decodeErrorResult = decodeErrorResult2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/stringify.js
var require_stringify = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = void 0;
    var stringify3 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
      const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
      return typeof replacer === "function" ? replacer(key, value2) : value2;
    }, space);
    exports.stringify = stringify3;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/formatAbiItemWithArgs.js
var require_formatAbiItemWithArgs = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/formatAbiItemWithArgs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiItemWithArgs = void 0;
    var stringify_js_1 = require_stringify();
    function formatAbiItemWithArgs2({ abiItem, args, includeFunctionName = true, includeName = false }) {
      if (!("name" in abiItem))
        return;
      if (!("inputs" in abiItem))
        return;
      if (!abiItem.inputs)
        return;
      return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? (0, stringify_js_1.stringify)(args[i]) : args[i]}`).join(", ")})`;
    }
    exports.formatAbiItemWithArgs = formatAbiItemWithArgs2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/unit.js
var require_unit = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/unit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.weiUnits = exports.gweiUnits = exports.etherUnits = void 0;
    exports.etherUnits = {
      gwei: 9,
      wei: 18
    };
    exports.gweiUnits = {
      ether: -9,
      wei: 9
    };
    exports.weiUnits = {
      ether: -18,
      gwei: -9
    };
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/formatUnits.js
var require_formatUnits = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/formatUnits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatUnits = void 0;
    function formatUnits3(value, decimals) {
      let display = value.toString();
      const negative = display.startsWith("-");
      if (negative)
        display = display.slice(1);
      display = display.padStart(decimals, "0");
      let [integer, fraction] = [
        display.slice(0, display.length - decimals),
        display.slice(display.length - decimals)
      ];
      fraction = fraction.replace(/(0+)$/, "");
      return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
    }
    exports.formatUnits = formatUnits3;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/formatEther.js
var require_formatEther = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/formatEther.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatEther = void 0;
    var unit_js_1 = require_unit();
    var formatUnits_js_1 = require_formatUnits();
    function formatEther3(wei, unit = "wei") {
      return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.etherUnits[unit]);
    }
    exports.formatEther = formatEther3;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/formatGwei.js
var require_formatGwei = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/formatGwei.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatGwei = void 0;
    var unit_js_1 = require_unit();
    var formatUnits_js_1 = require_formatUnits();
    function formatGwei2(wei, unit = "wei") {
      return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.gweiUnits[unit]);
    }
    exports.formatGwei = formatGwei2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/transaction.js
var require_transaction = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.prettyPrint = void 0;
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base2();
    function prettyPrint2(args) {
      const entries = Object.entries(args).map(([key, value]) => {
        if (value === void 0 || value === false)
          return null;
        return [key, value];
      }).filter(Boolean);
      const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
      return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
    }
    exports.prettyPrint = prettyPrint2;
    var FeeConflictError2 = class extends base_js_1.BaseError {
      constructor() {
        super([
          "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
          "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeConflictError"
        });
      }
    };
    exports.FeeConflictError = FeeConflictError2;
    var InvalidLegacyVError = class extends base_js_1.BaseError {
      constructor({ v }) {
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidLegacyVError"
        });
      }
    };
    exports.InvalidLegacyVError = InvalidLegacyVError;
    var InvalidSerializableTransactionError2 = class extends base_js_1.BaseError {
      constructor({ transaction }) {
        super("Cannot infer a transaction type from provided transaction.", {
          metaMessages: [
            "Provided Transaction:",
            "{",
            prettyPrint2(transaction),
            "}",
            "",
            "To infer the type, either provide:",
            "- a `type` to the Transaction, or",
            "- an EIP-1559 Transaction with `maxFeePerGas`, or",
            "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
            "- a Legacy Transaction with `gasPrice`"
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializableTransactionError"
        });
      }
    };
    exports.InvalidSerializableTransactionError = InvalidSerializableTransactionError2;
    var InvalidSerializedTransactionTypeError = class extends base_js_1.BaseError {
      constructor({ serializedType }) {
        super(`Serialized transaction type "${serializedType}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializedTransactionType"
        });
        Object.defineProperty(this, "serializedType", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.serializedType = serializedType;
      }
    };
    exports.InvalidSerializedTransactionTypeError = InvalidSerializedTransactionTypeError;
    var InvalidSerializedTransactionError = class extends base_js_1.BaseError {
      constructor({ attributes, serializedTransaction, type }) {
        const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
        super(`Invalid serialized transaction of type "${type}" was provided.`, {
          metaMessages: [
            `Serialized Transaction: "${serializedTransaction}"`,
            missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializedTransactionError"
        });
        Object.defineProperty(this, "serializedTransaction", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "type", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.serializedTransaction = serializedTransaction;
        this.type = type;
      }
    };
    exports.InvalidSerializedTransactionError = InvalidSerializedTransactionError;
    var InvalidStorageKeySizeError = class extends base_js_1.BaseError {
      constructor({ storageKey }) {
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStorageKeySizeError"
        });
      }
    };
    exports.InvalidStorageKeySizeError = InvalidStorageKeySizeError;
    var TransactionExecutionError2 = class extends base_js_1.BaseError {
      constructor(cause, { account, docsPath: docsPath4, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = prettyPrint2({
          chain: chain && `${chain?.name} (id: ${chain?.id})`,
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath: docsPath4,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Request Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.TransactionExecutionError = TransactionExecutionError2;
    var TransactionNotFoundError2 = class extends base_js_1.BaseError {
      constructor({ blockHash, blockNumber, blockTag, hash: hash4, index: index2 }) {
        let identifier = "Transaction";
        if (blockTag && index2 !== void 0)
          identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
        if (blockHash && index2 !== void 0)
          identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
        if (blockNumber && index2 !== void 0)
          identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
        if (hash4)
          identifier = `Transaction with hash "${hash4}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionNotFoundError"
        });
      }
    };
    exports.TransactionNotFoundError = TransactionNotFoundError2;
    var TransactionReceiptNotFoundError2 = class extends base_js_1.BaseError {
      constructor({ hash: hash4 }) {
        super(`Transaction receipt with hash "${hash4}" could not be found. The Transaction may not be processed on a block yet.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionReceiptNotFoundError"
        });
      }
    };
    exports.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError2;
    var WaitForTransactionReceiptTimeoutError2 = class extends base_js_1.BaseError {
      constructor({ hash: hash4 }) {
        super(`Timed out while waiting for transaction with hash "${hash4}" to be confirmed.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WaitForTransactionReceiptTimeoutError"
        });
      }
    };
    exports.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/contract.js
var require_contract = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var solidity_js_1 = require_solidity();
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    var formatAbiItem_js_1 = require_formatAbiItem();
    var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
    var getAbiItem_js_1 = require_getAbiItem();
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base2();
    var transaction_js_1 = require_transaction();
    var utils_js_1 = require_utils6();
    var CallExecutionError2 = class extends base_js_1.BaseError {
      constructor(cause, { account: account_, docsPath: docsPath4, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath: docsPath4,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Raw Call Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CallExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.CallExecutionError = CallExecutionError2;
    var ContractFunctionExecutionError2 = class extends base_js_1.BaseError {
      constructor(cause, { abi, args, contractAddress, docsPath: docsPath4, functionName, sender }) {
        const abiItem = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: functionName });
        const formattedArgs = abiItem ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
          abiItem,
          args,
          includeFunctionName: false,
          includeName: false
        }) : void 0;
        const functionWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : void 0;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          address: contractAddress && (0, utils_js_1.getContractAddress)(contractAddress),
          function: functionWithParams,
          args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
          sender
        });
        super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
          cause,
          docsPath: docsPath4,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Contract Call:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "abi", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "args", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "contractAddress", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "formattedArgs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "functionName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "sender", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionExecutionError"
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
      }
    };
    exports.ContractFunctionExecutionError = ContractFunctionExecutionError2;
    var ContractFunctionRevertedError2 = class extends base_js_1.BaseError {
      constructor({ abi, data, functionName, message }) {
        let decodedData = void 0;
        let metaMessages;
        let reason;
        if (data && data !== "0x") {
          decodedData = (0, decodeErrorResult_js_1.decodeErrorResult)({ abi, data });
          const { abiItem, errorName, args: errorArgs } = decodedData;
          if (errorName === "Error") {
            reason = errorArgs[0];
          } else if (errorName === "Panic") {
            const [firstArg] = errorArgs;
            reason = solidity_js_1.panicReasons[firstArg];
          } else {
            const errorWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : void 0;
            const formattedArgs = abiItem && errorArgs ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
              abiItem,
              args: errorArgs,
              includeFunctionName: false,
              includeName: false
            }) : void 0;
            metaMessages = [
              errorWithParams ? `Error: ${errorWithParams}` : "",
              formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
            ];
          }
        } else if (message)
          reason = message;
        super(reason && reason !== "execution reverted" ? [
          `The contract function "${functionName}" reverted with the following reason:`,
          reason
        ].join("\n") : `The contract function "${functionName}" reverted.`, {
          metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionRevertedError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "reason", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.reason = reason;
        this.data = decodedData;
      }
    };
    exports.ContractFunctionRevertedError = ContractFunctionRevertedError2;
    var ContractFunctionZeroDataError2 = class extends base_js_1.BaseError {
      constructor({ functionName }) {
        super(`The contract function "${functionName}" returned no data ("0x").`, {
          metaMessages: [
            "This could be due to any of the following:",
            `  - The contract does not have the function "${functionName}",`,
            "  - The parameters passed to the contract function may be invalid, or",
            "  - The address is not a contract."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionZeroDataError"
        });
      }
    };
    exports.ContractFunctionZeroDataError = ContractFunctionZeroDataError2;
    var RawContractError2 = class extends base_js_1.BaseError {
      constructor({ data, message }) {
        super(message || "");
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 3
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RawContractError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
      }
    };
    exports.RawContractError = RawContractError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getContractError.js
var require_getContractError = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getContractError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContractError = void 0;
    var abi_js_1 = require_abi();
    var base_js_1 = require_base2();
    var contract_js_1 = require_contract();
    var EXECUTION_REVERTED_ERROR_CODE2 = 3;
    function getContractError2(err, { abi, address, args, docsPath: docsPath4, functionName, sender }) {
      const { code, data, message, shortMessage } = err instanceof contract_js_1.RawContractError ? err : err instanceof base_js_1.BaseError ? err.walk((err2) => "data" in err2) : {};
      let cause = err;
      if (err instanceof abi_js_1.AbiDecodingZeroDataError) {
        cause = new contract_js_1.ContractFunctionZeroDataError({ functionName });
      } else if (code === EXECUTION_REVERTED_ERROR_CODE2 && (data || message || shortMessage)) {
        cause = new contract_js_1.ContractFunctionRevertedError({
          abi,
          data: typeof data === "object" ? data.data : data,
          functionName,
          message: shortMessage ?? message
        });
      }
      return new contract_js_1.ContractFunctionExecutionError(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath: docsPath4,
        functionName,
        sender
      });
    }
    exports.getContractError = getContractError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/account.js
var require_account = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountNotFoundError = void 0;
    var base_js_1 = require_base2();
    var AccountNotFoundError2 = class extends base_js_1.BaseError {
      constructor({ docsPath: docsPath4 } = {}) {
        super([
          "Could not find an Account to execute with this Action.",
          "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
        ].join("\n"), {
          docsPath: docsPath4,
          docsSlug: "account"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AccountNotFoundError"
        });
      }
    };
    exports.AccountNotFoundError = AccountNotFoundError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/estimateGas.js
var require_estimateGas = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/estimateGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EstimateGasExecutionError = void 0;
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base2();
    var transaction_js_1 = require_transaction();
    var EstimateGasExecutionError2 = class extends base_js_1.BaseError {
      constructor(cause, { account, docsPath: docsPath4, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath: docsPath4,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Estimate Gas Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EstimateGasExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.EstimateGasExecutionError = EstimateGasExecutionError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/node.js
var require_node = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownNodeError = exports.TipAboveFeeCapError = exports.TransactionTypeNotSupportedError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.NonceMaxValueError = exports.NonceTooLowError = exports.NonceTooHighError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = void 0;
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base2();
    var ExecutionRevertedError2 = class extends base_js_1.BaseError {
      constructor({ cause, message } = {}) {
        const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ExecutionRevertedError"
        });
      }
    };
    Object.defineProperty(ExecutionRevertedError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(ExecutionRevertedError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /execution reverted/
    });
    exports.ExecutionRevertedError = ExecutionRevertedError2;
    var FeeCapTooHighError2 = class extends base_js_1.BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooHigh"
        });
      }
    };
    Object.defineProperty(FeeCapTooHighError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    exports.FeeCapTooHighError = FeeCapTooHighError2;
    var FeeCapTooLowError2 = class extends base_js_1.BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooLow"
        });
      }
    };
    Object.defineProperty(FeeCapTooLowError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    exports.FeeCapTooLowError = FeeCapTooLowError2;
    var NonceTooHighError2 = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooHighError"
        });
      }
    };
    Object.defineProperty(NonceTooHighError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too high/
    });
    exports.NonceTooHighError = NonceTooHighError2;
    var NonceTooLowError2 = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super([
          `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
          "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
        ].join("\n"), { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooLowError"
        });
      }
    };
    Object.defineProperty(NonceTooLowError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too low|transaction already imported/
    });
    exports.NonceTooLowError = NonceTooLowError2;
    var NonceMaxValueError2 = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceMaxValueError"
        });
      }
    };
    Object.defineProperty(NonceMaxValueError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce has max value/
    });
    exports.NonceMaxValueError = NonceMaxValueError2;
    var InsufficientFundsError2 = class extends base_js_1.BaseError {
      constructor({ cause } = {}) {
        super([
          "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
        ].join("\n"), {
          cause,
          metaMessages: [
            "This error could arise when the account does not have enough funds to:",
            " - pay for the total gas fee,",
            " - pay for the value to send.",
            " ",
            "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
            " - `gas` is the amount of gas needed for transaction to execute,",
            " - `gas fee` is the gas fee,",
            " - `value` is the amount of ether to send to the recipient."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InsufficientFundsError"
        });
      }
    };
    Object.defineProperty(InsufficientFundsError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /insufficient funds/
    });
    exports.InsufficientFundsError = InsufficientFundsError2;
    var IntrinsicGasTooHighError2 = class extends base_js_1.BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooHighError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooHighError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too high|gas limit reached/
    });
    exports.IntrinsicGasTooHighError = IntrinsicGasTooHighError2;
    var IntrinsicGasTooLowError2 = class extends base_js_1.BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooLowError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooLowError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too low/
    });
    exports.IntrinsicGasTooLowError = IntrinsicGasTooLowError2;
    var TransactionTypeNotSupportedError2 = class extends base_js_1.BaseError {
      constructor({ cause }) {
        super("The transaction type is not supported for this chain.", {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionTypeNotSupportedError"
        });
      }
    };
    Object.defineProperty(TransactionTypeNotSupportedError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /transaction type not valid/
    });
    exports.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError2;
    var TipAboveFeeCapError2 = class extends base_js_1.BaseError {
      constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
        super([
          `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}).`
        ].join("\n"), {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TipAboveFeeCapError"
        });
      }
    };
    Object.defineProperty(TipAboveFeeCapError2, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
    exports.TipAboveFeeCapError = TipAboveFeeCapError2;
    var UnknownNodeError2 = class extends base_js_1.BaseError {
      constructor({ cause }) {
        super(`An error occurred while executing: ${cause?.message}`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownNodeError"
        });
      }
    };
    exports.UnknownNodeError = UnknownNodeError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/request.js
var require_request = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeoutError = exports.RpcRequestError = exports.WebSocketRequestError = exports.HttpRequestError = void 0;
    var stringify_js_1 = require_stringify();
    var base_js_1 = require_base2();
    var utils_js_1 = require_utils6();
    var HttpRequestError2 = class extends base_js_1.BaseError {
      constructor({ body, details, headers, status, url }) {
        super("HTTP request failed.", {
          details,
          metaMessages: [
            status && `Status: ${status}`,
            `URL: ${(0, utils_js_1.getUrl)(url)}`,
            body && `Request body: ${(0, stringify_js_1.stringify)(body)}`
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "HttpRequestError"
        });
        Object.defineProperty(this, "body", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "status", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "url", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
      }
    };
    exports.HttpRequestError = HttpRequestError2;
    var WebSocketRequestError = class extends base_js_1.BaseError {
      constructor({ body, details, url }) {
        super("WebSocket request failed.", {
          details,
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WebSocketRequestError"
        });
      }
    };
    exports.WebSocketRequestError = WebSocketRequestError;
    var RpcRequestError2 = class extends base_js_1.BaseError {
      constructor({ body, error, url }) {
        super("RPC Request failed.", {
          cause: error,
          details: error.message,
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcRequestError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.code = error.code;
      }
    };
    exports.RpcRequestError = RpcRequestError2;
    var TimeoutError = class extends base_js_1.BaseError {
      constructor({ body, url }) {
        super("The request took too long to respond.", {
          details: "The request timed out.",
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TimeoutError"
        });
      }
    };
    exports.TimeoutError = TimeoutError;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/rpc.js
var require_rpc = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/rpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownRpcError = exports.SwitchChainError = exports.ChainDisconnectedError = exports.ProviderDisconnectedError = exports.UnsupportedProviderMethodError = exports.UnauthorizedProviderError = exports.UserRejectedRequestError = exports.JsonRpcVersionUnsupportedError = exports.LimitExceededRpcError = exports.MethodNotSupportedRpcError = exports.TransactionRejectedRpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.InvalidParamsRpcError = exports.MethodNotFoundRpcError = exports.InvalidRequestRpcError = exports.ParseRpcError = exports.ProviderRpcError = exports.RpcError = void 0;
    var base_js_1 = require_base2();
    var request_js_1 = require_request();
    var unknownErrorCode2 = -1;
    var RpcError2 = class extends base_js_1.BaseError {
      constructor(cause, { code, docsPath: docsPath4, metaMessages, shortMessage }) {
        super(shortMessage, {
          cause,
          docsPath: docsPath4,
          metaMessages: metaMessages || cause?.metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = cause.name;
        this.code = cause instanceof request_js_1.RpcRequestError ? cause.code : code ?? unknownErrorCode2;
      }
    };
    exports.RpcError = RpcError2;
    var ProviderRpcError2 = class extends RpcError2 {
      constructor(cause, options) {
        super(cause, options);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderRpcError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = options.data;
      }
    };
    exports.ProviderRpcError = ProviderRpcError2;
    var ParseRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: ParseRpcError2.code,
          shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ParseRpcError"
        });
      }
    };
    Object.defineProperty(ParseRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    exports.ParseRpcError = ParseRpcError2;
    var InvalidRequestRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: InvalidRequestRpcError2.code,
          shortMessage: "JSON is not a valid request object."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidRequestRpcError"
        });
      }
    };
    Object.defineProperty(InvalidRequestRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    exports.InvalidRequestRpcError = InvalidRequestRpcError2;
    var MethodNotFoundRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: MethodNotFoundRpcError2.code,
          shortMessage: "The method does not exist / is not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotFoundRpcError"
        });
      }
    };
    Object.defineProperty(MethodNotFoundRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    exports.MethodNotFoundRpcError = MethodNotFoundRpcError2;
    var InvalidParamsRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: InvalidParamsRpcError2.code,
          shortMessage: [
            "Invalid parameters were provided to the RPC method.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParamsRpcError"
        });
      }
    };
    Object.defineProperty(InvalidParamsRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    exports.InvalidParamsRpcError = InvalidParamsRpcError2;
    var InternalRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: InternalRpcError2.code,
          shortMessage: "An internal error was received."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InternalRpcError"
        });
      }
    };
    Object.defineProperty(InternalRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    exports.InternalRpcError = InternalRpcError2;
    var InvalidInputRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: InvalidInputRpcError2.code,
          shortMessage: [
            "Missing or invalid parameters.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidInputRpcError"
        });
      }
    };
    Object.defineProperty(InvalidInputRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    exports.InvalidInputRpcError = InvalidInputRpcError2;
    var ResourceNotFoundRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: ResourceNotFoundRpcError2.code,
          shortMessage: "Requested resource not found."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceNotFoundRpcError"
        });
      }
    };
    Object.defineProperty(ResourceNotFoundRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    exports.ResourceNotFoundRpcError = ResourceNotFoundRpcError2;
    var ResourceUnavailableRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: ResourceUnavailableRpcError2.code,
          shortMessage: "Requested resource not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceUnavailableRpcError"
        });
      }
    };
    Object.defineProperty(ResourceUnavailableRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    exports.ResourceUnavailableRpcError = ResourceUnavailableRpcError2;
    var TransactionRejectedRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: TransactionRejectedRpcError2.code,
          shortMessage: "Transaction creation failed."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionRejectedRpcError"
        });
      }
    };
    Object.defineProperty(TransactionRejectedRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    exports.TransactionRejectedRpcError = TransactionRejectedRpcError2;
    var MethodNotSupportedRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: MethodNotSupportedRpcError2.code,
          shortMessage: "Method is not implemented."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotSupportedRpcError"
        });
      }
    };
    Object.defineProperty(MethodNotSupportedRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    exports.MethodNotSupportedRpcError = MethodNotSupportedRpcError2;
    var LimitExceededRpcError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: LimitExceededRpcError2.code,
          shortMessage: "Request exceeds defined limit."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "LimitExceededRpcError"
        });
      }
    };
    Object.defineProperty(LimitExceededRpcError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    exports.LimitExceededRpcError = LimitExceededRpcError2;
    var JsonRpcVersionUnsupportedError2 = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          code: JsonRpcVersionUnsupportedError2.code,
          shortMessage: "Version of JSON-RPC protocol is not supported."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "JsonRpcVersionUnsupportedError"
        });
      }
    };
    Object.defineProperty(JsonRpcVersionUnsupportedError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    exports.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError2;
    var UserRejectedRequestError2 = class extends ProviderRpcError2 {
      constructor(cause) {
        super(cause, {
          code: UserRejectedRequestError2.code,
          shortMessage: "User rejected the request."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UserRejectedRequestError"
        });
      }
    };
    Object.defineProperty(UserRejectedRequestError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    exports.UserRejectedRequestError = UserRejectedRequestError2;
    var UnauthorizedProviderError2 = class extends ProviderRpcError2 {
      constructor(cause) {
        super(cause, {
          code: UnauthorizedProviderError2.code,
          shortMessage: "The requested method and/or account has not been authorized by the user."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnauthorizedProviderError"
        });
      }
    };
    Object.defineProperty(UnauthorizedProviderError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    exports.UnauthorizedProviderError = UnauthorizedProviderError2;
    var UnsupportedProviderMethodError2 = class extends ProviderRpcError2 {
      constructor(cause) {
        super(cause, {
          code: UnsupportedProviderMethodError2.code,
          shortMessage: "The Provider does not support the requested method."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnsupportedProviderMethodError"
        });
      }
    };
    Object.defineProperty(UnsupportedProviderMethodError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    exports.UnsupportedProviderMethodError = UnsupportedProviderMethodError2;
    var ProviderDisconnectedError2 = class extends ProviderRpcError2 {
      constructor(cause) {
        super(cause, {
          code: ProviderDisconnectedError2.code,
          shortMessage: "The Provider is disconnected from all chains."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderDisconnectedError"
        });
      }
    };
    Object.defineProperty(ProviderDisconnectedError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    exports.ProviderDisconnectedError = ProviderDisconnectedError2;
    var ChainDisconnectedError2 = class extends ProviderRpcError2 {
      constructor(cause) {
        super(cause, {
          code: ChainDisconnectedError2.code,
          shortMessage: "The Provider is not connected to the requested chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDisconnectedError"
        });
      }
    };
    Object.defineProperty(ChainDisconnectedError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    exports.ChainDisconnectedError = ChainDisconnectedError2;
    var SwitchChainError2 = class extends ProviderRpcError2 {
      constructor(cause) {
        super(cause, {
          code: SwitchChainError2.code,
          shortMessage: "An error occurred when attempting to switch chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SwitchChainError"
        });
      }
    };
    Object.defineProperty(SwitchChainError2, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
    exports.SwitchChainError = SwitchChainError2;
    var UnknownRpcError = class extends RpcError2 {
      constructor(cause) {
        super(cause, {
          shortMessage: "An unknown RPC error occurred."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownRpcError"
        });
      }
    };
    exports.UnknownRpcError = UnknownRpcError;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getNodeError.js
var require_getNodeError = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getNodeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNodeError = exports.containsNodeError = void 0;
    var node_js_1 = require_node();
    var request_js_1 = require_request();
    var rpc_js_1 = require_rpc();
    function containsNodeError(err) {
      return err instanceof rpc_js_1.TransactionRejectedRpcError || err instanceof rpc_js_1.InvalidInputRpcError || err instanceof request_js_1.RpcRequestError && err.code === node_js_1.ExecutionRevertedError.code;
    }
    exports.containsNodeError = containsNodeError;
    function getNodeError2(err, args) {
      const message = err.details.toLowerCase();
      if (node_js_1.FeeCapTooHighError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooHighError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas
        });
      else if (node_js_1.FeeCapTooLowError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooLowError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas
        });
      else if (node_js_1.NonceTooHighError.nodeMessage.test(message))
        return new node_js_1.NonceTooHighError({ cause: err, nonce: args?.nonce });
      else if (node_js_1.NonceTooLowError.nodeMessage.test(message))
        return new node_js_1.NonceTooLowError({ cause: err, nonce: args?.nonce });
      else if (node_js_1.NonceMaxValueError.nodeMessage.test(message))
        return new node_js_1.NonceMaxValueError({ cause: err, nonce: args?.nonce });
      else if (node_js_1.InsufficientFundsError.nodeMessage.test(message))
        return new node_js_1.InsufficientFundsError({ cause: err });
      else if (node_js_1.IntrinsicGasTooHighError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
      else if (node_js_1.IntrinsicGasTooLowError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
      else if (node_js_1.TransactionTypeNotSupportedError.nodeMessage.test(message))
        return new node_js_1.TransactionTypeNotSupportedError({ cause: err });
      else if (node_js_1.TipAboveFeeCapError.nodeMessage.test(message))
        return new node_js_1.TipAboveFeeCapError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas,
          maxPriorityFeePerGas: args?.maxPriorityFeePerGas
        });
      else if (message.match(node_js_1.ExecutionRevertedError.nodeMessage) || "code" in err.cause && err.cause?.code === node_js_1.ExecutionRevertedError.code)
        return new node_js_1.ExecutionRevertedError({
          cause: err,
          message: err.cause.details || err.details
        });
      return new node_js_1.UnknownNodeError({
        cause: err.cause.cause
      });
    }
    exports.getNodeError = getNodeError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getEstimateGasError.js
var require_getEstimateGasError = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getEstimateGasError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEstimateGasError = void 0;
    var estimateGas_js_1 = require_estimateGas();
    var getNodeError_js_1 = require_getNodeError();
    function getEstimateGasError2(err, { docsPath: docsPath4, ...args }) {
      let cause = err;
      if ((0, getNodeError_js_1.containsNodeError)(err))
        cause = (0, getNodeError_js_1.getNodeError)(err, args);
      return new estimateGas_js_1.EstimateGasExecutionError(cause, {
        docsPath: docsPath4,
        ...args
      });
    }
    exports.getEstimateGasError = getEstimateGasError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/extract.js
var require_extract = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/extract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extract = void 0;
    function extract2(value, { format }) {
      if (!format)
        return {};
      const keys = Object.keys(format({}));
      return keys.reduce((data, key) => {
        if (value?.hasOwnProperty(key)) {
          ;
          data[key] = value[key];
        }
        return data;
      }, {});
    }
    exports.extract = extract2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/formatter.js
var require_formatter2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/formatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineFormatter = void 0;
    function defineFormatter(type, format) {
      return ({ exclude, format: overrides }) => {
        return {
          format: (args) => {
            const formatted = format(args);
            if (exclude) {
              for (const key of exclude) {
                delete formatted[key];
              }
            }
            return {
              ...formatted,
              ...overrides(args)
            };
          },
          type
        };
      };
    }
    exports.defineFormatter = defineFormatter;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/transactionRequest.js
var require_transactionRequest = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/transactionRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransactionRequest = exports.formatTransactionRequest = void 0;
    var toHex_js_1 = require_toHex();
    var formatter_js_1 = require_formatter2();
    function formatTransactionRequest2(transactionRequest) {
      return {
        ...transactionRequest,
        gas: typeof transactionRequest.gas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.gas) : void 0,
        gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.gasPrice) : void 0,
        maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.maxPriorityFeePerGas) : void 0,
        nonce: typeof transactionRequest.nonce !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.nonce) : void 0,
        value: typeof transactionRequest.value !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.value) : void 0
      };
    }
    exports.formatTransactionRequest = formatTransactionRequest2;
    exports.defineTransactionRequest = (0, formatter_js_1.defineFormatter)("transactionRequest", formatTransactionRequest2);
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/assertRequest.js
var require_assertRequest = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/assertRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertRequest = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var address_js_1 = require_address();
    var node_js_1 = require_node();
    var transaction_js_1 = require_transaction();
    var isAddress_js_1 = require_isAddress();
    function assertRequest2(args) {
      const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
      const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
      if (account && !(0, isAddress_js_1.isAddress)(account.address))
        throw new address_js_1.InvalidAddressError({ address: account.address });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
        throw new transaction_js_1.FeeConflictError();
      if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }
    exports.assertRequest = assertRequest2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/block.js
var require_block = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockNotFoundError = void 0;
    var base_js_1 = require_base2();
    var BlockNotFoundError2 = class extends base_js_1.BaseError {
      constructor({ blockHash, blockNumber }) {
        let identifier = "Block";
        if (blockHash)
          identifier = `Block at hash "${blockHash}"`;
        if (blockNumber)
          identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BlockNotFoundError"
        });
      }
    };
    exports.BlockNotFoundError = BlockNotFoundError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/transaction.js
var require_transaction2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransaction = exports.formatTransaction = exports.transactionType = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter2();
    exports.transactionType = {
      "0x0": "legacy",
      "0x1": "eip2930",
      "0x2": "eip1559"
    };
    function formatTransaction2(transaction) {
      const transaction_ = {
        ...transaction,
        blockHash: transaction.blockHash ? transaction.blockHash : null,
        blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
        chainId: transaction.chainId ? (0, fromHex_js_1.hexToNumber)(transaction.chainId) : void 0,
        gas: transaction.gas ? BigInt(transaction.gas) : void 0,
        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
        maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
        nonce: transaction.nonce ? (0, fromHex_js_1.hexToNumber)(transaction.nonce) : void 0,
        to: transaction.to ? transaction.to : null,
        transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
        type: transaction.type ? exports.transactionType[transaction.type] : void 0,
        typeHex: transaction.type ? transaction.type : void 0,
        value: transaction.value ? BigInt(transaction.value) : void 0,
        v: transaction.v ? BigInt(transaction.v) : void 0
      };
      if (transaction_.type === "legacy") {
        delete transaction_["accessList"];
        delete transaction_["maxFeePerGas"];
        delete transaction_["maxPriorityFeePerGas"];
      }
      if (transaction_.type === "eip2930") {
        delete transaction_["maxFeePerGas"];
        delete transaction_["maxPriorityFeePerGas"];
      }
      return transaction_;
    }
    exports.formatTransaction = formatTransaction2;
    exports.defineTransaction = (0, formatter_js_1.defineFormatter)("transaction", formatTransaction2);
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/block.js
var require_block2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineBlock = exports.formatBlock = void 0;
    var formatter_js_1 = require_formatter2();
    var transaction_js_1 = require_transaction2();
    function formatBlock3(block) {
      const transactions = block.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        return (0, transaction_js_1.formatTransaction)(transaction);
      });
      return {
        ...block,
        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
        difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
        hash: block.hash ? block.hash : null,
        logsBloom: block.logsBloom ? block.logsBloom : null,
        nonce: block.nonce ? block.nonce : null,
        number: block.number ? BigInt(block.number) : null,
        size: block.size ? BigInt(block.size) : void 0,
        timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
        transactions,
        totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
      };
    }
    exports.formatBlock = formatBlock3;
    exports.defineBlock = (0, formatter_js_1.defineFormatter)("block", formatBlock3);
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBlock.js
var require_getBlock = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlock = void 0;
    var block_js_1 = require_block();
    var toHex_js_1 = require_toHex();
    var block_js_2 = require_block2();
    async function getBlock2(client, { blockHash, blockNumber, blockTag = "latest", includeTransactions = false } = {}) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let block = null;
      if (blockHash) {
        block = await client.request({
          method: "eth_getBlockByHash",
          params: [blockHash, includeTransactions]
        });
      } else {
        block = await client.request({
          method: "eth_getBlockByNumber",
          params: [blockNumberHex || blockTag, includeTransactions]
        });
      }
      if (!block)
        throw new block_js_1.BlockNotFoundError({ blockHash, blockNumber });
      const format = client.chain?.formatters?.block?.format || block_js_2.formatBlock;
      return format(block);
    }
    exports.getBlock = getBlock2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getGasPrice.js
var require_getGasPrice = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getGasPrice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGasPrice = void 0;
    async function getGasPrice2(client) {
      const gasPrice = await client.request({
        method: "eth_gasPrice"
      });
      return BigInt(gasPrice);
    }
    exports.getGasPrice = getGasPrice2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getTransactionCount.js
var require_getTransactionCount = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getTransactionCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getTransactionCount2(client, { address, blockTag = "latest", blockNumber }) {
      const count = await client.request({
        method: "eth_getTransactionCount",
        params: [address, blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : blockTag]
      });
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports.getTransactionCount = getTransactionCount2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/prepareRequest.js
var require_prepareRequest = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/prepareRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareRequest = exports.defaultTip = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var estimateGas_js_1 = require_estimateGas2();
    var getBlock_js_1 = require_getBlock();
    var getGasPrice_js_1 = require_getGasPrice();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var account_js_1 = require_account();
    var base_js_1 = require_base2();
    var assertRequest_js_1 = require_assertRequest();
    exports.defaultTip = 1500000000n;
    async function prepareRequest(client, args) {
      const { account: account_, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError();
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const block = await (0, getBlock_js_1.getBlock)(client, { blockTag: "latest" });
      const request = { ...args, from: account.address };
      if (typeof nonce === "undefined")
        request.nonce = await (0, getTransactionCount_js_1.getTransactionCount)(client, {
          address: account.address,
          blockTag: "pending"
        });
      if (block.baseFeePerGas) {
        if (typeof gasPrice !== "undefined")
          throw new base_js_1.BaseError("Chain does not support legacy `gasPrice`.");
        if (typeof maxFeePerGas === "undefined") {
          request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? exports.defaultTip;
          request.maxFeePerGas = block.baseFeePerGas * 120n / 100n + request.maxPriorityFeePerGas;
        } else {
          if (typeof maxPriorityFeePerGas === "undefined" && maxFeePerGas < exports.defaultTip)
            throw new base_js_1.BaseError("`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei).");
          request.maxFeePerGas = maxFeePerGas;
          request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? exports.defaultTip;
        }
      } else {
        if (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined")
          throw new base_js_1.BaseError("Chain does not support EIP-1559 fees.");
        if (typeof gasPrice === "undefined")
          request.gasPrice = await (0, getGasPrice_js_1.getGasPrice)(client) * 120n / 100n;
      }
      if (typeof gas === "undefined")
        request.gas = await (0, estimateGas_js_1.estimateGas)(client, {
          ...request,
          account: { address: account.address, type: "json-rpc" }
        });
      (0, assertRequest_js_1.assertRequest)(request);
      return request;
    }
    exports.prepareRequest = prepareRequest;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/estimateGas.js
var require_estimateGas2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/estimateGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var assertRequest_js_1 = require_assertRequest();
    var prepareRequest_js_1 = require_prepareRequest();
    async function estimateGas2(client, args) {
      const account_ = args.account ?? client.account;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/public/estimateGas"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await (0, prepareRequest_js_1.prepareRequest)(client, args) : args;
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
        const block = blockNumberHex || blockTag;
        (0, assertRequest_js_1.assertRequest)(args);
        const format = client.chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format }),
          from: account.address,
          accessList,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        const balance = await client.request({
          method: "eth_estimateGas",
          params: block ? [request, block] : [request]
        });
        return BigInt(balance);
      } catch (err) {
        throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
          ...args,
          account,
          chain: client.chain
        });
      }
    }
    exports.estimateGas = estimateGas2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/estimateContractGas.js
var require_estimateContractGas = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/estimateContractGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateContractGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var estimateGas_js_1 = require_estimateGas2();
    async function estimateContractGas2(client, { abi, address, args, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const gas = await (0, estimateGas_js_1.estimateGas)(client, {
          data,
          to: address,
          ...request
        });
        return gas;
      } catch (err) {
        const account = request.account ? (0, parseAccount_js_1.parseAccount)(request.account) : void 0;
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/simulateContract",
          functionName,
          sender: account?.address
        });
      }
    }
    exports.estimateContractGas = estimateContractGas2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeFunctionResult.js
var require_decodeFunctionResult = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeFunctionResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFunctionResult = void 0;
    var abi_js_1 = require_abi();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath4 = "/docs/contract/decodeFunctionResult";
    function decodeFunctionResult2({ abi, args, functionName, data }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath: docsPath4 });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, { docsPath: docsPath4 });
      if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath4 });
      const values = (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.outputs, data);
      if (values && values.length > 1)
        return values;
      if (values && values.length === 1)
        return values[0];
      return void 0;
    }
    exports.decodeFunctionResult = decodeFunctionResult2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/abis.js
var require_abis = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/abis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.universalSignatureValidatorAbi = exports.smartAccountAbi = exports.singleAddressResolverAbi = exports.textResolverAbi = exports.universalResolverAbi = exports.multicall3Abi = void 0;
    exports.multicall3Abi = [
      {
        inputs: [
          {
            components: [
              {
                name: "target",
                type: "address"
              },
              {
                name: "allowFailure",
                type: "bool"
              },
              {
                name: "callData",
                type: "bytes"
              }
            ],
            name: "calls",
            type: "tuple[]"
          }
        ],
        name: "aggregate3",
        outputs: [
          {
            components: [
              {
                name: "success",
                type: "bool"
              },
              {
                name: "returnData",
                type: "bytes"
              }
            ],
            name: "returnData",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    exports.universalResolverAbi = [
      {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes" },
          { name: "data", type: "bytes" }
        ],
        outputs: [
          { name: "", type: "bytes" },
          { name: "address", type: "address" }
        ]
      }
    ];
    exports.textResolverAbi = [
      {
        name: "text",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes32" },
          { name: "key", type: "string" }
        ],
        outputs: [{ name: "", type: "string" }]
      }
    ];
    exports.singleAddressResolverAbi = [
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [{ name: "name", type: "bytes32" }],
        outputs: [{ name: "", type: "address" }]
      }
    ];
    exports.smartAccountAbi = [
      {
        name: "isValidSignature",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "hash", type: "bytes32" },
          { name: "signature", type: "bytes" }
        ],
        outputs: [{ name: "", type: "bytes4" }]
      }
    ];
    exports.universalSignatureValidatorAbi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_signer",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_hash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      }
    ];
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/contract.js
var require_contract2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aggregate3Signature = void 0;
    exports.aggregate3Signature = "0x82ad56cb";
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/chain.js
var require_chain = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/chain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = void 0;
    var base_js_1 = require_base2();
    var ChainDoesNotSupportContract2 = class extends base_js_1.BaseError {
      constructor({ blockNumber, chain, contract }) {
        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
          metaMessages: [
            "This could be due to any of the following:",
            ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
              `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
            ] : [
              `- The chain does not have the contract "${contract.name}" configured.`
            ]
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDoesNotSupportContract"
        });
      }
    };
    exports.ChainDoesNotSupportContract = ChainDoesNotSupportContract2;
    var ChainMismatchError2 = class extends base_js_1.BaseError {
      constructor({ chain, currentChainId }) {
        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
          metaMessages: [
            `Current Chain ID:  ${currentChainId}`,
            `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainMismatchError"
        });
      }
    };
    exports.ChainMismatchError = ChainMismatchError2;
    var ChainNotFoundError2 = class extends base_js_1.BaseError {
      constructor() {
        super([
          "No chain was provided to the request.",
          "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainNotFoundError"
        });
      }
    };
    exports.ChainNotFoundError = ChainNotFoundError2;
    var ClientChainNotConfiguredError2 = class extends base_js_1.BaseError {
      constructor() {
        super("No chain was provided to the Client.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ClientChainNotConfiguredError"
        });
      }
    };
    exports.ClientChainNotConfiguredError = ClientChainNotConfiguredError2;
    var InvalidChainIdError = class extends base_js_1.BaseError {
      constructor({ chainId }) {
        super(`Chain ID "${chainId}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidChainIdError"
        });
      }
    };
    exports.InvalidChainIdError = InvalidChainIdError;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/chain.js
var require_chain2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/chain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChainContractAddress = exports.defineChain = exports.assertCurrentChain = void 0;
    var chain_js_1 = require_chain();
    function assertCurrentChain2({ chain, currentChainId }) {
      if (!chain)
        throw new chain_js_1.ChainNotFoundError();
      if (currentChainId !== chain.id)
        throw new chain_js_1.ChainMismatchError({ chain, currentChainId });
    }
    exports.assertCurrentChain = assertCurrentChain2;
    function defineChain(chain, config2) {
      return {
        ...chain,
        formatters: config2?.formatters,
        serializers: config2?.serializers
      };
    }
    exports.defineChain = defineChain;
    function getChainContractAddress2({ blockNumber, chain, contract: name }) {
      const contract = chain?.contracts?.[name];
      if (!contract)
        throw new chain_js_1.ChainDoesNotSupportContract({
          chain,
          contract: { name }
        });
      if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
        throw new chain_js_1.ChainDoesNotSupportContract({
          blockNumber,
          chain,
          contract: {
            name,
            blockCreated: contract.blockCreated
          }
        });
      return contract.address;
    }
    exports.getChainContractAddress = getChainContractAddress2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getCallError.js
var require_getCallError = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getCallError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCallError = void 0;
    var contract_js_1 = require_contract();
    var getNodeError_js_1 = require_getNodeError();
    function getCallError2(err, { docsPath: docsPath4, ...args }) {
      let cause = err;
      if ((0, getNodeError_js_1.containsNodeError)(err))
        cause = (0, getNodeError_js_1.getNodeError)(err, args);
      return new contract_js_1.CallExecutionError(cause, {
        docsPath: docsPath4,
        ...args
      });
    }
    exports.getCallError = getCallError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/promise/createBatchScheduler.js
var require_createBatchScheduler = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/promise/createBatchScheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBatchScheduler = void 0;
    var schedulerCache2 = /* @__PURE__ */ new Map();
    function createBatchScheduler2({ fn, id: id4, shouldSplitBatch, wait: wait2 = 0 }) {
      const exec = async () => {
        const scheduler = getScheduler();
        flush();
        const args = scheduler.map(({ args: args2 }) => args2);
        if (args.length === 0)
          return;
        fn(args).then((data) => {
          scheduler.forEach(({ pendingPromise }, i) => pendingPromise.resolve?.([data[i], data]));
        }).catch((err) => {
          scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err));
        });
      };
      const flush = () => schedulerCache2.delete(id4);
      const getBatchedArgs = () => getScheduler().map(({ args }) => args);
      const getScheduler = () => schedulerCache2.get(id4) || [];
      const setScheduler = (item) => schedulerCache2.set(id4, [...getScheduler(), item]);
      return {
        flush,
        async schedule(args) {
          const pendingPromise = {};
          const promise = new Promise((resolve, reject) => {
            pendingPromise.resolve = resolve;
            pendingPromise.reject = reject;
          });
          const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
          if (split2)
            exec();
          const hasActiveScheduler = getScheduler().length > 0;
          if (hasActiveScheduler) {
            setScheduler({ args, pendingPromise });
            return promise;
          }
          setScheduler({ args, pendingPromise });
          setTimeout(exec, wait2);
          return promise;
        }
      };
    }
    exports.createBatchScheduler = createBatchScheduler2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/ccip.js
var require_ccip = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/ccip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OffchainLookupSenderMismatchError = exports.OffchainLookupResponseMalformedError = exports.OffchainLookupError = void 0;
    var stringify_js_1 = require_stringify();
    var base_js_1 = require_base2();
    var utils_js_1 = require_utils6();
    var OffchainLookupError2 = class extends base_js_1.BaseError {
      constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
        super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
          cause,
          metaMessages: [
            ...cause.metaMessages || [],
            cause.metaMessages?.length ? "" : [],
            "Offchain Gateway Call:",
            urls && [
              "  Gateway URL(s):",
              ...urls.map((url) => `    ${(0, utils_js_1.getUrl)(url)}`)
            ],
            `  Sender: ${sender}`,
            `  Data: ${data}`,
            `  Callback selector: ${callbackSelector}`,
            `  Extra data: ${extraData}`
          ].flat()
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupError"
        });
      }
    };
    exports.OffchainLookupError = OffchainLookupError2;
    var OffchainLookupResponseMalformedError2 = class extends base_js_1.BaseError {
      constructor({ result, url }) {
        super("Offchain gateway response is malformed. Response data must be a hex value.", {
          metaMessages: [
            `Gateway URL: ${(0, utils_js_1.getUrl)(url)}`,
            `Response: ${(0, stringify_js_1.stringify)(result)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupResponseMalformedError"
        });
      }
    };
    exports.OffchainLookupResponseMalformedError = OffchainLookupResponseMalformedError2;
    var OffchainLookupSenderMismatchError2 = class extends base_js_1.BaseError {
      constructor({ sender, to }) {
        super("Reverted sender address does not match target contract address (`to`).", {
          metaMessages: [
            `Contract address: ${to}`,
            `OffchainLookup sender address: ${sender}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupSenderMismatchError"
        });
      }
    };
    exports.OffchainLookupSenderMismatchError = OffchainLookupSenderMismatchError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/address/isAddressEqual.js
var require_isAddressEqual = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/address/isAddressEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAddressEqual = void 0;
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    function isAddressEqual2(a, b) {
      if (!(0, isAddress_js_1.isAddress)(a))
        throw new address_js_1.InvalidAddressError({ address: a });
      if (!(0, isAddress_js_1.isAddress)(b))
        throw new address_js_1.InvalidAddressError({ address: b });
      return a.toLowerCase() === b.toLowerCase();
    }
    exports.isAddressEqual = isAddressEqual2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ccip.js
var require_ccip2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ccip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ccipFetch = exports.offchainLookup = exports.offchainLookupAbiItem = exports.offchainLookupSignature = void 0;
    var call_js_1 = require_call();
    var ccip_js_1 = require_ccip();
    var request_js_1 = require_request();
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var concat_js_1 = require_concat();
    var isHex_js_1 = require_isHex();
    var stringify_js_1 = require_stringify();
    exports.offchainLookupSignature = "0x556f1830";
    exports.offchainLookupAbiItem = {
      name: "OffchainLookup",
      type: "error",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "urls",
          type: "string[]"
        },
        {
          name: "callData",
          type: "bytes"
        },
        {
          name: "callbackFunction",
          type: "bytes4"
        },
        {
          name: "extraData",
          type: "bytes"
        }
      ]
    };
    async function offchainLookup2(client, { blockNumber, blockTag, data, to }) {
      const { args } = (0, decodeErrorResult_js_1.decodeErrorResult)({
        data,
        abi: [exports.offchainLookupAbiItem]
      });
      const [sender, urls, callData, callbackSelector, extraData] = args;
      try {
        if (!(0, isAddressEqual_js_1.isAddressEqual)(to, sender))
          throw new ccip_js_1.OffchainLookupSenderMismatchError({ sender, to });
        const result = await ccipFetch2({ data: callData, sender, urls });
        const { data: data_ } = await (0, call_js_1.call)(client, {
          blockNumber,
          blockTag,
          data: (0, concat_js_1.concat)([
            callbackSelector,
            (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
          ]),
          to
        });
        return data_;
      } catch (err) {
        throw new ccip_js_1.OffchainLookupError({
          callbackSelector,
          cause: err,
          data,
          extraData,
          sender,
          urls
        });
      }
    }
    exports.offchainLookup = offchainLookup2;
    async function ccipFetch2({ data, sender, urls }) {
      let error = new Error("An unknown error occurred.");
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const method = url.includes("{sender}") || url.includes("{data}") ? "GET" : "POST";
        const body = method === "POST" ? { data, sender } : void 0;
        try {
          const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
            body: JSON.stringify(body),
            method
          });
          let result;
          if (response.headers.get("Content-Type")?.startsWith("application/json")) {
            result = (await response.json()).data;
          } else {
            result = await response.text();
          }
          if (!response.ok) {
            error = new request_js_1.HttpRequestError({
              body,
              details: (0, stringify_js_1.stringify)(result.error) || response.statusText,
              headers: response.headers,
              status: response.status,
              url
            });
            continue;
          }
          if (!(0, isHex_js_1.isHex)(result)) {
            error = new ccip_js_1.OffchainLookupResponseMalformedError({
              result,
              url
            });
            continue;
          }
          return result;
        } catch (err) {
          error = new request_js_1.HttpRequestError({
            body,
            details: err.message,
            url
          });
        }
      }
      throw error;
    }
    exports.ccipFetch = ccipFetch2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/call.js
var require_call = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRevertErrorData = exports.call = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var abis_js_1 = require_abis();
    var contract_js_1 = require_contract2();
    var base_js_1 = require_base2();
    var chain_js_1 = require_chain();
    var contract_js_2 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_2 = require_chain2();
    var toHex_js_1 = require_toHex();
    var getCallError_js_1 = require_getCallError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var assertRequest_js_1 = require_assertRequest();
    async function call2(client, args) {
      const { account: account_, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
      try {
        (0, assertRequest_js_1.assertRequest)(args);
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
        const block = blockNumberHex || blockTag;
        const format = client.chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format }),
          from: account?.address,
          accessList,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        if (batch && shouldPerformMulticall2({ request })) {
          try {
            return await scheduleMulticall2(client, {
              ...request,
              blockNumber,
              blockTag
            });
          } catch (err) {
            if (!(err instanceof chain_js_1.ClientChainNotConfiguredError) && !(err instanceof chain_js_1.ChainDoesNotSupportContract))
              throw err;
          }
        }
        const response = await client.request({
          method: "eth_call",
          params: block ? [request, block] : [request]
        });
        if (response === "0x")
          return { data: void 0 };
        return { data: response };
      } catch (err) {
        const data2 = getRevertErrorData2(err);
        const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => __toESM(require_ccip2()));
        if (data2?.slice(0, 10) === offchainLookupSignature2 && to) {
          return { data: await offchainLookup2(client, { data: data2, to }) };
        }
        throw (0, getCallError_js_1.getCallError)(err, {
          ...args,
          account,
          chain: client.chain
        });
      }
    }
    exports.call = call2;
    function shouldPerformMulticall2({ request }) {
      const { data, to, ...request_ } = request;
      if (!data)
        return false;
      if (data.startsWith(contract_js_1.aggregate3Signature))
        return false;
      if (!to)
        return false;
      if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
        return false;
      return true;
    }
    async function scheduleMulticall2(client, args) {
      const { batchSize = 1024, wait: wait2 = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
      const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
      let multicallAddress = multicallAddress_;
      if (!multicallAddress) {
        if (!client.chain)
          throw new chain_js_1.ClientChainNotConfiguredError();
        multicallAddress = (0, chain_js_2.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "multicall3"
        });
      }
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: `${client.uid}.${block}`,
        wait: wait2,
        shouldSplitBatch(args2) {
          const size3 = args2.reduce((size4, { data: data2 }) => size4 + (data2.length - 2), 0);
          return size3 > batchSize * 2;
        },
        fn: async (requests) => {
          const calls = requests.map((request) => ({
            allowFailure: true,
            callData: request.data,
            target: request.to
          }));
          const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi: abis_js_1.multicall3Abi,
            args: [calls],
            functionName: "aggregate3"
          });
          const data2 = await client.request({
            method: "eth_call",
            params: [
              {
                data: calldata,
                to: multicallAddress
              },
              block
            ]
          });
          return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi: abis_js_1.multicall3Abi,
            args: [calls],
            functionName: "aggregate3",
            data: data2 || "0x"
          });
        }
      });
      const [{ returnData, success }] = await schedule({ data, to });
      if (!success)
        throw new contract_js_2.RawContractError({ data: returnData });
      if (returnData === "0x")
        return { data: void 0 };
      return { data: returnData };
    }
    function getRevertErrorData2(err) {
      if (!(err instanceof base_js_1.BaseError))
        return void 0;
      const error = err.walk();
      return typeof error.data === "object" ? error.data.data : error.data;
    }
    exports.getRevertErrorData = getRevertErrorData2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/readContract.js
var require_readContract = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/readContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readContract = void 0;
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var call_js_1 = require_call();
    async function readContract2(client, { abi, address, args, functionName, ...callRequest }) {
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, call_js_1.call)(client, {
          data: calldata,
          to: address,
          ...callRequest
        });
        return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/readContract",
          functionName
        });
      }
    }
    exports.readContract = readContract2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/simulateContract.js
var require_simulateContract = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/simulateContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simulateContract = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var call_js_1 = require_call();
    async function simulateContract2(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
      const account = callRequest.account ? (0, parseAccount_js_1.parseAccount)(callRequest.account) : void 0;
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, call_js_1.call)(client, {
          batch: false,
          data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
          to: address,
          ...callRequest
        });
        const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
        return {
          result,
          request: {
            abi,
            address,
            args,
            functionName,
            ...callRequest
          }
        };
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/simulateContract",
          functionName,
          sender: account?.address
        });
      }
    }
    exports.simulateContract = simulateContract2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/observe.js
var require_observe = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/observe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observe = exports.cleanupCache = exports.listenersCache = void 0;
    exports.listenersCache = /* @__PURE__ */ new Map();
    exports.cleanupCache = /* @__PURE__ */ new Map();
    var callbackCount2 = 0;
    function observe2(observerId, callbacks, fn) {
      const callbackId = ++callbackCount2;
      const getListeners = () => exports.listenersCache.get(observerId) || [];
      const unsubscribe = () => {
        const listeners2 = getListeners();
        exports.listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
      };
      const unwatch = () => {
        const cleanup2 = exports.cleanupCache.get(observerId);
        if (getListeners().length === 1 && cleanup2)
          cleanup2();
        unsubscribe();
      };
      const listeners = getListeners();
      exports.listenersCache.set(observerId, [
        ...listeners,
        { id: callbackId, fns: callbacks }
      ]);
      if (listeners && listeners.length > 0)
        return unwatch;
      const emit = {};
      for (const key in callbacks) {
        emit[key] = (...args) => {
          const listeners2 = getListeners();
          if (listeners2.length === 0)
            return;
          listeners2.forEach((listener) => listener.fns[key]?.(...args));
        };
      }
      const cleanup = fn(emit);
      if (typeof cleanup === "function")
        exports.cleanupCache.set(observerId, cleanup);
      return unwatch;
    }
    exports.observe = observe2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/wait.js
var require_wait = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/wait.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wait = void 0;
    async function wait2(time) {
      return new Promise((res) => setTimeout(res, time));
    }
    exports.wait = wait2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/poll.js
var require_poll = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/poll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poll = void 0;
    var wait_js_1 = require_wait();
    function poll2(fn, { emitOnBegin, initialWaitTime, interval }) {
      let active = true;
      const unwatch = () => active = false;
      const watch = async () => {
        let data;
        if (emitOnBegin)
          data = await fn({ unpoll: unwatch });
        const initialWait = await initialWaitTime?.(data) ?? interval;
        await (0, wait_js_1.wait)(initialWait);
        const poll3 = async () => {
          if (!active)
            return;
          await fn({ unpoll: unwatch });
          await (0, wait_js_1.wait)(interval);
          poll3();
        };
        poll3();
      };
      watch();
      return unwatch;
    }
    exports.poll = poll2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/promise/withCache.js
var require_withCache = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/promise/withCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withCache = exports.getCache = exports.responseCache = exports.promiseCache = void 0;
    exports.promiseCache = /* @__PURE__ */ new Map();
    exports.responseCache = /* @__PURE__ */ new Map();
    function getCache2(cacheKey2) {
      const buildCache = (cacheKey3, cache) => ({
        clear: () => cache.delete(cacheKey3),
        get: () => cache.get(cacheKey3),
        set: (data) => cache.set(cacheKey3, data)
      });
      const promise = buildCache(cacheKey2, exports.promiseCache);
      const response = buildCache(cacheKey2, exports.responseCache);
      return {
        clear: () => {
          promise.clear();
          response.clear();
        },
        promise,
        response
      };
    }
    exports.getCache = getCache2;
    async function withCache2(fn, { cacheKey: cacheKey2, maxAge = Infinity }) {
      const cache = getCache2(cacheKey2);
      const response = cache.response.get();
      if (response && maxAge > 0) {
        const age = new Date().getTime() - response.created.getTime();
        if (age < maxAge)
          return response.data;
      }
      let promise = cache.promise.get();
      if (!promise) {
        promise = fn();
        cache.promise.set(promise);
      }
      try {
        const data = await promise;
        cache.response.set({ created: new Date(), data });
        return data;
      } finally {
        cache.promise.clear();
      }
    }
    exports.withCache = withCache2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBlockNumber.js
var require_getBlockNumber = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBlockNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlockNumber = exports.getBlockNumberCache = void 0;
    var withCache_js_1 = require_withCache();
    var cacheKey2 = (id4) => `blockNumber.${id4}`;
    function getBlockNumberCache(id4) {
      return (0, withCache_js_1.getCache)(cacheKey2(id4));
    }
    exports.getBlockNumberCache = getBlockNumberCache;
    async function getBlockNumber2(client, { maxAge = client.pollingInterval } = {}) {
      const blockNumberHex = await (0, withCache_js_1.withCache)(() => client.request({
        method: "eth_blockNumber"
      }), { cacheKey: cacheKey2(client.uid), maxAge });
      return BigInt(blockNumberHex);
    }
    exports.getBlockNumber = getBlockNumber2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeEventLog.js
var require_decodeEventLog = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeEventLog.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeEventLog = void 0;
    var abi_js_1 = require_abi();
    var getEventSelector_js_1 = require_getEventSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    var docsPath4 = "/docs/contract/decodeEventLog";
    function decodeEventLog2({ abi, data, strict: strict_, topics }) {
      const strict = strict_ ?? true;
      const [signature, ...argTopics] = topics;
      if (!signature)
        throw new abi_js_1.AbiEventSignatureEmptyTopicsError({
          docsPath: docsPath4
        });
      const abiItem = abi.find((x) => x.type === "event" && signature === (0, getEventSelector_js_1.getEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
        throw new abi_js_1.AbiEventSignatureNotFoundError(signature, {
          docsPath: docsPath4
        });
      const { name, inputs } = abiItem;
      const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
      let args = isUnnamed ? [] : {};
      const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
      if (argTopics.length > 0) {
        for (let i = 0; i < indexedInputs.length; i++) {
          const param = indexedInputs[i];
          const topic = argTopics[i];
          if (!topic)
            throw new abi_js_1.DecodeLogTopicsMismatch({
              abiItem,
              param
            });
          args[param.name || i] = decodeTopic2({ param, value: topic });
        }
      }
      const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
      if (nonIndexedInputs.length > 0) {
        if (data && data !== "0x") {
          try {
            const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);
            if (decodedData) {
              if (isUnnamed)
                args = [...args, ...decodedData];
              else {
                for (let i = 0; i < nonIndexedInputs.length; i++) {
                  args[nonIndexedInputs[i].name] = decodedData[i];
                }
              }
            }
          } catch (err) {
            if (strict) {
              if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError)
                throw new abi_js_1.DecodeLogDataMismatch({
                  abiItem,
                  data: err.data,
                  params: err.params,
                  size: err.size
                });
              throw err;
            }
          }
        } else if (strict) {
          throw new abi_js_1.DecodeLogDataMismatch({
            abiItem,
            data: "0x",
            params: nonIndexedInputs,
            size: 0
          });
        }
      }
      return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : void 0
      };
    }
    exports.decodeEventLog = decodeEventLog2;
    function decodeTopic2({ param, value }) {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return value;
      const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];
      return decodedArg[0];
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/log.js
var require_log2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLog = void 0;
    function formatLog2(log, { args, eventName } = {}) {
      return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
        ...eventName ? { args, eventName } : {}
      };
    }
    exports.formatLog = formatLog2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getFilterChanges.js
var require_getFilterChanges = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getFilterChanges.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilterChanges = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log2();
    async function getFilterChanges2(_client, { filter }) {
      const strict = "strict" in filter && filter.strict;
      const logs = await filter.request({
        method: "eth_getFilterChanges",
        params: [filter.id]
      });
      return logs.map((log) => {
        if (typeof log === "string")
          return log;
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getFilterChanges = getFilterChanges2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getLogs.js
var require_getLogs = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getLogs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var log_js_1 = require_log2();
    async function getLogs3(client, { address, blockHash, fromBlock, toBlock, event, args, strict: strict_ } = {}) {
      const strict = strict_ ?? false;
      let topics = [];
      if (event)
        topics = (0, encodeEventTopics_js_1.encodeEventTopics)({
          abi: [event],
          eventName: event.name,
          args
        });
      let logs;
      if (blockHash) {
        logs = await client.request({
          method: "eth_getLogs",
          params: [{ address, topics, blockHash }]
        });
      } else {
        logs = await client.request({
          method: "eth_getLogs",
          params: [
            {
              address,
              topics,
              fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
              toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock
            }
          ]
        });
      }
      return logs.map((log) => {
        try {
          const { eventName, args: args2 } = event ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: [event],
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args: args2, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if (strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getLogs = getLogs3;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/uninstallFilter.js
var require_uninstallFilter = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/uninstallFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uninstallFilter = void 0;
    async function uninstallFilter2(_client, { filter }) {
      return filter.request({
        method: "eth_uninstallFilter",
        params: [filter.id]
      });
    }
    exports.uninstallFilter = uninstallFilter2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchContractEvent.js
var require_watchContractEvent = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchContractEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchContractEvent = void 0;
    var getAbiItem_js_1 = require_getAbiItem();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getLogs_js_1 = require_getLogs();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchContractEvent2(client, { abi, address, args, batch = true, eventName, onError, onLogs, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const observerId = (0, stringify_js_1.stringify)([
        "watchContractEvent",
        address,
        args,
        batch,
        client.uid,
        eventName,
        pollingInterval
      ]);
      const strict = strict_ ?? false;
      return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
        let previousBlockNumber;
        let filter;
        let initialized = false;
        const unwatch = (0, poll_js_1.poll)(async () => {
          if (!initialized) {
            try {
              filter = await (0, createContractEventFilter_js_1.createContractEventFilter)(client, {
                abi,
                address,
                args,
                eventName,
                strict
              });
            } catch {
            }
            initialized = true;
            return;
          }
          try {
            let logs;
            if (filter) {
              logs = await (0, getFilterChanges_js_1.getFilterChanges)(client, { filter });
            } else {
              const blockNumber = await (0, getBlockNumber_js_1.getBlockNumber)(client);
              if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                logs = await (0, getLogs_js_1.getLogs)(client, {
                  address,
                  args,
                  fromBlock: previousBlockNumber + 1n,
                  toBlock: blockNumber,
                  event: (0, getAbiItem_js_1.getAbiItem)({
                    abi,
                    name: eventName
                  })
                });
              } else {
                logs = [];
              }
              previousBlockNumber = blockNumber;
            }
            if (logs.length === 0)
              return;
            if (batch)
              emit.onLogs(logs);
            else
              logs.forEach((log) => emit.onLogs([log]));
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await (0, uninstallFilter_js_1.uninstallFilter)(client, { filter });
          unwatch();
        };
      });
    }
    exports.watchContractEvent = watchContractEvent2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getTransactionError.js
var require_getTransactionError = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/errors/getTransactionError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionError = void 0;
    var transaction_js_1 = require_transaction();
    var getNodeError_js_1 = require_getNodeError();
    function getTransactionError2(err, { docsPath: docsPath4, ...args }) {
      let cause = err;
      if ((0, getNodeError_js_1.containsNodeError)(err))
        cause = (0, getNodeError_js_1.getNodeError)(err, args);
      return new transaction_js_1.TransactionExecutionError(cause, {
        docsPath: docsPath4,
        ...args
      });
    }
    exports.getTransactionError = getTransactionError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getChainId.js
var require_getChainId = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getChainId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChainId = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getChainId2(client) {
      const chainIdHex = await client.request({
        method: "eth_chainId"
      });
      return (0, fromHex_js_1.hexToNumber)(chainIdHex);
    }
    exports.getChainId = getChainId2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/sendTransaction.js
var require_sendTransaction = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/sendTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendTransaction = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var chain_js_1 = require_chain2();
    var getTransactionError_js_1 = require_getTransactionError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var assertRequest_js_1 = require_assertRequest();
    var prepareRequest_js_1 = require_prepareRequest();
    var getChainId_js_1 = require_getChainId();
    async function sendTransaction2(client, args) {
      const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/sendTransaction"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        (0, assertRequest_js_1.assertRequest)(args);
        let chainId;
        if (chain !== null) {
          chainId = await (0, getChainId_js_1.getChainId)(client);
          (0, chain_js_1.assertCurrentChain)({
            currentChainId: chainId,
            chain
          });
        }
        if (account.type === "local") {
          const request2 = await (0, prepareRequest_js_1.prepareRequest)(client, {
            account,
            accessList,
            chain,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
            ...rest
          });
          if (!chainId)
            chainId = await (0, getChainId_js_1.getChainId)(client);
          const serializer = chain?.serializers?.transaction;
          const signedRequest = await account.signTransaction({
            ...request2,
            chainId
          }, { serializer });
          return await client.request({
            method: "eth_sendRawTransaction",
            params: [signedRequest]
          });
        }
        const format = chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format }),
          accessList,
          data,
          from: account.address,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        return await client.request({
          method: "eth_sendTransaction",
          params: [request]
        });
      } catch (err) {
        throw (0, getTransactionError_js_1.getTransactionError)(err, {
          ...args,
          account,
          chain: args.chain || void 0
        });
      }
    }
    exports.sendTransaction = sendTransaction2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/writeContract.js
var require_writeContract = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/writeContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeContract = void 0;
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var sendTransaction_js_1 = require_sendTransaction();
    async function writeContract2(client, { abi, address, args, dataSuffix, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      const hash4 = await (0, sendTransaction_js_1.sendTransaction)(client, {
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...request
      });
      return hash4;
    }
    exports.writeContract = writeContract2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/getContract.js
var require_getContract = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/getContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventParameters = exports.getFunctionParameters = exports.getContract = void 0;
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var writeContract_js_1 = require_writeContract();
    function getContract2({ abi, address, publicClient, walletClient }) {
      const hasPublicClient = publicClient !== void 0 && publicClient !== null;
      const hasWalletClient = walletClient !== void 0 && walletClient !== null;
      const contract = {};
      let hasReadFunction = false;
      let hasWriteFunction = false;
      let hasEvent = false;
      for (const item of abi) {
        if (item.type === "function")
          if (item.stateMutability === "view" || item.stateMutability === "pure")
            hasReadFunction = true;
          else
            hasWriteFunction = true;
        else if (item.type === "event")
          hasEvent = true;
        if (hasReadFunction && hasWriteFunction && hasEvent)
          break;
      }
      if (hasPublicClient) {
        if (hasReadFunction)
          contract.read = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters2(parameters);
                return (0, readContract_js_1.readContract)(publicClient, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasWriteFunction)
          contract.simulate = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters2(parameters);
                return (0, simulateContract_js_1.simulateContract)(publicClient, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasEvent) {
          contract.createEventFilter = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters2(parameters, abiEvent);
                return (0, createContractEventFilter_js_1.createContractEventFilter)(publicClient, {
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
          contract.watchEvent = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters2(parameters, abiEvent);
                return (0, watchContractEvent_js_1.watchContractEvent)(publicClient, {
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
        }
      }
      if (hasWalletClient) {
        if (hasWriteFunction)
          contract.write = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters2(parameters);
                return (0, writeContract_js_1.writeContract)(walletClient, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
      }
      if (hasPublicClient || hasWalletClient) {
        if (hasWriteFunction)
          contract.estimateGas = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters2(parameters);
                const client = publicClient ?? walletClient;
                return (0, estimateContractGas_js_1.estimateContractGas)(client, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options,
                  account: options.account ?? walletClient.account
                });
              };
            }
          });
      }
      contract.address = address;
      contract.abi = abi;
      return contract;
    }
    exports.getContract = getContract2;
    function getFunctionParameters2(values) {
      const hasArgs = values.length && Array.isArray(values[0]);
      const args = hasArgs ? values[0] : [];
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports.getFunctionParameters = getFunctionParameters2;
    function getEventParameters2(values, abiEvent) {
      let hasArgs = false;
      if (Array.isArray(values[0]))
        hasArgs = true;
      else if (values.length === 1) {
        hasArgs = abiEvent.inputs.some((x) => x.indexed);
      } else if (values.length === 2) {
        hasArgs = true;
      }
      const args = hasArgs ? values[0] : void 0;
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports.getEventParameters = getEventParameters2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/accounts/utils/publicKeyToAddress.js
var require_publicKeyToAddress = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/accounts/utils/publicKeyToAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicKeyToAddress = void 0;
    var getAddress_js_1 = require_getAddress();
    var keccak256_js_1 = require_keccak256();
    function publicKeyToAddress(publicKey) {
      const address = (0, keccak256_js_1.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
      return (0, getAddress_js_1.checksumAddress)(`0x${address}`);
    }
    exports.publicKeyToAddress = publicKeyToAddress;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/accounts.js
var require_accounts = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/accounts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicKeyToAddress = exports.parseAccount = void 0;
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/uid.js
var require_uid = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/uid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uid = void 0;
    var size3 = 256;
    var index2 = size3;
    var buffer2;
    function uid2(length = 11) {
      if (!buffer2 || index2 + length > size3 * 2) {
        buffer2 = "";
        index2 = 0;
        for (let i = 0; i < size3; i++) {
          buffer2 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
        }
      }
      return buffer2.substring(index2, index2++ + length);
    }
    exports.uid = uid2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/createClient.js
var require_createClient = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/createClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createClient = void 0;
    var accounts_js_1 = require_accounts();
    var uid_js_1 = require_uid();
    function createClient2({ account, batch, chain, key = "base", name = "Base Client", pollingInterval = 4e3, transport, type = "base" }) {
      const { config: config2, request, value } = transport({ chain, pollingInterval });
      const client = {
        account: account ? (0, accounts_js_1.parseAccount)(account) : void 0,
        batch,
        chain,
        key,
        name,
        pollingInterval,
        request,
        transport: { ...config2, ...value },
        type,
        uid: (0, uid_js_1.uid)()
      };
      function extend(client_) {
        return (fn) => {
          const extended = fn(client_);
          for (const key2 in client)
            delete extended[key2];
          const nextClient = { ...client_, ...extended };
          return Object.assign(nextClient, { extend: extend(nextClient) });
        };
      }
      return Object.assign(client, { extend: extend(client) });
    }
    exports.createClient = createClient2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/promise/withRetry.js
var require_withRetry = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/promise/withRetry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withRetry = void 0;
    var wait_js_1 = require_wait();
    function withRetry2(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
      return new Promise((resolve, reject) => {
        const attemptRetry = async ({ count = 0 } = {}) => {
          const retry = async ({ error }) => {
            const delay2 = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
            if (delay2)
              await (0, wait_js_1.wait)(delay2);
            attemptRetry({ count: count + 1 });
          };
          try {
            const data = await fn();
            resolve(data);
          } catch (err) {
            if (count < retryCount && await shouldRetry({ count, error: err }))
              return retry({ error: err });
            reject(err);
          }
        };
        attemptRetry();
      });
    }
    exports.withRetry = withRetry2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/buildRequest.js
var require_buildRequest = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/buildRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildRequest = exports.isDeterministicError = void 0;
    var base_js_1 = require_base2();
    var request_js_1 = require_request();
    var rpc_js_1 = require_rpc();
    var withRetry_js_1 = require_withRetry();
    var isDeterministicError = (error) => {
      if ("code" in error)
        return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
      if (error instanceof request_js_1.HttpRequestError && error.status)
        return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
      return false;
    };
    exports.isDeterministicError = isDeterministicError;
    function buildRequest(request, { retryDelay = 150, retryCount = 3 } = {}) {
      return async (args) => (0, withRetry_js_1.withRetry)(async () => {
        try {
          return await request(args);
        } catch (err_) {
          const err = err_;
          switch (err.code) {
            case rpc_js_1.ParseRpcError.code:
              throw new rpc_js_1.ParseRpcError(err);
            case rpc_js_1.InvalidRequestRpcError.code:
              throw new rpc_js_1.InvalidRequestRpcError(err);
            case rpc_js_1.MethodNotFoundRpcError.code:
              throw new rpc_js_1.MethodNotFoundRpcError(err);
            case rpc_js_1.InvalidParamsRpcError.code:
              throw new rpc_js_1.InvalidParamsRpcError(err);
            case rpc_js_1.InternalRpcError.code:
              throw new rpc_js_1.InternalRpcError(err);
            case rpc_js_1.InvalidInputRpcError.code:
              throw new rpc_js_1.InvalidInputRpcError(err);
            case rpc_js_1.ResourceNotFoundRpcError.code:
              throw new rpc_js_1.ResourceNotFoundRpcError(err);
            case rpc_js_1.ResourceUnavailableRpcError.code:
              throw new rpc_js_1.ResourceUnavailableRpcError(err);
            case rpc_js_1.TransactionRejectedRpcError.code:
              throw new rpc_js_1.TransactionRejectedRpcError(err);
            case rpc_js_1.MethodNotSupportedRpcError.code:
              throw new rpc_js_1.MethodNotSupportedRpcError(err);
            case rpc_js_1.LimitExceededRpcError.code:
              throw new rpc_js_1.LimitExceededRpcError(err);
            case rpc_js_1.JsonRpcVersionUnsupportedError.code:
              throw new rpc_js_1.JsonRpcVersionUnsupportedError(err);
            case rpc_js_1.UserRejectedRequestError.code:
              throw new rpc_js_1.UserRejectedRequestError(err);
            case rpc_js_1.UnauthorizedProviderError.code:
              throw new rpc_js_1.UnauthorizedProviderError(err);
            case rpc_js_1.UnsupportedProviderMethodError.code:
              throw new rpc_js_1.UnsupportedProviderMethodError(err);
            case rpc_js_1.ProviderDisconnectedError.code:
              throw new rpc_js_1.ProviderDisconnectedError(err);
            case rpc_js_1.ChainDisconnectedError.code:
              throw new rpc_js_1.ChainDisconnectedError(err);
            case rpc_js_1.SwitchChainError.code:
              throw new rpc_js_1.SwitchChainError(err);
            default:
              if (err_ instanceof base_js_1.BaseError)
                throw err_;
              throw new rpc_js_1.UnknownRpcError(err);
          }
        }
      }, {
        delay: ({ count, error }) => {
          if (error && error instanceof request_js_1.HttpRequestError) {
            const retryAfter = error?.headers?.get("Retry-After");
            if (retryAfter?.match(/\d/))
              return parseInt(retryAfter) * 1e3;
          }
          return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => !(0, exports.isDeterministicError)(error)
      });
    }
    exports.buildRequest = buildRequest;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/createTransport.js
var require_createTransport = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/createTransport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransport = void 0;
    var buildRequest_js_1 = require_buildRequest();
    function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
      return {
        config: { key, name, request, retryCount, retryDelay, timeout, type },
        request: (0, buildRequest_js_1.buildRequest)(request, { retryCount, retryDelay }),
        value
      };
    }
    exports.createTransport = createTransport;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/custom.js
var require_custom = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/custom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.custom = void 0;
    var createTransport_js_1 = require_createTransport();
    function custom(provider, config2 = {}) {
      const { key = "custom", name = "Custom Provider", retryDelay } = config2;
      return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1.createTransport)({
        key,
        name,
        request: provider.request.bind(provider),
        retryCount: config2.retryCount ?? defaultRetryCount,
        retryDelay,
        type: "custom"
      });
    }
    exports.custom = custom;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/fallback.js
var require_fallback = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/fallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rankTransports = exports.fallback = void 0;
    var buildRequest_js_1 = require_buildRequest();
    var wait_js_1 = require_wait();
    var createTransport_js_1 = require_createTransport();
    function fallback(transports_, config2 = {}) {
      const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config2;
      return ({ chain, pollingInterval = 4e3, timeout }) => {
        let transports = transports_;
        let onResponse = () => {
        };
        const transport = (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const fetch2 = async (i = 0) => {
              const transport2 = transports[i]({ chain, retryCount: 0, timeout });
              try {
                const response = await transport2.request({
                  method,
                  params
                });
                onResponse({
                  method,
                  params,
                  response,
                  transport: transport2,
                  status: "success"
                });
                return response;
              } catch (err) {
                onResponse({
                  error: err,
                  method,
                  params,
                  transport: transport2,
                  status: "error"
                });
                if ((0, buildRequest_js_1.isDeterministicError)(err))
                  throw err;
                if (i === transports.length - 1)
                  throw err;
                return fetch2(i + 1);
              }
            };
            return fetch2();
          },
          retryCount,
          retryDelay,
          type: "fallback"
        }, {
          onResponse: (fn) => onResponse = fn,
          transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
        });
        if (rank) {
          const rankOptions = typeof rank === "object" ? rank : {};
          rankTransports({
            chain,
            interval: rankOptions.interval ?? pollingInterval,
            onTransports: (transports_2) => transports = transports_2,
            sampleCount: rankOptions.sampleCount,
            timeout: rankOptions.timeout,
            transports,
            weights: rankOptions.weights
          });
        }
        return transport;
      };
    }
    exports.fallback = fallback;
    function rankTransports({ chain, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
      const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
      const samples = [];
      const rankTransports_ = async () => {
        const sample = await Promise.all(transports.map(async (transport) => {
          const transport_ = transport({ chain, retryCount: 0, timeout });
          const start = Date.now();
          let end;
          let success;
          try {
            await transport_.request({ method: "net_listening" });
            success = 1;
          } catch {
            success = 0;
          } finally {
            end = Date.now();
          }
          const latency = end - start;
          return { latency, success };
        }));
        samples.push(sample);
        if (samples.length > sampleCount)
          samples.shift();
        const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
        const scores = transports.map((_, i) => {
          const latencies = samples.map((sample2) => sample2[i].latency);
          const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
          const latencyScore = 1 - meanLatency / maxLatency;
          const successes = samples.map((sample2) => sample2[i].success);
          const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
          if (stabilityScore === 0)
            return [0, i];
          return [
            latencyWeight * latencyScore + stabilityWeight * stabilityScore,
            i
          ];
        }).sort((a, b) => b[0] - a[0]);
        onTransports(scores.map(([, i]) => transports[i]));
        await (0, wait_js_1.wait)(interval);
        rankTransports_();
      };
      rankTransports_();
    }
    exports.rankTransports = rankTransports;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/transport.js
var require_transport = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlRequiredError = void 0;
    var base_js_1 = require_base2();
    var UrlRequiredError = class extends base_js_1.BaseError {
      constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
          docsPath: "/docs/clients/intro"
        });
      }
    };
    exports.UrlRequiredError = UrlRequiredError;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/promise/withTimeout.js
var require_withTimeout = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/promise/withTimeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    function withTimeout2(fn, { errorInstance, timeout, signal }) {
      return new Promise((resolve, reject) => {
        ;
        (async () => {
          let timeoutId;
          try {
            const controller = new AbortController();
            if (timeout > 0) {
              timeoutId = setTimeout(() => {
                if (signal) {
                  controller.abort();
                } else {
                  reject(errorInstance);
                }
              }, timeout);
            }
            resolve(await fn({ signal: controller?.signal }));
          } catch (err) {
            if (err.name === "AbortError")
              reject(errorInstance);
            reject(err);
          } finally {
            clearTimeout(timeoutId);
          }
        })();
      });
    }
    exports.withTimeout = withTimeout2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/isomorphic-ws/browser.js
var browser_exports = {};
__export(browser_exports, {
  default: () => browser_default
});
var ws, browser_default;
var init_browser = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/isomorphic-ws/browser.js"() {
    ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof window.self !== "undefined") {
      ws = window.self.WebSocket || window.self.MozWebSocket;
    }
    browser_default = ws;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/rpc.js
var require_rpc2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/rpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rpc = exports.getSocket = void 0;
    var request_js_1 = require_request();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var withTimeout_js_1 = require_withTimeout();
    var stringify_js_1 = require_stringify();
    var id4 = 0;
    async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
          const response2 = await fetch(url, {
            ...fetchOptions,
            body: Array.isArray(body) ? (0, stringify_js_1.stringify)(body.map((body2) => ({
              jsonrpc: "2.0",
              id: id4++,
              ...body2
            }))) : (0, stringify_js_1.stringify)({ jsonrpc: "2.0", id: id4++, ...body }),
            headers: {
              ...headers,
              "Content-Type": "application/json"
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : void 0)
          });
          return response2;
        }, {
          errorInstance: new request_js_1.TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          data = await response.json();
        } else {
          data = await response.text();
        }
        if (!response.ok) {
          throw new request_js_1.HttpRequestError({
            body,
            details: (0, stringify_js_1.stringify)(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof request_js_1.HttpRequestError)
          throw err;
        if (err instanceof request_js_1.TimeoutError)
          throw err;
        throw new request_js_1.HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    var sockets = /* @__PURE__ */ new Map();
    async function getSocket(url_) {
      const url = new URL(url_);
      const urlKey = url.toString();
      let socket = sockets.get(urlKey);
      if (socket)
        return socket;
      const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: urlKey,
        fn: async () => {
          let WebSocket2 = await Promise.resolve().then(() => (init_browser(), browser_exports));
          if (WebSocket2.default?.constructor)
            WebSocket2 = WebSocket2.default;
          else
            WebSocket2 = WebSocket2.WebSocket;
          const webSocket2 = new WebSocket2(url);
          const requests = /* @__PURE__ */ new Map();
          const subscriptions = /* @__PURE__ */ new Map();
          const onMessage = ({ data }) => {
            const message = JSON.parse(data);
            const isSubscription2 = message.method === "eth_subscription";
            const id5 = isSubscription2 ? message.params.subscription : message.id;
            const cache = isSubscription2 ? subscriptions : requests;
            const callback = cache.get(id5);
            if (callback)
              callback({ data });
            if (!isSubscription2)
              cache.delete(id5);
          };
          const onClose = () => {
            sockets.delete(urlKey);
            webSocket2.removeEventListener("close", onClose);
            webSocket2.removeEventListener("message", onMessage);
          };
          webSocket2.addEventListener("close", onClose);
          webSocket2.addEventListener("message", onMessage);
          if (webSocket2.readyState === WebSocket2.CONNECTING) {
            await new Promise((resolve, reject) => {
              if (!webSocket2)
                return;
              webSocket2.onopen = resolve;
              webSocket2.onerror = reject;
            });
          }
          socket = Object.assign(webSocket2, {
            requests,
            subscriptions
          });
          sockets.set(urlKey, socket);
          return [socket];
        }
      });
      const [_, [socket_]] = await schedule();
      return socket_;
    }
    exports.getSocket = getSocket;
    function webSocket(socket, { body, onResponse }) {
      if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
        throw new request_js_1.WebSocketRequestError({
          body,
          url: socket.url,
          details: "Socket is closed."
        });
      const id_ = id4++;
      const callback = ({ data }) => {
        const message = JSON.parse(data);
        if (typeof message.id === "number" && id_ !== message.id)
          return;
        onResponse?.(message);
        if (body.method === "eth_subscribe" && typeof message.result === "string") {
          socket.subscriptions.set(message.result, callback);
        }
        if (body.method === "eth_unsubscribe") {
          socket.subscriptions.delete(body.params?.[0]);
        }
      };
      socket.requests.set(id_, callback);
      socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
      return socket;
    }
    async function webSocketAsync(socket, { body, timeout = 1e4 }) {
      return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse) => exports.rpc.webSocket(socket, {
        body,
        onResponse
      })), {
        errorInstance: new request_js_1.TimeoutError({ body, url: socket.url }),
        timeout
      });
    }
    exports.rpc = {
      http,
      webSocket,
      webSocketAsync
    };
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/http.js
var require_http = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.http = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function http(url, config2 = {}) {
      const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", retryDelay } = config2;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
        const retryCount = config2.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config2.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.http[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
              id: `${url}`,
              wait: wait2,
              shouldSplitBatch(requests) {
                return requests.length > batchSize;
              },
              fn: (body2) => rpc_js_1.rpc.http(url_, {
                body: body2,
                fetchOptions,
                timeout
              })
            });
            const fn = async (body2) => batch ? schedule(body2) : [await rpc_js_1.rpc.http(url_, { body: body2, fetchOptions, timeout })];
            const [{ error, result }] = await fn(body);
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "http"
        }, {
          url
        });
      };
    }
    exports.http = http;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/regex.js
var require_regex2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.integerRegex = exports.bytesRegex = exports.arrayRegex = void 0;
    exports.arrayRegex = /^(.*)\[([0-9]*)\]$/;
    exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/typedData.js
var require_typedData = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/typedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTypedData = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var size_js_1 = require_size();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex2();
    function validateTypedData2({ domain, message, primaryType, types: types_ }) {
      const types = types_;
      const validateData = (struct, value_) => {
        for (const param of struct) {
          const { name, type: type_ } = param;
          const type = type_;
          const value = value_[name];
          const integerMatch = type.match(regex_js_1.integerRegex);
          if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
            const [_type, base, size_] = integerMatch;
            (0, toHex_js_1.numberToHex)(value, {
              signed: base === "int",
              size: parseInt(size_) / 8
            });
          }
          if (type === "address" && typeof value === "string" && !(0, isAddress_js_1.isAddress)(value))
            throw new address_js_1.InvalidAddressError({ address: value });
          const bytesMatch = type.match(regex_js_1.bytesRegex);
          if (bytesMatch) {
            const [_type, size_] = bytesMatch;
            if (size_ && (0, size_js_1.size)(value) !== parseInt(size_))
              throw new abi_js_1.BytesSizeMismatchError({
                expectedSize: parseInt(size_),
                givenSize: (0, size_js_1.size)(value)
              });
          }
          const struct2 = types[type];
          if (struct2)
            validateData(struct2, value);
        }
      };
      if (types["EIP712Domain"] && domain)
        validateData(types["EIP712Domain"], domain);
      if (primaryType !== "EIP712Domain") {
        const type = types[primaryType];
        validateData(type, message);
      }
    }
    exports.validateTypedData = validateTypedData2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeFunctionData.js
var require_decodeFunctionData = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeFunctionData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFunctionData = void 0;
    var abi_js_1 = require_abi();
    var slice_js_1 = require_slice();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    function decodeFunctionData({ abi, data }) {
      const signature = (0, slice_js_1.slice)(data, 0, 4);
      const description = abi.find((x) => x.type === "function" && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!description)
        throw new abi_js_1.AbiFunctionSignatureNotFoundError(signature, {
          docsPath: "/docs/contract/decodeFunctionData"
        });
      return {
        functionName: description.name,
        args: "inputs" in description && description.inputs && description.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, (0, slice_js_1.slice)(data, 4)) : void 0
      };
    }
    exports.decodeFunctionData = decodeFunctionData;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeDeployData.js
var require_encodeDeployData = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeDeployData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var docsPath4 = "/docs/contract/encodeDeployData";
    function encodeDeployData2({ abi, args, bytecode }) {
      if (!args || args.length === 0)
        return bytecode;
      const description = abi.find((x) => "type" in x && x.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath: docsPath4 });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath: docsPath4 });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath: docsPath4 });
      const data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(description.inputs, args);
      return (0, concat_js_1.concatHex)([bytecode, data]);
    }
    exports.encodeDeployData = encodeDeployData2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeErrorResult.js
var require_encodeErrorResult = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeErrorResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeErrorResult = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath4 = "/docs/contract/encodeErrorResult";
    function encodeErrorResult({ abi, errorName, args }) {
      let abiItem = abi[0];
      if (errorName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: errorName
        });
        if (!abiItem)
          throw new abi_js_1.AbiErrorNotFoundError(errorName, { docsPath: docsPath4 });
      }
      if (abiItem.type !== "error")
        throw new abi_js_1.AbiErrorNotFoundError(void 0, { docsPath: docsPath4 });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
      let data = "0x";
      if (args && args.length > 0) {
        if (!abiItem.inputs)
          throw new abi_js_1.AbiErrorInputsNotFoundError(abiItem.name, { docsPath: docsPath4 });
        data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args);
      }
      return (0, concat_js_1.concatHex)([signature, data]);
    }
    exports.encodeErrorResult = encodeErrorResult;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeFunctionResult.js
var require_encodeFunctionResult = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodeFunctionResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFunctionResult = void 0;
    var abi_js_1 = require_abi();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath4 = "/docs/contract/encodeFunctionResult";
    function encodeFunctionResult({ abi, functionName, result }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
            docsPath: "/docs/contract/encodeFunctionResult"
          });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeFunctionResult"
        });
      if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath4 });
      let values = Array.isArray(result) ? result : [result];
      if (abiItem.outputs.length === 0 && !values[0])
        values = [];
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.outputs, values);
    }
    exports.encodeFunctionResult = encodeFunctionResult;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodePacked.js
var require_encodePacked = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/encodePacked.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodePacked = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var pad_js_1 = require_pad();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex2();
    function encodePacked(types, values) {
      if (types.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
          expectedLength: types.length,
          givenLength: values.length
        });
      const data = [];
      for (let i = 0; i < types.length; i++) {
        const type = types[i];
        const value = values[i];
        data.push(encode(type, value));
      }
      return (0, concat_js_1.concat)(data);
    }
    exports.encodePacked = encodePacked;
    function encode(type, value, isArray = false) {
      if (type === "address") {
        const address = value;
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        return (0, pad_js_1.pad)(address.toLowerCase(), {
          size: isArray ? 32 : null
        });
      }
      if (type === "string")
        return (0, toHex_js_1.stringToHex)(value);
      if (type === "bytes")
        return value;
      if (type === "bool")
        return (0, pad_js_1.pad)((0, toHex_js_1.boolToHex)(value), { size: isArray ? 32 : 1 });
      const intMatch = type.match(regex_js_1.integerRegex);
      if (intMatch) {
        const [_type, baseType, bits = "256"] = intMatch;
        const size3 = parseInt(bits) / 8;
        return (0, toHex_js_1.numberToHex)(value, {
          size: isArray ? 32 : size3,
          signed: baseType === "int"
        });
      }
      const bytesMatch = type.match(regex_js_1.bytesRegex);
      if (bytesMatch) {
        const [_type, size3] = bytesMatch;
        if (parseInt(size3) !== (value.length - 2) / 2)
          throw new abi_js_1.BytesSizeMismatchError({
            expectedSize: parseInt(size3),
            givenSize: (value.length - 2) / 2
          });
        return (0, pad_js_1.pad)(value, { dir: "right", size: isArray ? 32 : null });
      }
      const arrayMatch = type.match(regex_js_1.arrayRegex);
      if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for (let i = 0; i < value.length; i++) {
          data.push(encode(childType, value[i], true));
        }
        return (0, concat_js_1.concat)(data);
      }
      throw new abi_js_1.UnsupportedPackedAbiType(type);
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/isBytes.js
var require_isBytes = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/isBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytes = void 0;
    function isBytes4(value) {
      if (!value)
        return false;
      if (typeof value !== "object")
        return false;
      if (!("BYTES_PER_ELEMENT" in value))
        return false;
      return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes4;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/toRlp.js
var require_toRlp = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/toRlp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesToRlp = exports.toRlp = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function toRlp(hexOrBytes, to_) {
      const to = to_ || "hex";
      return format(bytesToRlp(parse(hexOrBytes)), to);
    }
    exports.toRlp = toRlp;
    function parse(hexOrBytes) {
      if (Array.isArray(hexOrBytes))
        return hexOrBytes.map(parse);
      return typeof hexOrBytes === "string" ? (0, toBytes_js_1.toBytes)(hexOrBytes) : hexOrBytes;
    }
    function format(bytes4, type = "bytes") {
      return type === "hex" ? (0, toHex_js_1.bytesToHex)(bytes4) : bytes4;
    }
    function bytesToRlp(bytes4) {
      if (Array.isArray(bytes4)) {
        const encoded = (0, concat_js_1.concat)(bytes4.map(bytesToRlp));
        return new Uint8Array([...encodeLength(encoded.length, 192), ...encoded]);
      }
      if (bytes4.length === 1 && bytes4[0] < 128)
        return bytes4;
      return new Uint8Array([...encodeLength(bytes4.length, 128), ...bytes4]);
    }
    exports.bytesToRlp = bytesToRlp;
    function encodeLength(length, offset) {
      if (length < 56)
        return [offset + length];
      return [(0, toBytes_js_1.toBytes)(length).length + offset + 55, ...(0, toBytes_js_1.toBytes)(length)];
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/address/getContractAddress.js
var require_getContractAddress = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/address/getContractAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = void 0;
    var concat_js_1 = require_concat();
    var isBytes_js_1 = require_isBytes();
    var pad_js_1 = require_pad();
    var slice_js_1 = require_slice();
    var toBytes_js_1 = require_toBytes();
    var toRlp_js_1 = require_toRlp();
    var keccak256_js_1 = require_keccak256();
    var getAddress_js_1 = require_getAddress();
    function getContractAddress3(opts) {
      if (opts.opcode === "CREATE2")
        return getCreate2Address(opts);
      return getCreateAddress(opts);
    }
    exports.getContractAddress = getContractAddress3;
    function getCreateAddress(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      let nonce = (0, toBytes_js_1.toBytes)(opts.nonce);
      if (nonce[0] === 0)
        nonce = new Uint8Array([]);
      return (0, getAddress_js_1.getAddress)(`0x${(0, keccak256_js_1.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], "bytes")).slice(26)}`);
    }
    exports.getCreateAddress = getCreateAddress;
    function getCreate2Address(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      const salt = (0, pad_js_1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1.toBytes)(opts.salt), {
        size: 32
      });
      const bytecodeHash = (0, toBytes_js_1.toBytes)((0, keccak256_js_1.keccak256)((0, isBytes_js_1.isBytes)(opts.bytecode) ? opts.bytecode : (0, toBytes_js_1.toBytes)(opts.bytecode)));
      return (0, getAddress_js_1.getAddress)((0, slice_js_1.slice)((0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([(0, toBytes_js_1.toBytes)("0xff"), from, salt, bytecodeHash])), 12));
    }
    exports.getCreate2Address = getCreate2Address;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/transactionReceipt.js
var require_transactionReceipt = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/transactionReceipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransactionReceipt = exports.formatTransactionReceipt = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter2();
    var log_js_1 = require_log2();
    var transaction_js_1 = require_transaction2();
    var statuses2 = {
      "0x0": "reverted",
      "0x1": "success"
    };
    function formatTransactionReceipt2(transactionReceipt) {
      return {
        ...transactionReceipt,
        blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
        contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
        effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
        gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
        logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => (0, log_js_1.formatLog)(log)) : null,
        to: transactionReceipt.to ? transactionReceipt.to : null,
        transactionIndex: transactionReceipt.transactionIndex ? (0, fromHex_js_1.hexToNumber)(transactionReceipt.transactionIndex) : null,
        status: transactionReceipt.status ? statuses2[transactionReceipt.status] : null,
        type: transactionReceipt.type ? transaction_js_1.transactionType[transactionReceipt.type] || transactionReceipt.type : null
      };
    }
    exports.formatTransactionReceipt = formatTransactionReceipt2;
    exports.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)("transactionReceipt", formatTransactionReceipt2);
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/fromBytes.js
var require_fromBytes = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/fromBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.fromBytes = void 0;
    var encoding_js_1 = require_encoding();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    function fromBytes(bytes4, toOrOpts) {
      const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
      const to = opts.to;
      if (to === "number")
        return bytesToNumber(bytes4, opts);
      if (to === "bigint")
        return bytesToBigint(bytes4, opts);
      if (to === "boolean")
        return bytesToBool(bytes4, opts);
      if (to === "string")
        return bytesToString(bytes4, opts);
      return (0, toHex_js_1.bytesToHex)(bytes4, opts);
    }
    exports.fromBytes = fromBytes;
    function bytesToBigint(bytes4, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes4, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes4, opts);
      return (0, fromHex_js_1.hexToBigInt)(hex);
    }
    exports.bytesToBigint = bytesToBigint;
    function bytesToBool(bytes_, opts = {}) {
      let bytes4 = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes4, { size: opts.size });
        bytes4 = (0, trim_js_1.trim)(bytes4);
      }
      if (bytes4.length > 1 || bytes4[0] > 1)
        throw new encoding_js_1.InvalidBytesBooleanError(bytes4);
      return Boolean(bytes4[0]);
    }
    exports.bytesToBool = bytesToBool;
    function bytesToNumber(bytes4, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes4, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes4, opts);
      return (0, fromHex_js_1.hexToNumber)(hex);
    }
    exports.bytesToNumber = bytesToNumber;
    function bytesToString(bytes_, opts = {}) {
      let bytes4 = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes4, { size: opts.size });
        bytes4 = (0, trim_js_1.trim)(bytes4, { dir: "right" });
      }
      return new TextDecoder().decode(bytes4);
    }
    exports.bytesToString = bytesToString;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/fromRlp.js
var require_fromRlp = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/encoding/fromRlp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromRlp = void 0;
    var encoding_js_1 = require_encoding();
    var fromBytes_js_1 = require_fromBytes();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function fromRlp(value, to) {
      const bytes4 = parse(value);
      const [data, consumed] = rlpToBytes(bytes4);
      if (consumed < bytes4.length)
        throw new encoding_js_1.DataLengthTooLongError({
          consumed,
          length: bytes4.length
        });
      return format(data, to);
    }
    exports.fromRlp = fromRlp;
    function parse(value) {
      if (typeof value === "string") {
        if (value.length > 3 && value.length % 2 !== 0)
          throw new encoding_js_1.InvalidHexValueError(value);
        return (0, toBytes_js_1.hexToBytes)(value);
      }
      return value;
    }
    function format(bytes4, to) {
      if (Array.isArray(bytes4))
        return bytes4.map((b) => format(b, to));
      return to === "hex" ? (0, toHex_js_1.bytesToHex)(bytes4) : bytes4;
    }
    function rlpToBytes(bytes4, offset = 0) {
      if (bytes4.length === 0)
        return [new Uint8Array([]), 0];
      const prefix = bytes4[offset];
      if (prefix <= 127)
        return [new Uint8Array([bytes4[offset]]), 1];
      if (prefix <= 183) {
        const length2 = prefix - 128;
        const offset_ = offset + 1;
        if (offset_ + length2 > bytes4.length)
          throw new encoding_js_1.DataLengthTooShortError({
            length: offset_ + length2,
            dataLength: bytes4.length
          });
        return [bytes4.slice(offset_, offset_ + length2), 1 + length2];
      }
      if (prefix <= 191) {
        const lengthOfLength2 = prefix - 183;
        const offset_ = offset + 1;
        const length2 = (0, fromBytes_js_1.bytesToNumber)(bytes4.slice(offset_, offset_ + lengthOfLength2));
        if (offset_ + lengthOfLength2 + length2 > bytes4.length)
          throw new encoding_js_1.DataLengthTooShortError({
            length: lengthOfLength2 + length2,
            dataLength: bytes4.length - lengthOfLength2
          });
        return [
          bytes4.slice(offset_ + lengthOfLength2, offset_ + lengthOfLength2 + length2),
          1 + lengthOfLength2 + length2
        ];
      }
      let lengthOfLength = 0;
      let length = prefix - 192;
      if (prefix > 247) {
        lengthOfLength = prefix - 247;
        length = (0, fromBytes_js_1.bytesToNumber)(bytes4.slice(offset + 1, offset + 1 + lengthOfLength));
      }
      let nextOffset = offset + 1 + lengthOfLength;
      if (nextOffset > bytes4.length)
        throw new encoding_js_1.DataLengthTooShortError({
          length: nextOffset,
          dataLength: bytes4.length
        });
      const consumed = 1 + lengthOfLength + length;
      const result = [];
      while (nextOffset < offset + consumed) {
        const decoded = rlpToBytes(bytes4, nextOffset);
        result.push(decoded[0]);
        nextOffset += decoded[1];
        if (nextOffset > offset + consumed)
          throw new encoding_js_1.OffsetOutOfBoundsError({
            nextOffset,
            offset: offset + consumed
          });
      }
      return [result, consumed];
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/isHash.js
var require_isHash = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/hash/isHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHash = void 0;
    var isHex_js_1 = require_isHex();
    var size_js_1 = require_size();
    function isHash(hash4) {
      return (0, isHex_js_1.isHex)(hash4) && (0, size_js_1.size)(hash4) === 32;
    }
    exports.isHash = isHash;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/hashTypedData.js
var require_hashTypedData = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/hashTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTypedData = void 0;
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var concat_js_1 = require_concat();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var typedData_js_1 = require_typedData();
    function hashTypedData2({ domain: domain_, message, primaryType, types: types_ }) {
      const domain = typeof domain_ === "undefined" ? {} : domain_;
      const types = {
        EIP712Domain: [
          typeof domain?.name === "string" && { name: "name", type: "string" },
          domain?.version && { name: "version", type: "string" },
          typeof domain?.chainId === "number" && {
            name: "chainId",
            type: "uint256"
          },
          domain?.verifyingContract && {
            name: "verifyingContract",
            type: "address"
          },
          domain?.salt && { name: "salt", type: "bytes32" }
        ].filter(Boolean),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      const parts = ["0x1901"];
      if (domain)
        parts.push(hashDomain2({
          domain,
          types
        }));
      if (primaryType !== "EIP712Domain") {
        parts.push(hashStruct2({
          data: message,
          primaryType,
          types
        }));
      }
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));
    }
    exports.hashTypedData = hashTypedData2;
    function hashDomain2({ domain, types }) {
      return hashStruct2({
        data: domain,
        primaryType: "EIP712Domain",
        types
      });
    }
    function hashStruct2({ data, primaryType, types }) {
      const encoded = encodeData2({
        data,
        primaryType,
        types
      });
      return (0, keccak256_js_1.keccak256)(encoded);
    }
    function encodeData2({ data, primaryType, types }) {
      const encodedTypes = [{ type: "bytes32" }];
      const encodedValues = [hashType2({ primaryType, types })];
      for (const field of types[primaryType]) {
        const [type, value] = encodeField2({
          types,
          name: field.name,
          type: field.type,
          value: data[field.name]
        });
        encodedTypes.push(type);
        encodedValues.push(value);
      }
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
    }
    function hashType2({ primaryType, types }) {
      const encodedHashType = (0, toHex_js_1.toHex)(encodeType2({ primaryType, types }));
      return (0, keccak256_js_1.keccak256)(encodedHashType);
    }
    function encodeType2({ primaryType, types }) {
      let result = "";
      const unsortedDeps = findTypeDependencies2({ primaryType, types });
      unsortedDeps.delete(primaryType);
      const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
      for (const type of deps) {
        result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
      }
      return result;
    }
    function findTypeDependencies2({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
      const match = primaryType_.match(/^\w*/u);
      const primaryType = match?.[0];
      if (results.has(primaryType) || types[primaryType] === void 0) {
        return results;
      }
      results.add(primaryType);
      for (const field of types[primaryType]) {
        findTypeDependencies2({ primaryType: field.type, types }, results);
      }
      return results;
    }
    function encodeField2({ types, name, type, value }) {
      if (types[type] !== void 0) {
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)(encodeData2({ data: value, primaryType: type, types }))
        ];
      }
      if (type === "bytes") {
        const prepend = value.length % 2 ? "0" : "";
        value = `0x${prepend + value.slice(2)}`;
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)(value)];
      }
      if (type === "string")
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];
      if (type.lastIndexOf("]") === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item) => encodeField2({
          name,
          type: parsedType,
          types,
          value: item
        }));
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
        ];
      }
      return [{ type }, value];
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash4) {
  if (typeof hash4 !== "function" || typeof hash4.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash4.outputLen);
  number(hash4.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
var assert, assert_default;
var init_assert = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/_assert.js"() {
    assert = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    assert_default = assert;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/crypto.js
var crypto;
var init_crypto = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/crypto.js"() {
    crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad2 = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad2);
    pad2 += arr.length;
  }
  return result;
}
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var createView, rotr, isLE, hexes, Hash;
var init_utils = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/utils.js"() {
    init_crypto();
    createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    rotr = (word, shift) => word << 32 - shift | word >>> shift;
    isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!isLE)
      throw new Error("Non little-endian hardware is not supported");
    hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    Hash = class {
      clone() {
        return this._cloneInto();
      }
    };
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
var SHA2;
var init_sha2 = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/_sha2.js"() {
    init_assert();
    init_utils();
    SHA2 = class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE3) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE3;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data) {
        assert_default.exists(this);
        const { view, buffer: buffer2, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer2.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        assert_default.exists(this);
        assert_default.output(out, this);
        this.finished = true;
        const { buffer: buffer2, view, blockLen, isLE: isLE3 } = this;
        let { pos } = this;
        buffer2[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer2[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE3);
      }
      digest() {
        const { buffer: buffer2, outputLen } = this;
        this.digestInto(buffer2);
        const res = buffer2.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer2);
        return to;
      }
    };
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/sha256.js
var Chi, Maj, SHA256_K, IV, SHA256_W, SHA256, SHA224, sha256, sha224;
var init_sha256 = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/sha256.js"() {
    init_sha2();
    init_utils();
    Chi = (a, b, c) => a & b ^ ~a & c;
    Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA256_W = new Uint32Array(64);
    SHA256 = class extends SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    sha256 = wrapConstructor(() => new SHA256());
    sha224 = wrapConstructor(() => new SHA224());
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
function bytesToHex(bytes4) {
  if (!u8a(bytes4))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes4.length; i++) {
    hex += hexes2[bytes4[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hex.length % 2)
    throw new Error("hex string is invalid: unpadded " + hex.length);
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes4) {
  return hexToNumber(bytesToHex(bytes4));
}
function bytesToNumberLE(bytes4) {
  if (!u8a(bytes4))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes4).reverse()));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrs) {
  const r = new Uint8Array(arrs.reduce((sum, a) => sum + a.length, 0));
  let pad2 = 0;
  arrs.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad2);
    pad2 += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string") {
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
var _0n, _1n, _2n, u8a, hexes2, numberToBytesBE, numberToBytesLE, numberToVarBytesBE, bitGet, bitSet, bitMask, u8n, u8fr, validatorFns;
var init_utils2 = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/utils.js"() {
    _0n = BigInt(0);
    _1n = BigInt(1);
    _2n = BigInt(2);
    u8a = (a) => a instanceof Uint8Array;
    hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    numberToBytesBE = (n, len) => hexToBytes(n.toString(16).padStart(len * 2, "0"));
    numberToBytesLE = (n, len) => numberToBytesBE(n, len).reverse();
    numberToVarBytesBE = (n) => hexToBytes(numberToHexUnpadded(n));
    bitGet = (n, pos) => n >> BigInt(pos) & _1n;
    bitSet = (n, pos, value) => n | (value ? _1n : _0n) << BigInt(pos);
    bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    u8n = (data) => new Uint8Array(data);
    u8fr = (arr) => Uint8Array.from(arr);
    validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod(number3, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp2.sqr(ge2);
      x = Fp2.mul(x, ge2);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n2);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n2), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes4) => {
      if (bytes4.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes4.length}`);
      return isLE3 ? bytesToNumberLE(bytes4) : bytesToNumberBE(bytes4);
    }
  });
  return Object.freeze(f);
}
function hashToPrivateScalar(hash4, groupOrder, isLE3 = false) {
  hash4 = ensureBytes("privateHash", hash4);
  const hashLen = hash4.length;
  const minLen = nLength(groupOrder).nByteLength + 8;
  if (minLen < 24 || hashLen < minLen || hashLen > 1024)
    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
  const num = isLE3 ? bytesToNumberLE(hash4) : bytesToNumberBE(hash4);
  return mod(num, groupOrder - _1n2) + _1n2;
}
var _0n2, _1n2, _2n2, _3n, _4n, _5n, _8n, _9n, _16n, FIELD_FIELDS;
var init_modular = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/modular.js"() {
    init_utils2();
    _0n2 = BigInt(0);
    _1n2 = BigInt(1);
    _2n2 = BigInt(2);
    _3n = BigInt(3);
    _4n = BigInt(4);
    _5n = BigInt(5);
    _8n = BigInt(8);
    _9n = BigInt(9);
    _16n = BigInt(16);
    FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/curve.js
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
var _0n3, _1n3;
var init_curve = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/curve.js"() {
    init_modular();
    init_utils2();
    _0n3 = BigInt(0);
    _1n3 = BigInt(1);
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes4 = CURVE.toBytes || ((c, point, isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes4) => {
    const tail = bytes4.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint)
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n4)
        return I;
      assertGE(n);
      if (n === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes4(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp2.ORDER;
  }
  function modN2(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes4) {
      const len = bytes4.length;
      const head = bytes4[0];
      const tail = bytes4.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n4;
    return number3 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const rand = CURVE.randomBytes(Fp2.BYTES + 8);
      const num = hashToPrivateScalar(rand, CURVE_ORDER);
      return numberToBytesBE(num, CURVE.nByteLength);
    },
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes4) {
    const num = bytesToNumberBE(bytes4);
    const delta = bytes4.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes4) {
    return modN2(bits2int(bytes4));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash4, randomBytes: randomBytes4 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash4(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes4(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e, Fp2.BYTES));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n4)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const drbg = createHmacDrbg(CURVE.hash.outputLen, CURVE.nByteLength, CURVE.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN2(h * is);
    const u2 = modN2(r * is);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q = Fp2.ORDER;
  let l = _0n4;
  for (let o = q - _1n4; o % _2n3 === _0n4; o /= _2n3)
    l += _1n4;
  const c1 = l;
  const c2 = (q - _1n4) / _2n3 ** c1;
  const c3 = (c2 - _1n4) / _2n3;
  const c4 = _2n3 ** c1 - _1n4;
  const c5 = _2n3 ** (c1 - _1n4);
  const c6 = Fp2.pow(Z, c2);
  const c7 = Fp2.pow(Z, (c2 + _1n4) / _2n3);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v);
    let tv5 = Fp2.mul(u, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v);
    tv3 = Fp2.mul(tv5, u);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n4; i--) {
      let tv52 = _2n3 ** (i - _2n3);
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c22 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp2.sqr(v);
      const tv2 = Fp2.mul(u, v);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v);
      const isQR = Fp2.eql(tv3, u);
      let y = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp2.sqr(u);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x = Fp2.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y = Fp2.mul(tv1, u);
    y = Fp2.mul(y, value);
    x = Fp2.cmov(x, tv3, isValid);
    y = Fp2.cmov(y, value, isValid);
    const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
    y = Fp2.cmov(Fp2.neg(y), y, e1);
    x = Fp2.div(x, tv4);
    return { x, y };
  };
}
var b2n, h2b, DER, _0n4, _1n4, _2n3, _3n2, _4n2;
var init_weierstrass = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
    init_modular();
    init_utils2();
    init_utils2();
    init_curve();
    ({ bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports);
    DER = {
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice2(h(sig.s));
        const r = slice2(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    _0n4 = BigInt(0);
    _1n4 = BigInt(1);
    _2n3 = BigInt(2);
    _3n2 = BigInt(3);
    _4n2 = BigInt(4);
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function validateDST(dst) {
  if (dst instanceof Uint8Array)
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes2(dst);
  throw new Error("DST must be Uint8Array or string");
}
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function isBytes(item) {
  if (!(item instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function isNum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "string",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash4, expand, DST: _DST } = options;
  isBytes(msg);
  isNum(count);
  const DST = validateDST(_DST);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash4);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash4);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u[0]));
      const u1 = Point2.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}
var os2ip;
var init_hash_to_curve = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/abstract/hash-to-curve.js"() {
    init_modular();
    init_utils2();
    os2ip = bytesToNumberBE;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/hmac.js
var HMAC, hmac;
var init_hmac = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/hashes/esm/hmac.js"() {
    init_assert();
    init_utils();
    HMAC = class extends Hash {
      constructor(hash4, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        assert_default.hash(hash4);
        const key = toBytes(_key);
        this.iHash = hash4.create();
        if (typeof this.iHash.update !== "function")
          throw new TypeError("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad2 = new Uint8Array(blockLen);
        pad2.set(key.length > blockLen ? hash4.create().update(key).digest() : key);
        for (let i = 0; i < pad2.length; i++)
          pad2[i] ^= 54;
        this.iHash.update(pad2);
        this.oHash = hash4.create();
        for (let i = 0; i < pad2.length; i++)
          pad2[i] ^= 54 ^ 92;
        this.oHash.update(pad2);
        pad2.fill(0);
      }
      update(buf) {
        assert_default.exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        assert_default.exists(this);
        assert_default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    hmac = (hash4, key, message) => new HMAC(hash4, key).update(message).digest();
    hmac.create = (hash4, key) => new HMAC(hash4, key);
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash4) {
  return {
    hash: hash4,
    hmac: (key, ...msgs) => hmac(hash4, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash4) => weierstrass({ ...curveDef, ...getHash(hash4) });
  return Object.freeze({ ...create(defHash), create });
}
var init_shortw_utils = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/_shortw_utils.js"() {
    init_hmac();
    init_utils();
    init_weierstrass();
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_exports = {};
__export(secp256k1_exports, {
  encodeToCurve: () => encodeToCurve,
  hashToCurve: () => hashToCurve,
  schnorr: () => schnorr,
  secp256k1: () => secp256k1
});
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n4 !== _0n5)
    y = modP(-y);
  const p = new Point(x, y, _1n5);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var secp256k1P, secp256k1N, _1n5, _2n4, divNearest, Fp, secp256k1, _0n5, fe, ge, TAGGED_HASH_PREFIXES, pointToBytes, numTo32b, modP, modN, Point, GmulAdd, schnorr, isoMap, mapSWU, hashToCurve, encodeToCurve;
var init_secp256k1 = __esm({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/curves/esm/secp256k1.js"() {
    init_sha256();
    init_utils();
    init_modular();
    init_weierstrass();
    init_utils2();
    init_hash_to_curve();
    init_shortw_utils();
    secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    _1n5 = BigInt(1);
    _2n4 = BigInt(2);
    divNearest = (a, b) => (a + b / _2n4) / b;
    Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    secp256k1 = createCurve({
      a: BigInt(0),
      b: BigInt(7),
      Fp,
      n: secp256k1N,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = mod(k - c1 * a1 - c2 * a2, n);
          let k2 = mod(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256);
    _0n5 = BigInt(0);
    fe = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1P;
    ge = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1N;
    TAGGED_HASH_PREFIXES = {};
    pointToBytes = (point) => point.toRawBytes(true).slice(1);
    numTo32b = (n) => numberToBytesBE(n, 32);
    modP = (x) => mod(x, secp256k1P);
    modN = (x) => mod(x, secp256k1N);
    Point = secp256k1.ProjectivePoint;
    GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    schnorr = {
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE,
        bytesToNumberBE,
        taggedHash,
        mod
      }
    };
    isoMap = isogenyMap(Fp, [
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
      ],
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
      ]
    ].map((i) => i.map((j) => BigInt(j))));
    mapSWU = mapToCurveSimpleSWU(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    });
    ({ hashToCurve, encodeToCurve } = createHasher(secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256
    }));
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/recoverPublicKey.js
var require_recoverPublicKey = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/recoverPublicKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverPublicKey = void 0;
    var isHex_js_1 = require_isHex();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function recoverPublicKey({ hash: hash4, signature }) {
      const signatureHex = (0, isHex_js_1.isHex)(signature) ? signature : (0, toHex_js_1.toHex)(signature);
      const hashHex = (0, isHex_js_1.isHex)(hash4) ? hash4 : (0, toHex_js_1.toHex)(hash4);
      let v = (0, fromHex_js_1.hexToNumber)(`0x${signatureHex.slice(130)}`);
      if (v === 0 || v === 1)
        v += 27;
      const { secp256k1: secp256k12 } = await Promise.resolve().then(() => (init_secp256k1(), secp256k1_exports));
      const publicKey = secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);
      return `0x${publicKey}`;
    }
    exports.recoverPublicKey = recoverPublicKey;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/recoverAddress.js
var require_recoverAddress = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/recoverAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverAddress = void 0;
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    async function recoverAddress2({ hash: hash4, signature }) {
      return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash: hash4, signature }));
    }
    exports.recoverAddress = recoverAddress2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/hashMessage.js
var require_hashMessage = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/hashMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashMessage = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    function hashMessage4(message, to_) {
      const messageBytes = (() => {
        if (typeof message === "string")
          return (0, toBytes_js_1.stringToBytes)(message);
        if (message.raw instanceof Uint8Array)
          return message.raw;
        return (0, toBytes_js_1.toBytes)(message.raw);
      })();
      const prefixBytes = (0, toBytes_js_1.stringToBytes)(`Ethereum Signed Message:
${messageBytes.length}`);
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([prefixBytes, messageBytes]), to_);
    }
    exports.hashMessage = hashMessage4;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/recoverMessageAddress.js
var require_recoverMessageAddress = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/recoverMessageAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverMessageAddress = void 0;
    var hashMessage_js_1 = require_hashMessage();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverMessageAddress({ message, signature }) {
      return (0, recoverAddress_js_1.recoverAddress)({ hash: (0, hashMessage_js_1.hashMessage)(message), signature });
    }
    exports.recoverMessageAddress = recoverMessageAddress;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/recoverTypedDataAddress.js
var require_recoverTypedDataAddress = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/recoverTypedDataAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverTypedDataAddress = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverTypedDataAddress({ domain, message, primaryType, signature, types }) {
      return (0, recoverAddress_js_1.recoverAddress)({
        hash: (0, hashTypedData_js_1.hashTypedData)({
          domain,
          message,
          primaryType,
          types
        }),
        signature
      });
    }
    exports.recoverTypedDataAddress = recoverTypedDataAddress;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/verifyMessage.js
var require_verifyMessage = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/verifyMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyMessage = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    async function verifyMessage2({ address, message, signature }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature }));
    }
    exports.verifyMessage = verifyMessage2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/verifyTypedData.js
var require_verifyTypedData = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/signature/verifyTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    async function verifyTypedData2({ address, domain, message, primaryType, signature, types }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
        domain,
        message,
        primaryType,
        signature,
        types
      }));
    }
    exports.verifyTypedData = verifyTypedData2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/getSerializedTransactionType.js
var require_getSerializedTransactionType = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/getSerializedTransactionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSerializedTransactionType = void 0;
    var transaction_js_1 = require_transaction();
    var slice_js_1 = require_slice();
    var fromHex_js_1 = require_fromHex();
    function getSerializedTransactionType(serializedTransaction) {
      const serializedType = (0, slice_js_1.sliceHex)(serializedTransaction, 0, 1);
      if (serializedType === "0x02")
        return "eip1559";
      if (serializedType === "0x01")
        return "eip2930";
      if (serializedType !== "0x" && (0, fromHex_js_1.hexToNumber)(serializedType) >= 192)
        return "legacy";
      throw new transaction_js_1.InvalidSerializedTransactionTypeError({ serializedType });
    }
    exports.getSerializedTransactionType = getSerializedTransactionType;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/getTransactionType.js
var require_getTransactionType = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/getTransactionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionType = void 0;
    var transaction_js_1 = require_transaction();
    function getTransactionType2(transaction) {
      if (transaction.type)
        return transaction.type;
      if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined")
        return "eip1559";
      if (typeof transaction.gasPrice !== "undefined") {
        if (typeof transaction.accessList !== "undefined")
          return "eip2930";
        return "legacy";
      }
      throw new transaction_js_1.InvalidSerializableTransactionError({ transaction });
    }
    exports.getTransactionType = getTransactionType2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/assertTransaction.js
var require_assertTransaction = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/assertTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = void 0;
    var address_js_1 = require_address();
    var base_js_1 = require_base2();
    var chain_js_1 = require_chain();
    var node_js_1 = require_node();
    var isAddress_js_1 = require_isAddress();
    function assertTransactionEIP1559(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (gasPrice)
        throw new base_js_1.BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
      if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }
    exports.assertTransactionEIP1559 = assertTransactionEIP1559;
    function assertTransactionEIP2930(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
    }
    exports.assertTransactionEIP2930 = assertTransactionEIP2930;
    function assertTransactionLegacy(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction;
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (typeof chainId !== "undefined" && chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
      if (accessList)
        throw new base_js_1.BaseError("`accessList` is not a valid Legacy Transaction attribute.");
    }
    exports.assertTransactionLegacy = assertTransactionLegacy;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/parseTransaction.js
var require_parseTransaction = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/parseTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTransaction = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction();
    var isAddress_js_1 = require_isAddress();
    var isHex_js_1 = require_isHex();
    var pad_js_1 = require_pad();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var fromRlp_js_1 = require_fromRlp();
    var isHash_js_1 = require_isHash();
    var assertTransaction_js_1 = require_assertTransaction();
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    function parseTransaction(serializedTransaction) {
      const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
      if (type === "eip1559")
        return parseTransactionEIP1559(serializedTransaction);
      if (type === "eip2930")
        return parseTransactionEIP2930(serializedTransaction);
      return parseTransactionLegacy(serializedTransaction);
    }
    exports.parseTransaction = parseTransaction;
    function parseTransactionEIP1559(serializedTransaction) {
      const transactionArray = (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, "hex");
      const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s] = transactionArray;
      if (!(transactionArray.length === 9 || transactionArray.length === 12))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            maxPriorityFeePerGas,
            maxFeePerGas,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 9 ? {
              v,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "eip1559"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip1559"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== "0x")
        transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
      if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
        transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionEIP2930(serializedTransaction) {
      const transactionArray = (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, "hex");
      const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
      if (!(transactionArray.length === 8 || transactionArray.length === 11))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 8 ? {
              v,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "eip2930"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip2930"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionLegacy(serializedTransaction) {
      const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, "hex");
      const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
      if (!(transactionArray.length === 6 || transactionArray.length === 9))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            ...transactionArray.length > 6 ? {
              v: chainIdOrV_,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "legacy"
        });
      const transaction = {
        type: "legacy"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      if (transactionArray.length === 6)
        return transaction;
      const chainIdOrV = (0, isHex_js_1.isHex)(chainIdOrV_) && chainIdOrV_ !== "0x" ? (0, fromHex_js_1.hexToBigInt)(chainIdOrV_) : 0n;
      if (s === "0x" && r === "0x") {
        if (chainIdOrV > 0)
          transaction.chainId = Number(chainIdOrV);
        return transaction;
      }
      const v = chainIdOrV;
      const chainId = Number((v - 35n) / 2n);
      if (chainId > 0)
        transaction.chainId = chainId;
      else if (v !== 27n && v !== 28n)
        throw new transaction_js_1.InvalidLegacyVError({ v });
      transaction.v = v;
      transaction.s = s;
      transaction.r = r;
      return transaction;
    }
    function parseAccessList(accessList_) {
      const accessList = [];
      for (let i = 0; i < accessList_.length; i++) {
        const [address, storageKeys] = accessList_[i];
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        accessList.push({
          address,
          storageKeys: storageKeys.map((key) => (0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))
        });
      }
      return accessList;
    }
    function parseEIP155Signature(transactionArray) {
      const signature = transactionArray.slice(-3);
      const v = signature[0] === "0x" || (0, fromHex_js_1.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
      return {
        r: (0, pad_js_1.padHex)(signature[1], { size: 32 }),
        s: (0, pad_js_1.padHex)(signature[2], { size: 32 }),
        v,
        yParity: v === 27n ? 0 : 1
      };
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/serializeAccessList.js
var require_serializeAccessList = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/serializeAccessList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeAccessList = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction();
    var isAddress_js_1 = require_isAddress();
    function serializeAccessList(accessList) {
      if (!accessList || accessList.length === 0)
        return [];
      const serializedAccessList = [];
      for (let i = 0; i < accessList.length; i++) {
        const { address, storageKeys } = accessList[i];
        for (let j = 0; j < storageKeys.length; j++) {
          if (storageKeys[j].length - 2 !== 64) {
            throw new transaction_js_1.InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
          }
        }
        if (!(0, isAddress_js_1.isAddress)(address)) {
          throw new address_js_1.InvalidAddressError({ address });
        }
        serializedAccessList.push([address, storageKeys]);
      }
      return serializedAccessList;
    }
    exports.serializeAccessList = serializeAccessList;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/serializeTransaction.js
var require_serializeTransaction = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/transaction/serializeTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeTransaction = void 0;
    var transaction_js_1 = require_transaction();
    var concat_js_1 = require_concat();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var toRlp_js_1 = require_toRlp();
    var assertTransaction_js_1 = require_assertTransaction();
    var getTransactionType_js_1 = require_getTransactionType();
    var serializeAccessList_js_1 = require_serializeAccessList();
    function serializeTransaction(transaction, signature) {
      const type = (0, getTransactionType_js_1.getTransactionType)(transaction);
      if (type === "eip1559")
        return serializeTransactionEIP1559(transaction, signature);
      if (type === "eip2930")
        return serializeTransactionEIP2930(transaction, signature);
      return serializeTransactionLegacy(transaction, signature);
    }
    exports.serializeTransaction = serializeTransaction;
    function serializeTransactionEIP1559(transaction, signature) {
      const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature)
        serializedTransaction.push(signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1), (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      return (0, concat_js_1.concatHex)([
        "0x02",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionEIP2930(transaction, signature) {
      const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature)
        serializedTransaction.push(signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1), signature.r, signature.s);
      return (0, concat_js_1.concatHex)([
        "0x01",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionLegacy(transaction, signature) {
      const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      let serializedTransaction = [
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x"
      ];
      if (signature) {
        let v = 27n + (signature.v === 27n ? 0n : 1n);
        if (chainId > 0)
          v = BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
        else if (signature.v !== v)
          throw new transaction_js_1.InvalidLegacyVError({ v: signature.v });
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(v),
          signature.r,
          signature.s
        ];
      } else if (chainId > 0) {
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(chainId),
          "0x",
          "0x"
        ];
      }
      return (0, toRlp_js_1.toRlp)(serializedTransaction);
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/parseUnits.js
var require_parseUnits = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/parseUnits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseUnits = void 0;
    function parseUnits2(value, decimals) {
      let [integer, fraction = "0"] = value.split(".");
      const negative = integer.startsWith("-");
      if (negative)
        integer = integer.slice(1);
      fraction = fraction.replace(/(0+)$/, "");
      if (decimals === 0) {
        integer = `${Math.round(Number(`${integer}.${fraction}`))}`;
        fraction = "";
      } else if (fraction.length > decimals) {
        const [left, unit, right] = [
          fraction.slice(0, decimals - 1),
          fraction.slice(decimals - 1, decimals),
          fraction.slice(decimals)
        ];
        const rounded = Math.round(Number(`${unit}.${right}`));
        if (rounded > 9)
          fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
        else
          fraction = `${left}${rounded}`;
        if (fraction.length > decimals) {
          fraction = fraction.slice(1);
          integer = `${BigInt(integer) + 1n}`;
        }
        fraction = fraction.slice(0, decimals);
      } else {
        fraction = fraction.padEnd(decimals, "0");
      }
      return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
    }
    exports.parseUnits = parseUnits2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/parseEther.js
var require_parseEther = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/parseEther.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEther = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseEther2(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.etherUnits[unit]);
    }
    exports.parseEther = parseEther2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/parseGwei.js
var require_parseGwei = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/unit/parseGwei.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGwei = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseGwei(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit]);
    }
    exports.parseGwei = parseGwei;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/index.js
var require_utils8 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatHex = exports.concatBytes = exports.concat = exports.extractFunctionParts = exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.isAddressEqual = exports.isAddress = exports.getAddress = exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = exports.publicKeyToAddress = exports.parseAccount = exports.formatAbiParams = exports.formatAbiItem = exports.formatAbiItemWithArgs = exports.encodePacked = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.getAbiItem = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeAbiParameters = exports.validateTypedData = exports.stringify = exports.rpc = exports.getSocket = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = exports.getChainContractAddress = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.buildRequest = void 0;
    exports.getEventSelector = exports.defineFormatter = exports.getTransactionError = exports.getEstimateGasError = exports.getContractError = exports.getCallError = exports.getNodeError = exports.containsNodeError = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBigInt = exports.hexToBool = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.stringToHex = exports.numberToHex = exports.toHex = exports.bytesToHex = exports.boolToHex = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.toBytes = exports.boolToBytes = exports.toRlp = exports.extract = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.formatLog = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatBlock = exports.defineBlock = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = exports.padBytes = exports.pad = exports.isHex = exports.isBytes = void 0;
    exports.parseGwei = exports.parseEther = exports.parseUnits = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.serializeAccessList = exports.serializeTransaction = exports.prepareRequest = exports.parseTransaction = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.getTransactionType = exports.getSerializedTransactionType = exports.hashMessage = exports.verifyTypedData = exports.verifyMessage = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hashTypedData = exports.keccak256 = exports.isHash = exports.getFunctionSelector = void 0;
    var buildRequest_js_1 = require_buildRequest();
    Object.defineProperty(exports, "buildRequest", { enumerable: true, get: function() {
      return buildRequest_js_1.buildRequest;
    } });
    var ccip_js_1 = require_ccip2();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var chain_js_1 = require_chain2();
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return chain_js_1.assertCurrentChain;
    } });
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return chain_js_1.defineChain;
    } });
    Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function() {
      return chain_js_1.getChainContractAddress;
    } });
    var regex_js_1 = require_regex2();
    Object.defineProperty(exports, "arrayRegex", { enumerable: true, get: function() {
      return regex_js_1.arrayRegex;
    } });
    Object.defineProperty(exports, "bytesRegex", { enumerable: true, get: function() {
      return regex_js_1.bytesRegex;
    } });
    Object.defineProperty(exports, "integerRegex", { enumerable: true, get: function() {
      return regex_js_1.integerRegex;
    } });
    var rpc_js_1 = require_rpc2();
    Object.defineProperty(exports, "getSocket", { enumerable: true, get: function() {
      return rpc_js_1.getSocket;
    } });
    Object.defineProperty(exports, "rpc", { enumerable: true, get: function() {
      return rpc_js_1.rpc;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var abitype_1 = require_cjs();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
    Object.defineProperty(exports, "formatAbiItemWithArgs", { enumerable: true, get: function() {
      return formatAbiItemWithArgs_js_1.formatAbiItemWithArgs;
    } });
    var formatAbiItem_js_1 = require_formatAbiItem();
    Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiItem;
    } });
    Object.defineProperty(exports, "formatAbiParams", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiParams;
    } });
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var extractFunctionParts_js_1 = require_extractFunctionParts();
    Object.defineProperty(exports, "extractFunctionName", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionName;
    } });
    Object.defineProperty(exports, "extractFunctionParams", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParams;
    } });
    Object.defineProperty(exports, "extractFunctionType", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionType;
    } });
    Object.defineProperty(exports, "extractFunctionParts", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParts;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var block_js_1 = require_block2();
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_1.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_1.formatBlock;
    } });
    var transaction_js_1 = require_transaction2();
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_1.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_1.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_1.transactionType;
    } });
    var log_js_1 = require_log2();
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_1.formatLog;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    var extract_js_1 = require_extract();
    Object.defineProperty(exports, "extract", { enumerable: true, get: function() {
      return extract_js_1.extract;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigint;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getNodeError_js_1 = require_getNodeError();
    Object.defineProperty(exports, "containsNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.containsNodeError;
    } });
    Object.defineProperty(exports, "getNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.getNodeError;
    } });
    var getCallError_js_1 = require_getCallError();
    Object.defineProperty(exports, "getCallError", { enumerable: true, get: function() {
      return getCallError_js_1.getCallError;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    Object.defineProperty(exports, "getEstimateGasError", { enumerable: true, get: function() {
      return getEstimateGasError_js_1.getEstimateGasError;
    } });
    var getTransactionError_js_1 = require_getTransactionError();
    Object.defineProperty(exports, "getTransactionError", { enumerable: true, get: function() {
      return getTransactionError_js_1.getTransactionError;
    } });
    var formatter_js_1 = require_formatter2();
    Object.defineProperty(exports, "defineFormatter", { enumerable: true, get: function() {
      return formatter_js_1.defineFormatter;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var prepareRequest_js_1 = require_prepareRequest();
    Object.defineProperty(exports, "prepareRequest", { enumerable: true, get: function() {
      return prepareRequest_js_1.prepareRequest;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/encodedLabelToLabelhash.js
var require_encodedLabelToLabelhash = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/encodedLabelToLabelhash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodedLabelToLabelhash = void 0;
    var index_js_1 = require_utils8();
    function encodedLabelToLabelhash2(label) {
      if (label.length !== 66)
        return null;
      if (label.indexOf("[") !== 0)
        return null;
      if (label.indexOf("]") !== 65)
        return null;
      const hash4 = `0x${label.slice(1, 65)}`;
      if (!(0, index_js_1.isHex)(hash4))
        return null;
      return hash4;
    }
    exports.encodedLabelToLabelhash = encodedLabelToLabelhash2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/namehash.js
var require_namehash2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/namehash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.namehash = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function namehash3(name) {
      let result = new Uint8Array(32).fill(0);
      if (!name)
        return (0, toHex_js_1.bytesToHex)(result);
      const labels = name.split(".");
      for (let i = labels.length - 1; i >= 0; i -= 1) {
        const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(labels[i]);
        const hashed = hashFromEncodedLabel ? (0, toBytes_js_1.toBytes)(hashFromEncodedLabel) : (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(labels[i]), "bytes");
        result = (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([result, hashed]), "bytes");
      }
      return (0, toHex_js_1.bytesToHex)(result);
    }
    exports.namehash = namehash3;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/encodeLabelhash.js
var require_encodeLabelhash = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/encodeLabelhash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeLabelhash = void 0;
    function encodeLabelhash2(hash4) {
      return `[${hash4.slice(2)}]`;
    }
    exports.encodeLabelhash = encodeLabelhash2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/labelhash.js
var require_labelhash = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/labelhash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.labelhash = void 0;
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function labelhash2(label) {
      const result = new Uint8Array(32).fill(0);
      if (!label)
        return (0, toHex_js_1.bytesToHex)(result);
      return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(label));
    }
    exports.labelhash = labelhash2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/packetToBytes.js
var require_packetToBytes = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/packetToBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.packetToBytes = void 0;
    var toBytes_js_1 = require_toBytes();
    var encodeLabelhash_js_1 = require_encodeLabelhash();
    var labelhash_js_1 = require_labelhash();
    function packetToBytes2(packet) {
      const value = packet.replace(/^\.|\.$/gm, "");
      if (value.length === 0)
        return new Uint8Array(1);
      const bytes4 = new Uint8Array((0, toBytes_js_1.stringToBytes)(value).byteLength + 2);
      let offset = 0;
      const list = value.split(".");
      for (let i = 0; i < list.length; i++) {
        let encoded = (0, toBytes_js_1.stringToBytes)(list[i]);
        if (encoded.byteLength > 255)
          encoded = (0, toBytes_js_1.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i])));
        bytes4[offset] = encoded.length;
        bytes4.set(encoded, offset + 1);
        offset += encoded.length + 1;
      }
      if (bytes4.byteLength !== offset + 1)
        return bytes4.slice(0, offset + 1);
      return bytes4;
    }
    exports.packetToBytes = packetToBytes2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsAddress.js
var require_getEnsAddress = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsAddress = void 0;
    var abis_js_1 = require_abis();
    var contract_js_1 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_1 = require_chain2();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var namehash_js_1 = require_namehash2();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsAddress2(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      try {
        const res = await (0, readContract_js_1.readContract)(client, {
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverAbi,
          functionName: "resolve",
          args: [
            (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
            (0, encodeFunctionData_js_1.encodeFunctionData)({
              abi: abis_js_1.singleAddressResolverAbi,
              functionName: "addr",
              args: [(0, namehash_js_1.namehash)(name)]
            })
          ],
          blockNumber,
          blockTag
        });
        if (res[0] === "0x")
          return null;
        const address = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.singleAddressResolverAbi,
          functionName: "addr",
          data: res[0]
        });
        return (0, trim_js_1.trim)(address) === "0x00" ? null : address;
      } catch (err) {
        if (err instanceof contract_js_1.ContractFunctionExecutionError) {
          const reason = err.cause?.reason;
          if (reason?.includes("Wildcard on non-extended resolvers is not supported"))
            return null;
        }
        throw err;
      }
    }
    exports.getEnsAddress = getEnsAddress2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/ens.js
var require_ens = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/errors/ens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarUriResolutionError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarInvalidMetadataError = void 0;
    var base_js_1 = require_base2();
    var EnsAvatarInvalidMetadataError2 = class extends base_js_1.BaseError {
      constructor({ data }) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
          metaMessages: [
            "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
            "",
            `Provided data: ${JSON.stringify(data)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidMetadataError"
        });
      }
    };
    exports.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError2;
    var EnsAvatarInvalidNftUriError2 = class extends base_js_1.BaseError {
      constructor({ reason }) {
        super(`ENS NFT avatar URI is invalid. ${reason}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidNftUriError"
        });
      }
    };
    exports.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError2;
    var EnsAvatarUriResolutionError2 = class extends base_js_1.BaseError {
      constructor({ uri }) {
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUriResolutionError"
        });
      }
    };
    exports.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError2;
    var EnsAvatarUnsupportedNamespaceError2 = class extends base_js_1.BaseError {
      constructor({ namespace }) {
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUnsupportedNamespaceError"
        });
      }
    };
    exports.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/avatar/utils.js
var require_utils9 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/avatar/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNftTokenUri = exports.parseNftUri = exports.parseAvatarUri = exports.getMetadataAvatarUri = exports.getJsonImage = exports.resolveAvatarUri = exports.getGateway = exports.isImageUri = void 0;
    var readContract_js_1 = require_readContract();
    var ens_js_1 = require_ens();
    var networkRegex2 = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
    var ipfsHashRegex2 = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
    var base64Regex2 = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
    var dataURIRegex2 = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    async function isImageUri2(uri) {
      try {
        const res = await fetch(uri, { method: "HEAD" });
        if (res.status === 200) {
          const contentType = res.headers.get("content-type");
          return contentType?.startsWith("image/");
        }
        return false;
      } catch (error) {
        if (typeof error === "object" && typeof error.response !== "undefined") {
          return false;
        }
        if (!globalThis.hasOwnProperty("Image"))
          return false;
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            resolve(true);
          };
          img.onerror = () => {
            resolve(false);
          };
          img.src = uri;
        });
      }
    }
    exports.isImageUri = isImageUri2;
    function getGateway2(custom, defaultGateway) {
      if (!custom)
        return defaultGateway;
      if (custom.endsWith("/"))
        return custom.slice(0, -1);
      return custom;
    }
    exports.getGateway = getGateway2;
    function resolveAvatarUri2({ uri, gatewayUrls }) {
      const isEncoded = base64Regex2.test(uri);
      if (isEncoded)
        return { uri, isOnChain: true, isEncoded };
      const ipfsGateway = getGateway2(gatewayUrls?.ipfs, "https://ipfs.io");
      const arweaveGateway = getGateway2(gatewayUrls?.arweave, "https://arweave.net");
      const networkRegexMatch = uri.match(networkRegex2);
      const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
      const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
      const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex2.test(uri);
      if (uri.startsWith("http") && !isIPNS && !isIPFS) {
        let replacedUri = uri;
        if (gatewayUrls?.arweave)
          replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
        return { uri: replacedUri, isOnChain: false, isEncoded: false };
      }
      if ((isIPNS || isIPFS) && target) {
        return {
          uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
          isOnChain: false,
          isEncoded: false
        };
      } else if (protocol === "ar:/" && target) {
        return {
          uri: `${arweaveGateway}/${target}${subtarget || ""}`,
          isOnChain: false,
          isEncoded: false
        };
      }
      let parsedUri = uri.replace(dataURIRegex2, "");
      if (parsedUri.startsWith("<svg")) {
        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
      }
      if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
        return {
          uri: parsedUri,
          isOnChain: true,
          isEncoded: false
        };
      }
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports.resolveAvatarUri = resolveAvatarUri2;
    function getJsonImage2(data) {
      if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });
      }
      return data.image || data.image_url || data.image_data;
    }
    exports.getJsonImage = getJsonImage2;
    async function getMetadataAvatarUri2({ gatewayUrls, uri }) {
      try {
        const res = await fetch(uri).then((res2) => res2.json());
        const image = await parseAvatarUri2({
          gatewayUrls,
          uri: getJsonImage2(res)
        });
        return image;
      } catch {
        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
      }
    }
    exports.getMetadataAvatarUri = getMetadataAvatarUri2;
    async function parseAvatarUri2({ gatewayUrls, uri }) {
      const { uri: resolvedURI, isOnChain } = resolveAvatarUri2({ uri, gatewayUrls });
      if (isOnChain)
        return resolvedURI;
      const isImage = await isImageUri2(resolvedURI);
      if (isImage)
        return resolvedURI;
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports.parseAvatarUri = parseAvatarUri2;
    function parseNftUri2(uri) {
      if (uri.startsWith("did:nft:")) {
        uri = uri.replace("did:nft:", "").replace(/_/g, "/");
      }
      const [reference, asset_namespace, tokenID] = uri.split("/");
      const [eip_namespace, chainID] = reference.split(":");
      const [erc_namespace, contractAddress] = asset_namespace.split(":");
      if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
      if (!chainID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
      if (!contractAddress)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({
          reason: "Contract address not found"
        });
      if (!tokenID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
      if (!erc_namespace)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
      return {
        chainID: parseInt(chainID),
        namespace: erc_namespace.toLowerCase(),
        contractAddress,
        tokenID
      };
    }
    exports.parseNftUri = parseNftUri2;
    async function getNftTokenUri2(client, { nft }) {
      if (nft.namespace === "erc721") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "tokenURI",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "tokenId", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "tokenURI",
          args: [BigInt(nft.tokenID)]
        });
      }
      if (nft.namespace === "erc1155") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "uri",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "_id", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "uri",
          args: [BigInt(nft.tokenID)]
        });
      }
      throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
    }
    exports.getNftTokenUri = getNftTokenUri2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/avatar/parseAvatarRecord.js
var require_parseAvatarRecord = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/ens/avatar/parseAvatarRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAvatarRecord = void 0;
    var utils_js_1 = require_utils9();
    async function parseAvatarRecord2(client, { gatewayUrls, record }) {
      if (/eip155:/i.test(record))
        return parseNftAvatarUri2(client, { gatewayUrls, record });
      return (0, utils_js_1.parseAvatarUri)({ uri: record, gatewayUrls });
    }
    exports.parseAvatarRecord = parseAvatarRecord2;
    async function parseNftAvatarUri2(client, { gatewayUrls, record }) {
      const nft = (0, utils_js_1.parseNftUri)(record);
      const nftUri = await (0, utils_js_1.getNftTokenUri)(client, { nft });
      const { uri: resolvedNftUri, isOnChain, isEncoded } = (0, utils_js_1.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
      if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
        const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
        const decoded = JSON.parse(encodedJson);
        return (0, utils_js_1.parseAvatarUri)({ uri: (0, utils_js_1.getJsonImage)(decoded), gatewayUrls });
      }
      let uriTokenId = nft.tokenID;
      if (nft.namespace === "erc1155")
        uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
      return (0, utils_js_1.getMetadataAvatarUri)({
        gatewayUrls,
        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
      });
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsText.js
var require_getEnsText = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsText.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsText = void 0;
    var abis_js_1 = require_abis();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_1 = require_chain2();
    var toHex_js_1 = require_toHex();
    var namehash_js_1 = require_namehash2();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsText2(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const res = await (0, readContract_js_1.readContract)(client, {
        address: universalResolverAddress,
        abi: abis_js_1.universalResolverAbi,
        functionName: "resolve",
        args: [
          (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
          (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi: abis_js_1.textResolverAbi,
            functionName: "text",
            args: [(0, namehash_js_1.namehash)(name), key]
          })
        ],
        blockNumber,
        blockTag
      });
      if (res[0] === "0x")
        return null;
      const record = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
        abi: abis_js_1.textResolverAbi,
        functionName: "text",
        data: res[0]
      });
      return record === "" ? null : record;
    }
    exports.getEnsText = getEnsText2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsAvatar.js
var require_getEnsAvatar = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsAvatar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsAvatar = void 0;
    var parseAvatarRecord_js_1 = require_parseAvatarRecord();
    var getEnsText_js_1 = require_getEnsText();
    async function getEnsAvatar2(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
      const record = await (0, getEnsText_js_1.getEnsText)(client, {
        blockNumber,
        blockTag,
        key: "avatar",
        name,
        universalResolverAddress
      });
      if (!record)
        return null;
      try {
        return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client, { record, gatewayUrls });
      } catch {
        return null;
      }
    }
    exports.getEnsAvatar = getEnsAvatar2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsName.js
var require_getEnsName = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsName = void 0;
    var solidity_js_1 = require_solidity();
    var contract_js_1 = require_contract();
    var chain_js_1 = require_chain2();
    var toHex_js_1 = require_toHex();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsName2(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
      try {
        const res = await (0, readContract_js_1.readContract)(client, {
          address: universalResolverAddress,
          abi: [
            {
              name: "reverse",
              type: "function",
              stateMutability: "view",
              inputs: [{ type: "bytes", name: "reverseName" }],
              outputs: [
                { type: "string", name: "resolvedName" },
                { type: "address", name: "resolvedAddress" },
                { type: "address", name: "reverseResolver" },
                { type: "address", name: "resolver" }
              ]
            }
          ],
          functionName: "reverse",
          args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(reverseNode))],
          blockNumber,
          blockTag
        });
        return res[0];
      } catch (error) {
        if (error instanceof contract_js_1.ContractFunctionExecutionError && error.cause.reason === solidity_js_1.panicReasons[50])
          return null;
        throw error;
      }
    }
    exports.getEnsName = getEnsName2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsResolver.js
var require_getEnsResolver = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/ens/getEnsResolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsResolver = void 0;
    var chain_js_1 = require_chain2();
    var toHex_js_1 = require_toHex();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsResolver2(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const [resolverAddress] = await (0, readContract_js_1.readContract)(client, {
        address: universalResolverAddress,
        abi: [
          {
            inputs: [{ type: "bytes" }],
            name: "findResolver",
            outputs: [{ type: "address" }, { type: "bytes32" }],
            stateMutability: "view",
            type: "function"
          }
        ],
        functionName: "findResolver",
        args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],
        blockNumber,
        blockTag
      });
      return resolverAddress;
    }
    exports.getEnsResolver = getEnsResolver2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/createBlockFilter.js
var require_createBlockFilter = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/createBlockFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBlockFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createBlockFilter2(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newBlockFilter"
      });
      const id4 = await client.request({
        method: "eth_newBlockFilter"
      });
      return { id: id4, request: getRequest(id4), type: "block" };
    }
    exports.createBlockFilter = createBlockFilter2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/createEventFilter.js
var require_createEventFilter = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/createEventFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createEventFilter2(client, { address, args, event, fromBlock, strict, toBlock } = {}) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      let topics = [];
      if (event)
        topics = (0, encodeEventTopics_js_1.encodeEventTopics)({
          abi: [event],
          eventName: event.name,
          args
        });
      const id4 = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            ...topics.length ? { topics } : {}
          }
        ]
      });
      return {
        abi: event ? [event] : void 0,
        args,
        eventName: event ? event.name : void 0,
        id: id4,
        request: getRequest(id4),
        strict,
        type: "event"
      };
    }
    exports.createEventFilter = createEventFilter2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/createPendingTransactionFilter.js
var require_createPendingTransactionFilter = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/createPendingTransactionFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPendingTransactionFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createPendingTransactionFilter2(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newPendingTransactionFilter"
      });
      const id4 = await client.request({
        method: "eth_newPendingTransactionFilter"
      });
      return { id: id4, request: getRequest(id4), type: "transaction" };
    }
    exports.createPendingTransactionFilter = createPendingTransactionFilter2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBalance.js
var require_getBalance = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBalance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function getBalance2(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const balance = await client.request({
        method: "eth_getBalance",
        params: [address, blockNumberHex || blockTag]
      });
      return BigInt(balance);
    }
    exports.getBalance = getBalance2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBlockTransactionCount.js
var require_getBlockTransactionCount = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBlockTransactionCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlockTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getBlockTransactionCount2(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let count;
      if (blockHash) {
        count = await client.request({
          method: "eth_getBlockTransactionCountByHash",
          params: [blockHash]
        });
      } else {
        count = await client.request({
          method: "eth_getBlockTransactionCountByNumber",
          params: [blockNumberHex || blockTag]
        });
      }
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports.getBlockTransactionCount = getBlockTransactionCount2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBytecode.js
var require_getBytecode = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getBytecode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBytecode = void 0;
    var toHex_js_1 = require_toHex();
    async function getBytecode2(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const hex = await client.request({
        method: "eth_getCode",
        params: [address, blockNumberHex || blockTag]
      });
      if (hex === "0x")
        return void 0;
      return hex;
    }
    exports.getBytecode = getBytecode2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/feeHistory.js
var require_feeHistory = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/formatters/feeHistory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatFeeHistory = void 0;
    function formatFeeHistory2(feeHistory) {
      return {
        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
        gasUsedRatio: feeHistory.gasUsedRatio,
        oldestBlock: BigInt(feeHistory.oldestBlock),
        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
      };
    }
    exports.formatFeeHistory = formatFeeHistory2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getFeeHistory.js
var require_getFeeHistory = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getFeeHistory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeeHistory = void 0;
    var toHex_js_1 = require_toHex();
    var feeHistory_js_1 = require_feeHistory();
    async function getFeeHistory2(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const feeHistory = await client.request({
        method: "eth_feeHistory",
        params: [
          (0, toHex_js_1.numberToHex)(blockCount),
          blockNumberHex || blockTag,
          rewardPercentiles
        ]
      });
      return (0, feeHistory_js_1.formatFeeHistory)(feeHistory);
    }
    exports.getFeeHistory = getFeeHistory2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getFilterLogs.js
var require_getFilterLogs = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getFilterLogs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilterLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log2();
    async function getFilterLogs2(_client, { filter }) {
      const strict = filter.strict ?? false;
      const logs = await filter.request({
        method: "eth_getFilterLogs",
        params: [filter.id]
      });
      return logs.map((log) => {
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getFilterLogs = getFilterLogs2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getStorageAt.js
var require_getStorageAt = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getStorageAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function getStorageAt2(client, { address, blockNumber, blockTag = "latest", slot }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const data = await client.request({
        method: "eth_getStorageAt",
        params: [address, slot, blockNumberHex || blockTag]
      });
      return data;
    }
    exports.getStorageAt = getStorageAt2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getTransaction.js
var require_getTransaction = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransaction = void 0;
    var transaction_js_1 = require_transaction();
    var toHex_js_1 = require_toHex();
    var transaction_js_2 = require_transaction2();
    async function getTransaction2(client, { blockHash, blockNumber, blockTag = "latest", hash: hash4, index: index2 }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let transaction = null;
      if (hash4) {
        transaction = await client.request({
          method: "eth_getTransactionByHash",
          params: [hash4]
        });
      } else if (blockHash) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockHashAndIndex",
          params: [blockHash, (0, toHex_js_1.numberToHex)(index2)]
        });
      } else if (blockNumberHex || blockTag) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockNumberAndIndex",
          params: [blockNumberHex || blockTag, (0, toHex_js_1.numberToHex)(index2)]
        });
      }
      if (!transaction)
        throw new transaction_js_1.TransactionNotFoundError({
          blockHash,
          blockNumber,
          blockTag,
          hash: hash4,
          index: index2
        });
      const format = client.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
      return format(transaction);
    }
    exports.getTransaction = getTransaction2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getTransactionConfirmations.js
var require_getTransactionConfirmations = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getTransactionConfirmations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionConfirmations = void 0;
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getTransaction_js_1 = require_getTransaction();
    async function getTransactionConfirmations2(client, { hash: hash4, transactionReceipt }) {
      const [blockNumber, transaction] = await Promise.all([
        (0, getBlockNumber_js_1.getBlockNumber)(client),
        hash4 ? (0, getTransaction_js_1.getTransaction)(client, { hash: hash4 }) : void 0
      ]);
      const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
      if (!transactionBlockNumber)
        return 0n;
      return blockNumber - transactionBlockNumber + 1n;
    }
    exports.getTransactionConfirmations = getTransactionConfirmations2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getTransactionReceipt.js
var require_getTransactionReceipt = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/getTransactionReceipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionReceipt = void 0;
    var transaction_js_1 = require_transaction();
    var transactionReceipt_js_1 = require_transactionReceipt();
    async function getTransactionReceipt2(client, { hash: hash4 }) {
      const receipt = await client.request({
        method: "eth_getTransactionReceipt",
        params: [hash4]
      });
      if (!receipt)
        throw new transaction_js_1.TransactionReceiptNotFoundError({ hash: hash4 });
      const format = client.chain?.formatters?.transactionReceipt?.format || transactionReceipt_js_1.formatTransactionReceipt;
      return format(receipt);
    }
    exports.getTransactionReceipt = getTransactionReceipt2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/multicall.js
var require_multicall = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/multicall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multicall = void 0;
    var abis_js_1 = require_abis();
    var abi_js_1 = require_abi();
    var contract_js_1 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_1 = require_chain2();
    var getContractError_js_1 = require_getContractError();
    var readContract_js_1 = require_readContract();
    async function multicall2(client, args) {
      const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts_, multicallAddress: multicallAddress_ } = args;
      const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
      const contracts = contracts_;
      let multicallAddress = multicallAddress_;
      if (!multicallAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. multicallAddress is required.");
        multicallAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "multicall3"
        });
      }
      const chunkedCalls = [[]];
      let currentChunk = 0;
      let currentChunkSize = 0;
      for (let i = 0; i < contracts.length; i++) {
        const { abi, address, args: args2, functionName } = contracts[i];
        try {
          const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi,
            args: args2,
            functionName
          });
          currentChunkSize += callData.length;
          if (batchSize > 0 && currentChunkSize > batchSize) {
            currentChunk++;
            currentChunkSize = (callData.length - 2) / 2;
            chunkedCalls[currentChunk] = [];
          }
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData,
              target: address
            }
          ];
        } catch (err) {
          const error = (0, getContractError_js_1.getContractError)(err, {
            abi,
            address,
            args: args2,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData: "0x",
              target: address
            }
          ];
        }
      }
      const results = await Promise.all(chunkedCalls.map((calls) => (0, readContract_js_1.readContract)(client, {
        abi: abis_js_1.multicall3Abi,
        address: multicallAddress,
        args: [calls],
        blockNumber,
        blockTag,
        functionName: "aggregate3"
      })));
      return results.flat().map(({ returnData, success }, i) => {
        const calls = chunkedCalls.flat();
        const { callData } = calls[i];
        const { abi, address, functionName, args: args2 } = contracts[i];
        try {
          if (callData === "0x")
            throw new abi_js_1.AbiDecodingZeroDataError();
          if (!success)
            throw new contract_js_1.RawContractError({ data: returnData });
          const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi,
            data: returnData,
            functionName
          });
          return allowFailure ? { result, status: "success" } : result;
        } catch (err) {
          const error = (0, getContractError_js_1.getContractError)(err, {
            abi,
            address,
            args: args2,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          return { error, result: void 0, status: "failure" };
        }
      });
    }
    exports.multicall = multicall2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/contracts.js
var require_contracts = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/contracts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.universalSignatureValidatorByteCode = void 0;
    exports.universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/@noble/curves/abstract/utils.js
var require_utils10 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
    var _0n8 = BigInt(0);
    var _1n8 = BigInt(1);
    var _2n7 = BigInt(2);
    var u8a3 = (a) => a instanceof Uint8Array;
    var hexes4 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex3(bytes4) {
      if (!u8a3(bytes4))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes4.length; i++) {
        hex += hexes4[bytes4[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex3;
    function numberToHexUnpadded2(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports.numberToHexUnpadded = numberToHexUnpadded2;
    function hexToNumber3(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports.hexToNumber = hexToNumber3;
    function hexToBytes3(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      if (hex.length % 2)
        throw new Error("hex string is invalid: unpadded " + hex.length);
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes3;
    function bytesToNumberBE2(bytes4) {
      return hexToNumber3(bytesToHex3(bytes4));
    }
    exports.bytesToNumberBE = bytesToNumberBE2;
    function bytesToNumberLE2(bytes4) {
      if (!u8a3(bytes4))
        throw new Error("Uint8Array expected");
      return hexToNumber3(bytesToHex3(Uint8Array.from(bytes4).reverse()));
    }
    exports.bytesToNumberLE = bytesToNumberLE2;
    var numberToBytesBE2 = (n, len) => hexToBytes3(n.toString(16).padStart(len * 2, "0"));
    exports.numberToBytesBE = numberToBytesBE2;
    var numberToBytesLE2 = (n, len) => (0, exports.numberToBytesBE)(n, len).reverse();
    exports.numberToBytesLE = numberToBytesLE2;
    var numberToVarBytesBE2 = (n) => hexToBytes3(numberToHexUnpadded2(n));
    exports.numberToVarBytesBE = numberToVarBytesBE2;
    function ensureBytes2(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes3(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (u8a3(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports.ensureBytes = ensureBytes2;
    function concatBytes4(...arrs) {
      const r = new Uint8Array(arrs.reduce((sum, a) => sum + a.length, 0));
      let pad2 = 0;
      arrs.forEach((a) => {
        if (!u8a3(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad2);
        pad2 += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes4;
    function equalBytes3(b1, b2) {
      if (b1.length !== b2.length)
        return false;
      for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
          return false;
      return true;
    }
    exports.equalBytes = equalBytes3;
    function utf8ToBytes4(str) {
      if (typeof str !== "string") {
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes4;
    function bitLen2(n) {
      let len;
      for (len = 0; n > _0n8; n >>= _1n8, len += 1)
        ;
      return len;
    }
    exports.bitLen = bitLen2;
    var bitGet2 = (n, pos) => n >> BigInt(pos) & _1n8;
    exports.bitGet = bitGet2;
    var bitSet2 = (n, pos, value) => n | (value ? _1n8 : _0n8) << BigInt(pos);
    exports.bitSet = bitSet2;
    var bitMask2 = (n) => (_2n7 << BigInt(n - 1)) - _1n8;
    exports.bitMask = bitMask2;
    var u8n2 = (data) => new Uint8Array(data);
    var u8fr2 = (arr) => Uint8Array.from(arr);
    function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n2(hashLen);
      let k = u8n2(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n2()) => {
        k = h(u8fr2([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr2([1]), seed);
        v = h();
      };
      const gen2 = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes4(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen2())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports.createHmacDrbg = createHmacDrbg2;
    var validatorFns2 = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject2(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns2[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    exports.validateObject = validateObject2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/isBytesEqual.js
var require_isBytesEqual = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/data/isBytesEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytesEqual = void 0;
    var index_js_1 = require_cjs2();
    var utils_1 = require_utils10();
    function isBytesEqual2(a_, b_) {
      const a = (0, index_js_1.isHex)(a_) ? (0, index_js_1.toBytes)(a_) : a_;
      const b = (0, index_js_1.isHex)(b_) ? (0, index_js_1.toBytes)(b_) : b_;
      return (0, utils_1.equalBytes)(a, b);
    }
    exports.isBytesEqual = isBytesEqual2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/verifyHash.js
var require_verifyHash = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/verifyHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyHash = void 0;
    var abis_js_1 = require_abis();
    var contracts_js_1 = require_contracts();
    var contract_js_1 = require_contract();
    var isBytesEqual_js_1 = require_isBytesEqual();
    var index_js_1 = require_utils8();
    var call_js_1 = require_call();
    async function verifyHash2(client, { address, hash: hash4, signature, ...callRequest }) {
      const signatureHex = (0, index_js_1.isHex)(signature) ? signature : (0, index_js_1.toHex)(signature);
      try {
        const { data } = await (0, call_js_1.call)(client, {
          data: (0, index_js_1.encodeDeployData)({
            abi: abis_js_1.universalSignatureValidatorAbi,
            args: [address, hash4, signatureHex],
            bytecode: contracts_js_1.universalSignatureValidatorByteCode
          }),
          ...callRequest
        });
        return (0, isBytesEqual_js_1.isBytesEqual)(data ?? "0x0", "0x1");
      } catch (error) {
        if (error instanceof contract_js_1.CallExecutionError) {
          return false;
        }
        throw error;
      }
    }
    exports.verifyHash = verifyHash2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/verifyMessage.js
var require_verifyMessage2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/verifyMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyMessage = void 0;
    var index_js_1 = require_utils8();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyMessage2(client, { address, message, signature, ...callRequest }) {
      const hash4 = (0, index_js_1.hashMessage)(message);
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash: hash4,
        signature,
        ...callRequest
      });
    }
    exports.verifyMessage = verifyMessage2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/verifyTypedData.js
var require_verifyTypedData2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/verifyTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyTypedData2(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
      const hash4 = (0, hashTypedData_js_1.hashTypedData)({ message, primaryType, types, domain });
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash: hash4,
        signature,
        ...callRequest
      });
    }
    exports.verifyTypedData = verifyTypedData2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchBlockNumber.js
var require_watchBlockNumber = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchBlockNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchBlockNumber = void 0;
    var fromHex_js_1 = require_fromHex();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var getBlockNumber_js_1 = require_getBlockNumber();
    function watchBlockNumber2(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      let prevBlockNumber;
      const pollBlockNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlockNumber",
          client.uid,
          emitOnBegin,
          emitMissed,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const blockNumber = await (0, getBlockNumber_js_1.getBlockNumber)(client, { maxAge: 0 });
            if (prevBlockNumber) {
              if (blockNumber === prevBlockNumber)
                return;
              if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                  emit.onBlockNumber(i, prevBlockNumber);
                  prevBlockNumber = i;
                }
              }
            }
            if (!prevBlockNumber || blockNumber > prevBlockNumber) {
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlockNumber = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const blockNumber = (0, fromHex_js_1.hexToBigInt)(data.result?.number);
                onBlockNumber(blockNumber, prevBlockNumber);
                prevBlockNumber = blockNumber;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
    }
    exports.watchBlockNumber = watchBlockNumber2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/waitForTransactionReceipt.js
var require_waitForTransactionReceipt = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/waitForTransactionReceipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.waitForTransactionReceipt = void 0;
    var transaction_js_1 = require_transaction();
    var observe_js_1 = require_observe();
    var withRetry_js_1 = require_withRetry();
    var stringify_js_1 = require_stringify();
    var getBlock_js_1 = require_getBlock();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    async function waitForTransactionReceipt2(client, { confirmations = 1, hash: hash4, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
      const observerId = (0, stringify_js_1.stringify)(["waitForTransactionReceipt", client.uid, hash4]);
      let transaction;
      let replacedTransaction;
      let receipt;
      let retrying = false;
      return new Promise((resolve, reject) => {
        if (timeout)
          setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash: hash4 })), timeout);
        const _unobserve = (0, observe_js_1.observe)(observerId, { onReplaced, resolve, reject }, (emit) => {
          const unwatch = (0, watchBlockNumber_js_1.watchBlockNumber)(client, {
            emitMissed: true,
            emitOnBegin: true,
            poll: true,
            pollingInterval,
            async onBlockNumber(blockNumber_) {
              if (retrying)
                return;
              let blockNumber = blockNumber_;
              const done = async (fn) => {
                unwatch();
                fn();
                _unobserve();
              };
              try {
                if (receipt) {
                  if (blockNumber - receipt.blockNumber + 1n < confirmations)
                    return;
                  done(() => emit.resolve(receipt));
                  return;
                }
                if (!transaction) {
                  retrying = true;
                  await (0, withRetry_js_1.withRetry)(async () => {
                    transaction = await (0, getTransaction_js_1.getTransaction)(client, { hash: hash4 });
                    if (transaction.blockNumber)
                      blockNumber = transaction.blockNumber;
                  }, {
                    delay: ({ count }) => ~~(1 << count) * 200,
                    retryCount: 6
                  });
                  retrying = false;
                }
                receipt = await (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, { hash: hash4 });
                if (confirmations > 0 && blockNumber - receipt.blockNumber + 1n < confirmations)
                  return;
                done(() => emit.resolve(receipt));
              } catch (err) {
                if (transaction && (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError)) {
                  replacedTransaction = transaction;
                  const block = await (0, getBlock_js_1.getBlock)(client, {
                    blockNumber,
                    includeTransactions: true
                  });
                  const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                  if (!replacementTransaction)
                    return;
                  receipt = await (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, {
                    hash: replacementTransaction.hash
                  });
                  if (blockNumber - receipt.blockNumber + 1n < confirmations)
                    return;
                  let reason = "replaced";
                  if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                    reason = "repriced";
                  } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                    reason = "cancelled";
                  }
                  done(() => {
                    emit.onReplaced?.({
                      reason,
                      replacedTransaction,
                      transaction: replacementTransaction,
                      transactionReceipt: receipt
                    });
                    emit.resolve(receipt);
                  });
                } else {
                  done(() => emit.reject(err));
                }
              }
            }
          });
          return unwatch;
        });
      });
    }
    exports.waitForTransactionReceipt = waitForTransactionReceipt2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchBlocks.js
var require_watchBlocks = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchBlocks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchBlocks = void 0;
    var block_js_1 = require_block2();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var getBlock_js_1 = require_getBlock();
    function watchBlocks2(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions = false, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      let prevBlock;
      const pollBlocks = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlocks",
          client.uid,
          emitMissed,
          emitOnBegin,
          includeTransactions,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlock, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const block = await (0, getBlock_js_1.getBlock)(client, {
              blockTag,
              includeTransactions
            });
            if (block.number && prevBlock?.number) {
              if (block.number === prevBlock.number)
                return;
              if (block.number - prevBlock.number > 1 && emitMissed) {
                for (let i = prevBlock?.number + 1n; i < block.number; i++) {
                  const block2 = await (0, getBlock_js_1.getBlock)(client, {
                    blockNumber: i,
                    includeTransactions
                  });
                  emit.onBlock(block2, prevBlock);
                  prevBlock = block2;
                }
              }
            }
            if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
              emit.onBlock(block, prevBlock);
              prevBlock = block;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlocks = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const format = client.chain?.formatters?.block?.format || block_js_1.formatBlock;
                const block = format(data.result);
                onBlock(block, prevBlock);
                prevBlock = block;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlocks() : subscribeBlocks();
    }
    exports.watchBlocks = watchBlocks2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchEvent.js
var require_watchEvent = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchEvent = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var createEventFilter_js_1 = require_createEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getLogs_js_1 = require_getLogs();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchEvent2(client, { address, args, batch = true, event, onError, onLogs, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const observerId = (0, stringify_js_1.stringify)([
        "watchEvent",
        address,
        args,
        batch,
        client.uid,
        event,
        pollingInterval
      ]);
      const strict = strict_ ?? false;
      return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
        let previousBlockNumber;
        let filter;
        let initialized = false;
        const unwatch = (0, poll_js_1.poll)(async () => {
          if (!initialized) {
            try {
              filter = await (0, createEventFilter_js_1.createEventFilter)(client, {
                address,
                args,
                event,
                strict
              });
            } catch {
            }
            initialized = true;
            return;
          }
          try {
            let logs;
            if (filter) {
              logs = await (0, getFilterChanges_js_1.getFilterChanges)(client, { filter });
            } else {
              const blockNumber = await (0, getBlockNumber_js_1.getBlockNumber)(client);
              if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                logs = await (0, getLogs_js_1.getLogs)(client, {
                  address,
                  args,
                  fromBlock: previousBlockNumber + 1n,
                  toBlock: blockNumber,
                  event
                });
              } else {
                logs = [];
              }
              previousBlockNumber = blockNumber;
            }
            if (logs.length === 0)
              return;
            if (batch)
              emit.onLogs(logs);
            else
              logs.forEach((log) => emit.onLogs([log]));
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter)
            await (0, uninstallFilter_js_1.uninstallFilter)(client, { filter });
          unwatch();
        };
      });
    }
    exports.watchEvent = watchEvent2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchPendingTransactions.js
var require_watchPendingTransactions = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/public/watchPendingTransactions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchPendingTransactions = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchPendingTransactions2(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const pollPendingTransactions = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchPendingTransactions",
          client.uid,
          batch,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit) => {
          let filter;
          const unwatch = (0, poll_js_1.poll)(async () => {
            try {
              if (!filter) {
                try {
                  filter = await (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client);
                  return;
                } catch (err) {
                  unwatch();
                  throw err;
                }
              }
              const hashes = await (0, getFilterChanges_js_1.getFilterChanges)(client, { filter });
              if (hashes.length === 0)
                return;
              if (batch)
                emit.onTransactions(hashes);
              else
                hashes.forEach((hash4) => emit.onTransactions([hash4]));
            } catch (err) {
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, uninstallFilter_js_1.uninstallFilter)(client, { filter });
            unwatch();
          };
        });
      };
      const subscribePendingTransactions = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newPendingTransactions"],
              onData(data) {
                if (!active)
                  return;
                const transaction = data.result;
                onTransactions([transaction]);
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
    }
    exports.watchPendingTransactions = watchPendingTransactions2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/decorators/public.js
var require_public = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/decorators/public.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicActions = void 0;
    var getEnsAddress_js_1 = require_getEnsAddress();
    var getEnsAvatar_js_1 = require_getEnsAvatar();
    var getEnsName_js_1 = require_getEnsName();
    var getEnsResolver_js_1 = require_getEnsResolver();
    var getEnsText_js_1 = require_getEnsText();
    var call_js_1 = require_call();
    var createBlockFilter_js_1 = require_createBlockFilter();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var createEventFilter_js_1 = require_createEventFilter();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var estimateGas_js_1 = require_estimateGas2();
    var getBalance_js_1 = require_getBalance();
    var getBlock_js_1 = require_getBlock();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getBlockTransactionCount_js_1 = require_getBlockTransactionCount();
    var getBytecode_js_1 = require_getBytecode();
    var getChainId_js_1 = require_getChainId();
    var getFeeHistory_js_1 = require_getFeeHistory();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getFilterLogs_js_1 = require_getFilterLogs();
    var getGasPrice_js_1 = require_getGasPrice();
    var getLogs_js_1 = require_getLogs();
    var getStorageAt_js_1 = require_getStorageAt();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionConfirmations_js_1 = require_getTransactionConfirmations();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var multicall_js_1 = require_multicall();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var uninstallFilter_js_1 = require_uninstallFilter();
    var verifyMessage_js_1 = require_verifyMessage2();
    var verifyTypedData_js_1 = require_verifyTypedData2();
    var waitForTransactionReceipt_js_1 = require_waitForTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    var watchBlocks_js_1 = require_watchBlocks();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var watchEvent_js_1 = require_watchEvent();
    var watchPendingTransactions_js_1 = require_watchPendingTransactions();
    var publicActions2 = (client) => ({
      call: (args) => (0, call_js_1.call)(client, args),
      createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client),
      createContractEventFilter: (args) => (0, createContractEventFilter_js_1.createContractEventFilter)(client, args),
      createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client, args),
      createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client),
      estimateContractGas: (args) => (0, estimateContractGas_js_1.estimateContractGas)(client, args),
      estimateGas: (args) => (0, estimateGas_js_1.estimateGas)(client, args),
      getBalance: (args) => (0, getBalance_js_1.getBalance)(client, args),
      getBlock: (args) => (0, getBlock_js_1.getBlock)(client, args),
      getBlockNumber: (args) => (0, getBlockNumber_js_1.getBlockNumber)(client, args),
      getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client, args),
      getBytecode: (args) => (0, getBytecode_js_1.getBytecode)(client, args),
      getChainId: () => (0, getChainId_js_1.getChainId)(client),
      getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client, args),
      getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client, args),
      getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client, args),
      getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client, args),
      getEnsText: (args) => (0, getEnsText_js_1.getEnsText)(client, args),
      getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client, args),
      getFilterChanges: (args) => (0, getFilterChanges_js_1.getFilterChanges)(client, args),
      getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client, args),
      getGasPrice: () => (0, getGasPrice_js_1.getGasPrice)(client),
      getLogs: (args) => (0, getLogs_js_1.getLogs)(client, args),
      getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client, args),
      getTransaction: (args) => (0, getTransaction_js_1.getTransaction)(client, args),
      getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client, args),
      getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client, args),
      getTransactionReceipt: (args) => (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, args),
      multicall: (args) => (0, multicall_js_1.multicall)(client, args),
      readContract: (args) => (0, readContract_js_1.readContract)(client, args),
      simulateContract: (args) => (0, simulateContract_js_1.simulateContract)(client, args),
      verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client, args),
      verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client, args),
      uninstallFilter: (args) => (0, uninstallFilter_js_1.uninstallFilter)(client, args),
      waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client, args),
      watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client, args),
      watchBlockNumber: (args) => (0, watchBlockNumber_js_1.watchBlockNumber)(client, args),
      watchContractEvent: (args) => (0, watchContractEvent_js_1.watchContractEvent)(client, args),
      watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client, args),
      watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client, args)
    });
    exports.publicActions = publicActions2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/createPublicClient.js
var require_createPublicClient = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/createPublicClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPublicClient = void 0;
    var createClient_js_1 = require_createClient();
    var public_js_1 = require_public();
    function createPublicClient2({ batch, chain, key = "public", name = "Public Client", transport, pollingInterval }) {
      return (0, createClient_js_1.createClient)({
        batch,
        chain,
        key,
        name,
        pollingInterval,
        transport,
        type: "publicClient"
      }).extend(public_js_1.publicActions);
    }
    exports.createPublicClient = createPublicClient2;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/dropTransaction.js
var require_dropTransaction = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/dropTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropTransaction = void 0;
    async function dropTransaction(client, { hash: hash4 }) {
      await client.request({
        method: `${client.mode}_dropTransaction`,
        params: [hash4]
      });
    }
    exports.dropTransaction = dropTransaction;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/getAutomine.js
var require_getAutomine = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/getAutomine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAutomine = void 0;
    async function getAutomine(client) {
      if (client.mode === "ganache")
        return await client.request({
          method: "eth_mining"
        });
      return await client.request({
        method: `${client.mode}_getAutomine`
      });
    }
    exports.getAutomine = getAutomine;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/getTxpoolContent.js
var require_getTxpoolContent = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/getTxpoolContent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTxpoolContent = void 0;
    async function getTxpoolContent(client) {
      return await client.request({
        method: "txpool_content"
      });
    }
    exports.getTxpoolContent = getTxpoolContent;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/getTxpoolStatus.js
var require_getTxpoolStatus = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/getTxpoolStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTxpoolStatus = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getTxpoolStatus(client) {
      const { pending, queued } = await client.request({
        method: "txpool_status"
      });
      return {
        pending: (0, fromHex_js_1.hexToNumber)(pending),
        queued: (0, fromHex_js_1.hexToNumber)(queued)
      };
    }
    exports.getTxpoolStatus = getTxpoolStatus;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/impersonateAccount.js
var require_impersonateAccount = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/impersonateAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.impersonateAccount = void 0;
    async function impersonateAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_impersonateAccount`,
        params: [address]
      });
    }
    exports.impersonateAccount = impersonateAccount;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/increaseTime.js
var require_increaseTime = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/increaseTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.increaseTime = void 0;
    var toHex_js_1 = require_toHex();
    async function increaseTime(client, { seconds }) {
      return await client.request({
        method: "evm_increaseTime",
        params: [(0, toHex_js_1.numberToHex)(seconds)]
      });
    }
    exports.increaseTime = increaseTime;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/inspectTxpool.js
var require_inspectTxpool = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/inspectTxpool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inspectTxpool = void 0;
    async function inspectTxpool(client) {
      return await client.request({
        method: "txpool_inspect"
      });
    }
    exports.inspectTxpool = inspectTxpool;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/mine.js
var require_mine = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/mine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mine = void 0;
    var toHex_js_1 = require_toHex();
    async function mine(client, { blocks, interval }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_mine",
          params: [{ blocks: (0, toHex_js_1.numberToHex)(blocks) }]
        });
      else
        await client.request({
          method: `${client.mode}_mine`,
          params: [(0, toHex_js_1.numberToHex)(blocks), (0, toHex_js_1.numberToHex)(interval || 0)]
        });
    }
    exports.mine = mine;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/removeBlockTimestampInterval.js
var require_removeBlockTimestampInterval = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/removeBlockTimestampInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeBlockTimestampInterval = void 0;
    async function removeBlockTimestampInterval(client) {
      await client.request({
        method: `${client.mode}_removeBlockTimestampInterval`
      });
    }
    exports.removeBlockTimestampInterval = removeBlockTimestampInterval;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/reset.js
var require_reset = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/reset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reset = void 0;
    async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
      await client.request({
        method: `${client.mode}_reset`,
        params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }]
      });
    }
    exports.reset = reset;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/revert.js
var require_revert = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/revert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.revert = void 0;
    async function revert(client, { id: id4 }) {
      await client.request({
        method: "evm_revert",
        params: [id4]
      });
    }
    exports.revert = revert;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/sendUnsignedTransaction.js
var require_sendUnsignedTransaction = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/sendUnsignedTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendUnsignedTransaction = void 0;
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    async function sendUnsignedTransaction(client, args) {
      const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      const format = client.chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
      const request = format({
        ...(0, extract_js_1.extract)(rest, { format }),
        accessList,
        data,
        from,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      const hash4 = await client.request({
        method: "eth_sendUnsignedTransaction",
        params: [request]
      });
      return hash4;
    }
    exports.sendUnsignedTransaction = sendUnsignedTransaction;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setAutomine.js
var require_setAutomine = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setAutomine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setAutomine = void 0;
    async function setAutomine(client, enabled) {
      if (client.mode === "ganache") {
        if (enabled)
          await client.request({ method: "miner_start" });
        else
          await client.request({ method: "miner_stop" });
      } else
        await client.request({
          method: "evm_setAutomine",
          params: [enabled]
        });
    }
    exports.setAutomine = setAutomine;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setBalance.js
var require_setBalance = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setBalance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function setBalance(client, { address, value }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_setAccountBalance",
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
      else
        await client.request({
          method: `${client.mode}_setBalance`,
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
    }
    exports.setBalance = setBalance;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setBlockGasLimit.js
var require_setBlockGasLimit = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setBlockGasLimit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBlockGasLimit = void 0;
    var toHex_js_1 = require_toHex();
    async function setBlockGasLimit(client, { gasLimit }) {
      await client.request({
        method: "evm_setBlockGasLimit",
        params: [(0, toHex_js_1.numberToHex)(gasLimit)]
      });
    }
    exports.setBlockGasLimit = setBlockGasLimit;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setBlockTimestampInterval.js
var require_setBlockTimestampInterval = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setBlockTimestampInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBlockTimestampInterval = void 0;
    async function setBlockTimestampInterval(client, { interval }) {
      await client.request({
        method: `${client.mode}_setBlockTimestampInterval`,
        params: [interval]
      });
    }
    exports.setBlockTimestampInterval = setBlockTimestampInterval;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setCode.js
var require_setCode = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setCode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setCode = void 0;
    async function setCode(client, { address, bytecode }) {
      await client.request({
        method: `${client.mode}_setCode`,
        params: [address, bytecode]
      });
    }
    exports.setCode = setCode;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setCoinbase.js
var require_setCoinbase = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setCoinbase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setCoinbase = void 0;
    async function setCoinbase(client, { address }) {
      await client.request({
        method: `${client.mode}_setCoinbase`,
        params: [address]
      });
    }
    exports.setCoinbase = setCoinbase;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setIntervalMining.js
var require_setIntervalMining = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setIntervalMining.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setIntervalMining = void 0;
    async function setIntervalMining(client, { interval }) {
      await client.request({
        method: "evm_setIntervalMining",
        params: [interval]
      });
    }
    exports.setIntervalMining = setIntervalMining;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setLoggingEnabled.js
var require_setLoggingEnabled = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setLoggingEnabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setLoggingEnabled = void 0;
    async function setLoggingEnabled(client, enabled) {
      await client.request({
        method: `${client.mode}_setLoggingEnabled`,
        params: [enabled]
      });
    }
    exports.setLoggingEnabled = setLoggingEnabled;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setMinGasPrice.js
var require_setMinGasPrice = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setMinGasPrice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setMinGasPrice = void 0;
    var toHex_js_1 = require_toHex();
    async function setMinGasPrice(client, { gasPrice }) {
      await client.request({
        method: `${client.mode}_setMinGasPrice`,
        params: [(0, toHex_js_1.numberToHex)(gasPrice)]
      });
    }
    exports.setMinGasPrice = setMinGasPrice;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setNextBlockBaseFeePerGas.js
var require_setNextBlockBaseFeePerGas = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setNextBlockBaseFeePerGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNextBlockBaseFeePerGas = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
      await client.request({
        method: `${client.mode}_setNextBlockBaseFeePerGas`,
        params: [(0, toHex_js_1.numberToHex)(baseFeePerGas)]
      });
    }
    exports.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setNextBlockTimestamp.js
var require_setNextBlockTimestamp = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setNextBlockTimestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNextBlockTimestamp = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockTimestamp(client, { timestamp }) {
      await client.request({
        method: "evm_setNextBlockTimestamp",
        params: [(0, toHex_js_1.numberToHex)(timestamp)]
      });
    }
    exports.setNextBlockTimestamp = setNextBlockTimestamp;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setNonce.js
var require_setNonce = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setNonce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNonce = void 0;
    var toHex_js_1 = require_toHex();
    async function setNonce(client, { address, nonce }) {
      await client.request({
        method: `${client.mode}_setNonce`,
        params: [address, (0, toHex_js_1.numberToHex)(nonce)]
      });
    }
    exports.setNonce = setNonce;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setRpcUrl.js
var require_setRpcUrl = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setRpcUrl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setRpcUrl = void 0;
    async function setRpcUrl(client, jsonRpcUrl) {
      await client.request({
        method: `${client.mode}_setRpcUrl`,
        params: [jsonRpcUrl]
      });
    }
    exports.setRpcUrl = setRpcUrl;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setStorageAt.js
var require_setStorageAt = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/setStorageAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function setStorageAt(client, { address, index: index2, value }) {
      await client.request({
        method: `${client.mode}_setStorageAt`,
        params: [
          address,
          typeof index2 === "number" ? (0, toHex_js_1.numberToHex)(index2) : index2,
          value
        ]
      });
    }
    exports.setStorageAt = setStorageAt;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/snapshot.js
var require_snapshot = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/snapshot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.snapshot = void 0;
    async function snapshot(client) {
      return await client.request({
        method: "evm_snapshot"
      });
    }
    exports.snapshot = snapshot;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/stopImpersonatingAccount.js
var require_stopImpersonatingAccount = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/test/stopImpersonatingAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stopImpersonatingAccount = void 0;
    async function stopImpersonatingAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_stopImpersonatingAccount`,
        params: [address]
      });
    }
    exports.stopImpersonatingAccount = stopImpersonatingAccount;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/decorators/test.js
var require_test = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/decorators/test.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testActions = void 0;
    var dropTransaction_js_1 = require_dropTransaction();
    var getAutomine_js_1 = require_getAutomine();
    var getTxpoolContent_js_1 = require_getTxpoolContent();
    var getTxpoolStatus_js_1 = require_getTxpoolStatus();
    var impersonateAccount_js_1 = require_impersonateAccount();
    var increaseTime_js_1 = require_increaseTime();
    var inspectTxpool_js_1 = require_inspectTxpool();
    var mine_js_1 = require_mine();
    var removeBlockTimestampInterval_js_1 = require_removeBlockTimestampInterval();
    var reset_js_1 = require_reset();
    var revert_js_1 = require_revert();
    var sendUnsignedTransaction_js_1 = require_sendUnsignedTransaction();
    var setAutomine_js_1 = require_setAutomine();
    var setBalance_js_1 = require_setBalance();
    var setBlockGasLimit_js_1 = require_setBlockGasLimit();
    var setBlockTimestampInterval_js_1 = require_setBlockTimestampInterval();
    var setCode_js_1 = require_setCode();
    var setCoinbase_js_1 = require_setCoinbase();
    var setIntervalMining_js_1 = require_setIntervalMining();
    var setLoggingEnabled_js_1 = require_setLoggingEnabled();
    var setMinGasPrice_js_1 = require_setMinGasPrice();
    var setNextBlockBaseFeePerGas_js_1 = require_setNextBlockBaseFeePerGas();
    var setNextBlockTimestamp_js_1 = require_setNextBlockTimestamp();
    var setNonce_js_1 = require_setNonce();
    var setRpcUrl_js_1 = require_setRpcUrl();
    var setStorageAt_js_1 = require_setStorageAt();
    var snapshot_js_1 = require_snapshot();
    var stopImpersonatingAccount_js_1 = require_stopImpersonatingAccount();
    function testActions({ mode }) {
      return (client_) => {
        const client = client_.extend(() => ({
          mode
        }));
        return {
          dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client, args),
          getAutomine: () => (0, getAutomine_js_1.getAutomine)(client),
          getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client),
          getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client),
          impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client, args),
          increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client, args),
          inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client),
          mine: (args) => (0, mine_js_1.mine)(client, args),
          removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client),
          reset: (args) => (0, reset_js_1.reset)(client, args),
          revert: (args) => (0, revert_js_1.revert)(client, args),
          sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client, args),
          setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client, args),
          setBalance: (args) => (0, setBalance_js_1.setBalance)(client, args),
          setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client, args),
          setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client, args),
          setCode: (args) => (0, setCode_js_1.setCode)(client, args),
          setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client, args),
          setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client, args),
          setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client, args),
          setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client, args),
          setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client, args),
          setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client, args),
          setNonce: (args) => (0, setNonce_js_1.setNonce)(client, args),
          setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client, args),
          setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client, args),
          snapshot: () => (0, snapshot_js_1.snapshot)(client),
          stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client, args)
        };
      };
    }
    exports.testActions = testActions;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/createTestClient.js
var require_createTestClient = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/createTestClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTestClient = void 0;
    var createClient_js_1 = require_createClient();
    var test_js_1 = require_test();
    function createTestClient({ account, chain, key = "test", name = "Test Client", mode, pollingInterval, transport }) {
      return (0, createClient_js_1.createClient)({
        account,
        chain,
        key,
        name,
        pollingInterval,
        transport,
        type: "testClient"
      }).extend(() => ({ mode })).extend((0, test_js_1.testActions)({ mode }));
    }
    exports.createTestClient = createTestClient;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/addChain.js
var require_addChain = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/addChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addChain = void 0;
    var toHex_js_1 = require_toHex();
    async function addChain(client, { chain }) {
      const { id: id4, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
      await client.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id4),
            chainName: name,
            nativeCurrency,
            rpcUrls: rpcUrls.default.http,
            blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
          }
        ]
      });
    }
    exports.addChain = addChain;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/deployContract.js
var require_deployContract = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/deployContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deployContract = void 0;
    var encodeDeployData_js_1 = require_encodeDeployData();
    var sendTransaction_js_1 = require_sendTransaction();
    function deployContract(walletClient, { abi, args, bytecode, ...request }) {
      const calldata = (0, encodeDeployData_js_1.encodeDeployData)({
        abi,
        args,
        bytecode
      });
      return (0, sendTransaction_js_1.sendTransaction)(walletClient, {
        ...request,
        data: calldata
      });
    }
    exports.deployContract = deployContract;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/getAddresses.js
var require_getAddresses = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/getAddresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function getAddresses(client) {
      const addresses = await client.request({ method: "eth_accounts" });
      return addresses.map((address) => (0, getAddress_js_1.checksumAddress)(address));
    }
    exports.getAddresses = getAddresses;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/getPermissions.js
var require_getPermissions = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/getPermissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPermissions = void 0;
    async function getPermissions(client) {
      const permissions = await client.request({ method: "wallet_getPermissions" });
      return permissions;
    }
    exports.getPermissions = getPermissions;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/requestAddresses.js
var require_requestAddresses = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/requestAddresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function requestAddresses(client) {
      const addresses = await client.request({ method: "eth_requestAccounts" });
      return addresses.map((address) => (0, getAddress_js_1.getAddress)(address));
    }
    exports.requestAddresses = requestAddresses;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/requestPermissions.js
var require_requestPermissions = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/requestPermissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestPermissions = void 0;
    async function requestPermissions(client, permissions) {
      return client.request({
        method: "wallet_requestPermissions",
        params: [permissions]
      });
    }
    exports.requestPermissions = requestPermissions;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/signMessage.js
var require_signMessage = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/signMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signMessage = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    async function signMessage(client, { account: account_ = client.account, message }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signMessage"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      if (account.type === "local")
        return account.signMessage({ message });
      const message_ = (() => {
        if (typeof message === "string")
          return (0, toHex_js_1.stringToHex)(message);
        if (message.raw instanceof Uint8Array)
          return (0, toHex_js_1.toHex)(message.raw);
        return message.raw;
      })();
      return client.request({
        method: "personal_sign",
        params: [message_, account.address]
      });
    }
    exports.signMessage = signMessage;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/signTypedData.js
var require_signTypedData = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/signTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signTypedData = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var isHex_js_1 = require_isHex();
    var stringify_js_1 = require_stringify();
    var typedData_js_1 = require_typedData();
    async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_ }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signTypedData"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const types = {
        EIP712Domain: [
          typeof domain?.name === "string" && { name: "name", type: "string" },
          domain?.version && { name: "version", type: "string" },
          typeof domain?.chainId === "number" && {
            name: "chainId",
            type: "uint256"
          },
          domain?.verifyingContract && {
            name: "verifyingContract",
            type: "address"
          },
          domain?.salt && { name: "salt", type: "bytes32" }
        ].filter(Boolean),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      if (account.type === "local")
        return account.signTypedData({
          domain,
          primaryType,
          types,
          message
        });
      const typedData = (0, stringify_js_1.stringify)({ domain: domain ?? {}, primaryType, types, message }, (_, value) => (0, isHex_js_1.isHex)(value) ? value.toLowerCase() : value);
      return client.request({
        method: "eth_signTypedData_v4",
        params: [account.address, typedData]
      });
    }
    exports.signTypedData = signTypedData;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/switchChain.js
var require_switchChain = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/switchChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchChain = void 0;
    var toHex_js_1 = require_toHex();
    async function switchChain(client, { id: id4 }) {
      await client.request({
        method: "wallet_switchEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id4)
          }
        ]
      });
    }
    exports.switchChain = switchChain;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/watchAsset.js
var require_watchAsset = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/actions/wallet/watchAsset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchAsset = void 0;
    async function watchAsset(client, params) {
      const added = await client.request({
        method: "wallet_watchAsset",
        params
      });
      return added;
    }
    exports.watchAsset = watchAsset;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/decorators/wallet.js
var require_wallet = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/decorators/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walletActions = void 0;
    var getChainId_js_1 = require_getChainId();
    var addChain_js_1 = require_addChain();
    var deployContract_js_1 = require_deployContract();
    var getAddresses_js_1 = require_getAddresses();
    var getPermissions_js_1 = require_getPermissions();
    var requestAddresses_js_1 = require_requestAddresses();
    var requestPermissions_js_1 = require_requestPermissions();
    var sendTransaction_js_1 = require_sendTransaction();
    var signMessage_js_1 = require_signMessage();
    var signTypedData_js_1 = require_signTypedData();
    var switchChain_js_1 = require_switchChain();
    var watchAsset_js_1 = require_watchAsset();
    var writeContract_js_1 = require_writeContract();
    var walletActions = (client) => ({
      addChain: (args) => (0, addChain_js_1.addChain)(client, args),
      deployContract: (args) => (0, deployContract_js_1.deployContract)(client, args),
      getAddresses: () => (0, getAddresses_js_1.getAddresses)(client),
      getChainId: () => (0, getChainId_js_1.getChainId)(client),
      getPermissions: () => (0, getPermissions_js_1.getPermissions)(client),
      requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client),
      requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client, args),
      sendTransaction: (args) => (0, sendTransaction_js_1.sendTransaction)(client, args),
      signMessage: (args) => (0, signMessage_js_1.signMessage)(client, args),
      signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client, args),
      switchChain: (args) => (0, switchChain_js_1.switchChain)(client, args),
      watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client, args),
      writeContract: (args) => (0, writeContract_js_1.writeContract)(client, args)
    });
    exports.walletActions = walletActions;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/createWalletClient.js
var require_createWalletClient = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/createWalletClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWalletClient = void 0;
    var createClient_js_1 = require_createClient();
    var wallet_js_1 = require_wallet();
    function createWalletClient({ account, chain, transport, key = "wallet", name = "Wallet Client", pollingInterval }) {
      return (0, createClient_js_1.createClient)({
        account,
        chain,
        key,
        name,
        pollingInterval,
        transport: (opts) => transport({ ...opts, retryCount: 0 }),
        type: "walletClient"
      }).extend(wallet_js_1.walletActions);
    }
    exports.createWalletClient = createWalletClient;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/webSocket.js
var require_webSocket = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/clients/transports/webSocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.webSocket = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function webSocket(url, config2 = {}) {
      const { key = "webSocket", name = "WebSocket JSON-RPC", retryDelay } = config2;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const retryCount = config2.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config2.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { error, result } = await rpc_js_1.rpc.webSocketAsync(socket, {
              body,
              timeout
            });
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "webSocket"
        }, {
          getSocket() {
            return (0, rpc_js_1.getSocket)(url_);
          },
          async subscribe({ params, onData, onError }) {
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { result: subscriptionId } = await new Promise((resolve, reject) => rpc_js_1.rpc.webSocket(socket, {
              body: {
                method: "eth_subscribe",
                params
              },
              onResponse(response) {
                if (response.error) {
                  reject(response.error);
                  onError?.(response.error);
                  return;
                }
                if (typeof response.id === "number") {
                  resolve(response);
                  return;
                }
                if (response.method !== "eth_subscription")
                  return;
                onData(response.params);
              }
            }));
            return {
              subscriptionId,
              async unsubscribe() {
                return new Promise((resolve) => rpc_js_1.rpc.webSocket(socket, {
                  body: {
                    method: "eth_unsubscribe",
                    params: [subscriptionId]
                  },
                  onResponse: resolve
                }));
              }
            };
          }
        });
      };
    }
    exports.webSocket = webSocket;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/address.js
var require_address2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/constants/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroAddress = void 0;
    exports.zeroAddress = "0x0000000000000000000000000000000000000000";
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeDeployData.js
var require_decodeDeployData = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/utils/abi/decodeDeployData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var docsPath4 = "/docs/contract/decodeDeployData";
    function decodeDeployData({ abi, bytecode, data }) {
      if (data === bytecode)
        return { bytecode };
      const description = abi.find((x) => "type" in x && x.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath: docsPath4 });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath: docsPath4 });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath: docsPath4 });
      const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, "")}`);
      return { args, bytecode };
    }
    exports.decodeDeployData = decodeDeployData;
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/viem/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiEventNotFoundError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = exports.zeroAddress = exports.weiUnits = exports.gweiUnits = exports.etherUnits = exports.multicall3Abi = exports.webSocket = exports.createWalletClient = exports.createTransport = exports.walletActions = exports.testActions = exports.publicActions = exports.createTestClient = exports.createPublicClient = exports.http = exports.fallback = exports.custom = exports.createClient = exports.getContract = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.UnknownSignatureError = exports.UnknownTypeError = exports.SolidityProtectedKeywordError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.InvalidParenthesisError = exports.InvalidParameterError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.InvalidAbiItemError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.CircularReferenceError = void 0;
    exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = exports.EstimateGasExecutionError = exports.EnsAvatarUriResolutionError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainDoesNotSupportContract = exports.UserRejectedRequestError = exports.UnsupportedProviderMethodError = exports.UnknownRpcError = exports.UnauthorizedProviderError = exports.SwitchChainError = exports.TransactionRejectedRpcError = exports.RpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.ProviderRpcError = exports.ProviderDisconnectedError = exports.ParseRpcError = exports.MethodNotSupportedRpcError = exports.MethodNotFoundRpcError = exports.LimitExceededRpcError = exports.JsonRpcVersionUnsupportedError = exports.InvalidRequestRpcError = exports.InvalidParamsRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.ChainDisconnectedError = exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = exports.BlockNotFoundError = exports.BaseError = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiEncodingTypeError = exports.InvalidAbiDecodingTypeError = exports.DecodeLogTopicsMismatch = exports.AbiFunctionSignatureNotFoundError = void 0;
    exports.hashTypedData = exports.getTransactionType = exports.getSerializedTransactionType = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAbiItem = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeDeployData = exports.decodeAbiParameters = exports.formatLog = exports.formatBlock = exports.defineBlock = exports.namehash = exports.labelhash = exports.UrlRequiredError = exports.SizeExceedsPaddingSizeError = exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidLegacyVError = exports.InvalidAddressError = exports.WebSocketRequestError = exports.TimeoutError = exports.RpcRequestError = exports.HttpRequestError = exports.FilterTypeNotSupportedError = exports.UnknownNodeError = exports.TransactionTypeNotSupportedError = exports.TipAboveFeeCapError = exports.NonceTooLowError = exports.NonceTooHighError = exports.NonceMaxValueError = exports.IntrinsicGasTooLowError = void 0;
    exports.hashMessage = exports.getFunctionSelector = exports.getEventSelector = exports.getContractError = exports.getAddress = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.encodePacked = exports.defineChain = exports.assertCurrentChain = exports.concatHex = exports.concatBytes = exports.concat = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.verifyTypedData = exports.verifyMessage = exports.toRlp = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = void 0;
    exports.validateTypedData = exports.trim = exports.stringify = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.serializeTransaction = exports.serializeAccessList = exports.prepareRequest = exports.parseUnits = exports.parseTransaction = exports.parseGwei = exports.parseEther = exports.padHex = exports.padBytes = exports.pad = exports.keccak256 = exports.isHex = exports.isHash = exports.isBytes = exports.isAddressEqual = exports.isAddress = void 0;
    var abitype_1 = require_cjs();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return abitype_1.CircularReferenceError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return abitype_1.InvalidParenthesisError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abitype_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abitype_1.UnknownTypeError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return abitype_1.UnknownSignatureError;
    } });
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var getContract_js_1 = require_getContract();
    Object.defineProperty(exports, "getContract", { enumerable: true, get: function() {
      return getContract_js_1.getContract;
    } });
    var createClient_js_1 = require_createClient();
    Object.defineProperty(exports, "createClient", { enumerable: true, get: function() {
      return createClient_js_1.createClient;
    } });
    var custom_js_1 = require_custom();
    Object.defineProperty(exports, "custom", { enumerable: true, get: function() {
      return custom_js_1.custom;
    } });
    var fallback_js_1 = require_fallback();
    Object.defineProperty(exports, "fallback", { enumerable: true, get: function() {
      return fallback_js_1.fallback;
    } });
    var http_js_1 = require_http();
    Object.defineProperty(exports, "http", { enumerable: true, get: function() {
      return http_js_1.http;
    } });
    var createPublicClient_js_1 = require_createPublicClient();
    Object.defineProperty(exports, "createPublicClient", { enumerable: true, get: function() {
      return createPublicClient_js_1.createPublicClient;
    } });
    var createTestClient_js_1 = require_createTestClient();
    Object.defineProperty(exports, "createTestClient", { enumerable: true, get: function() {
      return createTestClient_js_1.createTestClient;
    } });
    var public_js_1 = require_public();
    Object.defineProperty(exports, "publicActions", { enumerable: true, get: function() {
      return public_js_1.publicActions;
    } });
    var test_js_1 = require_test();
    Object.defineProperty(exports, "testActions", { enumerable: true, get: function() {
      return test_js_1.testActions;
    } });
    var wallet_js_1 = require_wallet();
    Object.defineProperty(exports, "walletActions", { enumerable: true, get: function() {
      return wallet_js_1.walletActions;
    } });
    var createTransport_js_1 = require_createTransport();
    Object.defineProperty(exports, "createTransport", { enumerable: true, get: function() {
      return createTransport_js_1.createTransport;
    } });
    var createWalletClient_js_1 = require_createWalletClient();
    Object.defineProperty(exports, "createWalletClient", { enumerable: true, get: function() {
      return createWalletClient_js_1.createWalletClient;
    } });
    var webSocket_js_1 = require_webSocket();
    Object.defineProperty(exports, "webSocket", { enumerable: true, get: function() {
      return webSocket_js_1.webSocket;
    } });
    var abis_js_1 = require_abis();
    Object.defineProperty(exports, "multicall3Abi", { enumerable: true, get: function() {
      return abis_js_1.multicall3Abi;
    } });
    var unit_js_1 = require_unit();
    Object.defineProperty(exports, "etherUnits", { enumerable: true, get: function() {
      return unit_js_1.etherUnits;
    } });
    Object.defineProperty(exports, "gweiUnits", { enumerable: true, get: function() {
      return unit_js_1.gweiUnits;
    } });
    Object.defineProperty(exports, "weiUnits", { enumerable: true, get: function() {
      return unit_js_1.weiUnits;
    } });
    var address_js_1 = require_address2();
    Object.defineProperty(exports, "zeroAddress", { enumerable: true, get: function() {
      return address_js_1.zeroAddress;
    } });
    var abi_js_1 = require_abi();
    Object.defineProperty(exports, "AbiConstructorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiConstructorParamsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorParamsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiDecodingDataSizeInvalidError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingDataSizeInvalidError;
    } });
    Object.defineProperty(exports, "AbiDecodingZeroDataError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingZeroDataError;
    } });
    Object.defineProperty(exports, "AbiEncodingArrayLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingArrayLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiEncodingLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiErrorInputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorInputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureEmptyTopicsError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureEmptyTopicsError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionOutputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionOutputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "DecodeLogTopicsMismatch", { enumerable: true, get: function() {
      return abi_js_1.DecodeLogTopicsMismatch;
    } });
    Object.defineProperty(exports, "InvalidAbiDecodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiDecodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiEncodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiEncodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidArrayError", { enumerable: true, get: function() {
      return abi_js_1.InvalidArrayError;
    } });
    Object.defineProperty(exports, "InvalidDefinitionTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidDefinitionTypeError;
    } });
    var base_js_1 = require_base2();
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return base_js_1.BaseError;
    } });
    var block_js_1 = require_block();
    Object.defineProperty(exports, "BlockNotFoundError", { enumerable: true, get: function() {
      return block_js_1.BlockNotFoundError;
    } });
    var contract_js_1 = require_contract();
    Object.defineProperty(exports, "CallExecutionError", { enumerable: true, get: function() {
      return contract_js_1.CallExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionExecutionError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionRevertedError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionRevertedError;
    } });
    Object.defineProperty(exports, "ContractFunctionZeroDataError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionZeroDataError;
    } });
    Object.defineProperty(exports, "RawContractError", { enumerable: true, get: function() {
      return contract_js_1.RawContractError;
    } });
    var rpc_js_1 = require_rpc();
    Object.defineProperty(exports, "ChainDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ChainDisconnectedError;
    } });
    Object.defineProperty(exports, "InternalRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InternalRpcError;
    } });
    Object.defineProperty(exports, "InvalidInputRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidInputRpcError;
    } });
    Object.defineProperty(exports, "InvalidParamsRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidParamsRpcError;
    } });
    Object.defineProperty(exports, "InvalidRequestRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidRequestRpcError;
    } });
    Object.defineProperty(exports, "JsonRpcVersionUnsupportedError", { enumerable: true, get: function() {
      return rpc_js_1.JsonRpcVersionUnsupportedError;
    } });
    Object.defineProperty(exports, "LimitExceededRpcError", { enumerable: true, get: function() {
      return rpc_js_1.LimitExceededRpcError;
    } });
    Object.defineProperty(exports, "MethodNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotFoundRpcError;
    } });
    Object.defineProperty(exports, "MethodNotSupportedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotSupportedRpcError;
    } });
    Object.defineProperty(exports, "ParseRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ParseRpcError;
    } });
    Object.defineProperty(exports, "ProviderDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderDisconnectedError;
    } });
    Object.defineProperty(exports, "ProviderRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderRpcError;
    } });
    Object.defineProperty(exports, "ResourceNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceNotFoundRpcError;
    } });
    Object.defineProperty(exports, "ResourceUnavailableRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceUnavailableRpcError;
    } });
    Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
      return rpc_js_1.RpcError;
    } });
    Object.defineProperty(exports, "TransactionRejectedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.TransactionRejectedRpcError;
    } });
    Object.defineProperty(exports, "SwitchChainError", { enumerable: true, get: function() {
      return rpc_js_1.SwitchChainError;
    } });
    Object.defineProperty(exports, "UnauthorizedProviderError", { enumerable: true, get: function() {
      return rpc_js_1.UnauthorizedProviderError;
    } });
    Object.defineProperty(exports, "UnknownRpcError", { enumerable: true, get: function() {
      return rpc_js_1.UnknownRpcError;
    } });
    Object.defineProperty(exports, "UnsupportedProviderMethodError", { enumerable: true, get: function() {
      return rpc_js_1.UnsupportedProviderMethodError;
    } });
    Object.defineProperty(exports, "UserRejectedRequestError", { enumerable: true, get: function() {
      return rpc_js_1.UserRejectedRequestError;
    } });
    var chain_js_1 = require_chain();
    Object.defineProperty(exports, "ChainDoesNotSupportContract", { enumerable: true, get: function() {
      return chain_js_1.ChainDoesNotSupportContract;
    } });
    Object.defineProperty(exports, "ClientChainNotConfiguredError", { enumerable: true, get: function() {
      return chain_js_1.ClientChainNotConfiguredError;
    } });
    Object.defineProperty(exports, "InvalidChainIdError", { enumerable: true, get: function() {
      return chain_js_1.InvalidChainIdError;
    } });
    var encoding_js_1 = require_encoding();
    Object.defineProperty(exports, "DataLengthTooLongError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooLongError;
    } });
    Object.defineProperty(exports, "DataLengthTooShortError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooShortError;
    } });
    Object.defineProperty(exports, "InvalidBytesBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidBytesBooleanError;
    } });
    Object.defineProperty(exports, "InvalidHexBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexBooleanError;
    } });
    Object.defineProperty(exports, "InvalidHexValueError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexValueError;
    } });
    Object.defineProperty(exports, "OffsetOutOfBoundsError", { enumerable: true, get: function() {
      return encoding_js_1.OffsetOutOfBoundsError;
    } });
    var ens_js_1 = require_ens();
    Object.defineProperty(exports, "EnsAvatarUriResolutionError", { enumerable: true, get: function() {
      return ens_js_1.EnsAvatarUriResolutionError;
    } });
    var estimateGas_js_1 = require_estimateGas();
    Object.defineProperty(exports, "EstimateGasExecutionError", { enumerable: true, get: function() {
      return estimateGas_js_1.EstimateGasExecutionError;
    } });
    var node_js_1 = require_node();
    Object.defineProperty(exports, "ExecutionRevertedError", { enumerable: true, get: function() {
      return node_js_1.ExecutionRevertedError;
    } });
    Object.defineProperty(exports, "FeeCapTooHighError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooHighError;
    } });
    Object.defineProperty(exports, "FeeCapTooLowError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooLowError;
    } });
    Object.defineProperty(exports, "InsufficientFundsError", { enumerable: true, get: function() {
      return node_js_1.InsufficientFundsError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooHighError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooHighError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooLowError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooLowError;
    } });
    Object.defineProperty(exports, "NonceMaxValueError", { enumerable: true, get: function() {
      return node_js_1.NonceMaxValueError;
    } });
    Object.defineProperty(exports, "NonceTooHighError", { enumerable: true, get: function() {
      return node_js_1.NonceTooHighError;
    } });
    Object.defineProperty(exports, "NonceTooLowError", { enumerable: true, get: function() {
      return node_js_1.NonceTooLowError;
    } });
    Object.defineProperty(exports, "TipAboveFeeCapError", { enumerable: true, get: function() {
      return node_js_1.TipAboveFeeCapError;
    } });
    Object.defineProperty(exports, "TransactionTypeNotSupportedError", { enumerable: true, get: function() {
      return node_js_1.TransactionTypeNotSupportedError;
    } });
    Object.defineProperty(exports, "UnknownNodeError", { enumerable: true, get: function() {
      return node_js_1.UnknownNodeError;
    } });
    var log_js_1 = require_log();
    Object.defineProperty(exports, "FilterTypeNotSupportedError", { enumerable: true, get: function() {
      return log_js_1.FilterTypeNotSupportedError;
    } });
    var request_js_1 = require_request();
    Object.defineProperty(exports, "HttpRequestError", { enumerable: true, get: function() {
      return request_js_1.HttpRequestError;
    } });
    Object.defineProperty(exports, "RpcRequestError", { enumerable: true, get: function() {
      return request_js_1.RpcRequestError;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return request_js_1.TimeoutError;
    } });
    Object.defineProperty(exports, "WebSocketRequestError", { enumerable: true, get: function() {
      return request_js_1.WebSocketRequestError;
    } });
    var address_js_2 = require_address();
    Object.defineProperty(exports, "InvalidAddressError", { enumerable: true, get: function() {
      return address_js_2.InvalidAddressError;
    } });
    var transaction_js_1 = require_transaction();
    Object.defineProperty(exports, "InvalidLegacyVError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidLegacyVError;
    } });
    Object.defineProperty(exports, "TransactionExecutionError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionExecutionError;
    } });
    Object.defineProperty(exports, "TransactionNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionNotFoundError;
    } });
    Object.defineProperty(exports, "TransactionReceiptNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionReceiptNotFoundError;
    } });
    Object.defineProperty(exports, "WaitForTransactionReceiptTimeoutError", { enumerable: true, get: function() {
      return transaction_js_1.WaitForTransactionReceiptTimeoutError;
    } });
    var data_js_1 = require_data();
    Object.defineProperty(exports, "SizeExceedsPaddingSizeError", { enumerable: true, get: function() {
      return data_js_1.SizeExceedsPaddingSizeError;
    } });
    var transport_js_1 = require_transport();
    Object.defineProperty(exports, "UrlRequiredError", { enumerable: true, get: function() {
      return transport_js_1.UrlRequiredError;
    } });
    var labelhash_js_1 = require_labelhash();
    Object.defineProperty(exports, "labelhash", { enumerable: true, get: function() {
      return labelhash_js_1.labelhash;
    } });
    var namehash_js_1 = require_namehash2();
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_js_1.namehash;
    } });
    var block_js_2 = require_block2();
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_2.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_2.formatBlock;
    } });
    var log_js_2 = require_log2();
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_2.formatLog;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeDeployData_js_1 = require_decodeDeployData();
    Object.defineProperty(exports, "decodeDeployData", { enumerable: true, get: function() {
      return decodeDeployData_js_1.decodeDeployData;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var transaction_js_2 = require_transaction2();
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_2.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_2.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_2.transactionType;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigint;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var ccip_js_1 = require_ccip2();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var chain_js_2 = require_chain2();
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return chain_js_2.assertCurrentChain;
    } });
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return chain_js_2.defineChain;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var prepareRequest_js_1 = require_prepareRequest();
    Object.defineProperty(exports, "prepareRequest", { enumerable: true, get: function() {
      return prepareRequest_js_1.prepareRequest;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/base/base-http-provider.js
var require_base_http_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/base/base-http-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildViemTransportForHttpSource = exports.buildEthersProviderForHttpSource = exports.BaseHttpProvider = void 0;
    var providers_1 = require_lib22();
    var viem_1 = require_cjs2();
    var BaseHttpProvider = class {
      supportedClients() {
        const support = { ethers: true, viem: true };
        return Object.fromEntries(this.supportedChains().map((chainId) => [chainId, support]));
      }
      getEthersProvider({ chainId }) {
        this.assertChainIsValid(chainId);
        const url = this.calculateUrl(chainId);
        return buildEthersProviderForHttpSource(url, chainId);
      }
      getViemTransport({ chainId }) {
        this.assertChainIsValid(chainId);
        const url = this.calculateUrl(chainId);
        return buildViemTransportForHttpSource(url, chainId);
      }
      assertChainIsValid(chainId) {
        if (!this.supportedChains().includes(chainId))
          throw new Error(`Chain with id ${chainId} is not supported`);
      }
    };
    exports.BaseHttpProvider = BaseHttpProvider;
    function buildEthersProviderForHttpSource(url, chainId) {
      return new providers_1.StaticJsonRpcProvider(url, chainId);
    }
    exports.buildEthersProviderForHttpSource = buildEthersProviderForHttpSource;
    function buildViemTransportForHttpSource(url, chainId) {
      return (0, viem_1.http)(url);
    }
    exports.buildViemTransportForHttpSource = buildViemTransportForHttpSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/base/base-web-socket-provider.js
var require_base_web_socket_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/base/base-web-socket-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildViemTransportForWebSocketSource = exports.buildEthersProviderForWebSocketSource = exports.BaseWebSocketProvider = void 0;
    var providers_1 = require_lib22();
    var viem_1 = require_cjs2();
    var BaseWebSocketProvider = class {
      supportedClients() {
        const support = { ethers: true, viem: true };
        return Object.fromEntries(this.supportedChains().map((chainId) => [chainId, support]));
      }
      getEthersProvider({ chainId }) {
        this.assertChainIsValid(chainId);
        const url = this.calculateUrl(chainId);
        return buildEthersProviderForWebSocketSource(url, chainId);
      }
      getViemTransport({ chainId }) {
        this.assertChainIsValid(chainId);
        const url = this.calculateUrl(chainId);
        return buildViemTransportForWebSocketSource(url, chainId);
      }
      assertChainIsValid(chainId) {
        if (!this.supportedChains().includes(chainId))
          throw new Error(`Chain with id ${chainId} is not supported`);
      }
    };
    exports.BaseWebSocketProvider = BaseWebSocketProvider;
    function buildEthersProviderForWebSocketSource(url, chainId) {
      return new providers_1.WebSocketProvider(url, chainId);
    }
    exports.buildEthersProviderForWebSocketSource = buildEthersProviderForWebSocketSource;
    function buildViemTransportForWebSocketSource(url, chainId) {
      return (0, viem_1.webSocket)(url);
    }
    exports.buildViemTransportForWebSocketSource = buildViemTransportForWebSocketSource;
  }
});

// ../node_modules/@ethersproject/units/lib.esm/_version.js
var version;
var init_version = __esm({
  "../node_modules/@ethersproject/units/lib.esm/_version.js"() {
    version = "units/5.7.0";
  }
});

// ../node_modules/@ethersproject/units/lib.esm/index.js
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return (0, import_bignumber.formatFixed)(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index2 = names.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return (0, import_bignumber.parseFixed)(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var import_bignumber, import_logger, logger, names;
var init_lib = __esm({
  "../node_modules/@ethersproject/units/lib.esm/index.js"() {
    "use strict";
    import_bignumber = __toESM(require_lib3());
    import_logger = __toESM(require_lib());
    init_version();
    logger = new import_logger.Logger(version);
    names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/_version.js
var version2;
var init_version2 = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/_version.js"() {
    version2 = "abi/5.7.0";
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/fragments.js
function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }
  if (ModifiersBytes[name] || name === "payable") {
    logger2.throwArgumentError("invalid modifier", "name", name);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError(i) {
    logger2.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i = 0; i < param.length; i++) {
    let c = param[i];
    switch (c) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError(i);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              if (node.indexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i);
        }
        node.type += c;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i);
        }
        node.type += c;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c;
        } else {
          throwError(i);
        }
    }
  }
  if (node.parent) {
    logger2.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (let key in params) {
    (0, import_properties.defineReadOnly)(object, key, params[key]);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger2.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger2.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = import_bignumber2.BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger2.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger2.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger2.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger2.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger2.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger2.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger2.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c = value[offset];
    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;
      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;
        if (depth === -1) {
          logger2.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
var import_bignumber2, import_properties, import_logger2, logger2, _constructorGuard, ModifiersBytes, ModifiersNest, FormatTypes, paramTypeArray, ParamType, Fragment, EventFragment, ConstructorFragment, FunctionFragment, ErrorFragment, regexIdentifier, regexParen;
var init_fragments = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/fragments.js"() {
    "use strict";
    import_bignumber2 = __toESM(require_lib3());
    import_properties = __toESM(require_lib4());
    import_logger2 = __toESM(require_lib());
    init_version2();
    logger2 = new import_logger2.Logger(version2);
    _constructorGuard = {};
    ModifiersBytes = { calldata: true, memory: true, storage: true };
    ModifiersNest = { calldata: true, memory: true };
    FormatTypes = Object.freeze({
      sighash: "sighash",
      minimal: "minimal",
      full: "full",
      json: "json"
    });
    paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
    ParamType = class {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
          logger2.throwError("use fromString", import_logger2.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
          });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
          populate(this, {
            arrayLength: parseInt(match[2] || "-1"),
            arrayChildren: ParamType.fromObject({
              type: match[1],
              components: this.components
            }),
            baseType: "array"
          });
        } else {
          populate(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
          });
        }
        this._isParamType = true;
        Object.freeze(this);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger2.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          let result2 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name: this.name || void 0
          };
          if (typeof this.indexed === "boolean") {
            result2.indexed = this.indexed;
          }
          if (this.components) {
            result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
          }
          return JSON.stringify(result2);
        }
        let result = "";
        if (this.baseType === "array") {
          result += this.arrayChildren.format(format);
          result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        } else {
          if (this.baseType === "tuple") {
            if (format !== FormatTypes.sighash) {
              result += this.type;
            }
            result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (format !== FormatTypes.sighash) {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (format === FormatTypes.full && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      }
      static from(value, allowIndexed) {
        if (typeof value === "string") {
          return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
      }
      static fromObject(value) {
        if (ParamType.isParamType(value)) {
          return value;
        }
        return new ParamType(_constructorGuard, {
          name: value.name || null,
          type: verifyType(value.type),
          indexed: value.indexed == null ? null : !!value.indexed,
          components: value.components ? value.components.map(ParamType.fromObject) : null
        });
      }
      static fromString(value, allowIndexed) {
        function ParamTypify(node) {
          return ParamType.fromObject({
            name: node.name,
            type: node.type,
            indexed: node.indexed,
            components: node.components
          });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
      }
      static isParamType(value) {
        return !!(value != null && value._isParamType);
      }
    };
    Fragment = class {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
          logger2.throwError("use a static from method", import_logger2.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
          });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
      }
      static from(value) {
        if (Fragment.isFragment(value)) {
          return value;
        }
        if (typeof value === "string") {
          return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
      }
      static fromObject(value) {
        if (Fragment.isFragment(value)) {
          return value;
        }
        switch (value.type) {
          case "function":
            return FunctionFragment.fromObject(value);
          case "event":
            return EventFragment.fromObject(value);
          case "constructor":
            return ConstructorFragment.fromObject(value);
          case "error":
            return ErrorFragment.fromObject(value);
          case "fallback":
          case "receive":
            return null;
        }
        return logger2.throwArgumentError("invalid fragment object", "value", value);
      }
      static fromString(value) {
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
          return EventFragment.fromString(value.substring(5).trim());
        } else if (value.split(" ")[0] === "function") {
          return FunctionFragment.fromString(value.substring(8).trim());
        } else if (value.split("(")[0].trim() === "constructor") {
          return ConstructorFragment.fromString(value.trim());
        } else if (value.split(" ")[0] === "error") {
          return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger2.throwArgumentError("unsupported fragment", "value", value);
      }
      static isFragment(value) {
        return !!(value && value._isFragment);
      }
    };
    EventFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger2.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.anonymous) {
            result += "anonymous ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
      }
      static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
          return value;
        }
        if (value.type !== "event") {
          logger2.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
          name: verifyIdentifier(value.name),
          anonymous: value.anonymous,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          type: "event"
        };
        return new EventFragment(_constructorGuard, params);
      }
      static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
          logger2.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
          switch (modifier.trim()) {
            case "anonymous":
              anonymous = true;
              break;
            case "":
              break;
            default:
              logger2.warn("unknown modifier: " + modifier);
          }
        });
        return EventFragment.fromObject({
          name: match[1].trim(),
          anonymous,
          inputs: parseParams(match[2], true),
          type: "event"
        });
      }
      static isEventFragment(value) {
        return value && value._isFragment && value.type === "event";
      }
    };
    ConstructorFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger2.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        if (format === FormatTypes.sighash) {
          logger2.throwError("cannot format a constructor for sighash", import_logger2.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
          });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
      }
      static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
          return value;
        }
        if (value.type !== "constructor") {
          logger2.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
          logger2.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
          name: null,
          type: value.type,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? import_bignumber2.BigNumber.from(value.gas) : null
        };
        return new ConstructorFragment(_constructorGuard, params);
      }
      static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
          logger2.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
      }
      static isConstructorFragment(value) {
        return value && value._isFragment && value.type === "constructor";
      }
    };
    FunctionFragment = class extends ConstructorFragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger2.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            outputs: this.outputs.map((output3) => JSON.parse(output3.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.stateMutability) {
            if (this.stateMutability !== "nonpayable") {
              result += this.stateMutability + " ";
            }
          } else if (this.constant) {
            result += "view ";
          }
          if (this.outputs && this.outputs.length) {
            result += "returns (" + this.outputs.map((output3) => output3.format(format)).join(", ") + ") ";
          }
          if (this.gas != null) {
            result += "@" + this.gas.toString() + " ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
      }
      static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
          return value;
        }
        if (value.type !== "function") {
          logger2.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          constant: state.constant,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? import_bignumber2.BigNumber.from(value.gas) : null
        };
        return new FunctionFragment(_constructorGuard, params);
      }
      static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
          logger2.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
          logger2.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        if (comps.length > 1) {
          let returns = comps[1].match(regexParen);
          if (returns[1].trim() != "" || returns[3].trim() != "") {
            logger2.throwArgumentError("unexpected tokens", "value", value);
          }
          params.outputs = parseParams(returns[2], false);
        } else {
          params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
      }
      static isFunctionFragment(value) {
        return value && value._isFragment && value.type === "function";
      }
    };
    ErrorFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger2.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
      }
      static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
          return value;
        }
        if (value.type !== "error") {
          logger2.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
      }
      static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
          logger2.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
      }
      static isErrorFragment(value) {
        return value && value._isFragment && value.type === "error";
      }
    };
    regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
    regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (let key in object) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object[key]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var import_bytes, import_bignumber3, import_properties2, import_logger3, logger3, Coder, Writer, Reader;
var init_abstract_coder = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"() {
    "use strict";
    import_bytes = __toESM(require_lib2());
    import_bignumber3 = __toESM(require_lib3());
    import_properties2 = __toESM(require_lib4());
    import_logger3 = __toESM(require_lib());
    init_version2();
    logger3 = new import_logger3.Logger(version2);
    Coder = class {
      constructor(name, type, localName, dynamic) {
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
      }
      _throwError(message, value) {
        logger3.throwArgumentError(message, this.localName, value);
      }
    };
    Writer = class {
      constructor(wordSize) {
        (0, import_properties2.defineReadOnly)(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
      }
      get data() {
        return (0, import_bytes.hexConcat)(this._data);
      }
      get length() {
        return this._dataLength;
      }
      _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
      }
      appendWriter(writer) {
        return this._writeData((0, import_bytes.concat)(writer._data));
      }
      writeBytes(value) {
        let bytes4 = (0, import_bytes.arrayify)(value);
        const paddingOffset = bytes4.length % this.wordSize;
        if (paddingOffset) {
          bytes4 = (0, import_bytes.concat)([bytes4, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes4);
      }
      _getValue(value) {
        let bytes4 = (0, import_bytes.arrayify)(import_bignumber3.BigNumber.from(value));
        if (bytes4.length > this.wordSize) {
          logger3.throwError("value out-of-bounds", import_logger3.Logger.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: bytes4.length
          });
        }
        if (bytes4.length % this.wordSize) {
          bytes4 = (0, import_bytes.concat)([this._padding.slice(bytes4.length % this.wordSize), bytes4]);
        }
        return bytes4;
      }
      writeValue(value) {
        return this._writeData(this._getValue(value));
      }
      writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
          this._data[offset] = this._getValue(value);
        };
      }
    };
    Reader = class {
      constructor(data, wordSize, coerceFunc, allowLoose) {
        (0, import_properties2.defineReadOnly)(this, "_data", (0, import_bytes.arrayify)(data));
        (0, import_properties2.defineReadOnly)(this, "wordSize", wordSize || 32);
        (0, import_properties2.defineReadOnly)(this, "_coerceFunc", coerceFunc);
        (0, import_properties2.defineReadOnly)(this, "allowLoose", allowLoose);
        this._offset = 0;
      }
      get data() {
        return (0, import_bytes.hexlify)(this._data);
      }
      get consumed() {
        return this._offset;
      }
      static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
          value = value.toNumber();
        }
        return value;
      }
      coerce(name, value) {
        if (this._coerceFunc) {
          return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
      }
      _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
          if (this.allowLoose && loose && this._offset + length <= this._data.length) {
            alignedLength = length;
          } else {
            logger3.throwError("data out-of-bounds", import_logger3.Logger.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + alignedLength
            });
          }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
      }
      subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
      }
      readBytes(length, loose) {
        let bytes4 = this._peekBytes(0, length, !!loose);
        this._offset += bytes4.length;
        return bytes4.slice(0, length);
      }
      readValue() {
        return import_bignumber3.BigNumber.from(this.readBytes(this.wordSize));
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/address.js
var import_address, import_bytes2, AddressCoder;
var init_address = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/address.js"() {
    "use strict";
    import_address = __toESM(require_lib14());
    import_bytes2 = __toESM(require_lib2());
    init_abstract_coder();
    AddressCoder = class extends Coder {
      constructor(localName) {
        super("address", "address", localName, false);
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000";
      }
      encode(writer, value) {
        try {
          value = (0, import_address.getAddress)(value);
        } catch (error) {
          this._throwError(error.message, value);
        }
        return writer.writeValue(value);
      }
      decode(reader) {
        return (0, import_address.getAddress)((0, import_bytes2.hexZeroPad)(reader.readValue().toHexString(), 20));
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder;
var init_anonymous = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js"() {
    "use strict";
    init_abstract_coder();
    AnonymousCoder = class extends Coder {
      constructor(coder) {
        super(coder.name, coder.type, void 0, coder.dynamic);
        this.coder = coder;
      }
      defaultValue() {
        return this.coder.defaultValue();
      }
      encode(writer, value) {
        return this.coder.encode(writer, value);
      }
      decode(reader) {
        return this.coder.decode(reader);
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      if (!name) {
        logger4.throwError("cannot encode object for signature with missing names", import_logger4.Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name]) {
        logger4.throwError("cannot encode object for signature with duplicate names", import_logger4.Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name] = true;
      return values[name];
    });
  } else {
    logger4.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger4.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === import_logger4.Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === import_logger4.Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name = coder.localName;
    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }
      accum[name]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index2) => {
    let name = coder.localName;
    if (!name || uniqueNames[name] !== 1) {
      return;
    }
    if (name === "length") {
      name = "_length";
    }
    if (values[name] != null) {
      return;
    }
    const value = values[index2];
    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var import_logger4, logger4, ArrayCoder;
var init_array = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/array.js"() {
    "use strict";
    import_logger4 = __toESM(require_lib());
    init_version2();
    init_abstract_coder();
    init_anonymous();
    logger4 = new import_logger4.Logger(version2);
    ArrayCoder = class extends Coder {
      constructor(coder, length, localName) {
        const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        const dynamic = length === -1 || coder.dynamic;
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
      }
      defaultValue() {
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
          result.push(defaultChild);
        }
        return result;
      }
      encode(writer, value) {
        if (!Array.isArray(value)) {
          this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
          count = value.length;
          writer.writeValue(value.length);
        }
        logger4.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
          coders.push(this.coder);
        }
        return pack(writer, coders, value);
      }
      decode(reader) {
        let count = this.length;
        if (count === -1) {
          count = reader.readValue().toNumber();
          if (count * 32 > reader._data.length) {
            logger4.throwError("insufficient data length", import_logger4.Logger.errors.BUFFER_OVERRUN, {
              length: reader._data.length,
              count
            });
          }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
          coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder;
var init_boolean = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/boolean.js"() {
    "use strict";
    init_abstract_coder();
    BooleanCoder = class extends Coder {
      constructor(localName) {
        super("bool", "bool", localName, false);
      }
      defaultValue() {
        return false;
      }
      encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
      }
      decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var import_bytes3, DynamicBytesCoder, BytesCoder;
var init_bytes = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/bytes.js"() {
    "use strict";
    import_bytes3 = __toESM(require_lib2());
    init_abstract_coder();
    DynamicBytesCoder = class extends Coder {
      constructor(type, localName) {
        super(type, type, localName, true);
      }
      defaultValue() {
        return "0x";
      }
      encode(writer, value) {
        value = (0, import_bytes3.arrayify)(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
      }
      decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
      }
    };
    BytesCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("bytes", localName);
      }
      decode(reader) {
        return reader.coerce(this.name, (0, import_bytes3.hexlify)(super.decode(reader)));
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var import_bytes4, FixedBytesCoder;
var init_fixed_bytes = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js"() {
    "use strict";
    import_bytes4 = __toESM(require_lib2());
    init_abstract_coder();
    FixedBytesCoder = class extends Coder {
      constructor(size3, localName) {
        let name = "bytes" + String(size3);
        super(name, name, localName, false);
        this.size = size3;
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
      }
      encode(writer, value) {
        let data = (0, import_bytes4.arrayify)(value);
        if (data.length !== this.size) {
          this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
      }
      decode(reader) {
        return reader.coerce(this.name, (0, import_bytes4.hexlify)(reader.readBytes(this.size)));
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder;
var init_null = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/null.js"() {
    "use strict";
    init_abstract_coder();
    NullCoder = class extends Coder {
      constructor(localName) {
        super("null", "", localName, false);
      }
      defaultValue() {
        return null;
      }
      encode(writer, value) {
        if (value != null) {
          this._throwError("not null", value);
        }
        return writer.writeBytes([]);
      }
      decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/number.js
var import_bignumber4, import_constants, NumberCoder;
var init_number = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/number.js"() {
    "use strict";
    import_bignumber4 = __toESM(require_lib3());
    import_constants = __toESM(require_lib9());
    init_abstract_coder();
    NumberCoder = class extends Coder {
      constructor(size3, signed, localName) {
        const name = (signed ? "int" : "uint") + size3 * 8;
        super(name, name, localName, false);
        this.size = size3;
        this.signed = signed;
      }
      defaultValue() {
        return 0;
      }
      encode(writer, value) {
        let v = import_bignumber4.BigNumber.from(value);
        let maxUintValue = import_constants.MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
          let bounds = maxUintValue.mask(this.size * 8 - 1);
          if (v.gt(bounds) || v.lt(bounds.add(import_constants.One).mul(import_constants.NegativeOne))) {
            this._throwError("value out-of-bounds", value);
          }
        } else if (v.lt(import_constants.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
          this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
          v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
      }
      decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
          value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/string.js
var import_strings, StringCoder;
var init_string = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/string.js"() {
    "use strict";
    import_strings = __toESM(require_lib11());
    init_bytes();
    StringCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("string", localName);
      }
      defaultValue() {
        return "";
      }
      encode(writer, value) {
        return super.encode(writer, (0, import_strings.toUtf8Bytes)(value));
      }
      decode(reader) {
        return (0, import_strings.toUtf8String)(super.decode(reader));
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder;
var init_tuple = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/coders/tuple.js"() {
    "use strict";
    init_abstract_coder();
    init_array();
    TupleCoder = class extends Coder {
      constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
          if (coder.dynamic) {
            dynamic = true;
          }
          types.push(coder.type);
        });
        const type = "tuple(" + types.join(",") + ")";
        super("tuple", type, localName, dynamic);
        this.coders = coders;
      }
      defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
          values.push(coder.defaultValue());
        });
        const uniqueNames = this.coders.reduce((accum, coder) => {
          const name = coder.localName;
          if (name) {
            if (!accum[name]) {
              accum[name] = 0;
            }
            accum[name]++;
          }
          return accum;
        }, {});
        this.coders.forEach((coder, index2) => {
          let name = coder.localName;
          if (!name || uniqueNames[name] !== 1) {
            return;
          }
          if (name === "length") {
            name = "_length";
          }
          if (values[name] != null) {
            return;
          }
          values[name] = values[index2];
        });
        return Object.freeze(values);
      }
      encode(writer, value) {
        return pack(writer, this.coders, value);
      }
      decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var import_bytes6, import_properties3, import_logger5, logger5, paramTypeBytes, paramTypeNumber, AbiCoder, defaultAbiCoder;
var init_abi_coder = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/abi-coder.js"() {
    "use strict";
    import_bytes6 = __toESM(require_lib2());
    import_properties3 = __toESM(require_lib4());
    import_logger5 = __toESM(require_lib());
    init_version2();
    init_abstract_coder();
    init_address();
    init_array();
    init_boolean();
    init_bytes();
    init_fixed_bytes();
    init_null();
    init_number();
    init_string();
    init_tuple();
    init_fragments();
    logger5 = new import_logger5.Logger(version2);
    paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    AbiCoder = class {
      constructor(coerceFunc) {
        (0, import_properties3.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
      }
      _getCoder(param) {
        switch (param.baseType) {
          case "address":
            return new AddressCoder(param.name);
          case "bool":
            return new BooleanCoder(param.name);
          case "string":
            return new StringCoder(param.name);
          case "bytes":
            return new BytesCoder(param.name);
          case "array":
            return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
          case "tuple":
            return new TupleCoder((param.components || []).map((component) => {
              return this._getCoder(component);
            }), param.name);
          case "":
            return new NullCoder(param.name);
        }
        let match = param.type.match(paramTypeNumber);
        if (match) {
          let size3 = parseInt(match[2] || "256");
          if (size3 === 0 || size3 > 256 || size3 % 8 !== 0) {
            logger5.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
          }
          return new NumberCoder(size3 / 8, match[1] === "int", param.name);
        }
        match = param.type.match(paramTypeBytes);
        if (match) {
          let size3 = parseInt(match[1]);
          if (size3 === 0 || size3 > 32) {
            logger5.throwArgumentError("invalid bytes length", "param", param);
          }
          return new FixedBytesCoder(size3, param.name);
        }
        return logger5.throwArgumentError("invalid type", "type", param.type);
      }
      _getWordSize() {
        return 32;
      }
      _getReader(data, allowLoose) {
        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
      }
      _getWriter() {
        return new Writer(this._getWordSize());
      }
      getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
      }
      encode(types, values) {
        if (types.length !== values.length) {
          logger5.throwError("types/values length mismatch", import_logger5.Logger.errors.INVALID_ARGUMENT, {
            count: { types: types.length, values: values.length },
            value: { types, values }
          });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
      }
      decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader((0, import_bytes6.arrayify)(data), loose));
      }
    };
    defaultAbiCoder = new AbiCoder();
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/interface.js
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
var import_address3, import_bignumber5, import_bytes8, import_hash, import_keccak256, import_properties4, import_logger6, logger6, LogDescription, TransactionDescription, ErrorDescription, Indexed, BuiltinErrors, Interface;
var init_interface = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/interface.js"() {
    "use strict";
    import_address3 = __toESM(require_lib14());
    import_bignumber5 = __toESM(require_lib3());
    import_bytes8 = __toESM(require_lib2());
    import_hash = __toESM(require_lib15());
    import_keccak256 = __toESM(require_lib10());
    import_properties4 = __toESM(require_lib4());
    init_abi_coder();
    init_abstract_coder();
    init_fragments();
    import_logger6 = __toESM(require_lib());
    init_version2();
    logger6 = new import_logger6.Logger(version2);
    LogDescription = class extends import_properties4.Description {
    };
    TransactionDescription = class extends import_properties4.Description {
    };
    ErrorDescription = class extends import_properties4.Description {
    };
    Indexed = class extends import_properties4.Description {
      static isIndexed(value) {
        return !!(value && value._isIndexed);
      }
    };
    BuiltinErrors = {
      "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
      "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
    };
    Interface = class {
      constructor(fragments) {
        let abi = [];
        if (typeof fragments === "string") {
          abi = JSON.parse(fragments);
        } else {
          abi = fragments;
        }
        (0, import_properties4.defineReadOnly)(this, "fragments", abi.map((fragment) => {
          return Fragment.from(fragment);
        }).filter((fragment) => fragment != null));
        (0, import_properties4.defineReadOnly)(this, "_abiCoder", (0, import_properties4.getStatic)(new.target, "getAbiCoder")());
        (0, import_properties4.defineReadOnly)(this, "functions", {});
        (0, import_properties4.defineReadOnly)(this, "errors", {});
        (0, import_properties4.defineReadOnly)(this, "events", {});
        (0, import_properties4.defineReadOnly)(this, "structs", {});
        this.fragments.forEach((fragment) => {
          let bucket = null;
          switch (fragment.type) {
            case "constructor":
              if (this.deploy) {
                logger6.warn("duplicate definition - constructor");
                return;
              }
              (0, import_properties4.defineReadOnly)(this, "deploy", fragment);
              return;
            case "function":
              bucket = this.functions;
              break;
            case "event":
              bucket = this.events;
              break;
            case "error":
              bucket = this.errors;
              break;
            default:
              return;
          }
          let signature = fragment.format();
          if (bucket[signature]) {
            logger6.warn("duplicate definition - " + signature);
            return;
          }
          bucket[signature] = fragment;
        });
        if (!this.deploy) {
          (0, import_properties4.defineReadOnly)(this, "deploy", ConstructorFragment.from({
            payable: false,
            type: "constructor"
          }));
        }
        (0, import_properties4.defineReadOnly)(this, "_isInterface", true);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
          logger6.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        if (format === FormatTypes.json) {
          return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
      }
      static getAbiCoder() {
        return defaultAbiCoder;
      }
      static getAddress(address) {
        return (0, import_address3.getAddress)(address);
      }
      static getSighash(fragment) {
        return (0, import_bytes8.hexDataSlice)((0, import_hash.id)(fragment.format()), 0, 4);
      }
      static getEventTopic(eventFragment) {
        return (0, import_hash.id)(eventFragment.format());
      }
      getFunction(nameOrSignatureOrSighash) {
        if ((0, import_bytes8.isHexString)(nameOrSignatureOrSighash)) {
          for (const name in this.functions) {
            if (nameOrSignatureOrSighash === this.getSighash(name)) {
              return this.functions[name];
            }
          }
          logger6.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.functions).filter((f) => f.split("(")[0] === name);
          if (matching.length === 0) {
            logger6.throwArgumentError("no matching function", "name", name);
          } else if (matching.length > 1) {
            logger6.throwArgumentError("multiple matching functions", "name", name);
          }
          return this.functions[matching[0]];
        }
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger6.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      getEvent(nameOrSignatureOrTopic) {
        if ((0, import_bytes8.isHexString)(nameOrSignatureOrTopic)) {
          const topichash = nameOrSignatureOrTopic.toLowerCase();
          for (const name in this.events) {
            if (topichash === this.getEventTopic(name)) {
              return this.events[name];
            }
          }
          logger6.throwArgumentError("no matching event", "topichash", topichash);
        }
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
          const name = nameOrSignatureOrTopic.trim();
          const matching = Object.keys(this.events).filter((f) => f.split("(")[0] === name);
          if (matching.length === 0) {
            logger6.throwArgumentError("no matching event", "name", name);
          } else if (matching.length > 1) {
            logger6.throwArgumentError("multiple matching events", "name", name);
          }
          return this.events[matching[0]];
        }
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
          logger6.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
      }
      getError(nameOrSignatureOrSighash) {
        if ((0, import_bytes8.isHexString)(nameOrSignatureOrSighash)) {
          const getSighash = (0, import_properties4.getStatic)(this.constructor, "getSighash");
          for (const name in this.errors) {
            const error = this.errors[name];
            if (nameOrSignatureOrSighash === getSighash(error)) {
              return this.errors[name];
            }
          }
          logger6.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.errors).filter((f) => f.split("(")[0] === name);
          if (matching.length === 0) {
            logger6.throwArgumentError("no matching error", "name", name);
          } else if (matching.length > 1) {
            logger6.throwArgumentError("multiple matching errors", "name", name);
          }
          return this.errors[matching[0]];
        }
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger6.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      getSighash(fragment) {
        if (typeof fragment === "string") {
          try {
            fragment = this.getFunction(fragment);
          } catch (error) {
            try {
              fragment = this.getError(fragment);
            } catch (_) {
              throw error;
            }
          }
        }
        return (0, import_properties4.getStatic)(this.constructor, "getSighash")(fragment);
      }
      getEventTopic(eventFragment) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        return (0, import_properties4.getStatic)(this.constructor, "getEventTopic")(eventFragment);
      }
      _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
      }
      _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
      }
      encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
      }
      decodeErrorResult(fragment, data) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        const bytes4 = (0, import_bytes8.arrayify)(data);
        if ((0, import_bytes8.hexlify)(bytes4.slice(0, 4)) !== this.getSighash(fragment)) {
          logger6.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", (0, import_bytes8.hexlify)(bytes4));
        }
        return this._decodeParams(fragment.inputs, bytes4.slice(4));
      }
      encodeErrorResult(fragment, values) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        return (0, import_bytes8.hexlify)((0, import_bytes8.concat)([
          this.getSighash(fragment),
          this._encodeParams(fragment.inputs, values || [])
        ]));
      }
      decodeFunctionData(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        const bytes4 = (0, import_bytes8.arrayify)(data);
        if ((0, import_bytes8.hexlify)(bytes4.slice(0, 4)) !== this.getSighash(functionFragment)) {
          logger6.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", (0, import_bytes8.hexlify)(bytes4));
        }
        return this._decodeParams(functionFragment.inputs, bytes4.slice(4));
      }
      encodeFunctionData(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return (0, import_bytes8.hexlify)((0, import_bytes8.concat)([
          this.getSighash(functionFragment),
          this._encodeParams(functionFragment.inputs, values || [])
        ]));
      }
      decodeFunctionResult(functionFragment, data) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        let bytes4 = (0, import_bytes8.arrayify)(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes4.length % this._abiCoder._getWordSize()) {
          case 0:
            try {
              return this._abiCoder.decode(functionFragment.outputs, bytes4);
            } catch (error) {
            }
            break;
          case 4: {
            const selector = (0, import_bytes8.hexlify)(bytes4.slice(0, 4));
            const builtin = BuiltinErrors[selector];
            if (builtin) {
              errorArgs = this._abiCoder.decode(builtin.inputs, bytes4.slice(4));
              errorName = builtin.name;
              errorSignature = builtin.signature;
              if (builtin.reason) {
                reason = errorArgs[0];
              }
              if (errorName === "Error") {
                message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
              } else if (errorName === "Panic") {
                message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
              }
            } else {
              try {
                const error = this.getError(selector);
                errorArgs = this._abiCoder.decode(error.inputs, bytes4.slice(4));
                errorName = error.name;
                errorSignature = error.format();
              } catch (error) {
              }
            }
            break;
          }
        }
        return logger6.throwError("call revert exception" + message, import_logger6.Logger.errors.CALL_EXCEPTION, {
          method: functionFragment.format(),
          data: (0, import_bytes8.hexlify)(data),
          errorArgs,
          errorName,
          errorSignature,
          reason
        });
      }
      encodeFunctionResult(functionFragment, values) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return (0, import_bytes8.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
      }
      encodeFilterTopics(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
          logger6.throwError("too many arguments for " + eventFragment.format(), import_logger6.Logger.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: values
          });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
          if (param.type === "string") {
            return (0, import_hash.id)(value);
          } else if (param.type === "bytes") {
            return (0, import_keccak256.keccak256)((0, import_bytes8.hexlify)(value));
          }
          if (param.type === "bool" && typeof value === "boolean") {
            value = value ? "0x01" : "0x00";
          }
          if (param.type.match(/^u?int/)) {
            value = import_bignumber5.BigNumber.from(value).toHexString();
          }
          if (param.type === "address") {
            this._abiCoder.encode(["address"], [value]);
          }
          return (0, import_bytes8.hexZeroPad)((0, import_bytes8.hexlify)(value), 32);
        };
        values.forEach((value, index2) => {
          let param = eventFragment.inputs[index2];
          if (!param.indexed) {
            if (value != null) {
              logger6.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
            }
            return;
          }
          if (value == null) {
            topics.push(null);
          } else if (param.baseType === "array" || param.baseType === "tuple") {
            logger6.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
          } else if (Array.isArray(value)) {
            topics.push(value.map((value2) => encodeTopic(param, value2)));
          } else {
            topics.push(encodeTopic(param, value));
          }
        });
        while (topics.length && topics[topics.length - 1] === null) {
          topics.pop();
        }
        return topics;
      }
      encodeEventLog(eventFragment, values) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
          logger6.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index2) => {
          const value = values[index2];
          if (param.indexed) {
            if (param.type === "string") {
              topics.push((0, import_hash.id)(value));
            } else if (param.type === "bytes") {
              topics.push((0, import_keccak256.keccak256)(value));
            } else if (param.baseType === "tuple" || param.baseType === "array") {
              throw new Error("not implemented");
            } else {
              topics.push(this._abiCoder.encode([param.type], [value]));
            }
          } else {
            dataTypes.push(param);
            dataValues.push(value);
          }
        });
        return {
          data: this._abiCoder.encode(dataTypes, dataValues),
          topics
        };
      }
      decodeEventLog(eventFragment, data, topics) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
          let topicHash = this.getEventTopic(eventFragment);
          if (!(0, import_bytes8.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
            logger6.throwError("fragment/topic mismatch", import_logger6.Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
          }
          topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index2) => {
          if (param.indexed) {
            if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
              indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
              dynamic.push(true);
            } else {
              indexed.push(param);
              dynamic.push(false);
            }
          } else {
            nonIndexed.push(param);
            dynamic.push(false);
          }
        });
        let resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0, import_bytes8.concat)(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index2) => {
          if (param.indexed) {
            if (resultIndexed == null) {
              result[index2] = new Indexed({ _isIndexed: true, hash: null });
            } else if (dynamic[index2]) {
              result[index2] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
            } else {
              try {
                result[index2] = resultIndexed[indexedIndex++];
              } catch (error) {
                result[index2] = error;
              }
            }
          } else {
            try {
              result[index2] = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
              result[index2] = error;
            }
          }
          if (param.name && result[param.name] == null) {
            const value = result[index2];
            if (value instanceof Error) {
              Object.defineProperty(result, param.name, {
                enumerable: true,
                get: () => {
                  throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
                }
              });
            } else {
              result[param.name] = value;
            }
          }
        });
        for (let i = 0; i < result.length; i++) {
          const value = result[i];
          if (value instanceof Error) {
            Object.defineProperty(result, i, {
              enumerable: true,
              get: () => {
                throw wrapAccessError(`index ${i}`, value);
              }
            });
          }
        }
        return Object.freeze(result);
      }
      parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new TransactionDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
          functionFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment),
          value: import_bignumber5.BigNumber.from(tx.value || "0")
        });
      }
      parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
          return null;
        }
        return new LogDescription({
          eventFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          topic: this.getEventTopic(fragment),
          args: this.decodeEventLog(fragment, log.data, log.topics)
        });
      }
      parseError(data) {
        const hexData = (0, import_bytes8.hexlify)(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new ErrorDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
          errorFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment)
        });
      }
      static isInterface(value) {
        return !!(value && value._isInterface);
      }
    };
  }
});

// ../node_modules/@ethersproject/abi/lib.esm/index.js
var init_lib2 = __esm({
  "../node_modules/@ethersproject/abi/lib.esm/index.js"() {
    "use strict";
    init_interface();
  }
});

// ../node_modules/alchemy-sdk/dist/esm/api/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  Interface: () => Interface,
  arrayify: () => import_bytes10.arrayify,
  concat: () => import_bytes10.concat,
  dnsEncode: () => import_hash2.dnsEncode,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  hashMessage: () => import_hash2.hashMessage,
  hexConcat: () => import_bytes10.hexConcat,
  hexDataLength: () => import_bytes10.hexDataLength,
  hexDataSlice: () => import_bytes10.hexDataSlice,
  hexStripZeros: () => import_bytes10.hexStripZeros,
  hexValue: () => import_bytes10.hexValue,
  hexZeroPad: () => import_bytes10.hexZeroPad,
  hexlify: () => import_bytes10.hexlify,
  id: () => import_hash2.id,
  isBytes: () => import_bytes10.isBytes,
  isBytesLike: () => import_bytes10.isBytesLike,
  isHexString: () => import_bytes10.isHexString,
  isValidName: () => import_hash2.isValidName,
  joinSignature: () => import_bytes10.joinSignature,
  namehash: () => import_hash2.namehash,
  parseEther: () => parseEther,
  parseUnits: () => parseUnits,
  splitSignature: () => import_bytes10.splitSignature,
  stripZeros: () => import_bytes10.stripZeros,
  toUtf8Bytes: () => toUtf8Bytes2,
  toUtf8String: () => toUtf8String2,
  zeroPad: () => import_bytes10.zeroPad
});
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
function errorFunc(reason, offset, bytes4, output3, badCodepoint) {
  return logger7.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes4);
}
function ignoreFunc(reason, offset, bytes4, output3, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes4.length; o++) {
      if (bytes4[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes4.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes4, output3, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output3.push(badCodepoint);
    return 0;
  }
  output3.push(65533);
  return ignoreFunc(reason, offset, bytes4);
}
function getUtf8CodePoints(bytes4, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes4 = (0, import_bytes9.arrayify)(bytes4);
  const result = [];
  let i = 0;
  while (i < bytes4.length) {
    const c = bytes4[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes4, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes4, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes4.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes4, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes4[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes4, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes4, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes4, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes4, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes2(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger7.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return (0, import_bytes9.arrayify)(result);
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String2(bytes4, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes4, onError));
}
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var import_hash2, import_bytes9, import_bytes10, version$1, _permanentCensorErrors, _censorErrors, LogLevels, _logLevel, _globalLogger, _normalizeError, LogLevel, ErrorCode, HEX, Logger7, version3, logger7, UnicodeNormalizationForm, Utf8ErrorReason, Utf8ErrorFuncs;
var init_utils3 = __esm({
  "../node_modules/alchemy-sdk/dist/esm/api/utils.js"() {
    import_hash2 = __toESM(require_lib15());
    import_bytes9 = __toESM(require_lib2());
    import_bytes10 = __toESM(require_lib2());
    init_lib();
    init_lib2();
    version$1 = "logger/5.7.0";
    _permanentCensorErrors = false;
    _censorErrors = false;
    LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    _logLevel = LogLevels["default"];
    _globalLogger = null;
    _normalizeError = _checkNormalize();
    (function(LogLevel3) {
      LogLevel3["DEBUG"] = "DEBUG";
      LogLevel3["INFO"] = "INFO";
      LogLevel3["WARNING"] = "WARNING";
      LogLevel3["ERROR"] = "ERROR";
      LogLevel3["OFF"] = "OFF";
    })(LogLevel || (LogLevel = {}));
    (function(ErrorCode3) {
      ErrorCode3["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode3["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode3["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode3["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode3["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode3["TIMEOUT"] = "TIMEOUT";
      ErrorCode3["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode3["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode3["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode3["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode3["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode3["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode3["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode3["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode3["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode3["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode3["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode3["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode3["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode || (ErrorCode = {}));
    HEX = "0123456789abcdef";
    Logger7 = class {
      constructor(version11) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version11,
          writable: false
        });
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log.apply(console, args);
      }
      debug(...args) {
        this._log(Logger7.levels.DEBUG, args);
      }
      info(...args) {
        this._log(Logger7.levels.INFO, args);
      }
      warn(...args) {
        this._log(Logger7.levels.WARNING, args);
      }
      makeError(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = Logger7.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
          const value = params[key];
          try {
            if (value instanceof Uint8Array) {
              let hex = "";
              for (let i = 0; i < value.length; i++) {
                hex += HEX[value[i] >> 4];
                hex += HEX[value[i] & 15];
              }
              messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
          }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
          case ErrorCode.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            const fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode.CALL_EXCEPTION:
          case ErrorCode.INSUFFICIENT_FUNDS:
          case ErrorCode.MISSING_NEW:
          case ErrorCode.NONCE_EXPIRED:
          case ErrorCode.REPLACEMENT_UNDERPRICED:
          case ErrorCode.TRANSACTION_REPLACED:
          case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key) {
          error[key] = params[key];
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name, value) {
        return this.throwError(message, Logger7.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      }
      assert(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      }
      checkNormalize(message) {
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", Logger7.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      }
      checkSafeUint53(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, Logger7.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, Logger7.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      }
      checkArgumentCount(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, Logger7.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, Logger7.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", Logger7.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger7.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", Logger7.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger) {
          _globalLogger = new Logger7(version$1);
        }
        return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", Logger7.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", Logger7.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          Logger7.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel = level;
      }
      static from(version11) {
        return new Logger7(version11);
      }
    };
    Logger7.errors = ErrorCode;
    Logger7.levels = LogLevel;
    version3 = "strings/5.7.0";
    logger7 = new Logger7(version3);
    (function(UnicodeNormalizationForm4) {
      UnicodeNormalizationForm4["current"] = "";
      UnicodeNormalizationForm4["NFC"] = "NFC";
      UnicodeNormalizationForm4["NFD"] = "NFD";
      UnicodeNormalizationForm4["NFKC"] = "NFKC";
      UnicodeNormalizationForm4["NFKD"] = "NFKD";
    })(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
    (function(Utf8ErrorReason2) {
      Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
      Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
      Utf8ErrorReason2["OVERRUN"] = "string overrun";
      Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
      Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
      Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
      Utf8ErrorReason2["OVERLONG"] = "overlong representation";
    })(Utf8ErrorReason || (Utf8ErrorReason = {}));
    Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
    });
    createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
    "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
    createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
    createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
    createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
    createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind2(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/utils.js
var require_utils11 = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind2 = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction2(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction2(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim2(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind2(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim: trim2,
      stripBOM
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize2(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id4) {
      if (this.handlers[id4]) {
        this.handlers[id4] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config2, code, request, response) {
      error.config = config2;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/defaults/transitional.js"(exports, module) {
    "use strict";
    module.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config2, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config2, code, request, response);
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var transitionalDefaults = require_transitional();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config2) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config2.data;
        var requestHeaders = config2.headers;
        var responseType = config2.responseType;
        var onCanceled;
        function done() {
          if (config2.cancelToken) {
            config2.cancelToken.unsubscribe(onCanceled);
          }
          if (config2.signal) {
            config2.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config2.auth) {
          var username = config2.auth.username || "";
          var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config2.baseURL, config2.url);
        request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
        request.timeout = config2.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config2,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config2, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config2, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config2.transitional || transitionalDefaults;
          if (config2.timeoutErrorMessage) {
            timeoutErrorMessage = config2.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config2,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config2.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config2.withCredentials)) {
          request.withCredentials = !!config2.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config2.responseType;
        }
        if (typeof config2.onDownloadProgress === "function") {
          request.addEventListener("progress", config2.onDownloadProgress);
        }
        if (typeof config2.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config2.onUploadProgress);
        }
        if (config2.cancelToken || config2.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
          if (config2.signal) {
            config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/defaults/index.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var transitionalDefaults = require_transitional();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder3) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder3 || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context2 = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context2, data, headers);
      });
      return data;
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = config2.headers || {};
      config2.data = transformData.call(
        config2,
        config2.data,
        config2.headers,
        config2.transformRequest
      );
      config2.headers = utils.merge(
        config2.headers.common || {},
        config2.headers[config2.method] || {},
        config2.headers
      );
      utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config2.headers[method];
        }
      );
      var adapter = config2.adapter || defaults.adapter;
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          response.data,
          response.headers,
          config2.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              reason.response.data,
              reason.response.headers,
              config2.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config3 = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/env/data.js
var require_data2 = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.26.1"
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION2 = require_data2().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version11, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version11 ? " in " + version11 : "")));
        }
        if (version11 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version11 + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      if (config2.method) {
        config2.method = config2.method.toLowerCase();
      } else if (this.defaults.method) {
        config2.method = this.defaults.method.toLowerCase();
      } else {
        config2.method = "get";
      }
      var transitional = config2.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config2);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config2;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      return buildURL(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url,
          data: (config2 || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token2 = this;
      this.promise.then(function(cancel) {
        if (!token2._listeners)
          return;
        var i;
        var l = token2._listeners.length;
        for (i = 0; i < l; i++) {
          token2._listeners[i](cancel);
        }
        token2._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token2.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token2.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token2.reason) {
          return;
        }
        token2.reason = new Cancel(message);
        resolvePromise(token2.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token2 = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token2,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    module.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils11();
    var bind2 = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context2 = new Axios(defaultConfig);
      var instance = bind2(Axios.prototype.request, context2);
      utils.extend(instance, Axios.prototype, context2);
      utils.extend(instance, context2);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data2().version;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module.exports = axios2;
    module.exports.default = axios2;
  }
});

// ../node_modules/alchemy-sdk/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "../node_modules/alchemy-sdk/node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// ../node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = (0, import_bytes11.arrayify)(password);
  salt = (0, import_bytes11.arrayify)(salt);
  let hLen;
  let l = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r;
  let T;
  for (let i = 1; i <= l; i++) {
    block1[salt.length] = i >> 24 & 255;
    block1[salt.length + 1] = i >> 16 & 255;
    block1[salt.length + 2] = i >> 8 & 255;
    block1[salt.length + 3] = i & 255;
    let U = (0, import_bytes11.arrayify)((0, import_sha22.computeHmac)(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U.length;
      T = new Uint8Array(hLen);
      l = Math.ceil(keylen / hLen);
      r = keylen - (l - 1) * hLen;
    }
    T.set(U);
    for (let j = 1; j < iterations; j++) {
      U = (0, import_bytes11.arrayify)((0, import_sha22.computeHmac)(hashAlgorithm, password, U));
      for (let k = 0; k < hLen; k++)
        T[k] ^= U[k];
    }
    const destPos = (i - 1) * hLen;
    const len = i === l ? r : hLen;
    DK.set((0, import_bytes11.arrayify)(T).slice(0, len), destPos);
  }
  return (0, import_bytes11.hexlify)(DK);
}
var import_bytes11, import_sha22;
var init_pbkdf2 = __esm({
  "../node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js"() {
    "use strict";
    import_bytes11 = __toESM(require_lib2());
    import_sha22 = __toESM(require_lib16());
  }
});

// ../node_modules/@ethersproject/pbkdf2/lib.esm/index.js
var init_lib3 = __esm({
  "../node_modules/@ethersproject/pbkdf2/lib.esm/index.js"() {
    init_pbkdf2();
  }
});

// ../node_modules/@ethersproject/wordlists/lib.esm/_version.js
var version4;
var init_version3 = __esm({
  "../node_modules/@ethersproject/wordlists/lib.esm/_version.js"() {
    version4 = "wordlists/5.7.0";
  }
});

// ../node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var import_hash3, import_properties5, import_logger7, exportWordlist, logger8, Wordlist;
var init_wordlist = __esm({
  "../node_modules/@ethersproject/wordlists/lib.esm/wordlist.js"() {
    "use strict";
    import_hash3 = __toESM(require_lib15());
    import_properties5 = __toESM(require_lib4());
    import_logger7 = __toESM(require_lib());
    init_version3();
    exportWordlist = false;
    logger8 = new import_logger7.Logger(version4);
    Wordlist = class {
      constructor(locale) {
        logger8.checkAbstract(new.target, Wordlist);
        (0, import_properties5.defineReadOnly)(this, "locale", locale);
      }
      split(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
      }
      join(words2) {
        return words2.join(" ");
      }
      static check(wordlist2) {
        const words2 = [];
        for (let i = 0; i < 2048; i++) {
          const word = wordlist2.getWord(i);
          if (i !== wordlist2.getWordIndex(word)) {
            return "0x";
          }
          words2.push(word);
        }
        return (0, import_hash3.id)(words2.join("\n") + "\n");
      }
      static register(lang, name) {
        if (!name) {
          name = lang.locale;
        }
        if (exportWordlist) {
          try {
            const anyGlobal = window;
            if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
              if (!anyGlobal._ethers.wordlists[name]) {
                (0, import_properties5.defineReadOnly)(anyGlobal._ethers.wordlists, name, lang);
              }
            }
          } catch (error) {
          }
        }
      }
    };
  }
});

// ../node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var words, wordlist, LangEn, langEn;
var init_lang_en = __esm({
  "../node_modules/@ethersproject/wordlists/lib.esm/lang-en.js"() {
    "use strict";
    init_wordlist();
    words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
    wordlist = null;
    LangEn = class extends Wordlist {
      constructor() {
        super("en");
      }
      getWord(index2) {
        loadWords(this);
        return wordlist[index2];
      }
      getWordIndex(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      }
    };
    langEn = new LangEn();
    Wordlist.register(langEn);
  }
});

// ../node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists;
var init_wordlists = __esm({
  "../node_modules/@ethersproject/wordlists/lib.esm/wordlists.js"() {
    "use strict";
    init_lang_en();
    wordlists = {
      en: langEn
    };
  }
});

// ../node_modules/@ethersproject/wordlists/lib.esm/index.js
var init_lib4 = __esm({
  "../node_modules/@ethersproject/wordlists/lib.esm/index.js"() {
    "use strict";
    init_wordlists();
  }
});

// ../node_modules/@ethersproject/hdnode/lib.esm/_version.js
var version5;
var init_version4 = __esm({
  "../node_modules/@ethersproject/hdnode/lib.esm/_version.js"() {
    version5 = "hdnode/5.7.0";
  }
});

// ../node_modules/@ethersproject/hdnode/lib.esm/index.js
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return (0, import_bytes12.hexZeroPad)((0, import_bytes12.hexlify)(value), 32);
}
function base58check(data) {
  return import_basex.Base58.encode((0, import_bytes12.concat)([data, (0, import_bytes12.hexDataSlice)((0, import_sha23.sha256)((0, import_sha23.sha256)(data)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger9.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = (0, import_strings2.toUtf8Bytes)("mnemonic" + password, import_strings2.UnicodeNormalizationForm.NFKD);
  return pbkdf2((0, import_strings2.toUtf8Bytes)(mnemonic, import_strings2.UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger9.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = (0, import_bytes12.arrayify)(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset = 0;
  for (let i = 0; i < words2.length; i++) {
    let index2 = wordlist2.getWordIndex(words2[i].normalize("NFKD"));
    if (index2 === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index2 & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = (0, import_bytes12.arrayify)((0, import_sha23.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return (0, import_bytes12.hexlify)(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = (0, import_bytes12.arrayify)(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = (0, import_bytes12.arrayify)((0, import_sha23.sha256)(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index2) => wordlist2.getWord(index2)));
}
var import_basex, import_bytes12, import_bignumber6, import_strings2, import_properties6, import_signing_key, import_sha23, import_transactions, import_logger8, logger9, N, MasterSecret, HardenedBit, _constructorGuard2, defaultPath, HDNode;
var init_lib5 = __esm({
  "../node_modules/@ethersproject/hdnode/lib.esm/index.js"() {
    "use strict";
    import_basex = __toESM(require_lib8());
    import_bytes12 = __toESM(require_lib2());
    import_bignumber6 = __toESM(require_lib3());
    import_strings2 = __toESM(require_lib11());
    init_lib3();
    import_properties6 = __toESM(require_lib4());
    import_signing_key = __toESM(require_lib18());
    import_sha23 = __toESM(require_lib16());
    import_transactions = __toESM(require_lib19());
    init_lib4();
    import_logger8 = __toESM(require_lib());
    init_version4();
    logger9 = new import_logger8.Logger(version5);
    N = import_bignumber6.BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    MasterSecret = (0, import_strings2.toUtf8Bytes)("Bitcoin seed");
    HardenedBit = 2147483648;
    _constructorGuard2 = {};
    defaultPath = "m/44'/60'/0'/0/0";
    HDNode = class {
      constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index2, depth, mnemonicOrPath) {
        if (constructorGuard !== _constructorGuard2) {
          throw new Error("HDNode constructor cannot be called directly");
        }
        if (privateKey) {
          const signingKey = new import_signing_key.SigningKey(privateKey);
          (0, import_properties6.defineReadOnly)(this, "privateKey", signingKey.privateKey);
          (0, import_properties6.defineReadOnly)(this, "publicKey", signingKey.compressedPublicKey);
        } else {
          (0, import_properties6.defineReadOnly)(this, "privateKey", null);
          (0, import_properties6.defineReadOnly)(this, "publicKey", (0, import_bytes12.hexlify)(publicKey));
        }
        (0, import_properties6.defineReadOnly)(this, "parentFingerprint", parentFingerprint);
        (0, import_properties6.defineReadOnly)(this, "fingerprint", (0, import_bytes12.hexDataSlice)((0, import_sha23.ripemd160)((0, import_sha23.sha256)(this.publicKey)), 0, 4));
        (0, import_properties6.defineReadOnly)(this, "address", (0, import_transactions.computeAddress)(this.publicKey));
        (0, import_properties6.defineReadOnly)(this, "chainCode", chainCode);
        (0, import_properties6.defineReadOnly)(this, "index", index2);
        (0, import_properties6.defineReadOnly)(this, "depth", depth);
        if (mnemonicOrPath == null) {
          (0, import_properties6.defineReadOnly)(this, "mnemonic", null);
          (0, import_properties6.defineReadOnly)(this, "path", null);
        } else if (typeof mnemonicOrPath === "string") {
          (0, import_properties6.defineReadOnly)(this, "mnemonic", null);
          (0, import_properties6.defineReadOnly)(this, "path", mnemonicOrPath);
        } else {
          (0, import_properties6.defineReadOnly)(this, "mnemonic", mnemonicOrPath);
          (0, import_properties6.defineReadOnly)(this, "path", mnemonicOrPath.path);
        }
      }
      get extendedKey() {
        if (this.depth >= 256) {
          throw new Error("Depth too large!");
        }
        return base58check((0, import_bytes12.concat)([
          this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
          (0, import_bytes12.hexlify)(this.depth),
          this.parentFingerprint,
          (0, import_bytes12.hexZeroPad)((0, import_bytes12.hexlify)(this.index), 4),
          this.chainCode,
          this.privateKey != null ? (0, import_bytes12.concat)(["0x00", this.privateKey]) : this.publicKey
        ]));
      }
      neuter() {
        return new HDNode(_constructorGuard2, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
      }
      _derive(index2) {
        if (index2 > 4294967295) {
          throw new Error("invalid index - " + String(index2));
        }
        let path = this.path;
        if (path) {
          path += "/" + (index2 & ~HardenedBit);
        }
        const data = new Uint8Array(37);
        if (index2 & HardenedBit) {
          if (!this.privateKey) {
            throw new Error("cannot derive child of neutered node");
          }
          data.set((0, import_bytes12.arrayify)(this.privateKey), 1);
          if (path) {
            path += "'";
          }
        } else {
          data.set((0, import_bytes12.arrayify)(this.publicKey));
        }
        for (let i = 24; i >= 0; i -= 8) {
          data[33 + (i >> 3)] = index2 >> 24 - i & 255;
        }
        const I = (0, import_bytes12.arrayify)((0, import_sha23.computeHmac)(import_sha23.SupportedAlgorithm.sha512, this.chainCode, data));
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        let ki = null;
        let Ki = null;
        if (this.privateKey) {
          ki = bytes32(import_bignumber6.BigNumber.from(IL).add(this.privateKey).mod(N));
        } else {
          const ek = new import_signing_key.SigningKey((0, import_bytes12.hexlify)(IL));
          Ki = ek._addPoint(this.publicKey);
        }
        let mnemonicOrPath = path;
        const srcMnemonic = this.mnemonic;
        if (srcMnemonic) {
          mnemonicOrPath = Object.freeze({
            phrase: srcMnemonic.phrase,
            path,
            locale: srcMnemonic.locale || "en"
          });
        }
        return new HDNode(_constructorGuard2, ki, Ki, this.fingerprint, bytes32(IR), index2, this.depth + 1, mnemonicOrPath);
      }
      derivePath(path) {
        const components = path.split("/");
        if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
          throw new Error("invalid path - " + path);
        }
        if (components[0] === "m") {
          components.shift();
        }
        let result = this;
        for (let i = 0; i < components.length; i++) {
          const component = components[i];
          if (component.match(/^[0-9]+'$/)) {
            const index2 = parseInt(component.substring(0, component.length - 1));
            if (index2 >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(HardenedBit + index2);
          } else if (component.match(/^[0-9]+$/)) {
            const index2 = parseInt(component);
            if (index2 >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(index2);
          } else {
            throw new Error("invalid path component - " + component);
          }
        }
        return result;
      }
      static _fromSeed(seed, mnemonic) {
        const seedArray = (0, import_bytes12.arrayify)(seed);
        if (seedArray.length < 16 || seedArray.length > 64) {
          throw new Error("invalid seed");
        }
        const I = (0, import_bytes12.arrayify)((0, import_sha23.computeHmac)(import_sha23.SupportedAlgorithm.sha512, MasterSecret, seedArray));
        return new HDNode(_constructorGuard2, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
      }
      static fromMnemonic(mnemonic, password, wordlist2) {
        wordlist2 = getWordlist(wordlist2);
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
          phrase: mnemonic,
          path: "m",
          locale: wordlist2.locale
        });
      }
      static fromSeed(seed) {
        return HDNode._fromSeed(seed, null);
      }
      static fromExtendedKey(extendedKey) {
        const bytes4 = import_basex.Base58.decode(extendedKey);
        if (bytes4.length !== 82 || base58check(bytes4.slice(0, 78)) !== extendedKey) {
          logger9.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }
        const depth = bytes4[4];
        const parentFingerprint = (0, import_bytes12.hexlify)(bytes4.slice(5, 9));
        const index2 = parseInt((0, import_bytes12.hexlify)(bytes4.slice(9, 13)).substring(2), 16);
        const chainCode = (0, import_bytes12.hexlify)(bytes4.slice(13, 45));
        const key = bytes4.slice(45, 78);
        switch ((0, import_bytes12.hexlify)(bytes4.slice(0, 4))) {
          case "0x0488b21e":
          case "0x043587cf":
            return new HDNode(_constructorGuard2, null, (0, import_bytes12.hexlify)(key), parentFingerprint, chainCode, index2, depth, null);
          case "0x0488ade4":
          case "0x04358394 ":
            if (key[0] !== 0) {
              break;
            }
            return new HDNode(_constructorGuard2, (0, import_bytes12.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index2, depth, null);
        }
        return logger9.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      }
    };
  }
});

// ../node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "../node_modules/aes-js/index.js"(exports, module) {
    "use strict";
    (function(root) {
      function checkInt(value) {
        return parseInt(value) === value;
      }
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i = 0; i < arrayish.length; i++) {
          if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function coerceArray(arg, copy) {
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
          if (copy) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      function createArray(length) {
        return new Uint8Array(length);
      }
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      var convertUtf8 = function() {
        function toBytes4(text) {
          var result = [], i = 0;
          text = encodeURI(text);
          while (i < text.length) {
            var c = text.charCodeAt(i++);
            if (c === 37) {
              result.push(parseInt(text.substr(i, 2), 16));
              i += 2;
            } else {
              result.push(c);
            }
          }
          return coerceArray(result);
        }
        function fromBytes(bytes4) {
          var result = [], i = 0;
          while (i < bytes4.length) {
            var c = bytes4[i];
            if (c < 128) {
              result.push(String.fromCharCode(c));
              i++;
            } else if (c > 191 && c < 224) {
              result.push(String.fromCharCode((c & 31) << 6 | bytes4[i + 1] & 63));
              i += 2;
            } else {
              result.push(String.fromCharCode((c & 15) << 12 | (bytes4[i + 1] & 63) << 6 | bytes4[i + 2] & 63));
              i += 3;
            }
          }
          return result.join("");
        }
        return {
          toBytes: toBytes4,
          fromBytes
        };
      }();
      var convertHex = function() {
        function toBytes4(text) {
          var result = [];
          for (var i = 0; i < text.length; i += 2) {
            result.push(parseInt(text.substr(i, 2), 16));
          }
          return result;
        }
        var Hex7 = "0123456789abcdef";
        function fromBytes(bytes4) {
          var result = [];
          for (var i = 0; i < bytes4.length; i++) {
            var v = bytes4[i];
            result.push(Hex7[(v & 240) >> 4] + Hex7[v & 15]);
          }
          return result.join("");
        }
        return {
          toBytes: toBytes4,
          fromBytes
        };
      }();
      var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt32(bytes4) {
        var result = [];
        for (var i = 0; i < bytes4.length; i += 4) {
          result.push(
            bytes4[i] << 24 | bytes4[i + 1] << 16 | bytes4[i + 2] << 8 | bytes4[i + 3]
          );
        }
        return result;
      }
      var AES = function(key) {
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key, true)
        });
        this._prepare();
      };
      AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i = 0; i <= rounds; i++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt32(this.key);
        var index2;
        for (var i = 0; i < KC; i++) {
          index2 = i >> 2;
          this._Ke[index2][i % 4] = tk[i];
          this._Kd[rounds - index2][i % 4] = tk[i];
        }
        var rconpointer = 0;
        var t = KC, tt;
        while (t < roundKeyCount) {
          tt = tk[KC - 1];
          tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i = 1; i < KC; i++) {
              tk[i] ^= tk[i - 1];
            }
          } else {
            for (var i = 1; i < KC / 2; i++) {
              tk[i] ^= tk[i - 1];
            }
            tt = tk[KC / 2 - 1];
            tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
            for (var i = KC / 2 + 1; i < KC; i++) {
              tk[i] ^= tk[i - 1];
            }
          }
          var i = 0, r, c;
          while (i < KC && t < roundKeyCount) {
            r = t >> 2;
            c = t % 4;
            this._Ke[r][c] = tk[i];
            this._Kd[rounds - r][c] = tk[i++];
            t++;
          }
        }
        for (var r = 1; r < rounds; r++) {
          for (var c = 0; c < 4; c++) {
            tt = this._Kd[r][c];
            this._Kd[r][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
          }
        }
      };
      AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a = [0, 0, 0, 0];
        var t = convertToInt32(plaintext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= this._Ke[0][i];
        }
        for (var r = 1; r < rounds; r++) {
          for (var i = 0; i < 4; i++) {
            a[i] = T1[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ this._Ke[r][i];
          }
          t = a.slice();
        }
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
          tt = this._Ke[rounds][i];
          result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a = [0, 0, 0, 0];
        var t = convertToInt32(ciphertext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= this._Kd[0][i];
        }
        for (var r = 1; r < rounds; r++) {
          for (var i = 0; i < 4; i++) {
            a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ this._Kd[r][i];
          }
          t = a.slice();
        }
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
          tt = this._Kd[rounds][i];
          result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key);
      };
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i = 0; i < plaintext.length; i += 16) {
          copyArray(plaintext, block, 0, i, i + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i = 0; i < ciphertext.length; i += 16) {
          copyArray(ciphertext, block, 0, i, i + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES(key);
      };
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i = 0; i < plaintext.length; i += 16) {
          copyArray(plaintext, block, 0, i, i + 16);
          for (var j = 0; j < 16; j++) {
            block[j] ^= this._lastCipherblock[j];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i = 0; i < ciphertext.length; i += 16) {
          copyArray(ciphertext, block, 0, i, i + 16);
          block = this._aes.decrypt(block);
          for (var j = 0; j < 16; j++) {
            plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES(key);
      };
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            encrypted[i + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            plaintext[i + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key);
      };
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i = 0; i < encrypted.length; i++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      };
      Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) {
          throw new Error("invalid counter value (must be an integer)");
        }
        for (var index2 = 15; index2 >= 0; --index2) {
          this._counter[index2] = value % 256;
          value = value >> 8;
        }
      };
      Counter.prototype.setBytes = function(bytes4) {
        bytes4 = coerceArray(bytes4, true);
        if (bytes4.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes4;
      };
      Counter.prototype.increment = function() {
        for (var i = 15; i >= 0; i--) {
          if (this._counter[i] === 255) {
            this._counter[i] = 0;
          } else {
            this._counter[i]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
          counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key);
      };
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i = 0; i < encrypted.length; i++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - data.length % 16;
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i = data.length; i < result.length; i++) {
          result[i] = padder;
        }
        return result;
      }
      function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data[data.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length = data.length - padder;
        for (var i = 0; i < padder; i++) {
          if (data[length + i] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
      }
      var aesjs = {
        AES,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define(aesjs);
      } else {
        if (root.aesjs) {
          aesjs._aesjs = root.aesjs;
        }
        root.aesjs = aesjs;
      }
    })(exports);
  }
});

// ../node_modules/@ethersproject/json-wallets/lib.esm/_version.js
var version6;
var init_version5 = __esm({
  "../node_modules/@ethersproject/json-wallets/lib.esm/_version.js"() {
    version6 = "json-wallets/5.7.0";
  }
});

// ../node_modules/@ethersproject/json-wallets/lib.esm/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return (0, import_bytes13.arrayify)(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return (0, import_strings3.toUtf8Bytes)(password, import_strings3.UnicodeNormalizationForm.NFKC);
  }
  return (0, import_bytes13.arrayify)(password);
}
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split("/");
  for (let i = 0; i < comps.length; i++) {
    let matchingChild = null;
    for (const key in currentChild) {
      if (key.toLowerCase() === comps[i]) {
        matchingChild = currentChild[key];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes4) {
  const bytes4 = (0, import_bytes13.arrayify)(randomBytes4);
  bytes4[6] = bytes4[6] & 15 | 64;
  bytes4[8] = bytes4[8] & 63 | 128;
  const value = (0, import_bytes13.hexlify)(bytes4);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
var import_bytes13, import_strings3;
var init_utils4 = __esm({
  "../node_modules/@ethersproject/json-wallets/lib.esm/utils.js"() {
    "use strict";
    import_bytes13 = __toESM(require_lib2());
    import_strings3 = __toESM(require_lib11());
  }
});

// ../node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
function decrypt(json, password) {
  const data = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = (0, import_address4.getAddress)(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger10.throwArgumentError("invalid encseed", "json", json);
  }
  const key = (0, import_bytes14.arrayify)(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key, iv);
  const seed = import_aes_js.default.padding.pkcs7.strip((0, import_bytes14.arrayify)(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  const seedHexBytes = (0, import_strings4.toUtf8Bytes)(seedHex);
  const privateKey = (0, import_keccak2562.keccak256)(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
var import_aes_js, import_address4, import_bytes14, import_keccak2562, import_strings4, import_properties7, import_logger9, logger10, CrowdsaleAccount;
var init_crowdsale = __esm({
  "../node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js"() {
    "use strict";
    import_aes_js = __toESM(require_aes_js());
    import_address4 = __toESM(require_lib14());
    import_bytes14 = __toESM(require_lib2());
    import_keccak2562 = __toESM(require_lib10());
    init_lib3();
    import_strings4 = __toESM(require_lib11());
    import_properties7 = __toESM(require_lib4());
    import_logger9 = __toESM(require_lib());
    init_version5();
    init_utils4();
    logger10 = new import_logger9.Logger(version6);
    CrowdsaleAccount = class extends import_properties7.Description {
      isCrowdsaleAccount(value) {
        return !!(value && value._isCrowdsaleAccount);
      }
    };
  }
});

// ../node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
function isCrowdsaleWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;
  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
var init_inspect = __esm({
  "../node_modules/@ethersproject/json-wallets/lib.esm/inspect.js"() {
    "use strict";
  }
});

// ../node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS({
  "../node_modules/scrypt-js/scrypt.js"(exports, module) {
    "use strict";
    (function(root) {
      const MAX_VALUE = 2147483647;
      function SHA2562(m) {
        const K = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
        let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
        const w = new Uint32Array(64);
        function blocks(p2) {
          let off = 0, len = p2.length;
          while (len >= 64) {
            let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i2, j, t1, t2;
            for (i2 = 0; i2 < 16; i2++) {
              j = off + i2 * 4;
              w[i2] = (p2[j] & 255) << 24 | (p2[j + 1] & 255) << 16 | (p2[j + 2] & 255) << 8 | p2[j + 3] & 255;
            }
            for (i2 = 16; i2 < 64; i2++) {
              u = w[i2 - 2];
              t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
              u = w[i2 - 15];
              t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
              w[i2] = (t1 + w[i2 - 7] | 0) + (t2 + w[i2 - 16] | 0) | 0;
            }
            for (i2 = 0; i2 < 64; i2++) {
              t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i2] + w[i2] | 0) | 0) | 0;
              t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            h0 = h0 + a | 0;
            h1 = h1 + b | 0;
            h2 = h2 + c | 0;
            h3 = h3 + d | 0;
            h4 = h4 + e | 0;
            h5 = h5 + f | 0;
            h6 = h6 + g | 0;
            h7 = h7 + h | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m);
        let i, bytesLeft = m.length % 64, bitLenHi = m.length / 536870912 | 0, bitLenLo = m.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p = m.slice(m.length - bytesLeft, m.length);
        p.push(128);
        for (i = bytesLeft + 1; i < numZeros; i++) {
          p.push(0);
        }
        p.push(bitLenHi >>> 24 & 255);
        p.push(bitLenHi >>> 16 & 255);
        p.push(bitLenHi >>> 8 & 255);
        p.push(bitLenHi >>> 0 & 255);
        p.push(bitLenLo >>> 24 & 255);
        p.push(bitLenLo >>> 16 & 255);
        p.push(bitLenLo >>> 8 & 255);
        p.push(bitLenLo >>> 0 & 255);
        blocks(p);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 >>> 0 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 >>> 0 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 >>> 0 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        password = password.length <= 64 ? password : SHA2562(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i;
        let dk = [];
        for (i = 0; i < 64; i++) {
          inner[i] = 54;
        }
        for (i = 0; i < password.length; i++) {
          inner[i] ^= password[i];
        }
        for (i = 0; i < salt.length; i++) {
          inner[64 + i] = salt[i];
        }
        for (i = innerLen - 4; i < innerLen; i++) {
          inner[i] = 0;
        }
        for (i = 0; i < 64; i++)
          outerKey[i] = 92;
        for (i = 0; i < password.length; i++)
          outerKey[i] ^= password[i];
        function incrementCounter() {
          for (let i2 = innerLen - 1; i2 >= innerLen - 4; i2--) {
            inner[i2]++;
            if (inner[i2] <= 255)
              return;
            inner[i2] = 0;
          }
        }
        while (dkLen >= 32) {
          incrementCounter();
          dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))));
          dkLen -= 32;
        }
        if (dkLen > 0) {
          incrementCounter();
          dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))).slice(0, dkLen));
        }
        return dk;
      }
      function blockmix_salsa8(BY, Yi, r, x, _X) {
        let i;
        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
        for (i = 0; i < 2 * r; i++) {
          blockxor(BY, i * 16, _X, 16);
          salsa20_8(_X, x);
          arraycopy(_X, 0, BY, Yi + i * 16, 16);
        }
        for (i = 0; i < r; i++) {
          arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
        }
        for (i = 0; i < r; i++) {
          arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
        }
      }
      function R(a, b) {
        return a << b | a >>> 32 - b;
      }
      function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);
        for (let i = 8; i > 0; i -= 2) {
          x[4] ^= R(x[0] + x[12], 7);
          x[8] ^= R(x[4] + x[0], 9);
          x[12] ^= R(x[8] + x[4], 13);
          x[0] ^= R(x[12] + x[8], 18);
          x[9] ^= R(x[5] + x[1], 7);
          x[13] ^= R(x[9] + x[5], 9);
          x[1] ^= R(x[13] + x[9], 13);
          x[5] ^= R(x[1] + x[13], 18);
          x[14] ^= R(x[10] + x[6], 7);
          x[2] ^= R(x[14] + x[10], 9);
          x[6] ^= R(x[2] + x[14], 13);
          x[10] ^= R(x[6] + x[2], 18);
          x[3] ^= R(x[15] + x[11], 7);
          x[7] ^= R(x[3] + x[15], 9);
          x[11] ^= R(x[7] + x[3], 13);
          x[15] ^= R(x[11] + x[7], 18);
          x[1] ^= R(x[0] + x[3], 7);
          x[2] ^= R(x[1] + x[0], 9);
          x[3] ^= R(x[2] + x[1], 13);
          x[0] ^= R(x[3] + x[2], 18);
          x[6] ^= R(x[5] + x[4], 7);
          x[7] ^= R(x[6] + x[5], 9);
          x[4] ^= R(x[7] + x[6], 13);
          x[5] ^= R(x[4] + x[7], 18);
          x[11] ^= R(x[10] + x[9], 7);
          x[8] ^= R(x[11] + x[10], 9);
          x[9] ^= R(x[8] + x[11], 13);
          x[10] ^= R(x[9] + x[8], 18);
          x[12] ^= R(x[15] + x[14], 7);
          x[13] ^= R(x[12] + x[15], 9);
          x[14] ^= R(x[13] + x[12], 13);
          x[15] ^= R(x[14] + x[13], 18);
        }
        for (let i = 0; i < 16; ++i) {
          B[i] += x[i];
        }
      }
      function blockxor(S, Si, D, len) {
        for (let i = 0; i < len; i++) {
          D[i] ^= S[Si + i];
        }
      }
      function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
          dest[destPos++] = src[srcPos++];
        }
      }
      function checkBufferish(o) {
        if (!o || typeof o.length !== "number") {
          return false;
        }
        for (let i = 0; i < o.length; i++) {
          const v = o[i];
          if (typeof v !== "number" || v % 1 || v < 0 || v >= 256) {
            return false;
          }
        }
        return true;
      }
      function ensureInteger(value, name) {
        if (typeof value !== "number" || value % 1) {
          throw new Error("invalid " + name);
        }
        return value;
      }
      function _scrypt(password, salt, N2, r, p, dkLen, callback) {
        N2 = ensureInteger(N2, "N");
        r = ensureInteger(r, "r");
        p = ensureInteger(p, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N2 === 0 || (N2 & N2 - 1) !== 0) {
          throw new Error("N must be power of 2");
        }
        if (N2 > MAX_VALUE / 128 / r) {
          throw new Error("N too large");
        }
        if (r > MAX_VALUE / 128 / p) {
          throw new Error("r too large");
        }
        if (!checkBufferish(password)) {
          throw new Error("password must be an array or buffer");
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
          throw new Error("salt must be an array or buffer");
        }
        salt = Array.prototype.slice.call(salt);
        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
        const B = new Uint32Array(p * 32 * r);
        for (let i = 0; i < B.length; i++) {
          const j = i * 4;
          B[i] = (b[j + 3] & 255) << 24 | (b[j + 2] & 255) << 16 | (b[j + 1] & 255) << 8 | (b[j + 0] & 255) << 0;
        }
        const XY = new Uint32Array(64 * r);
        const V = new Uint32Array(32 * r * N2);
        const Yi = 32 * r;
        const x = new Uint32Array(16);
        const _X = new Uint32Array(16);
        const totalOps = p * N2 * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        let stop = false;
        let state = 0;
        let i0 = 0, i1;
        let Bi;
        const limit = callback ? parseInt(1e3 / r) : 4294967295;
        const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        const incrementalSMix = function() {
          if (stop) {
            return callback(new Error("cancelled"), currentOp / totalOps);
          }
          let steps;
          switch (state) {
            case 0:
              Bi = i0 * 32 * r;
              arraycopy(B, Bi, XY, 0, Yi);
              state = 1;
              i1 = 0;
            case 1:
              steps = N2 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i = 0; i < steps; i++) {
                arraycopy(XY, 0, V, (i1 + i) * Yi, Yi);
                blockmix_salsa8(XY, Yi, r, x, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N2) {
                break;
              }
              i1 = 0;
              state = 2;
            case 2:
              steps = N2 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i = 0; i < steps; i++) {
                const offset = (2 * r - 1) * 16;
                const j = XY[offset] & N2 - 1;
                blockxor(V, j * Yi, XY, Yi);
                blockmix_salsa8(XY, Yi, r, x, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N2) {
                break;
              }
              arraycopy(XY, 0, B, Bi, Yi);
              i0++;
              if (i0 < p) {
                state = 0;
                break;
              }
              b = [];
              for (let i = 0; i < B.length; i++) {
                b.push(B[i] >> 0 & 255);
                b.push(B[i] >> 8 & 255);
                b.push(B[i] >> 16 & 255);
                b.push(B[i] >> 24 & 255);
              }
              const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);
              if (callback) {
                callback(null, 1, derivedKey);
              }
              return derivedKey;
          }
          if (callback) {
            nextTick(incrementalSMix);
          }
        };
        if (!callback) {
          while (true) {
            const derivedKey = incrementalSMix();
            if (derivedKey != void 0) {
              return derivedKey;
            }
          }
        }
        incrementalSMix();
      }
      const lib = {
        scrypt: function(password, salt, N2, r, p, dkLen, progressCallback) {
          return new Promise(function(resolve, reject) {
            let lastProgress = 0;
            if (progressCallback) {
              progressCallback(0);
            }
            _scrypt(password, salt, N2, r, p, dkLen, function(error, progress, key) {
              if (error) {
                reject(error);
              } else if (key) {
                if (progressCallback && lastProgress !== 1) {
                  progressCallback(1);
                }
                resolve(new Uint8Array(key));
              } else if (progressCallback && progress !== lastProgress) {
                lastProgress = progress;
                return progressCallback(progress);
              }
            });
          });
        },
        syncScrypt: function(password, salt, N2, r, p, dkLen) {
          return new Uint8Array(_scrypt(password, salt, N2, r, p, dkLen));
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = lib;
      } else if (typeof define === "function" && define.amd) {
        define(lib);
      } else if (root) {
        if (root.scrypt) {
          root._scrypt = root.scrypt;
        }
        root.scrypt = lib;
      }
    })(exports);
  }
});

// ../node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
function hasMnemonic(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
function _decrypt(data, key, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key, counter);
    return (0, import_bytes15.arrayify)(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = (0, import_bytes15.hexlify)((0, import_keccak2563.keccak256)((0, import_bytes15.concat)([key.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger11.throwError("unsupported cipher", import_logger10.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key.slice(32, 64);
  const address = (0, import_transactions2.computeAddress)(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if ((0, import_address5.getAddress)(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: (0, import_bytes15.hexlify)(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
    const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = (0, import_bytes15.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node.mnemonic;
    } catch (error) {
      if (error.code !== import_logger10.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
  return (0, import_bytes15.arrayify)(pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf22(passwordBytes, salt, count, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError = function(name, value) {
      return logger11.throwArgumentError("invalid key-derivation function parameters", name, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N2 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N2 || !r || !p) {
        throwError("kdf", kdf);
      }
      if ((N2 & N2 - 1) !== 0) {
        throwError("N", N2);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N2, r, p, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError("prf", prf);
      }
      const count = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
    }
  }
  return logger11.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data = JSON.parse(json);
  const key = _computeKdfKey(data, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
  return _getAccount(data, key);
}
function decrypt2(json, password, progressCallback) {
  return __awaiter(this, void 0, void 0, function* () {
    const data = JSON.parse(json);
    const key = yield _computeKdfKey(data, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
    return _getAccount(data, key);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    if ((0, import_address5.getAddress)(account.address) !== (0, import_transactions2.computeAddress)(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic(account)) {
      const mnemonic = account.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e) {
    return Promise.reject(e);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = (0, import_bytes15.arrayify)(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = (0, import_bytes15.arrayify)(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = (0, import_bytes15.arrayify)(options.salt);
  } else {
    salt = (0, import_random.randomBytes)(32);
    ;
  }
  let iv = null;
  if (options.iv) {
    iv = (0, import_bytes15.arrayify)(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = (0, import_random.randomBytes)(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = (0, import_bytes15.arrayify)(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = (0, import_random.randomBytes)(16);
  }
  let N2 = 1 << 17, r = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  return import_scrypt_js.default.scrypt(passwordBytes, salt, N2, r, p, 64, progressCallback).then((key) => {
    key = (0, import_bytes15.arrayify)(key);
    const derivedKey = key.slice(0, 16);
    const macPrefix = key.slice(16, 32);
    const mnemonicKey = key.slice(32, 64);
    const counter = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = (0, import_bytes15.arrayify)(aesCtr.encrypt(privateKey));
    const mac = (0, import_keccak2563.keccak256)((0, import_bytes15.concat)([macPrefix, ciphertext]));
    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: (0, import_bytes15.hexlify)(iv).substring(2)
        },
        ciphertext: (0, import_bytes15.hexlify)(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: (0, import_bytes15.hexlify)(salt).substring(2),
          n: N2,
          dklen: 32,
          p,
          r
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = (0, import_random.randomBytes)(16);
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = (0, import_bytes15.arrayify)(mnemonicAesCtr.encrypt(entropy));
      const now = new Date();
      const timestamp = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp + "--" + data.address,
        mnemonicCounter: (0, import_bytes15.hexlify)(mnemonicIv).substring(2),
        mnemonicCiphertext: (0, import_bytes15.hexlify)(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}
var import_aes_js2, import_scrypt_js, import_address5, import_bytes15, import_keccak2563, import_random, import_properties8, import_transactions2, import_logger10, __awaiter, logger11, KeystoreAccount;
var init_keystore = __esm({
  "../node_modules/@ethersproject/json-wallets/lib.esm/keystore.js"() {
    "use strict";
    import_aes_js2 = __toESM(require_aes_js());
    import_scrypt_js = __toESM(require_scrypt());
    import_address5 = __toESM(require_lib14());
    import_bytes15 = __toESM(require_lib2());
    init_lib5();
    import_keccak2563 = __toESM(require_lib10());
    init_lib3();
    import_random = __toESM(require_lib21());
    import_properties8 = __toESM(require_lib4());
    import_transactions2 = __toESM(require_lib19());
    init_utils4();
    import_logger10 = __toESM(require_lib());
    init_version5();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger11 = new import_logger10.Logger(version6);
    KeystoreAccount = class extends import_properties8.Description {
      isKeystoreAccount(value) {
        return !!(value && value._isKeystoreAccount);
      }
    };
  }
});

// ../node_modules/@ethersproject/json-wallets/lib.esm/index.js
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt2(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}
var init_lib6 = __esm({
  "../node_modules/@ethersproject/json-wallets/lib.esm/index.js"() {
    "use strict";
    init_crowdsale();
    init_inspect();
    init_keystore();
  }
});

// ../node_modules/@ethersproject/wallet/lib.esm/_version.js
var version7;
var init_version6 = __esm({
  "../node_modules/@ethersproject/wallet/lib.esm/_version.js"() {
    version7 = "wallet/5.7.0";
  }
});

// ../node_modules/@ethersproject/wallet/lib.esm/index.js
function isAccount(value) {
  return value != null && (0, import_bytes16.isHexString)(value.privateKey, 32) && value.address != null;
}
function hasMnemonic2(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
var import_address6, import_abstract_provider, import_abstract_signer, import_bytes16, import_hash4, import_keccak2564, import_properties9, import_random2, import_signing_key2, import_transactions3, import_logger11, __awaiter2, logger12, Wallet;
var init_lib7 = __esm({
  "../node_modules/@ethersproject/wallet/lib.esm/index.js"() {
    "use strict";
    import_address6 = __toESM(require_lib14());
    import_abstract_provider = __toESM(require_lib5());
    import_abstract_signer = __toESM(require_lib20());
    import_bytes16 = __toESM(require_lib2());
    import_hash4 = __toESM(require_lib15());
    init_lib5();
    import_keccak2564 = __toESM(require_lib10());
    import_properties9 = __toESM(require_lib4());
    import_random2 = __toESM(require_lib21());
    import_signing_key2 = __toESM(require_lib18());
    init_lib6();
    import_transactions3 = __toESM(require_lib19());
    import_logger11 = __toESM(require_lib());
    init_version6();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger12 = new import_logger11.Logger(version7);
    Wallet = class extends import_abstract_signer.Signer {
      constructor(privateKey, provider) {
        super();
        if (isAccount(privateKey)) {
          const signingKey = new import_signing_key2.SigningKey(privateKey.privateKey);
          (0, import_properties9.defineReadOnly)(this, "_signingKey", () => signingKey);
          (0, import_properties9.defineReadOnly)(this, "address", (0, import_transactions3.computeAddress)(this.publicKey));
          if (this.address !== (0, import_address6.getAddress)(privateKey.address)) {
            logger12.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
          }
          if (hasMnemonic2(privateKey)) {
            const srcMnemonic = privateKey.mnemonic;
            (0, import_properties9.defineReadOnly)(this, "_mnemonic", () => ({
              phrase: srcMnemonic.phrase,
              path: srcMnemonic.path || defaultPath,
              locale: srcMnemonic.locale || "en"
            }));
            const mnemonic = this.mnemonic;
            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
            if ((0, import_transactions3.computeAddress)(node.privateKey) !== this.address) {
              logger12.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            }
          } else {
            (0, import_properties9.defineReadOnly)(this, "_mnemonic", () => null);
          }
        } else {
          if (import_signing_key2.SigningKey.isSigningKey(privateKey)) {
            if (privateKey.curve !== "secp256k1") {
              logger12.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
            }
            (0, import_properties9.defineReadOnly)(this, "_signingKey", () => privateKey);
          } else {
            if (typeof privateKey === "string") {
              if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                privateKey = "0x" + privateKey;
              }
            }
            const signingKey = new import_signing_key2.SigningKey(privateKey);
            (0, import_properties9.defineReadOnly)(this, "_signingKey", () => signingKey);
          }
          (0, import_properties9.defineReadOnly)(this, "_mnemonic", () => null);
          (0, import_properties9.defineReadOnly)(this, "address", (0, import_transactions3.computeAddress)(this.publicKey));
        }
        if (provider && !import_abstract_provider.Provider.isProvider(provider)) {
          logger12.throwArgumentError("invalid provider", "provider", provider);
        }
        (0, import_properties9.defineReadOnly)(this, "provider", provider || null);
      }
      get mnemonic() {
        return this._mnemonic();
      }
      get privateKey() {
        return this._signingKey().privateKey;
      }
      get publicKey() {
        return this._signingKey().publicKey;
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      connect(provider) {
        return new Wallet(this, provider);
      }
      signTransaction(transaction) {
        return (0, import_properties9.resolveProperties)(transaction).then((tx) => {
          if (tx.from != null) {
            if ((0, import_address6.getAddress)(tx.from) !== this.address) {
              logger12.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
            }
            delete tx.from;
          }
          const signature = this._signingKey().signDigest((0, import_keccak2564.keccak256)((0, import_transactions3.serialize)(tx)));
          return (0, import_transactions3.serialize)(tx, signature);
        });
      }
      signMessage(message) {
        return __awaiter2(this, void 0, void 0, function* () {
          return (0, import_bytes16.joinSignature)(this._signingKey().signDigest((0, import_hash4.hashMessage)(message)));
        });
      }
      _signTypedData(domain, types, value) {
        return __awaiter2(this, void 0, void 0, function* () {
          const populated = yield import_hash4._TypedDataEncoder.resolveNames(domain, types, value, (name) => {
            if (this.provider == null) {
              logger12.throwError("cannot resolve ENS names without a provider", import_logger11.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName",
                value: name
              });
            }
            return this.provider.resolveName(name);
          });
          return (0, import_bytes16.joinSignature)(this._signingKey().signDigest(import_hash4._TypedDataEncoder.hash(populated.domain, types, populated.value)));
        });
      }
      encrypt(password, options, progressCallback) {
        if (typeof options === "function" && !progressCallback) {
          progressCallback = options;
          options = {};
        }
        if (progressCallback && typeof progressCallback !== "function") {
          throw new Error("invalid callback");
        }
        if (!options) {
          options = {};
        }
        return encrypt(this, password, options, progressCallback);
      }
      static createRandom(options) {
        let entropy = (0, import_random2.randomBytes)(16);
        if (!options) {
          options = {};
        }
        if (options.extraEntropy) {
          entropy = (0, import_bytes16.arrayify)((0, import_bytes16.hexDataSlice)((0, import_keccak2564.keccak256)((0, import_bytes16.concat)([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = entropyToMnemonic(entropy, options.locale);
        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
      }
      static fromEncryptedJson(json, password, progressCallback) {
        return decryptJsonWallet(json, password, progressCallback).then((account) => {
          return new Wallet(account);
        });
      }
      static fromEncryptedJsonSync(json, password) {
        return new Wallet(decryptJsonWalletSync(json, password));
      }
      static fromMnemonic(mnemonic, path, wordlist2) {
        if (!path) {
          path = defaultPath;
        }
        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
      }
    };
  }
});

// ../node_modules/@ethersproject/contracts/lib.esm/_version.js
var version8;
var init_version7 = __esm({
  "../node_modules/@ethersproject/contracts/lib.esm/_version.js"() {
    version8 = "contracts/5.7.0";
  }
});

// ../node_modules/@ethersproject/contracts/lib.esm/index.js
function resolveName(resolver, nameOrPromise) {
  return __awaiter3(this, void 0, void 0, function* () {
    const name = yield nameOrPromise;
    if (typeof name !== "string") {
      logger13.throwArgumentError("invalid address or ENS name", "name", name);
    }
    try {
      return (0, import_address7.getAddress)(name);
    } catch (error) {
    }
    if (!resolver) {
      logger13.throwError("a provider or signer is needed to resolve ENS names", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name);
    if (address == null) {
      logger13.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter3(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index2) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index2] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger13.makeError("invalid value for array", import_logger12.Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter3(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = (0, import_properties10.shallowCopy)(args.pop());
    }
    logger13.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = (0, import_properties10.resolveProperties)({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter3(this, void 0, void 0, function* () {
          if ((0, import_address7.getAddress)(check.signer) !== check.override) {
            logger13.throwError("Contract with a Signer cannot override from", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield (0, import_properties10.resolveProperties)({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: (0, import_properties10.resolveProperties)(overrides) || {}
    });
    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = import_bignumber7.BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = import_bignumber7.BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = import_bignumber7.BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = import_bignumber7.BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = import_bignumber7.BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = (0, import_transactions4.accessListify)(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes4 = (0, import_bytes17.arrayify)(data);
      for (let i = 0; i < bytes4.length; i++) {
        intrinsic += 4;
        if (bytes4[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = import_bignumber7.BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = import_bignumber7.BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger13.throwError("non-payable method cannot override value", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = (0, import_properties10.shallowCopy)(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key) => overrides[key] != null);
    if (leftovers.length) {
      logger13.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, import_logger12.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger13.throwError("estimate require a provider or signer", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait2 = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait2(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = (0, import_properties10.deepCopy)(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter3(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = (0, import_properties10.shallowCopy)(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === import_logger12.Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger13.throwError("sending a transaction requires a signer", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var import_abstract_provider2, import_abstract_signer2, import_address7, import_bignumber7, import_bytes17, import_properties10, import_transactions4, import_logger12, __awaiter3, logger13, allowedTransactionKeys, RunningEvent, ErrorRunningEvent, FragmentRunningEvent, WildcardRunningEvent, BaseContract, Contract, ContractFactory;
var init_lib8 = __esm({
  "../node_modules/@ethersproject/contracts/lib.esm/index.js"() {
    "use strict";
    init_lib2();
    import_abstract_provider2 = __toESM(require_lib5());
    import_abstract_signer2 = __toESM(require_lib20());
    import_address7 = __toESM(require_lib14());
    import_bignumber7 = __toESM(require_lib3());
    import_bytes17 = __toESM(require_lib2());
    import_properties10 = __toESM(require_lib4());
    import_transactions4 = __toESM(require_lib19());
    import_logger12 = __toESM(require_lib());
    init_version7();
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger13 = new import_logger12.Logger(version8);
    allowedTransactionKeys = {
      chainId: true,
      data: true,
      from: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true,
      customData: true,
      ccipReadEnabled: true
    };
    RunningEvent = class {
      constructor(tag, filter) {
        (0, import_properties10.defineReadOnly)(this, "tag", tag);
        (0, import_properties10.defineReadOnly)(this, "filter", filter);
        this._listeners = [];
      }
      addListener(listener, once) {
        this._listeners.push({ listener, once });
      }
      removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item) => {
          if (done || item.listener !== listener) {
            return true;
          }
          done = true;
          return false;
        });
      }
      removeAllListeners() {
        this._listeners = [];
      }
      listeners() {
        return this._listeners.map((i) => i.listener);
      }
      listenerCount() {
        return this._listeners.length;
      }
      run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item) => {
          const argsCopy = args.slice();
          setTimeout(() => {
            item.listener.apply(this, argsCopy);
          }, 0);
          return !item.once;
        });
        return listenerCount;
      }
      prepareEvent(event) {
      }
      getEmit(event) {
        return [event];
      }
    };
    ErrorRunningEvent = class extends RunningEvent {
      constructor() {
        super("error", null);
      }
    };
    FragmentRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface, fragment, topics) {
        const filter = {
          address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
          if (topic !== topics[0]) {
            logger13.throwArgumentError("topic mismatch", "topics", topics);
          }
          filter.topics = topics.slice();
        } else {
          filter.topics = [topic];
        }
        super(getEventTag(filter), filter);
        (0, import_properties10.defineReadOnly)(this, "address", address);
        (0, import_properties10.defineReadOnly)(this, "interface", contractInterface);
        (0, import_properties10.defineReadOnly)(this, "fragment", fragment);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics) => {
          return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
          event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        } catch (error) {
          event.args = null;
          event.decodeError = error;
        }
      }
      getEmit(event) {
        const errors = checkResultErrors(event.args);
        if (errors.length) {
          throw errors[0].error;
        }
        const args = (event.args || []).slice();
        args.push(event);
        return args;
      }
    };
    WildcardRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface) {
        super("*", { address });
        (0, import_properties10.defineReadOnly)(this, "address", address);
        (0, import_properties10.defineReadOnly)(this, "interface", contractInterface);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        try {
          const parsed = this.interface.parseLog(event);
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
          event.decode = (data, topics) => {
            return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };
          event.args = parsed.args;
        } catch (error) {
        }
      }
    };
    BaseContract = class {
      constructor(addressOrName, contractInterface, signerOrProvider) {
        (0, import_properties10.defineReadOnly)(this, "interface", (0, import_properties10.getStatic)(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
          (0, import_properties10.defineReadOnly)(this, "provider", null);
          (0, import_properties10.defineReadOnly)(this, "signer", null);
        } else if (import_abstract_signer2.Signer.isSigner(signerOrProvider)) {
          (0, import_properties10.defineReadOnly)(this, "provider", signerOrProvider.provider || null);
          (0, import_properties10.defineReadOnly)(this, "signer", signerOrProvider);
        } else if (import_abstract_provider2.Provider.isProvider(signerOrProvider)) {
          (0, import_properties10.defineReadOnly)(this, "provider", signerOrProvider);
          (0, import_properties10.defineReadOnly)(this, "signer", null);
        } else {
          logger13.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        (0, import_properties10.defineReadOnly)(this, "callStatic", {});
        (0, import_properties10.defineReadOnly)(this, "estimateGas", {});
        (0, import_properties10.defineReadOnly)(this, "functions", {});
        (0, import_properties10.defineReadOnly)(this, "populateTransaction", {});
        (0, import_properties10.defineReadOnly)(this, "filters", {});
        {
          const uniqueFilters = {};
          Object.keys(this.interface.events).forEach((eventSignature) => {
            const event = this.interface.events[eventSignature];
            (0, import_properties10.defineReadOnly)(this.filters, eventSignature, (...args) => {
              return {
                address: this.address,
                topics: this.interface.encodeFilterTopics(event, args)
              };
            });
            if (!uniqueFilters[event.name]) {
              uniqueFilters[event.name] = [];
            }
            uniqueFilters[event.name].push(eventSignature);
          });
          Object.keys(uniqueFilters).forEach((name) => {
            const filters = uniqueFilters[name];
            if (filters.length === 1) {
              (0, import_properties10.defineReadOnly)(this.filters, name, this.filters[filters[0]]);
            } else {
              logger13.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
            }
          });
        }
        (0, import_properties10.defineReadOnly)(this, "_runningEvents", {});
        (0, import_properties10.defineReadOnly)(this, "_wrappedEmits", {});
        if (addressOrName == null) {
          logger13.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        (0, import_properties10.defineReadOnly)(this, "address", addressOrName);
        if (this.provider) {
          (0, import_properties10.defineReadOnly)(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        } else {
          try {
            (0, import_properties10.defineReadOnly)(this, "resolvedAddress", Promise.resolve((0, import_address7.getAddress)(addressOrName)));
          } catch (error) {
            logger13.throwError("provider is required to use ENS name as contract address", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new Contract"
            });
          }
        }
        this.resolvedAddress.catch((e) => {
        });
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature) => {
          const fragment = this.interface.functions[signature];
          if (uniqueSignatures[signature]) {
            logger13.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
            return;
          }
          uniqueSignatures[signature] = true;
          {
            const name = fragment.name;
            if (!uniqueNames[`%${name}`]) {
              uniqueNames[`%${name}`] = [];
            }
            uniqueNames[`%${name}`].push(signature);
          }
          if (this[signature] == null) {
            (0, import_properties10.defineReadOnly)(this, signature, buildDefault(this, fragment, true));
          }
          if (this.functions[signature] == null) {
            (0, import_properties10.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));
          }
          if (this.callStatic[signature] == null) {
            (0, import_properties10.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));
          }
          if (this.populateTransaction[signature] == null) {
            (0, import_properties10.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));
          }
          if (this.estimateGas[signature] == null) {
            (0, import_properties10.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));
          }
        });
        Object.keys(uniqueNames).forEach((name) => {
          const signatures = uniqueNames[name];
          if (signatures.length > 1) {
            return;
          }
          name = name.substring(1);
          const signature = signatures[0];
          try {
            if (this[name] == null) {
              (0, import_properties10.defineReadOnly)(this, name, this[signature]);
            }
          } catch (e) {
          }
          if (this.functions[name] == null) {
            (0, import_properties10.defineReadOnly)(this.functions, name, this.functions[signature]);
          }
          if (this.callStatic[name] == null) {
            (0, import_properties10.defineReadOnly)(this.callStatic, name, this.callStatic[signature]);
          }
          if (this.populateTransaction[name] == null) {
            (0, import_properties10.defineReadOnly)(this.populateTransaction, name, this.populateTransaction[signature]);
          }
          if (this.estimateGas[name] == null) {
            (0, import_properties10.defineReadOnly)(this.estimateGas, name, this.estimateGas[signature]);
          }
        });
      }
      static getContractAddress(transaction) {
        return (0, import_address7.getContractAddress)(transaction);
      }
      static getInterface(contractInterface) {
        if (Interface.isInterface(contractInterface)) {
          return contractInterface;
        }
        return new Interface(contractInterface);
      }
      deployed() {
        return this._deployed();
      }
      _deployed(blockTag) {
        if (!this._deployedPromise) {
          if (this.deployTransaction) {
            this._deployedPromise = this.deployTransaction.wait().then(() => {
              return this;
            });
          } else {
            this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
              if (code === "0x") {
                logger13.throwError("contract not deployed", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, {
                  contractAddress: this.address,
                  operation: "getDeployed"
                });
              }
              return this;
            });
          }
        }
        return this._deployedPromise;
      }
      fallback(overrides) {
        if (!this.signer) {
          logger13.throwError("sending a transactions require a signer", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        const tx = (0, import_properties10.shallowCopy)(overrides || {});
        ["from", "to"].forEach(function(key) {
          if (tx[key] == null) {
            return;
          }
          logger13.throwError("cannot override " + key, import_logger12.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(() => {
          return this.signer.sendTransaction(tx);
        });
      }
      connect(signerOrProvider) {
        if (typeof signerOrProvider === "string") {
          signerOrProvider = new import_abstract_signer2.VoidSigner(signerOrProvider, this.provider);
        }
        const contract = new this.constructor(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
          (0, import_properties10.defineReadOnly)(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
      }
      attach(addressOrName) {
        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
      }
      static isIndexed(value) {
        return Indexed.isIndexed(value);
      }
      _normalizeRunningEvent(runningEvent) {
        if (this._runningEvents[runningEvent.tag]) {
          return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
      }
      _getRunningEvent(eventName) {
        if (typeof eventName === "string") {
          if (eventName === "error") {
            return this._normalizeRunningEvent(new ErrorRunningEvent());
          }
          if (eventName === "event") {
            return this._normalizeRunningEvent(new RunningEvent("event", null));
          }
          if (eventName === "*") {
            return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
          }
          const fragment = this.interface.getEvent(eventName);
          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        if (eventName.topics && eventName.topics.length > 0) {
          try {
            const topic = eventName.topics[0];
            if (typeof topic !== "string") {
              throw new Error("invalid topic");
            }
            const fragment = this.interface.getEvent(topic);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
          } catch (error) {
          }
          const filter = {
            address: this.address,
            topics: eventName.topics
          };
          return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
          delete this._runningEvents[runningEvent.tag];
          const emit = this._wrappedEmits[runningEvent.tag];
          if (emit && runningEvent.filter) {
            this.provider.off(runningEvent.filter, emit);
            delete this._wrappedEmits[runningEvent.tag];
          }
        }
      }
      _wrapEvent(runningEvent, log, listener) {
        const event = (0, import_properties10.deepCopy)(log);
        event.removeListener = () => {
          if (!listener) {
            return;
          }
          runningEvent.removeListener(listener);
          this._checkRunningEvents(runningEvent);
        };
        event.getBlock = () => {
          return this.provider.getBlock(log.blockHash);
        };
        event.getTransaction = () => {
          return this.provider.getTransaction(log.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return this.provider.getTransactionReceipt(log.transactionHash);
        };
        runningEvent.prepareEvent(event);
        return event;
      }
      _addEventListener(runningEvent, listener, once) {
        if (!this.provider) {
          logger13.throwError("events require a provider or a signer with a provider", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        this._runningEvents[runningEvent.tag] = runningEvent;
        if (!this._wrappedEmits[runningEvent.tag]) {
          const wrappedEmit = (log) => {
            let event = this._wrapEvent(runningEvent, log, listener);
            if (event.decodeError == null) {
              try {
                const args = runningEvent.getEmit(event);
                this.emit(runningEvent.filter, ...args);
              } catch (error) {
                event.decodeError = error.error;
              }
            }
            if (runningEvent.filter != null) {
              this.emit("event", event);
            }
            if (event.decodeError != null) {
              this.emit("error", event.decodeError, event);
            }
          };
          this._wrappedEmits[runningEvent.tag] = wrappedEmit;
          if (runningEvent.filter != null) {
            this.provider.on(runningEvent.filter, wrappedEmit);
          }
        }
      }
      queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = (0, import_properties10.shallowCopy)(runningEvent.filter);
        if (typeof fromBlockOrBlockhash === "string" && (0, import_bytes17.isHexString)(fromBlockOrBlockhash, 32)) {
          if (toBlock != null) {
            logger13.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
          }
          filter.blockHash = fromBlockOrBlockhash;
        } else {
          filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
          filter.toBlock = toBlock != null ? toBlock : "latest";
        }
        return this.provider.getLogs(filter).then((logs) => {
          return logs.map((log) => this._wrapEvent(runningEvent, log, null));
        });
      }
      on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
      }
      once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
      }
      emit(eventName, ...args) {
        if (!this.provider) {
          return false;
        }
        const runningEvent = this._getRunningEvent(eventName);
        const result = runningEvent.run(args) > 0;
        this._checkRunningEvents(runningEvent);
        return result;
      }
      listenerCount(eventName) {
        if (!this.provider) {
          return 0;
        }
        if (eventName == null) {
          return Object.keys(this._runningEvents).reduce((accum, key) => {
            return accum + this._runningEvents[key].listenerCount();
          }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
      }
      listeners(eventName) {
        if (!this.provider) {
          return [];
        }
        if (eventName == null) {
          const result = [];
          for (let tag in this._runningEvents) {
            this._runningEvents[tag].listeners().forEach((listener) => {
              result.push(listener);
            });
          }
          return result;
        }
        return this._getRunningEvent(eventName).listeners();
      }
      removeAllListeners(eventName) {
        if (!this.provider) {
          return this;
        }
        if (eventName == null) {
          for (const tag in this._runningEvents) {
            const runningEvent2 = this._runningEvents[tag];
            runningEvent2.removeAllListeners();
            this._checkRunningEvents(runningEvent2);
          }
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
      }
      off(eventName, listener) {
        if (!this.provider) {
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
      }
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
    };
    Contract = class extends BaseContract {
    };
    ContractFactory = class {
      constructor(contractInterface, bytecode, signer) {
        let bytecodeHex = null;
        if (typeof bytecode === "string") {
          bytecodeHex = bytecode;
        } else if ((0, import_bytes17.isBytes)(bytecode)) {
          bytecodeHex = (0, import_bytes17.hexlify)(bytecode);
        } else if (bytecode && typeof bytecode.object === "string") {
          bytecodeHex = bytecode.object;
        } else {
          bytecodeHex = "!";
        }
        if (bytecodeHex.substring(0, 2) !== "0x") {
          bytecodeHex = "0x" + bytecodeHex;
        }
        if (!(0, import_bytes17.isHexString)(bytecodeHex) || bytecodeHex.length % 2) {
          logger13.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        }
        if (signer && !import_abstract_signer2.Signer.isSigner(signer)) {
          logger13.throwArgumentError("invalid signer", "signer", signer);
        }
        (0, import_properties10.defineReadOnly)(this, "bytecode", bytecodeHex);
        (0, import_properties10.defineReadOnly)(this, "interface", (0, import_properties10.getStatic)(new.target, "getInterface")(contractInterface));
        (0, import_properties10.defineReadOnly)(this, "signer", signer || null);
      }
      getDeployTransaction(...args) {
        let tx = {};
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
          tx = (0, import_properties10.shallowCopy)(args.pop());
          for (const key in tx) {
            if (!allowedTransactionKeys[key]) {
              throw new Error("unknown transaction override " + key);
            }
          }
        }
        ["data", "from", "to"].forEach((key) => {
          if (tx[key] == null) {
            return;
          }
          logger13.throwError("cannot override " + key, import_logger12.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        if (tx.value) {
          const value = import_bignumber7.BigNumber.from(tx.value);
          if (!value.isZero() && !this.interface.deploy.payable) {
            logger13.throwError("non-payable constructor cannot override value", import_logger12.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.value",
              value: tx.value
            });
          }
        }
        logger13.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        tx.data = (0, import_bytes17.hexlify)((0, import_bytes17.concat)([
          this.bytecode,
          this.interface.encodeDeploy(args)
        ]));
        return tx;
      }
      deploy(...args) {
        return __awaiter3(this, void 0, void 0, function* () {
          let overrides = {};
          if (args.length === this.interface.deploy.inputs.length + 1) {
            overrides = args.pop();
          }
          logger13.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
          const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
          params.push(overrides);
          const unsignedTx = this.getDeployTransaction(...params);
          const tx = yield this.signer.sendTransaction(unsignedTx);
          const address = (0, import_properties10.getStatic)(this.constructor, "getContractAddress")(tx);
          const contract = (0, import_properties10.getStatic)(this.constructor, "getContract")(address, this.interface, this.signer);
          addContractWait(contract, tx);
          (0, import_properties10.defineReadOnly)(contract, "deployTransaction", tx);
          return contract;
        });
      }
      attach(address) {
        return this.constructor.getContract(address, this.interface, this.signer);
      }
      connect(signer) {
        return new this.constructor(this.interface, this.bytecode, signer);
      }
      static fromSolidity(compilerOutput, signer) {
        if (compilerOutput == null) {
          logger13.throwError("missing compiler output", import_logger12.Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
        }
        if (typeof compilerOutput === "string") {
          compilerOutput = JSON.parse(compilerOutput);
        }
        const abi = compilerOutput.abi;
        let bytecode = null;
        if (compilerOutput.bytecode) {
          bytecode = compilerOutput.bytecode;
        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
          bytecode = compilerOutput.evm.bytecode;
        }
        return new this(abi, bytecode, signer);
      }
      static getInterface(contractInterface) {
        return Contract.getInterface(contractInterface);
      }
      static getContractAddress(tx) {
        return (0, import_address7.getContractAddress)(tx);
      }
      static getContract(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
      }
    };
  }
});

// ../node_modules/alchemy-sdk/dist/esm/alchemy-provider-deeb5501.js
var alchemy_provider_deeb5501_exports = {};
__export(alchemy_provider_deeb5501_exports, {
  AlchemyProvider: () => AlchemyProvider
});
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
var import_networks2, import_providers, import_web, import_axios, DEFAULT_MAX_REQUEST_BATCH_SIZE, DEFAULT_REQUEST_BATCH_DELAY_MS, RequestBatcher, AlchemyProvider;
var init_alchemy_provider_deeb5501 = __esm({
  "../node_modules/alchemy-sdk/dist/esm/alchemy-provider-deeb5501.js"() {
    init_index_8bd23ae5();
    import_networks2 = __toESM(require_lib6());
    import_providers = __toESM(require_lib22());
    import_web = __toESM(require_lib17());
    import_axios = __toESM(require_axios2());
    DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;
    DEFAULT_REQUEST_BATCH_DELAY_MS = 10;
    RequestBatcher = class {
      constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {
        this.sendBatchFn = sendBatchFn;
        this.maxBatchSize = maxBatchSize;
        this.pendingBatch = [];
      }
      enqueueRequest(request) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const inflightRequest = {
            request,
            resolve: void 0,
            reject: void 0
          };
          const promise = new Promise((resolve, reject) => {
            inflightRequest.resolve = resolve;
            inflightRequest.reject = reject;
          });
          this.pendingBatch.push(inflightRequest);
          if (this.pendingBatch.length === this.maxBatchSize) {
            void this.sendBatchRequest();
          } else if (!this.pendingBatchTimer) {
            this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);
          }
          return promise;
        });
      }
      sendBatchRequest() {
        return __awaiter$1(this, void 0, void 0, function* () {
          const batch = this.pendingBatch;
          this.pendingBatch = [];
          if (this.pendingBatchTimer) {
            clearTimeout(this.pendingBatchTimer);
            this.pendingBatchTimer = void 0;
          }
          const request = batch.map((inflight) => inflight.request);
          return this.sendBatchFn(request).then((result) => {
            batch.forEach((inflightRequest, index2) => {
              const payload = result[index2];
              if (payload.error) {
                const error = new Error(payload.error.message);
                error.code = payload.error.code;
                error.data = payload.error.data;
                inflightRequest.reject(error);
              } else {
                inflightRequest.resolve(payload.result);
              }
            });
          }, (error) => {
            batch.forEach((inflightRequest) => {
              inflightRequest.reject(error);
            });
          });
        });
      }
    };
    AlchemyProvider = class extends import_providers.JsonRpcProvider {
      constructor(config2) {
        const apiKey = AlchemyProvider.getApiKey(config2.apiKey);
        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config2.network);
        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, "http");
        if (config2.url !== void 0) {
          connection.url = config2.url;
        }
        connection.throttleLimit = config2.maxRetries;
        const ethersNetwork = EthersNetwork[alchemyNetwork];
        super(connection, ethersNetwork);
        this.apiKey = config2.apiKey;
        this.maxRetries = config2.maxRetries;
        this.batchRequests = config2.batchRequests;
        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { "Alchemy-Ethers-Sdk-Method": "batchSend" }) });
        const sendBatchFn = (requests) => {
          return (0, import_web.fetchJson)(batcherConnection, JSON.stringify(requests));
        };
        this.batcher = new RequestBatcher(sendBatchFn);
      }
      static getApiKey(apiKey) {
        if (apiKey == null) {
          return DEFAULT_ALCHEMY_API_KEY;
        }
        if (apiKey && typeof apiKey !== "string") {
          throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);
        }
        return apiKey;
      }
      static getNetwork(network) {
        if (typeof network === "string" && network in CustomNetworks) {
          return CustomNetworks[network];
        }
        return (0, import_networks2.getNetwork)(network);
      }
      static getAlchemyNetwork(network) {
        if (network === void 0) {
          return DEFAULT_NETWORK;
        }
        if (typeof network === "number") {
          throw new Error(`Invalid network '${network}' provided. Network must be a string.`);
        }
        const isValidNetwork = Object.values(Network).includes(network);
        if (!isValidNetwork) {
          throw new Error(`Invalid network '${network}' provided. Network must be one of: ${Object.values(Network).join(", ")}.`);
        }
        return network;
      }
      static getAlchemyConnectionInfo(network, apiKey, type) {
        const url = type === "http" ? getAlchemyHttpUrl(network, apiKey) : getAlchemyWsUrl(network, apiKey);
        return {
          headers: IS_BROWSER ? {
            "Alchemy-Ethers-Sdk-Version": VERSION
          } : {
            "Alchemy-Ethers-Sdk-Version": VERSION,
            "Accept-Encoding": "gzip"
          },
          allowGzip: true,
          url
        };
      }
      detectNetwork() {
        const _super = Object.create(null, {
          detectNetwork: { get: () => super.detectNetwork }
        });
        return __awaiter$1(this, void 0, void 0, function* () {
          let network = this.network;
          if (network == null) {
            network = yield _super.detectNetwork.call(this);
            if (!network) {
              throw new Error("No network detected");
            }
          }
          return network;
        });
      }
      _startPending() {
        logWarn("WARNING: Alchemy Provider does not support pending filters");
      }
      isCommunityResource() {
        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;
      }
      send(method, params) {
        return this._send(method, params, "send");
      }
      _send(method, params, methodName, forceBatch = false) {
        const request = {
          method,
          params,
          id: this._nextId++,
          jsonrpc: "2.0"
        };
        const connection = Object.assign({}, this.connection);
        connection.headers["Alchemy-Ethers-Sdk-Method"] = methodName;
        if (this.batchRequests || forceBatch) {
          return this.batcher.enqueueRequest(request);
        }
        this.emit("debug", {
          action: "request",
          request: deepCopy2(request),
          provider: this
        });
        const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
        if (cache && this._cache[method]) {
          return this._cache[method];
        }
        const result = (0, import_web.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result2) => {
          this.emit("debug", {
            action: "response",
            request,
            response: result2,
            provider: this
          });
          return result2;
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request,
            provider: this
          });
          throw error;
        });
        if (cache) {
          this._cache[method] = result;
          setTimeout(() => {
            this._cache[method] = null;
          }, 0);
        }
        return result;
      }
    };
  }
});

// ../node_modules/sturdy-websocket/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/sturdy-websocket/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SHOULD_RECONNECT_FALSE_MESSAGE = "Provided shouldReconnect() returned false. Closing permanently.";
    var SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = "Provided shouldReconnect() resolved to false. Closing permanently.";
    var SturdyWebSocket2 = function() {
      function SturdyWebSocket3(url, protocolsOrOptions, options) {
        if (options === void 0) {
          options = {};
        }
        this.url = url;
        this.onclose = null;
        this.onerror = null;
        this.onmessage = null;
        this.onopen = null;
        this.ondown = null;
        this.onreopen = null;
        this.CONNECTING = SturdyWebSocket3.CONNECTING;
        this.OPEN = SturdyWebSocket3.OPEN;
        this.CLOSING = SturdyWebSocket3.CLOSING;
        this.CLOSED = SturdyWebSocket3.CLOSED;
        this.hasBeenOpened = false;
        this.isClosed = false;
        this.messageBuffer = [];
        this.nextRetryTime = 0;
        this.reconnectCount = 0;
        this.lastKnownExtensions = "";
        this.lastKnownProtocol = "";
        this.listeners = {};
        if (protocolsOrOptions == null || typeof protocolsOrOptions === "string" || Array.isArray(protocolsOrOptions)) {
          this.protocols = protocolsOrOptions;
        } else {
          options = protocolsOrOptions;
        }
        this.options = applyDefaultOptions(options);
        if (!this.options.wsConstructor) {
          if (typeof WebSocket !== "undefined") {
            this.options.wsConstructor = WebSocket;
          } else {
            throw new Error("WebSocket not present in global scope and no wsConstructor option was provided.");
          }
        }
        this.openNewWebSocket();
      }
      Object.defineProperty(SturdyWebSocket3.prototype, "binaryType", {
        get: function() {
          return this.binaryTypeInternal || "blob";
        },
        set: function(binaryType) {
          this.binaryTypeInternal = binaryType;
          if (this.ws) {
            this.ws.binaryType = binaryType;
          }
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SturdyWebSocket3.prototype, "bufferedAmount", {
        get: function() {
          var sum = this.ws ? this.ws.bufferedAmount : 0;
          var hasUnknownAmount = false;
          this.messageBuffer.forEach(function(data) {
            var byteLength = getDataByteLength(data);
            if (byteLength != null) {
              sum += byteLength;
            } else {
              hasUnknownAmount = true;
            }
          });
          if (hasUnknownAmount) {
            this.debugLog("Some buffered data had unknown length. bufferedAmount() return value may be below the correct amount.");
          }
          return sum;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SturdyWebSocket3.prototype, "extensions", {
        get: function() {
          return this.ws ? this.ws.extensions : this.lastKnownExtensions;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SturdyWebSocket3.prototype, "protocol", {
        get: function() {
          return this.ws ? this.ws.protocol : this.lastKnownProtocol;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SturdyWebSocket3.prototype, "readyState", {
        get: function() {
          return this.isClosed ? SturdyWebSocket3.CLOSED : SturdyWebSocket3.OPEN;
        },
        enumerable: true,
        configurable: true
      });
      SturdyWebSocket3.prototype.close = function(code, reason) {
        this.disposeSocket(code, reason);
        this.shutdown();
        this.debugLog("WebSocket permanently closed by client.");
      };
      SturdyWebSocket3.prototype.send = function(data) {
        if (this.isClosed) {
          throw new Error("WebSocket is already in CLOSING or CLOSED state.");
        } else if (this.ws && this.ws.readyState === this.OPEN) {
          this.ws.send(data);
        } else {
          this.messageBuffer.push(data);
        }
      };
      SturdyWebSocket3.prototype.reconnect = function() {
        if (this.isClosed) {
          throw new Error("Cannot call reconnect() on socket which is permanently closed.");
        }
        this.disposeSocket(1e3, "Client requested reconnect.");
        this.handleClose(void 0);
      };
      SturdyWebSocket3.prototype.addEventListener = function(type, listener) {
        if (!this.listeners[type]) {
          this.listeners[type] = [];
        }
        this.listeners[type].push(listener);
      };
      SturdyWebSocket3.prototype.dispatchEvent = function(event) {
        return this.dispatchEventOfType(event.type, event);
      };
      SturdyWebSocket3.prototype.removeEventListener = function(type, listener) {
        if (this.listeners[type]) {
          this.listeners[type] = this.listeners[type].filter(function(l) {
            return l !== listener;
          });
        }
      };
      SturdyWebSocket3.prototype.openNewWebSocket = function() {
        var _this = this;
        if (this.isClosed) {
          return;
        }
        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;
        this.debugLog("Opening new WebSocket to " + this.url + ".");
        var ws2 = new wsConstructor(this.url, this.protocols);
        ws2.onclose = function(event) {
          return _this.handleClose(event);
        };
        ws2.onerror = function(event) {
          return _this.handleError(event);
        };
        ws2.onmessage = function(event) {
          return _this.handleMessage(event);
        };
        ws2.onopen = function(event) {
          return _this.handleOpen(event);
        };
        this.connectTimeoutId = setTimeout(function() {
          _this.clearConnectTimeout();
          _this.disposeSocket();
          _this.handleClose(void 0);
        }, connectTimeout);
        this.ws = ws2;
      };
      SturdyWebSocket3.prototype.handleOpen = function(event) {
        var _this = this;
        if (!this.ws || this.isClosed) {
          return;
        }
        var allClearResetTime = this.options.allClearResetTime;
        this.debugLog("WebSocket opened.");
        if (this.binaryTypeInternal != null) {
          this.ws.binaryType = this.binaryTypeInternal;
        } else {
          this.binaryTypeInternal = this.ws.binaryType;
        }
        this.clearConnectTimeout();
        if (this.hasBeenOpened) {
          this.dispatchEventOfType("reopen", event);
        } else {
          this.dispatchEventOfType("open", event);
          this.hasBeenOpened = true;
        }
        this.messageBuffer.forEach(function(message) {
          return _this.send(message);
        });
        this.messageBuffer = [];
        this.allClearTimeoutId = setTimeout(function() {
          _this.clearAllClearTimeout();
          _this.nextRetryTime = 0;
          _this.reconnectCount = 0;
          var openTime = allClearResetTime / 1e3 | 0;
          _this.debugLog("WebSocket remained open for " + openTime + " seconds. Resetting retry time and count.");
        }, allClearResetTime);
      };
      SturdyWebSocket3.prototype.handleMessage = function(event) {
        if (this.isClosed) {
          return;
        }
        this.dispatchEventOfType("message", event);
      };
      SturdyWebSocket3.prototype.handleClose = function(event) {
        var _this = this;
        if (this.isClosed) {
          return;
        }
        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;
        this.clearConnectTimeout();
        this.clearAllClearTimeout();
        if (this.ws) {
          this.lastKnownExtensions = this.ws.extensions;
          this.lastKnownProtocol = this.ws.protocol;
          this.disposeSocket();
        }
        this.dispatchEventOfType("down", event);
        if (this.reconnectCount >= maxReconnectAttempts) {
          this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());
          return;
        }
        var willReconnect = !event || shouldReconnect(event);
        if (typeof willReconnect === "boolean") {
          this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);
        } else {
          willReconnect.then(function(willReconnectResolved) {
            if (_this.isClosed) {
              return;
            }
            _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);
          });
        }
      };
      SturdyWebSocket3.prototype.handleError = function(event) {
        this.dispatchEventOfType("error", event);
        this.debugLog("WebSocket encountered an error.");
      };
      SturdyWebSocket3.prototype.handleWillReconnect = function(willReconnect, event, denialReason) {
        if (willReconnect) {
          this.reestablishConnection();
        } else {
          this.stopReconnecting(event, denialReason);
        }
      };
      SturdyWebSocket3.prototype.reestablishConnection = function() {
        var _this = this;
        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;
        this.reconnectCount++;
        var retryTime = this.nextRetryTime;
        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));
        setTimeout(function() {
          return _this.openNewWebSocket();
        }, retryTime);
        var retryTimeSeconds = retryTime / 1e3 | 0;
        this.debugLog("WebSocket was closed. Re-opening in " + retryTimeSeconds + " seconds.");
      };
      SturdyWebSocket3.prototype.stopReconnecting = function(event, debugReason) {
        this.debugLog(debugReason);
        this.shutdown();
        if (event) {
          this.dispatchEventOfType("close", event);
        }
      };
      SturdyWebSocket3.prototype.shutdown = function() {
        this.isClosed = true;
        this.clearAllTimeouts();
        this.messageBuffer = [];
        this.disposeSocket();
      };
      SturdyWebSocket3.prototype.disposeSocket = function(closeCode, reason) {
        if (!this.ws) {
          return;
        }
        this.ws.onerror = noop3;
        this.ws.onclose = noop3;
        this.ws.onmessage = noop3;
        this.ws.onopen = noop3;
        this.ws.close(closeCode, reason);
        this.ws = void 0;
      };
      SturdyWebSocket3.prototype.clearAllTimeouts = function() {
        this.clearConnectTimeout();
        this.clearAllClearTimeout();
      };
      SturdyWebSocket3.prototype.clearConnectTimeout = function() {
        if (this.connectTimeoutId != null) {
          clearTimeout(this.connectTimeoutId);
          this.connectTimeoutId = void 0;
        }
      };
      SturdyWebSocket3.prototype.clearAllClearTimeout = function() {
        if (this.allClearTimeoutId != null) {
          clearTimeout(this.allClearTimeoutId);
          this.allClearTimeoutId = void 0;
        }
      };
      SturdyWebSocket3.prototype.dispatchEventOfType = function(type, event) {
        var _this = this;
        switch (type) {
          case "close":
            if (this.onclose) {
              this.onclose(event);
            }
            break;
          case "error":
            if (this.onerror) {
              this.onerror(event);
            }
            break;
          case "message":
            if (this.onmessage) {
              this.onmessage(event);
            }
            break;
          case "open":
            if (this.onopen) {
              this.onopen(event);
            }
            break;
          case "down":
            if (this.ondown) {
              this.ondown(event);
            }
            break;
          case "reopen":
            if (this.onreopen) {
              this.onreopen(event);
            }
            break;
        }
        if (type in this.listeners) {
          this.listeners[type].slice().forEach(function(listener) {
            return _this.callListener(listener, event);
          });
        }
        return !event || !event.defaultPrevented;
      };
      SturdyWebSocket3.prototype.callListener = function(listener, event) {
        if (typeof listener === "function") {
          listener.call(this, event);
        } else {
          listener.handleEvent.call(this, event);
        }
      };
      SturdyWebSocket3.prototype.debugLog = function(message) {
        if (this.options.debug) {
          console.log(message);
        }
      };
      SturdyWebSocket3.prototype.getTooManyFailedReconnectsMessage = function() {
        var maxReconnectAttempts = this.options.maxReconnectAttempts;
        return "Failed to reconnect after " + maxReconnectAttempts + " " + pluralize("attempt", maxReconnectAttempts) + ". Closing permanently.";
      };
      SturdyWebSocket3.DEFAULT_OPTIONS = {
        allClearResetTime: 5e3,
        connectTimeout: 5e3,
        debug: false,
        minReconnectDelay: 1e3,
        maxReconnectDelay: 3e4,
        maxReconnectAttempts: Number.POSITIVE_INFINITY,
        reconnectBackoffFactor: 1.5,
        shouldReconnect: function() {
          return true;
        },
        wsConstructor: void 0
      };
      SturdyWebSocket3.CONNECTING = 0;
      SturdyWebSocket3.OPEN = 1;
      SturdyWebSocket3.CLOSING = 2;
      SturdyWebSocket3.CLOSED = 3;
      return SturdyWebSocket3;
    }();
    exports.default = SturdyWebSocket2;
    function applyDefaultOptions(options) {
      var result = {};
      Object.keys(SturdyWebSocket2.DEFAULT_OPTIONS).forEach(function(key) {
        var value = options[key];
        result[key] = value === void 0 ? SturdyWebSocket2.DEFAULT_OPTIONS[key] : value;
      });
      return result;
    }
    function getDataByteLength(data) {
      if (typeof data === "string") {
        return 2 * data.length;
      } else if (data instanceof ArrayBuffer) {
        return data.byteLength;
      } else if (data instanceof Blob) {
        return data.size;
      } else {
        return void 0;
      }
    }
    function pluralize(s, n) {
      return n === 1 ? s : s + "s";
    }
    function noop3() {
    }
  }
});

// ../node_modules/es5-ext/global.js
var require_global = __commonJS({
  "../node_modules/es5-ext/global.js"(exports, module) {
    var naiveFallback = function() {
      if (typeof window.self === "object" && window.self)
        return window.self;
      if (typeof window === "object" && window)
        return window;
      throw new Error("Unable to resolve global `this`");
    };
    module.exports = function() {
      if (this)
        return this;
      if (typeof globalThis === "object" && globalThis)
        return globalThis;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__)
          return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// ../node_modules/websocket/package.json
var require_package2 = __commonJS({
  "../node_modules/websocket/package.json"(exports, module) {
    module.exports = {
      name: "websocket",
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      author: "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
      contributors: [
        "I\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
      ],
      version: "1.0.34",
      repository: {
        type: "git",
        url: "https://github.com/theturtle32/WebSocket-Node.git"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      engines: {
        node: ">=4.0.0"
      },
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.50",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        "jshint-stylish": "^2.2.1",
        jshint: "^2.0.0",
        tape: "^4.9.1"
      },
      config: {
        verbose: false
      },
      scripts: {
        test: "tape test/unit/*.js",
        gulp: "gulp"
      },
      main: "index",
      directories: {
        lib: "./lib"
      },
      browser: "lib/browser.js",
      license: "Apache-2.0"
    };
  }
});

// ../node_modules/websocket/lib/version.js
var require_version20 = __commonJS({
  "../node_modules/websocket/lib/version.js"(exports, module) {
    module.exports = require_package2().version;
  }
});

// ../node_modules/websocket/lib/browser.js
var require_browser = __commonJS({
  "../node_modules/websocket/lib/browser.js"(exports, module) {
    var _globalThis;
    if (typeof globalThis === "object") {
      _globalThis = globalThis;
    } else {
      try {
        _globalThis = require_global();
      } catch (error) {
      } finally {
        if (!_globalThis && typeof window !== "undefined") {
          _globalThis = window;
        }
        if (!_globalThis) {
          throw new Error("Could not determine global this");
        }
      }
    }
    var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
    var websocket_version = require_version20();
    function W3CWebSocket(uri, protocols) {
      var native_instance;
      if (protocols) {
        native_instance = new NativeWebSocket(uri, protocols);
      } else {
        native_instance = new NativeWebSocket(uri);
      }
      return native_instance;
    }
    if (NativeWebSocket) {
      ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(prop) {
        Object.defineProperty(W3CWebSocket, prop, {
          get: function() {
            return NativeWebSocket[prop];
          }
        });
      });
    }
    module.exports = {
      "w3cwebsocket": NativeWebSocket ? W3CWebSocket : null,
      "version": websocket_version
    };
  }
});

// ../node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-cf92d428.js
var alchemy_websocket_provider_cf92d428_exports = {};
__export(alchemy_websocket_provider_cf92d428_exports, {
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider
});
function toNewHeadsEvent(head) {
  const result = Object.assign({}, head);
  delete result.totalDifficulty;
  delete result.transactions;
  delete result.uncles;
  return result;
}
function dedupeNewHeads(events) {
  return dedupe(events, (event) => event.hash);
}
function dedupeLogs(events) {
  return dedupe(events, (event) => `${event.blockHash}/${event.logIndex}`);
}
function dedupe(items, getKey) {
  const keysSeen = /* @__PURE__ */ new Set();
  const result = [];
  items.forEach((item) => {
    const key = getKey(item);
    if (!keysSeen.has(key)) {
      keysSeen.add(key);
      result.push(item);
    }
  });
  return result;
}
function throwIfCancelled(isCancelled) {
  if (isCancelled()) {
    throw CANCELLED;
  }
}
function getWebsocketConstructor() {
  return isNodeEnvironment() ? require_browser().w3cwebsocket : WebSocket;
}
function isNodeEnvironment() {
  return typeof process !== "undefined" && process != null && process.versions != null && process.versions.node != null;
}
function makeCancelToken() {
  let cancelled = false;
  return { cancel: () => cancelled = true, isCancelled: () => cancelled };
}
function withBackoffRetries(f, retryCount, shouldRetry = () => true) {
  return __awaiter$1(this, void 0, void 0, function* () {
    let nextWaitTime = 0;
    let i = 0;
    while (true) {
      try {
        return yield f();
      } catch (error) {
        i++;
        if (i >= retryCount || !shouldRetry(error)) {
          throw error;
        }
        yield delay(nextWaitTime);
        if (!shouldRetry(error)) {
          throw error;
        }
        nextWaitTime = nextWaitTime === 0 ? MIN_RETRY_DELAY : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);
      }
    }
  });
}
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function withTimeout(promise, ms) {
  return Promise.race([
    promise,
    new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout")), ms))
  ]);
}
function getNewHeadsBlockNumber(event) {
  return fromHex(event.number);
}
function getLogsBlockNumber(event) {
  return fromHex(event.blockNumber);
}
function isResponse(message) {
  return Array.isArray(message) || message.jsonrpc === "2.0" && message.id !== void 0;
}
function isSubscriptionEvent(message) {
  return !isResponse(message);
}
function addToNewHeadsEventsBuffer(pastEvents, event) {
  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);
}
function addToLogsEventsBuffer(pastEvents, event) {
  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);
}
function addToPastEventsBuffer(pastEvents, event, getBlockNumber2) {
  const currentBlockNumber = getBlockNumber2(event);
  const firstGoodIndex = pastEvents.findIndex((e) => getBlockNumber2(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);
  if (firstGoodIndex === -1) {
    pastEvents.length = 0;
  } else {
    pastEvents.splice(0, firstGoodIndex);
  }
  pastEvents.push(event);
}
var import_sturdy_websocket, import_bignumber8, import_networks3, import_providers2, import_axios2, MAX_BACKFILL_BLOCKS, WebsocketBackfiller, CANCELLED, HEARTBEAT_INTERVAL, HEARTBEAT_WAIT_TIME, BACKFILL_TIMEOUT, BACKFILL_RETRIES, RETAINED_EVENT_BLOCK_COUNT, AlchemyWebSocketProvider, MIN_RETRY_DELAY, RETRY_BACKOFF_FACTOR, MAX_RETRY_DELAY;
var init_alchemy_websocket_provider_cf92d428 = __esm({
  "../node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-cf92d428.js"() {
    init_index_8bd23ae5();
    import_sturdy_websocket = __toESM(require_dist2());
    import_bignumber8 = __toESM(require_lib3());
    import_networks3 = __toESM(require_lib6());
    import_providers2 = __toESM(require_lib22());
    init_alchemy_provider_deeb5501();
    import_axios2 = __toESM(require_axios2());
    MAX_BACKFILL_BLOCKS = 120;
    WebsocketBackfiller = class {
      constructor(provider) {
        this.provider = provider;
        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;
      }
      getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {
        return __awaiter$1(this, void 0, void 0, function* () {
          throwIfCancelled(isCancelled);
          const toBlockNumber = yield this.getBlockNumber();
          throwIfCancelled(isCancelled);
          if (previousHeads.length === 0) {
            return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);
          }
          const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);
          const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;
          if (lastSeenBlockNumber <= minBlockNumber) {
            return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);
          }
          const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);
          throwIfCancelled(isCancelled);
          const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);
          throwIfCancelled(isCancelled);
          return [...reorgHeads, ...intermediateHeads];
        });
      }
      getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {
        return __awaiter$1(this, void 0, void 0, function* () {
          throwIfCancelled(isCancelled);
          const toBlockNumber = yield this.getBlockNumber();
          throwIfCancelled(isCancelled);
          if (previousLogs.length === 0) {
            return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);
          }
          const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);
          const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;
          if (lastSeenBlockNumber < minBlockNumber) {
            return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);
          }
          const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);
          throwIfCancelled(isCancelled);
          const removedLogs = previousLogs.filter((log) => fromHex(log.blockNumber) > commonAncestor.blockNumber).map((log) => Object.assign(Object.assign({}, log), { removed: true }));
          const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY ? fromHex(previousLogs[0].blockNumber) : commonAncestor.blockNumber;
          let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);
          addedLogs = addedLogs.filter((log) => log && (fromHex(log.blockNumber) > commonAncestor.blockNumber || fromHex(log.logIndex) > commonAncestor.logIndex));
          throwIfCancelled(isCancelled);
          return [...removedLogs, ...addedLogs];
        });
      }
      setMaxBackfillBlock(newMax) {
        this.maxBackfillBlocks = newMax;
      }
      getBlockNumber() {
        return __awaiter$1(this, void 0, void 0, function* () {
          const blockNumberHex = yield this.provider.send("eth_blockNumber");
          return fromHex(blockNumberHex);
        });
      }
      getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {
        return __awaiter$1(this, void 0, void 0, function* () {
          if (fromBlockInclusive >= toBlockExclusive) {
            return [];
          }
          const batchParts = [];
          for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {
            batchParts.push({
              method: "eth_getBlockByNumber",
              params: [toHex(i), false]
            });
          }
          const blockHeads = yield this.provider.sendBatch(batchParts);
          return blockHeads.map(toNewHeadsEvent);
        });
      }
      getReorgHeads(isCancelled, previousHeads) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const result = [];
          for (let i = previousHeads.length - 1; i >= 0; i--) {
            const oldEvent = previousHeads[i];
            const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));
            throwIfCancelled(isCancelled);
            if (oldEvent.hash === blockHead.hash) {
              break;
            }
            result.push(toNewHeadsEvent(blockHead));
          }
          return result.reverse();
        });
      }
      getBlockByNumber(blockNumber) {
        return __awaiter$1(this, void 0, void 0, function* () {
          return this.provider.send("eth_getBlockByNumber", [
            toHex(blockNumber),
            false
          ]);
        });
      }
      getCommonAncestor(isCancelled, previousLogs) {
        return __awaiter$1(this, void 0, void 0, function* () {
          let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));
          throwIfCancelled(isCancelled);
          for (let i = previousLogs.length - 1; i >= 0; i--) {
            const oldLog = previousLogs[i];
            if (oldLog.blockNumber !== blockHead.number) {
              blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));
            }
            if (oldLog.blockHash === blockHead.hash) {
              return {
                blockNumber: fromHex(oldLog.blockNumber),
                logIndex: fromHex(oldLog.logIndex)
              };
            }
          }
          return {
            blockNumber: Number.NEGATIVE_INFINITY,
            logIndex: Number.NEGATIVE_INFINITY
          };
        });
      }
      getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {
        return __awaiter$1(this, void 0, void 0, function* () {
          if (fromBlockInclusive >= toBlockExclusive) {
            return [];
          }
          const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: toHex(fromBlockInclusive), toBlock: toHex(toBlockExclusive - 1) });
          return this.provider.send("eth_getLogs", [rangeFilter]);
        });
      }
    };
    CANCELLED = new Error("Cancelled");
    HEARTBEAT_INTERVAL = 3e4;
    HEARTBEAT_WAIT_TIME = 1e4;
    BACKFILL_TIMEOUT = 6e4;
    BACKFILL_RETRIES = 5;
    RETAINED_EVENT_BLOCK_COUNT = 10;
    AlchemyWebSocketProvider = class extends import_providers2.WebSocketProvider {
      constructor(config2, wsConstructor) {
        var _a;
        const apiKey = AlchemyProvider.getApiKey(config2.apiKey);
        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config2.network);
        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, "wss");
        const protocol = `alchemy-sdk-${VERSION}`;
        const ws2 = new import_sturdy_websocket.default((_a = config2.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {
          wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()
        });
        const ethersNetwork = EthersNetwork[alchemyNetwork];
        super(ws2, ethersNetwork);
        this._events = [];
        this.virtualSubscriptionsById = /* @__PURE__ */ new Map();
        this.virtualIdsByPhysicalId = /* @__PURE__ */ new Map();
        this.handleMessage = (event) => {
          const message = JSON.parse(event.data);
          if (!isSubscriptionEvent(message)) {
            return;
          }
          const physicalId = message.params.subscription;
          const virtualId = this.virtualIdsByPhysicalId.get(physicalId);
          if (!virtualId) {
            return;
          }
          const subscription = this.virtualSubscriptionsById.get(virtualId);
          if (subscription.method !== "eth_subscribe") {
            return;
          }
          switch (subscription.params[0]) {
            case "newHeads": {
              const newHeadsSubscription = subscription;
              const newHeadsMessage = message;
              const { isBackfilling, backfillBuffer } = newHeadsSubscription;
              const { result } = newHeadsMessage.params;
              if (isBackfilling) {
                addToNewHeadsEventsBuffer(backfillBuffer, result);
              } else if (physicalId !== virtualId) {
                this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);
              } else {
                this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);
              }
              break;
            }
            case "logs": {
              const logsSubscription = subscription;
              const logsMessage = message;
              const { isBackfilling, backfillBuffer } = logsSubscription;
              const { result } = logsMessage.params;
              if (isBackfilling) {
                addToLogsEventsBuffer(backfillBuffer, result);
              } else if (virtualId !== physicalId) {
                this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);
              } else {
                this.rememberEvent(virtualId, result, getLogsBlockNumber);
              }
              break;
            }
            default:
              if (physicalId !== virtualId) {
                const { result } = message.params;
                this.emitEvent(virtualId, result);
              }
          }
        };
        this.handleReopen = () => {
          this.virtualIdsByPhysicalId.clear();
          const { cancel, isCancelled } = makeCancelToken();
          this.cancelBackfill = cancel;
          for (const subscription of this.virtualSubscriptionsById.values()) {
            void (() => __awaiter$1(this, void 0, void 0, function* () {
              try {
                yield this.resubscribeAndBackfill(isCancelled, subscription);
              } catch (error) {
                if (!isCancelled()) {
                  console.error(`Error while backfilling "${subscription.params[0]}" subscription. Some events may be missing.`, error);
                }
              }
            }))();
          }
          this.startHeartbeat();
        };
        this.stopHeartbeatAndBackfill = () => {
          if (this.heartbeatIntervalId != null) {
            clearInterval(this.heartbeatIntervalId);
            this.heartbeatIntervalId = void 0;
          }
          this.cancelBackfill();
        };
        this.apiKey = apiKey;
        this.backfiller = new WebsocketBackfiller(this);
        this.addSocketListeners();
        this.startHeartbeat();
        this.cancelBackfill = noop2;
      }
      static getNetwork(network) {
        if (typeof network === "string" && network in CustomNetworks) {
          return CustomNetworks[network];
        }
        return (0, import_networks3.getNetwork)(network);
      }
      on(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
      }
      once(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
      }
      off(eventName, listener) {
        if (isAlchemyEvent(eventName)) {
          return this._off(eventName, listener);
        } else {
          return super.off(eventName, listener);
        }
      }
      removeAllListeners(eventName) {
        if (eventName !== void 0 && isAlchemyEvent(eventName)) {
          return this._removeAllListeners(eventName);
        } else {
          return super.removeAllListeners(eventName);
        }
      }
      listenerCount(eventName) {
        if (eventName !== void 0 && isAlchemyEvent(eventName)) {
          return this._listenerCount(eventName);
        } else {
          return super.listenerCount(eventName);
        }
      }
      listeners(eventName) {
        if (eventName !== void 0 && isAlchemyEvent(eventName)) {
          return this._listeners(eventName);
        } else {
          return super.listeners(eventName);
        }
      }
      _addEventListener(eventName, listener, once) {
        if (isAlchemyEvent(eventName)) {
          verifyAlchemyEventName(eventName);
          const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);
          this._events.push(event);
          this._startEvent(event);
          return this;
        } else {
          return super._addEventListener(eventName, listener, once);
        }
      }
      _startEvent(event) {
        const customLogicTypes = [...ALCHEMY_EVENT_TYPES, "block", "filter"];
        if (customLogicTypes.includes(event.type)) {
          this.customStartEvent(event);
        } else {
          super._startEvent(event);
        }
      }
      _subscribe(tag, param, processFunc, event) {
        return __awaiter$1(this, void 0, void 0, function* () {
          let subIdPromise = this._subIds[tag];
          const startingBlockNumber = yield this.getBlockNumber();
          if (subIdPromise == null) {
            subIdPromise = Promise.all(param).then((param2) => {
              return this.send("eth_subscribe", param2);
            });
            this._subIds[tag] = subIdPromise;
          }
          const subId = yield subIdPromise;
          const resolvedParams = yield Promise.all(param);
          this.virtualSubscriptionsById.set(subId, {
            event,
            method: "eth_subscribe",
            params: resolvedParams,
            startingBlockNumber,
            virtualId: subId,
            physicalId: subId,
            sentEvents: [],
            isBackfilling: false,
            backfillBuffer: []
          });
          this.virtualIdsByPhysicalId.set(subId, subId);
          this._subs[subId] = { tag, processFunc };
        });
      }
      emit(eventName, ...args) {
        if (isAlchemyEvent(eventName)) {
          let result = false;
          const stopped = [];
          const eventTag = getAlchemyEventTag(eventName);
          this._events = this._events.filter((event) => {
            if (event.tag !== eventTag) {
              return true;
            }
            setTimeout(() => {
              event.listener.apply(this, args);
            }, 0);
            result = true;
            if (event.once) {
              stopped.push(event);
              return false;
            }
            return true;
          });
          stopped.forEach((event) => {
            this._stopEvent(event);
          });
          return result;
        } else {
          return super.emit(eventName, ...args);
        }
      }
      sendBatch(parts) {
        return __awaiter$1(this, void 0, void 0, function* () {
          let nextId = 0;
          const payload = parts.map(({ method, params }) => {
            return {
              method,
              params,
              jsonrpc: "2.0",
              id: `alchemy-sdk:${nextId++}`
            };
          });
          return this.sendBatchConcurrently(payload);
        });
      }
      destroy() {
        this.removeSocketListeners();
        this.stopHeartbeatAndBackfill();
        return super.destroy();
      }
      isCommunityResource() {
        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;
      }
      _stopEvent(event) {
        let tag = event.tag;
        if (ALCHEMY_EVENT_TYPES.includes(event.type)) {
          if (this._events.filter((e) => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {
            return;
          }
        } else if (event.type === "tx") {
          if (this._events.filter((e) => e.type === "tx").length) {
            return;
          }
          tag = "tx";
        } else if (this.listenerCount(event.event)) {
          return;
        }
        const subId = this._subIds[tag];
        if (!subId) {
          return;
        }
        delete this._subIds[tag];
        void subId.then((subId2) => {
          if (!this._subs[subId2]) {
            return;
          }
          delete this._subs[subId2];
          void this.send("eth_unsubscribe", [subId2]);
        });
      }
      addSocketListeners() {
        this._websocket.addEventListener("message", this.handleMessage);
        this._websocket.addEventListener("reopen", this.handleReopen);
        this._websocket.addEventListener("down", this.stopHeartbeatAndBackfill);
      }
      removeSocketListeners() {
        this._websocket.removeEventListener("message", this.handleMessage);
        this._websocket.removeEventListener("reopen", this.handleReopen);
        this._websocket.removeEventListener("down", this.stopHeartbeatAndBackfill);
      }
      resubscribeAndBackfill(isCancelled, subscription) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;
          subscription.isBackfilling = true;
          backfillBuffer.length = 0;
          try {
            const physicalId = yield this.send(method, params);
            throwIfCancelled(isCancelled);
            subscription.physicalId = physicalId;
            this.virtualIdsByPhysicalId.set(physicalId, virtualId);
            switch (params[0]) {
              case "newHeads": {
                const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());
                throwIfCancelled(isCancelled);
                const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);
                events.forEach((event) => this.emitNewHeadsEvent(virtualId, event));
                break;
              }
              case "logs": {
                const filter = params[1] || {};
                const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());
                throwIfCancelled(isCancelled);
                const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);
                events.forEach((event) => this.emitLogsEvent(virtualId, event));
                break;
              }
              default:
                break;
            }
          } finally {
            subscription.isBackfilling = false;
            backfillBuffer.length = 0;
          }
        });
      }
      emitNewHeadsEvent(virtualId, result) {
        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);
      }
      emitLogsEvent(virtualId, result) {
        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);
      }
      emitAndRememberEvent(virtualId, result, getBlockNumber2) {
        this.rememberEvent(virtualId, result, getBlockNumber2);
        this.emitEvent(virtualId, result);
      }
      emitEvent(virtualId, result) {
        const subscription = this.virtualSubscriptionsById.get(virtualId);
        if (!subscription) {
          return;
        }
        this.emitGenericEvent(subscription, result);
      }
      rememberEvent(virtualId, result, getBlockNumber2) {
        const subscription = this.virtualSubscriptionsById.get(virtualId);
        if (!subscription) {
          return;
        }
        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber2);
      }
      emitGenericEvent(subscription, result) {
        const emitFunction = this.emitProcessFn(subscription.event);
        emitFunction(result);
      }
      startHeartbeat() {
        if (this.heartbeatIntervalId != null) {
          return;
        }
        this.heartbeatIntervalId = setInterval(() => __awaiter$1(this, void 0, void 0, function* () {
          try {
            yield withTimeout(this.send("net_version"), HEARTBEAT_WAIT_TIME);
          } catch (_a) {
            this._websocket.reconnect();
          }
        }), HEARTBEAT_INTERVAL);
      }
      sendBatchConcurrently(payload) {
        return __awaiter$1(this, void 0, void 0, function* () {
          return Promise.all(payload.map((req) => this.send(req.method, req.params)));
        });
      }
      customStartEvent(event) {
        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
          const { fromAddress, toAddress, hashesOnly } = event;
          void this._subscribe(event.tag, [
            AlchemySubscription.PENDING_TRANSACTIONS,
            { fromAddress, toAddress, hashesOnly }
          ], this.emitProcessFn(event), event);
        } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {
          const { addresses, includeRemoved, hashesOnly } = event;
          void this._subscribe(event.tag, [
            AlchemySubscription.MINED_TRANSACTIONS,
            { addresses, includeRemoved, hashesOnly }
          ], this.emitProcessFn(event), event);
        } else if (event.type === "block") {
          void this._subscribe("block", ["newHeads"], this.emitProcessFn(event), event);
        } else if (event.type === "filter") {
          void this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], this.emitProcessFn(event), event);
        }
      }
      emitProcessFn(event) {
        switch (event.type) {
          case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:
            return (result) => this.emit({
              method: AlchemySubscription.PENDING_TRANSACTIONS,
              fromAddress: event.fromAddress,
              toAddress: event.toAddress,
              hashesOnly: event.hashesOnly
            }, result);
          case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:
            return (result) => this.emit({
              method: AlchemySubscription.MINED_TRANSACTIONS,
              addresses: event.addresses,
              includeRemoved: event.includeRemoved,
              hashesOnly: event.hashesOnly
            }, result);
          case "block":
            return (result) => {
              const blockNumber = import_bignumber8.BigNumber.from(result.number).toNumber();
              this._emitted.block = blockNumber;
              this.emit("block", blockNumber);
            };
          case "filter":
            return (result) => {
              if (result.removed == null) {
                result.removed = false;
              }
              this.emit(event.filter, this.formatter.filterLog(result));
            };
          default:
            throw new Error("Invalid event type to `emitProcessFn()`");
        }
      }
      _off(eventName, listener) {
        if (listener == null) {
          return this.removeAllListeners(eventName);
        }
        const stopped = [];
        let found = false;
        const eventTag = getAlchemyEventTag(eventName);
        this._events = this._events.filter((event) => {
          if (event.tag !== eventTag || event.listener != listener) {
            return true;
          }
          if (found) {
            return true;
          }
          found = true;
          stopped.push(event);
          return false;
        });
        stopped.forEach((event) => {
          this._stopEvent(event);
        });
        return this;
      }
      _removeAllListeners(eventName) {
        let stopped = [];
        if (eventName == null) {
          stopped = this._events;
          this._events = [];
        } else {
          const eventTag = getAlchemyEventTag(eventName);
          this._events = this._events.filter((event) => {
            if (event.tag !== eventTag) {
              return true;
            }
            stopped.push(event);
            return false;
          });
        }
        stopped.forEach((event) => {
          this._stopEvent(event);
        });
        return this;
      }
      _listenerCount(eventName) {
        if (!eventName) {
          return this._events.length;
        }
        const eventTag = getAlchemyEventTag(eventName);
        return this._events.filter((event) => {
          return event.tag === eventTag;
        }).length;
      }
      _listeners(eventName) {
        if (eventName == null) {
          return this._events.map((event) => event.listener);
        }
        const eventTag = getAlchemyEventTag(eventName);
        return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
      }
    };
    MIN_RETRY_DELAY = 1e3;
    RETRY_BACKOFF_FACTOR = 2;
    MAX_RETRY_DELAY = 3e4;
  }
});

// ../node_modules/alchemy-sdk/dist/esm/index-8bd23ae5.js
function __awaiter$1(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values2(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function getAlchemyHttpUrl(network, apiKey) {
  return `https://${network}.g.alchemy.com/v2/${apiKey}`;
}
function getAlchemyNftHttpUrl(network, apiKey) {
  return `https://${network}.g.alchemy.com/nft/v2/${apiKey}`;
}
function getAlchemyWsUrl(network, apiKey) {
  return `wss://${network}.g.alchemy.com/v2/${apiKey}`;
}
function getAlchemyWebhookHttpUrl() {
  return "https://dashboard.alchemy.com/api";
}
function noop2() {
}
function _checkNormalize2() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
function defineReadOnly9(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value,
    writable: false
  });
}
function resolveProperties3(object) {
  return __awaiter4(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map((key) => {
      const value = object[key];
      return Promise.resolve(value).then((v) => ({ key, value: v }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function _isFrozen(object) {
  if (object === void 0 || object === null || opaque[typeof object]) {
    return true;
  }
  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      let value = null;
      try {
        value = object[keys[i]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger14.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    return Object.freeze(object.map((item) => deepCopy2(item)));
  }
  if (typeof object === "object") {
    const result = {};
    for (const key in object) {
      const value = object[key];
      if (value === void 0) {
        continue;
      }
      defineReadOnly9(result, key, deepCopy2(value));
    }
    return result;
  }
  return logger14.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy2(object) {
  return _deepCopy(object);
}
function fromHex(hexString) {
  return import_bignumber9.BigNumber.from(hexString).toNumber();
}
function toHex(num) {
  return import_bignumber9.BigNumber.from(num).toHexString();
}
function isHex(possibleHexString) {
  return /^0x[0-9a-fA-F]+$/.test(possibleHexString);
}
function formatBlock(block) {
  if (typeof block === "string") {
    return block;
  } else if (Number.isInteger(block)) {
    return toHex(block);
  }
  return block.toString();
}
function stringToEnum(x, enumb) {
  return Object.values(enumb).includes(x) ? x : void 0;
}
function getNftContractFromRaw(rawNftContract) {
  return {
    address: rawNftContract.address,
    name: rawNftContract.contractMetadata.name,
    symbol: rawNftContract.contractMetadata.symbol,
    totalSupply: rawNftContract.contractMetadata.totalSupply,
    tokenType: parseNftTokenType(rawNftContract.contractMetadata.tokenType),
    openSea: parseOpenSeaMetadata(rawNftContract.contractMetadata.openSea),
    contractDeployer: rawNftContract.contractMetadata.contractDeployer,
    deployedBlockNumber: rawNftContract.contractMetadata.deployedBlockNumber
  };
}
function getBaseNftFromRaw(rawBaseNft, contractAddress) {
  var _a;
  return {
    contract: contractAddress ? { address: contractAddress } : rawBaseNft.contract,
    tokenId: import_bignumber9.BigNumber.from(rawBaseNft.id.tokenId).toString(),
    tokenType: parseNftTokenType((_a = rawBaseNft.id.tokenMetadata) === null || _a === void 0 ? void 0 : _a.tokenType)
  };
}
function getNftFromRaw(rawNft) {
  var _a, _b, _c, _d, _e, _f, _g;
  try {
    const tokenType = parseNftTokenType((_a = rawNft.id.tokenMetadata) === null || _a === void 0 ? void 0 : _a.tokenType);
    const spamInfo = parseSpamInfo(rawNft.spamInfo);
    return {
      contract: {
        address: rawNft.contract.address,
        name: (_b = rawNft.contractMetadata) === null || _b === void 0 ? void 0 : _b.name,
        symbol: (_c = rawNft.contractMetadata) === null || _c === void 0 ? void 0 : _c.symbol,
        totalSupply: (_d = rawNft.contractMetadata) === null || _d === void 0 ? void 0 : _d.totalSupply,
        tokenType,
        openSea: parseOpenSeaMetadata((_e = rawNft.contractMetadata) === null || _e === void 0 ? void 0 : _e.openSea),
        contractDeployer: (_f = rawNft.contractMetadata) === null || _f === void 0 ? void 0 : _f.contractDeployer,
        deployedBlockNumber: (_g = rawNft.contractMetadata) === null || _g === void 0 ? void 0 : _g.deployedBlockNumber
      },
      tokenId: parseNftTokenId(rawNft.id.tokenId),
      tokenType,
      title: rawNft.title,
      description: parseNftDescription(rawNft.description),
      timeLastUpdated: rawNft.timeLastUpdated,
      metadataError: rawNft.error,
      rawMetadata: rawNft.metadata,
      tokenUri: parseNftTokenUri(rawNft.tokenUri),
      media: parseNftTokenUriArray(rawNft.media),
      spamInfo,
      acquiredAt: rawNft.acquiredAt
    };
  } catch (e) {
    throw new Error("Error parsing the NFT response: " + e);
  }
}
function getNftSalesFromRaw(rawNftSales) {
  var _a, _b;
  return {
    nftSales: rawNftSales.nftSales.map((rawNftSale) => ({
      marketplace: parseNftSaleMarketplace(rawNftSale.marketplace),
      contractAddress: rawNftSale.contractAddress,
      tokenId: rawNftSale.tokenId,
      quantity: rawNftSale.quantity,
      buyerAddress: rawNftSale.buyerAddress,
      sellerAddress: rawNftSale.sellerAddress,
      taker: parseNftTaker(rawNftSale.taker),
      sellerFee: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.sellerFee,
      marketplaceFee: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.protocolFee,
      protocolFee: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.protocolFee,
      royaltyFee: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.royaltyFee,
      blockNumber: rawNftSale === null || rawNftSale === void 0 ? void 0 : rawNftSale.blockNumber,
      logIndex: rawNftSale.logIndex,
      bundleIndex: rawNftSale.bundleIndex,
      transactionHash: rawNftSale.transactionHash
    })),
    validAt: {
      blockNumber: rawNftSales.validAt.blockNumber,
      blockHash: (_a = rawNftSales.validAt.blockHash) !== null && _a !== void 0 ? _a : void 0,
      blockTimestamp: (_b = rawNftSales.validAt.blockTimestamp) !== null && _b !== void 0 ? _b : void 0
    },
    pageKey: rawNftSales === null || rawNftSales === void 0 ? void 0 : rawNftSales.pageKey
  };
}
function parseNftSaleMarketplace(marketplace) {
  switch (marketplace) {
    case "looksrare":
      return NftSaleMarketplace.LOOKSRARE;
    case "seaport":
      return NftSaleMarketplace.SEAPORT;
    case "x2y2":
      return NftSaleMarketplace.X2Y2;
    case "wyvern":
      return NftSaleMarketplace.WYVERN;
    case "cryptopunks":
      return NftSaleMarketplace.CRYPTOPUNKS;
    case "blur":
      return NftSaleMarketplace.BLUR;
    default:
      return NftSaleMarketplace.UNKNOWN;
  }
}
function parseNftTaker(taker) {
  switch (taker.toLowerCase()) {
    case "buyer":
      return NftSaleTakerType.BUYER;
    case "seller":
      return NftSaleTakerType.SELLER;
    default:
      throw new Error(`Unsupported NftSaleTakerType ${taker}`);
  }
}
function getNftRarityFromRaw(rawNftRarity) {
  return rawNftRarity.map(({ prevalence, trait_type, value }) => ({
    prevalence,
    traitType: trait_type,
    value
  }));
}
function getContractsForOwnerFromRaw(rawContractsForOwner) {
  return {
    pageKey: rawContractsForOwner === null || rawContractsForOwner === void 0 ? void 0 : rawContractsForOwner.pageKey,
    totalCount: rawContractsForOwner.totalCount,
    contracts: rawContractsForOwner.contracts.map((contract) => {
      return {
        address: contract.address,
        totalSupply: contract.totalSupply,
        isSpam: contract.isSpam,
        media: contract.media,
        numDistinctTokensOwned: contract.numDistinctTokensOwned,
        tokenId: contract.tokenId,
        totalBalance: contract.totalBalance,
        name: contract.name,
        title: contract.title,
        openSea: parseOpenSeaMetadata(contract === null || contract === void 0 ? void 0 : contract.opensea),
        symbol: contract === null || contract === void 0 ? void 0 : contract.symbol,
        tokenType: parseNftTokenType(contract === null || contract === void 0 ? void 0 : contract.tokenType),
        contractDeployer: contract.contractDeployer,
        deployedBlockNumber: contract.deployedBlockNumber
      };
    })
  };
}
function parseNftTokenId(tokenId) {
  return import_bignumber9.BigNumber.from(tokenId).toString();
}
function parseNftTokenType(tokenType) {
  switch (tokenType) {
    case "erc721":
    case "ERC721":
      return NftTokenType.ERC721;
    case "erc1155":
    case "ERC1155":
      return NftTokenType.ERC1155;
    case "no_supported_nft_standard":
    case "NO_SUPPORTED_NFT_STANDARD":
      return NftTokenType.NO_SUPPORTED_NFT_STANDARD;
    case "not_a_contract":
    case "NOT_A_CONTRACT":
      return NftTokenType.NOT_A_CONTRACT;
    default:
      return NftTokenType.UNKNOWN;
  }
}
function parseSpamInfo(spamInfo) {
  if (!spamInfo) {
    return void 0;
  }
  const { isSpam, classifications } = spamInfo;
  return {
    isSpam: isSpam === "true",
    classifications
  };
}
function parseNftDescription(description) {
  if (description === void 0) {
    return "";
  }
  if (!Array.isArray(description) && typeof description === "object") {
    return JSON.stringify(description);
  }
  return typeof description === "string" ? description : description.join(" ");
}
function parseNftTokenUri(uri) {
  if (uri && uri.raw.length === 0 && uri.gateway.length == 0) {
    return void 0;
  }
  return uri;
}
function parseNftTokenUriArray(arr) {
  if (arr === void 0) {
    return [];
  }
  return arr.filter((uri) => parseNftTokenUri(uri) !== void 0);
}
function parseOpenSeaMetadata(openSea) {
  if (openSea === void 0) {
    return void 0;
  }
  return {
    floorPrice: openSea.floorPrice,
    collectionName: openSea.collectionName,
    safelistRequestStatus: openSea.safelistRequestStatus !== void 0 ? stringToEnum(openSea.safelistRequestStatus, OpenSeaSafelistRequestStatus) : void 0,
    imageUrl: openSea.imageUrl,
    description: openSea.description,
    externalUrl: openSea.externalUrl,
    twitterUsername: openSea.twitterUsername,
    discordUrl: openSea.discordUrl,
    lastIngestedAt: openSea.lastIngestedAt
  };
}
function nullsToUndefined(obj) {
  if (obj === null) {
    return void 0;
  }
  if (typeof obj === "object") {
    for (const key in obj) {
      obj[key] = nullsToUndefined(obj[key]);
    }
  }
  return obj;
}
function getAssetTransfers(config2, params, srcMethod = "getAssetTransfers") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const provider = yield config2.getProvider();
    if (params.fromAddress) {
      params.fromAddress = yield provider._getAddress(params.fromAddress);
    }
    if (params.toAddress) {
      params.toAddress = yield provider._getAddress(params.toAddress);
    }
    return provider._send("alchemy_getAssetTransfers", [
      Object.assign(Object.assign({}, params), { fromBlock: params.fromBlock != null ? formatBlock(params.fromBlock) : void 0, toBlock: params.toBlock != null ? formatBlock(params.toBlock) : void 0, maxCount: params.maxCount != null ? toHex(params.maxCount) : void 0 })
    ], srcMethod);
  });
}
function getTransactionReceipts(config2, params, srcMethod = "getTransactionReceipts") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const provider = yield config2.getProvider();
    return provider._send("alchemy_getTransactionReceipts", [params], srcMethod);
  });
}
function getLogs(config2, filter) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const provider = yield config2.getProvider();
    yield provider.getNetwork();
    const params = yield resolveProperties3({
      filter: getFilter(config2, filter)
    });
    const logs = yield provider.send("eth_getLogs", [params.filter]);
    logs.forEach((log) => {
      if (log.removed == null) {
        log.removed = false;
      }
    });
    return arrayOf(provider.formatter.filterLog.bind(provider.formatter))(logs);
  });
}
function getFilter(config2, filter) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const provider = yield config2.getProvider();
    const resolvedFilter = yield filter;
    let result = {};
    ["blockHash", "topics"].forEach((key) => {
      if (resolvedFilter[key] == null) {
        return;
      }
      result[key] = resolvedFilter[key];
    });
    ["fromBlock", "toBlock"].forEach((key) => {
      if (resolvedFilter[key] == null) {
        return;
      }
      result[key] = provider._getBlockTag(resolvedFilter[key]);
    });
    result = provider.formatter.filter(yield resolveProperties3(result));
    if (Array.isArray(resolvedFilter.address)) {
      result.address = yield Promise.all(resolvedFilter.address.map((address) => __awaiter$1(this, void 0, void 0, function* () {
        return provider._getAddress(address);
      })));
    } else if (resolvedFilter.address != null) {
      result.address = yield provider._getAddress(resolvedFilter.address);
    }
    return result;
  });
}
function arrayOf(format) {
  return function(array) {
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    const result = [];
    array.forEach((value) => {
      result.push(format(value));
    });
    return result;
  };
}
function binarySearchFirstBlock(start, end, address, config2) {
  return __awaiter$1(this, void 0, void 0, function* () {
    if (start >= end) {
      return end;
    }
    const mid = Math.floor((start + end) / 2);
    const provider = yield config2.getProvider();
    const code = yield provider.getCode(address, mid);
    if (code === ETH_NULL_VALUE) {
      return binarySearchFirstBlock(mid + 1, end, address, config2);
    }
    return binarySearchFirstBlock(start, mid, address, config2);
  });
}
function parseTracerParams(tracer, timeout) {
  return Object.assign({ tracer: tracer.type }, tracer.onlyTopCall !== void 0 && {
    tracerConfig: {
      onlyTopCall: tracer.onlyTopCall,
      timeout
    }
  });
}
function sanitizeTokenType(tokenType) {
  if (tokenType === NftTokenType.ERC1155 || tokenType === NftTokenType.ERC721) {
    return tokenType;
  }
  return void 0;
}
function setLogLevel(logLevel) {
  loggerClient.logLevel = logLevelStringToEnum[logLevel];
}
function logDebug(message, ...args) {
  loggerClient.debug(message, args);
}
function logInfo(message, ...args) {
  loggerClient.info(message, args);
}
function logWarn(message, ...args) {
  loggerClient.warn(message, args);
}
function stringify(obj) {
  if (typeof obj === "string") {
    return obj;
  } else {
    try {
      return JSON.stringify(obj);
    } catch (e) {
      return obj;
    }
  }
}
function sendAxiosRequest(baseUrl, restApiName, methodName, params, overrides) {
  var _a;
  const requestUrl = baseUrl + "/" + restApiName;
  const config2 = Object.assign(Object.assign({}, overrides), { headers: Object.assign(Object.assign(Object.assign({}, overrides === null || overrides === void 0 ? void 0 : overrides.headers), !IS_BROWSER && { "Accept-Encoding": "gzip" }), { "Alchemy-Ethers-Sdk-Version": VERSION, "Alchemy-Ethers-Sdk-Method": methodName }), method: (_a = overrides === null || overrides === void 0 ? void 0 : overrides.method) !== null && _a !== void 0 ? _a : "GET", url: requestUrl, params });
  return (0, import_axios3.default)(config2);
}
function requestHttpWithBackoff(config2, apiType, restApiName, methodName, params, overrides) {
  return __awaiter$1(this, void 0, void 0, function* () {
    let lastError = void 0;
    const backoff = new ExponentialBackoff(config2.maxRetries);
    for (let attempt = 0; attempt < config2.maxRetries + 1; attempt++) {
      try {
        if (lastError !== void 0) {
          logInfo("requestHttp", `Retrying after error: ${lastError.message}`);
        }
        try {
          yield backoff.backoff();
        } catch (err) {
          break;
        }
        const response = yield sendAxiosRequest(config2._getRequestUrl(apiType), restApiName, methodName, params, Object.assign(Object.assign({}, overrides), { timeout: config2.requestTimeout }));
        if (response.status === 200) {
          logDebug(restApiName, `Successful request: ${restApiName}`);
          return response.data;
        } else {
          logInfo(restApiName, `Request failed: ${restApiName}, ${response.status}, ${response.data}`);
          lastError = new Error(response.status + ": " + response.data);
        }
      } catch (err) {
        if (!import_axios3.default.isAxiosError(err) || err.response === void 0) {
          throw err;
        }
        lastError = new Error(err.response.status + ": " + err.response.data);
        if (!isRetryableHttpError(err, apiType)) {
          break;
        }
      }
    }
    return Promise.reject(lastError);
  });
}
function isRetryableHttpError(err, apiType) {
  const retryableCodes = apiType === AlchemyApiType.WEBHOOK ? [429, 500] : [429];
  return err.response !== void 0 && retryableCodes.includes(err.response.status);
}
function paginateEndpoint(config2, apiType, restApiName, methodName, reqPageKey, resPageKey, params) {
  return __asyncGenerator(this, arguments, function* paginateEndpoint_1() {
    let hasNext = true;
    const requestParams = Object.assign({}, params);
    while (hasNext) {
      const response = yield __await(requestHttpWithBackoff(config2, apiType, restApiName, methodName, requestParams));
      yield yield __await(response);
      if (response[resPageKey] !== void 0) {
        requestParams[reqPageKey] = response[resPageKey];
      } else {
        hasNext = false;
      }
    }
  });
}
function getNftMetadata(config2, contractAddress, tokenId, options, srcMethod = "getNftMetadata") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getNFTMetadata", srcMethod, {
      contractAddress,
      tokenId: import_bignumber9.BigNumber.from(tokenId).toString(),
      tokenType: sanitizeTokenType(options === null || options === void 0 ? void 0 : options.tokenType),
      tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,
      refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache
    });
    return getNftFromRaw(response);
  });
}
function getNftMetadataBatch(config2, tokens, options) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const data = {
      tokens,
      tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,
      refreshCache: options === null || options === void 0 ? void 0 : options.refreshCache
    };
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getNFTMetadataBatch", "getNftMetadataBatch", {}, {
      method: "POST",
      data
    });
    return response.map(getNftFromRaw);
  });
}
function getContractMetadata(config2, contractAddress, srcMethod = "getContractMetadata") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getContractMetadata", srcMethod, {
      contractAddress
    });
    return getNftContractFromRaw(response);
  });
}
function getContractMetadataBatch(config2, contractAddresses) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getContractMetadataBatch", "getContractMetadataBatch", {}, {
      method: "POST",
      data: { contractAddresses }
    });
    return response.map(getNftContractFromRaw);
  });
}
function getNftsForOwnerIterator(config2, owner, options, srcMethod = "getNftsForOwnerIterator") {
  return __asyncGenerator(this, arguments, function* getNftsForOwnerIterator_1() {
    var e_1, _a;
    const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);
    try {
      for (var _b = __asyncValues(paginateEndpoint(config2, AlchemyApiType.NFT, "getNFTs", srcMethod, "pageKey", "pageKey", {
        contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,
        pageKey: options === null || options === void 0 ? void 0 : options.pageKey,
        filters: options === null || options === void 0 ? void 0 : options.excludeFilters,
        owner,
        withMetadata
      })), _c; _c = yield __await(_b.next()), !_c.done; ) {
        const response = _c.value;
        for (const ownedNft of response.ownedNfts) {
          yield yield __await(Object.assign(Object.assign({}, nftFromGetNftResponse(ownedNft)), { balance: parseInt(ownedNft.balance) }));
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          yield __await(_a.call(_b));
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  });
}
function getNftsForOwner(config2, owner, options, srcMethod = "getNftsForOwner") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getNFTs", srcMethod, {
      contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,
      pageKey: options === null || options === void 0 ? void 0 : options.pageKey,
      filters: options === null || options === void 0 ? void 0 : options.excludeFilters,
      excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,
      includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,
      owner,
      pageSize: options === null || options === void 0 ? void 0 : options.pageSize,
      withMetadata,
      tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs,
      orderBy: options === null || options === void 0 ? void 0 : options.orderBy
    });
    return {
      ownedNfts: response.ownedNfts.map((res) => Object.assign(Object.assign({}, nftFromGetNftResponse(res)), { balance: parseInt(res.balance) })),
      pageKey: response.pageKey,
      totalCount: response.totalCount,
      blockHash: response.blockHash
    };
  });
}
function getNftsForContract(config2, contractAddress, options, srcMethod = "getNftsForContract") {
  var _a;
  return __awaiter$1(this, void 0, void 0, function* () {
    const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getNFTsForCollection", srcMethod, {
      contractAddress,
      startToken: options === null || options === void 0 ? void 0 : options.pageKey,
      withMetadata,
      limit: (_a = options === null || options === void 0 ? void 0 : options.pageSize) !== null && _a !== void 0 ? _a : void 0,
      tokenUriTimeoutInMs: options === null || options === void 0 ? void 0 : options.tokenUriTimeoutInMs
    });
    return {
      nfts: response.nfts.map((res) => nftFromGetNftContractResponse(res, contractAddress)),
      pageKey: response.nextToken
    };
  });
}
function getNftsForContractIterator(config2, contractAddress, options, srcMethod = "getNftsForContractIterator") {
  return __asyncGenerator(this, arguments, function* getNftsForContractIterator_1() {
    var e_2, _a;
    const withMetadata = omitMetadataToWithMetadata(options === null || options === void 0 ? void 0 : options.omitMetadata);
    try {
      for (var _b = __asyncValues(paginateEndpoint(config2, AlchemyApiType.NFT, "getNFTsForCollection", srcMethod, "startToken", "nextToken", {
        contractAddress,
        startToken: options === null || options === void 0 ? void 0 : options.pageKey,
        withMetadata
      })), _c; _c = yield __await(_b.next()), !_c.done; ) {
        const response = _c.value;
        for (const nft of response.nfts) {
          yield yield __await(nftFromGetNftContractResponse(nft, contractAddress));
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          yield __await(_a.call(_b));
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  });
}
function getOwnersForContract(config2, contractAddress, options, srcMethod = "getOwnersForContract") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getOwnersForCollection", srcMethod, Object.assign(Object.assign({}, options), { contractAddress }));
    return Object.assign({ owners: response.ownerAddresses, totalCount: response.totalCount }, response.pageKey !== void 0 && { pageKey: response.pageKey });
  });
}
function getContractsForOwner(config2, owner, options, srcMethod = "getContractsForOwner") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getContractsForOwner", srcMethod, {
      owner,
      excludeFilters: options === null || options === void 0 ? void 0 : options.excludeFilters,
      includeFilters: options === null || options === void 0 ? void 0 : options.includeFilters,
      pageKey: options === null || options === void 0 ? void 0 : options.pageKey,
      pageSize: options === null || options === void 0 ? void 0 : options.pageSize,
      orderBy: options === null || options === void 0 ? void 0 : options.orderBy
    });
    return getContractsForOwnerFromRaw(response);
  });
}
function getOwnersForNft(config2, contractAddress, tokenId, options, srcMethod = "getOwnersForNft") {
  return __awaiter$1(this, void 0, void 0, function* () {
    return requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getOwnersForToken", srcMethod, Object.assign({ contractAddress, tokenId: import_bignumber9.BigNumber.from(tokenId).toString() }, options));
  });
}
function getMintedNfts(config2, owner, options) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const provider = yield config2.getProvider();
    const ownerAddress = yield provider._getAddress(owner);
    const category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);
    const params = {
      fromBlock: "0x0",
      fromAddress: ETH_NULL_ADDRESS,
      toAddress: ownerAddress,
      excludeZeroValue: true,
      contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,
      category,
      maxCount: 100,
      pageKey: options === null || options === void 0 ? void 0 : options.pageKey
    };
    const response = yield getAssetTransfers(config2, params, "getMintedNfts");
    return getNftsForTransfers(config2, response);
  });
}
function getTransfersForOwner(config2, owner, transferType, options) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const provider = yield config2.getProvider();
    const ownerAddress = yield provider._getAddress(owner);
    const category = nftTokenTypeToCategory(options === null || options === void 0 ? void 0 : options.tokenType);
    const params = {
      fromBlock: "0x0",
      excludeZeroValue: true,
      contractAddresses: options === null || options === void 0 ? void 0 : options.contractAddresses,
      category,
      maxCount: 100,
      pageKey: options === null || options === void 0 ? void 0 : options.pageKey
    };
    if (transferType === GetTransfersForOwnerTransferType.TO) {
      params.toAddress = ownerAddress;
    } else {
      params.fromAddress = ownerAddress;
    }
    const transfersResponse = yield getAssetTransfers(config2, params, "getTransfersForOwner");
    return getNftsForTransfers(config2, transfersResponse);
  });
}
function getTransfersForContract(config2, contract, options) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const category = [
      AssetTransfersCategory.ERC721,
      AssetTransfersCategory.ERC1155,
      AssetTransfersCategory.SPECIALNFT
    ];
    const provider = yield config2.getProvider();
    const fromBlock = (options === null || options === void 0 ? void 0 : options.fromBlock) ? provider.formatter.blockTag(yield provider._getBlockTag(options.fromBlock)) : "0x0";
    const toBlock = (options === null || options === void 0 ? void 0 : options.toBlock) ? provider.formatter.blockTag(yield provider._getBlockTag(options.toBlock)) : void 0;
    const params = {
      fromBlock,
      toBlock,
      excludeZeroValue: true,
      contractAddresses: [contract],
      order: options === null || options === void 0 ? void 0 : options.order,
      category,
      maxCount: 100,
      pageKey: options === null || options === void 0 ? void 0 : options.pageKey
    };
    const transfersResponse = yield getAssetTransfers(config2, params, "getTransfersForContract");
    return getNftsForTransfers(config2, transfersResponse);
  });
}
function nftTokenTypeToCategory(tokenType) {
  switch (tokenType) {
    case NftTokenType.ERC721:
      return [AssetTransfersCategory.ERC721];
    case NftTokenType.ERC1155:
      return [AssetTransfersCategory.ERC1155];
    default:
      return [
        AssetTransfersCategory.ERC721,
        AssetTransfersCategory.ERC1155,
        AssetTransfersCategory.SPECIALNFT
      ];
  }
}
function parse1155Transfer(transfer) {
  return transfer.erc1155Metadata.map((metadata) => ({
    contractAddress: transfer.rawContract.address,
    tokenId: metadata.tokenId,
    tokenType: NftTokenType.ERC1155
  }));
}
function checkNftOwnership(config2, owner, contractAddresses, srcMethod = "checkNftOwnership") {
  return __awaiter$1(this, void 0, void 0, function* () {
    if (contractAddresses.length === 0) {
      throw new Error("Must provide at least one contract address");
    }
    const response = yield getNftsForOwner(config2, owner, {
      contractAddresses,
      omitMetadata: true
    }, srcMethod);
    return response.ownedNfts.length > 0;
  });
}
function verifyNftOwnership(config2, owner, contractAddresses, srcMethod = "verifyNftOwnership") {
  return __awaiter$1(this, void 0, void 0, function* () {
    if (typeof contractAddresses === "string") {
      const response = yield getNftsForOwner(config2, owner, {
        contractAddresses: [contractAddresses],
        omitMetadata: true
      }, srcMethod);
      return response.ownedNfts.length > 0;
    } else {
      if (contractAddresses.length === 0) {
        throw new Error("Must provide at least one contract address");
      }
      const response = yield getNftsForOwner(config2, owner, {
        contractAddresses,
        omitMetadata: true
      }, srcMethod);
      const result = contractAddresses.reduce((acc, curr) => {
        acc[curr] = false;
        return acc;
      }, {});
      for (const nft of response.ownedNfts) {
        result[nft.contract.address] = true;
      }
      return result;
    }
  });
}
function isSpamContract(config2, contractAddress, srcMethod = "isSpamContract") {
  return __awaiter$1(this, void 0, void 0, function* () {
    return requestHttpWithBackoff(config2, AlchemyApiType.NFT, "isSpamContract", srcMethod, {
      contractAddress
    });
  });
}
function getSpamContracts(config2, srcMethod = "getSpamContracts") {
  return __awaiter$1(this, void 0, void 0, function* () {
    return requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getSpamContracts", srcMethod, void 0);
  });
}
function getFloorPrice(config2, contractAddress, srcMethod = "getFloorPrice") {
  return __awaiter$1(this, void 0, void 0, function* () {
    return requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getFloorPrice", srcMethod, {
      contractAddress
    });
  });
}
function getNftSales(config2, options = {}, srcMethod = "getNftSales") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const params = Object.assign({}, options);
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getNFTSales", srcMethod, {
      fromBlock: params === null || params === void 0 ? void 0 : params.fromBlock,
      toBlock: params === null || params === void 0 ? void 0 : params.toBlock,
      order: params === null || params === void 0 ? void 0 : params.order,
      marketplace: params === null || params === void 0 ? void 0 : params.marketplace,
      contractAddress: params === null || params === void 0 ? void 0 : params.contractAddress,
      tokenId: (params === null || params === void 0 ? void 0 : params.tokenId) ? import_bignumber9.BigNumber.from(params === null || params === void 0 ? void 0 : params.tokenId).toString() : void 0,
      sellerAddress: params === null || params === void 0 ? void 0 : params.sellerAddress,
      buyerAddress: params === null || params === void 0 ? void 0 : params.buyerAddress,
      taker: params === null || params === void 0 ? void 0 : params.taker,
      limit: params === null || params === void 0 ? void 0 : params.limit,
      pageKey: params === null || params === void 0 ? void 0 : params.pageKey
    });
    return getNftSalesFromRaw(response);
  });
}
function computeRarity(config2, contractAddress, tokenId, refreshCache, srcMethod = "computeRarity") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "computeRarity", srcMethod, {
      contractAddress,
      tokenId: import_bignumber9.BigNumber.from(tokenId).toString(),
      refreshCache
    });
    return getNftRarityFromRaw(response);
  });
}
function searchContractMetadata(config2, query, srcMethod = "searchContractMetadata") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "searchContractMetadata", srcMethod, {
      query
    });
    return response.map(getNftContractFromRaw);
  });
}
function summarizeNftAttributes(config2, contractAddress, refreshCache, srcMethod = "summarizeNftAttributes") {
  return __awaiter$1(this, void 0, void 0, function* () {
    return requestHttpWithBackoff(config2, AlchemyApiType.NFT, "summarizeNftAttributes", srcMethod, {
      contractAddress,
      refreshCache
    });
  });
}
function refreshNftMetadata(config2, contractAddress, tokenId, srcMethod = "refreshNftMetadata") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const tokenIdString = import_bignumber9.BigNumber.from(tokenId).toString();
    const first = yield getNftMetadata(config2, contractAddress, tokenIdString, void 0, srcMethod);
    const second = yield refresh(config2, contractAddress, tokenIdString, srcMethod);
    return first.timeLastUpdated !== second.timeLastUpdated;
  });
}
function refreshContract(config2, contractAddress, srcMethod = "refreshContract") {
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "reingestContract", srcMethod, {
      contractAddress
    });
    return {
      contractAddress: response.contractAddress,
      refreshState: parseReingestionState(response.reingestionState),
      progress: response.progress
    };
  });
}
function refresh(config2, contractAddress, tokenId, srcMethod) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const response = yield requestHttpWithBackoff(config2, AlchemyApiType.NFT, "getNFTMetadata", srcMethod, {
      contractAddress,
      tokenId: import_bignumber9.BigNumber.from(tokenId).toString(),
      refreshCache: true
    });
    return getNftFromRaw(response);
  });
}
function nftFromGetNftResponse(ownedNft) {
  if (isNftWithMetadata(ownedNft)) {
    return getNftFromRaw(ownedNft);
  } else {
    return getBaseNftFromRaw(ownedNft);
  }
}
function nftFromGetNftContractResponse(ownedNft, contractAddress) {
  if (isNftWithMetadata(ownedNft)) {
    return getNftFromRaw(ownedNft);
  } else {
    return getBaseNftFromRaw(ownedNft, contractAddress);
  }
}
function isNftWithMetadata(response) {
  return response.title !== void 0;
}
function getNftsForTransfers(config2, response) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const metadataTransfers = response.transfers.filter((transfer) => transfer.rawContract.address !== null).flatMap((transfer) => {
      var _a;
      const tokens = getTokensFromTransfer(transfer);
      const metadata = {
        from: transfer.from,
        to: (_a = transfer.to) !== null && _a !== void 0 ? _a : void 0,
        transactionHash: transfer.hash,
        blockNumber: transfer.blockNum
      };
      return tokens.map((token2) => ({ metadata, token: token2 }));
    });
    if (metadataTransfers.length === 0) {
      return { nfts: [] };
    }
    const batchSize = 100;
    const requestBatches = [];
    for (let i = 0; i < metadataTransfers.length; i += batchSize) {
      requestBatches.push(metadataTransfers.slice(i, i + batchSize));
    }
    const responseBatches = yield Promise.all(requestBatches.map((batch) => getNftMetadataBatch(config2, batch.map((transfer) => transfer.token))));
    const nfts = responseBatches.flat();
    const nftsByTokenId = /* @__PURE__ */ new Map();
    nfts.forEach((nft) => {
      const key = `${nft.contract.address}-${import_bignumber9.BigNumber.from(nft.tokenId).toString()}`;
      nftsByTokenId.set(key, nft);
    });
    const transferredNfts = metadataTransfers.map((t) => {
      const key = `${t.token.contractAddress}-${import_bignumber9.BigNumber.from(t.token.tokenId).toString()}`;
      return Object.assign(Object.assign({}, nftsByTokenId.get(key)), t.metadata);
    });
    return {
      nfts: transferredNfts,
      pageKey: response.pageKey
    };
  });
}
function getTokensFromTransfer(transfer) {
  if (transfer.category === AssetTransfersCategory.ERC1155) {
    return parse1155Transfer(transfer);
  } else {
    return [
      {
        contractAddress: transfer.rawContract.address,
        tokenId: transfer.tokenId,
        tokenType: transfer.category === AssetTransfersCategory.ERC721 ? NftTokenType.ERC721 : void 0
      }
    ];
  }
}
function omitMetadataToWithMetadata(omitMetadata) {
  return omitMetadata === void 0 ? true : !omitMetadata;
}
function parseReingestionState(reingestionState) {
  switch (reingestionState) {
    case "does_not_exist":
      return RefreshState.DOES_NOT_EXIST;
    case "already_queued":
      return RefreshState.ALREADY_QUEUED;
    case "in_progress":
      return RefreshState.IN_PROGRESS;
    case "finished":
      return RefreshState.FINISHED;
    case "queued":
      return RefreshState.QUEUED;
    case "queue_failed":
      return RefreshState.QUEUE_FAILED;
    default:
      throw new Error("Unknown reingestion state: " + reingestionState);
  }
}
function parseRawWebhookResponse(response) {
  return response.data.map(parseRawWebhook);
}
function parseRawWebhook(rawWebhook) {
  return Object.assign({ id: rawWebhook.id, network: WEBHOOK_NETWORK_TO_NETWORK[rawWebhook.network], type: rawWebhook.webhook_type, url: rawWebhook.webhook_url, isActive: rawWebhook.is_active, timeCreated: new Date(rawWebhook.time_created).toISOString(), signingKey: rawWebhook.signing_key, version: rawWebhook.version }, rawWebhook.app_id !== void 0 && { appId: rawWebhook.app_id });
}
function parseRawAddressActivityResponse(response) {
  return {
    addresses: response.data,
    totalCount: response.pagination.total_count,
    pageKey: response.pagination.cursors.after
  };
}
function parseRawCustomGraphqlWebhookResponse(response) {
  return {
    graphqlQuery: response.data.graphql_query
  };
}
function parseRawNftFiltersResponse(response) {
  return {
    filters: response.data.map((f) => f.token_id ? {
      contractAddress: f.contract_address,
      tokenId: import_bignumber9.BigNumber.from(f.token_id).toString()
    } : {
      contractAddress: f.contract_address
    }),
    totalCount: response.pagination.total_count,
    pageKey: response.pagination.cursors.after
  };
}
function nftFilterToParam(filter) {
  return filter.tokenId ? {
    contract_address: filter.contractAddress,
    token_id: import_bignumber9.BigNumber.from(filter.tokenId).toString()
  } : {
    contract_address: filter.contractAddress
  };
}
function generateGasSpreadTransactions(transaction, gasLimit, baseFee, priorityFee) {
  return GAS_OPTIMIZED_TX_FEE_MULTIPLES.map((feeMultiplier) => {
    return Object.assign(Object.assign({}, transaction), { gasLimit, maxFeePerGas: Math.round(baseFee * feeMultiplier + priorityFee * feeMultiplier), maxPriorityFeePerGas: Math.round(feeMultiplier * priorityFee) });
  });
}
function isAlchemyEvent(event) {
  return typeof event === "object" && "method" in event;
}
function getAlchemyEventTag(event) {
  if (!isAlchemyEvent(event)) {
    throw new Error("Event tag requires AlchemyEventType");
  }
  if (event.method === AlchemySubscription.PENDING_TRANSACTIONS) {
    return serializePendingTransactionsEvent(event);
  } else if (event.method === AlchemySubscription.MINED_TRANSACTIONS) {
    return serializeMinedTransactionsEvent(event);
  } else {
    throw new Error(`Unrecognized AlchemyFilterEvent: ${event}`);
  }
}
function verifyAlchemyEventName(eventName) {
  if (!Object.values(AlchemySubscription).includes(eventName.method)) {
    throw new Error(`Invalid method name ${eventName.method}. Accepted method names: ${Object.values(AlchemySubscription)}`);
  }
}
function serializePendingTransactionsEvent(event) {
  const fromAddress = serializeAddressField(event.fromAddress);
  const toAddress = serializeAddressField(event.toAddress);
  const hashesOnly = serializeBooleanField(event.hashesOnly);
  return ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE + ":" + fromAddress + ":" + toAddress + ":" + hashesOnly;
}
function serializeMinedTransactionsEvent(event) {
  const addresses = serializeAddressesField(event.addresses);
  const includeRemoved = serializeBooleanField(event.includeRemoved);
  const hashesOnly = serializeBooleanField(event.hashesOnly);
  return ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE + ":" + addresses + ":" + includeRemoved + ":" + hashesOnly;
}
function serializeAddressesField(addresses) {
  if (addresses === void 0) {
    return "*";
  }
  return addresses.map((filter) => serializeAddressField(filter.to) + "," + serializeAddressField(filter.from)).join("|");
}
function serializeAddressField(field) {
  if (field === void 0) {
    return "*";
  } else if (Array.isArray(field)) {
    return field.join("|");
  } else {
    return field;
  }
}
function serializeBooleanField(field) {
  if (field === void 0) {
    return "*";
  } else {
    return field.toString();
  }
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function deserializeAddressField(data) {
  if (data === "") {
    return void 0;
  }
  const addresses = data.split("|");
  return addresses.length === 1 ? addresses[0] : addresses;
}
function deserializeAddressesField(data) {
  if (data === "") {
    return void 0;
  }
  return data.split("|").map((addressStr) => addressStr.split(",")).map((addressPair) => Object.assign(Object.assign({}, addressPair[0] !== "*" && { to: addressPair[0] }), addressPair[1] !== "*" && { from: addressPair[1] }));
}
var import_bignumber9, import_axios3, import_abstract_provider3, Network, TokenBalanceType, AssetTransfersCategory, AssetTransfersOrder, NftTokenType, NftSpamClassification, NftExcludeFilters, NftFilters, NftOrdering, GetTransfersForOwnerTransferType, SortingOrder, NftSaleMarketplace, NftSaleTakerType, RefreshState, OpenSeaSafelistRequestStatus, AlchemySubscription, SimulateAssetType, SimulateChangeType, DecodingAuthority, DebugCallType, GasOptimizedTransactionStatus, WebhookVersion, WebhookType, CommitmentLevel, DebugTracerType, DEFAULT_ALCHEMY_API_KEY, DEFAULT_NETWORK, DEFAULT_MAX_RETRIES, DEFAULT_REQUEST_TIMEOUT, AlchemyApiType, EthersNetwork, CustomNetworks, ETH_NULL_VALUE, ETH_NULL_ADDRESS, AlchemyConfig, version$12, _permanentCensorErrors2, _censorErrors2, LogLevels2, _logLevel2, _globalLogger2, _normalizeError2, LogLevel$1, ErrorCode2, HEX2, Logger$1, version9, __awaiter4, logger14, opaque, IS_BROWSER, CoreNamespace, DebugNamespace, LogLevel2, logLevelStringToEnum, logLevelToConsoleFn, DEFAULT_LOG_LEVEL, Logger14, loggerClient, VERSION, DEFAULT_BACKOFF_INITIAL_DELAY_MS, DEFAULT_BACKOFF_MULTIPLIER, DEFAULT_BACKOFF_MAX_DELAY_MS, DEFAULT_BACKOFF_MAX_ATTEMPTS, ExponentialBackoff, NftNamespace, NotifyNamespace, WEBHOOK_NETWORK_TO_NETWORK, NETWORK_TO_WEBHOOK_NETWORK, GAS_OPTIMIZED_TX_FEE_MULTIPLES, TransactNamespace, ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, ALCHEMY_EVENT_TYPES, Event, EthersEvent, WebSocketNamespace, Alchemy, Wallet2, Contract2, ContractFactory2;
var init_index_8bd23ae5 = __esm({
  "../node_modules/alchemy-sdk/dist/esm/index-8bd23ae5.js"() {
    init_utils3();
    import_bignumber9 = __toESM(require_lib3());
    import_axios3 = __toESM(require_axios2());
    import_abstract_provider3 = __toESM(require_lib5());
    init_lib7();
    init_lib8();
    (function(Network2) {
      Network2["ETH_MAINNET"] = "eth-mainnet";
      Network2["ETH_ROPSTEN"] = "eth-ropsten";
      Network2["ETH_GOERLI"] = "eth-goerli";
      Network2["ETH_KOVAN"] = "eth-kovan";
      Network2["ETH_RINKEBY"] = "eth-rinkeby";
      Network2["ETH_SEPOLIA"] = "eth-sepolia";
      Network2["OPT_MAINNET"] = "opt-mainnet";
      Network2["OPT_KOVAN"] = "opt-kovan";
      Network2["OPT_GOERLI"] = "opt-goerli";
      Network2["ARB_MAINNET"] = "arb-mainnet";
      Network2["ARB_RINKEBY"] = "arb-rinkeby";
      Network2["ARB_GOERLI"] = "arb-goerli";
      Network2["MATIC_MAINNET"] = "polygon-mainnet";
      Network2["MATIC_MUMBAI"] = "polygon-mumbai";
      Network2["ASTAR_MAINNET"] = "astar-mainnet";
      Network2["POLYGONZKEVM_MAINNET"] = "polygonzkevm-mainnet";
      Network2["POLYGONZKEVM_TESTNET"] = "polygonzkevm-testnet";
    })(Network || (Network = {}));
    (function(TokenBalanceType2) {
      TokenBalanceType2["DEFAULT_TOKENS"] = "DEFAULT_TOKENS";
      TokenBalanceType2["ERC20"] = "erc20";
    })(TokenBalanceType || (TokenBalanceType = {}));
    (function(AssetTransfersCategory2) {
      AssetTransfersCategory2["EXTERNAL"] = "external";
      AssetTransfersCategory2["INTERNAL"] = "internal";
      AssetTransfersCategory2["ERC20"] = "erc20";
      AssetTransfersCategory2["ERC721"] = "erc721";
      AssetTransfersCategory2["ERC1155"] = "erc1155";
      AssetTransfersCategory2["SPECIALNFT"] = "specialnft";
    })(AssetTransfersCategory || (AssetTransfersCategory = {}));
    (function(AssetTransfersOrder2) {
      AssetTransfersOrder2["ASCENDING"] = "asc";
      AssetTransfersOrder2["DESCENDING"] = "desc";
    })(AssetTransfersOrder || (AssetTransfersOrder = {}));
    (function(NftTokenType2) {
      NftTokenType2["ERC721"] = "ERC721";
      NftTokenType2["ERC1155"] = "ERC1155";
      NftTokenType2["NO_SUPPORTED_NFT_STANDARD"] = "NO_SUPPORTED_NFT_STANDARD";
      NftTokenType2["NOT_A_CONTRACT"] = "NOT_A_CONTRACT";
      NftTokenType2["UNKNOWN"] = "UNKNOWN";
    })(NftTokenType || (NftTokenType = {}));
    (function(NftSpamClassification2) {
      NftSpamClassification2["Erc721TooManyOwners"] = "Erc721TooManyOwners";
      NftSpamClassification2["Erc721TooManyTokens"] = "Erc721TooManyTokens";
      NftSpamClassification2["Erc721DishonestTotalSupply"] = "Erc721DishonestTotalSupply";
      NftSpamClassification2["MostlyHoneyPotOwners"] = "MostlyHoneyPotOwners";
      NftSpamClassification2["OwnedByMostHoneyPots"] = "OwnedByMostHoneyPots";
    })(NftSpamClassification || (NftSpamClassification = {}));
    (function(NftExcludeFilters2) {
      NftExcludeFilters2["SPAM"] = "SPAM";
      NftExcludeFilters2["AIRDROPS"] = "AIRDROPS";
    })(NftExcludeFilters || (NftExcludeFilters = {}));
    (function(NftFilters2) {
      NftFilters2["SPAM"] = "SPAM";
      NftFilters2["AIRDROPS"] = "AIRDROPS";
    })(NftFilters || (NftFilters = {}));
    (function(NftOrdering2) {
      NftOrdering2["TRANSFERTIME"] = "TRANSFERTIME";
    })(NftOrdering || (NftOrdering = {}));
    (function(GetTransfersForOwnerTransferType2) {
      GetTransfersForOwnerTransferType2["TO"] = "TO";
      GetTransfersForOwnerTransferType2["FROM"] = "FROM";
    })(GetTransfersForOwnerTransferType || (GetTransfersForOwnerTransferType = {}));
    (function(SortingOrder2) {
      SortingOrder2["ASCENDING"] = "asc";
      SortingOrder2["DESCENDING"] = "desc";
    })(SortingOrder || (SortingOrder = {}));
    (function(NftSaleMarketplace2) {
      NftSaleMarketplace2["SEAPORT"] = "seaport";
      NftSaleMarketplace2["LOOKSRARE"] = "looksrare";
      NftSaleMarketplace2["X2Y2"] = "x2y2";
      NftSaleMarketplace2["WYVERN"] = "wyvern";
      NftSaleMarketplace2["CRYPTOPUNKS"] = "cryptopunks";
      NftSaleMarketplace2["BLUR"] = "blur";
      NftSaleMarketplace2["UNKNOWN"] = "unknown";
    })(NftSaleMarketplace || (NftSaleMarketplace = {}));
    (function(NftSaleTakerType2) {
      NftSaleTakerType2["BUYER"] = "buyer";
      NftSaleTakerType2["SELLER"] = "seller";
    })(NftSaleTakerType || (NftSaleTakerType = {}));
    (function(RefreshState2) {
      RefreshState2["DOES_NOT_EXIST"] = "does_not_exist";
      RefreshState2["ALREADY_QUEUED"] = "already_queued";
      RefreshState2["IN_PROGRESS"] = "in_progress";
      RefreshState2["FINISHED"] = "finished";
      RefreshState2["QUEUED"] = "queued";
      RefreshState2["QUEUE_FAILED"] = "queue_failed";
    })(RefreshState || (RefreshState = {}));
    (function(OpenSeaSafelistRequestStatus2) {
      OpenSeaSafelistRequestStatus2["VERIFIED"] = "verified";
      OpenSeaSafelistRequestStatus2["APPROVED"] = "approved";
      OpenSeaSafelistRequestStatus2["REQUESTED"] = "requested";
      OpenSeaSafelistRequestStatus2["NOT_REQUESTED"] = "not_requested";
    })(OpenSeaSafelistRequestStatus || (OpenSeaSafelistRequestStatus = {}));
    (function(AlchemySubscription2) {
      AlchemySubscription2["PENDING_TRANSACTIONS"] = "alchemy_pendingTransactions";
      AlchemySubscription2["MINED_TRANSACTIONS"] = "alchemy_minedTransactions";
    })(AlchemySubscription || (AlchemySubscription = {}));
    (function(SimulateAssetType2) {
      SimulateAssetType2["NATIVE"] = "NATIVE";
      SimulateAssetType2["ERC20"] = "ERC20";
      SimulateAssetType2["ERC721"] = "ERC721";
      SimulateAssetType2["ERC1155"] = "ERC1155";
      SimulateAssetType2["SPECIAL_NFT"] = "SPECIAL_NFT";
    })(SimulateAssetType || (SimulateAssetType = {}));
    (function(SimulateChangeType2) {
      SimulateChangeType2["APPROVE"] = "APPROVE";
      SimulateChangeType2["TRANSFER"] = "TRANSFER";
    })(SimulateChangeType || (SimulateChangeType = {}));
    (function(DecodingAuthority2) {
      DecodingAuthority2["ETHERSCAN"] = "ETHERSCAN";
    })(DecodingAuthority || (DecodingAuthority = {}));
    (function(DebugCallType2) {
      DebugCallType2["CREATE"] = "CREATE";
      DebugCallType2["CALL"] = "CALL";
      DebugCallType2["STATICCALL"] = "STATICCALL";
      DebugCallType2["DELEGATECALL"] = "DELEGATECALL";
    })(DebugCallType || (DebugCallType = {}));
    (function(GasOptimizedTransactionStatus2) {
      GasOptimizedTransactionStatus2["UNSPECIFIED"] = "TRANSACTION_JOB_STATUS_UNSPECIFIED";
      GasOptimizedTransactionStatus2["IN_PROGRESS"] = "IN_PROGRESS";
      GasOptimizedTransactionStatus2["COMPLETE"] = "COMPLETE";
      GasOptimizedTransactionStatus2["ABANDONED"] = "ABANDONED";
    })(GasOptimizedTransactionStatus || (GasOptimizedTransactionStatus = {}));
    (function(WebhookVersion2) {
      WebhookVersion2["V1"] = "V1";
      WebhookVersion2["V2"] = "V2";
    })(WebhookVersion || (WebhookVersion = {}));
    (function(WebhookType2) {
      WebhookType2["MINED_TRANSACTION"] = "MINED_TRANSACTION";
      WebhookType2["DROPPED_TRANSACTION"] = "DROPPED_TRANSACTION";
      WebhookType2["ADDRESS_ACTIVITY"] = "ADDRESS_ACTIVITY";
      WebhookType2["NFT_ACTIVITY"] = "NFT_ACTIVITY";
      WebhookType2["NFT_METADATA_UPDATE"] = "NFT_METADATA_UPDATE";
      WebhookType2["GRAPHQL"] = "GRAPHQL";
    })(WebhookType || (WebhookType = {}));
    (function(CommitmentLevel2) {
      CommitmentLevel2["PENDING"] = "pending";
      CommitmentLevel2["LATEST"] = "latest";
      CommitmentLevel2["SAFE"] = "safe";
      CommitmentLevel2["FINALIZED"] = "finalized";
      CommitmentLevel2["EARLIEST"] = "earliest";
    })(CommitmentLevel || (CommitmentLevel = {}));
    (function(DebugTracerType2) {
      DebugTracerType2["CALL_TRACER"] = "callTracer";
      DebugTracerType2["PRESTATE_TRACER"] = "prestateTracer";
    })(DebugTracerType || (DebugTracerType = {}));
    DEFAULT_ALCHEMY_API_KEY = "demo";
    DEFAULT_NETWORK = Network.ETH_MAINNET;
    DEFAULT_MAX_RETRIES = 5;
    DEFAULT_REQUEST_TIMEOUT = 0;
    (function(AlchemyApiType2) {
      AlchemyApiType2[AlchemyApiType2["BASE"] = 0] = "BASE";
      AlchemyApiType2[AlchemyApiType2["NFT"] = 1] = "NFT";
      AlchemyApiType2[AlchemyApiType2["WEBHOOK"] = 2] = "WEBHOOK";
    })(AlchemyApiType || (AlchemyApiType = {}));
    EthersNetwork = {
      [Network.ETH_MAINNET]: "mainnet",
      [Network.ETH_ROPSTEN]: "ropsten",
      [Network.ETH_GOERLI]: "goerli",
      [Network.ETH_KOVAN]: "kovan",
      [Network.ETH_RINKEBY]: "rinkeby",
      [Network.ETH_SEPOLIA]: "sepolia",
      [Network.OPT_MAINNET]: "optimism",
      [Network.OPT_KOVAN]: "optimism-kovan",
      [Network.OPT_GOERLI]: "optimism-goerli",
      [Network.ARB_MAINNET]: "arbitrum",
      [Network.ARB_RINKEBY]: "arbitrum-rinkeby",
      [Network.ARB_GOERLI]: "arbitrum-goerli",
      [Network.MATIC_MAINNET]: "matic",
      [Network.MATIC_MUMBAI]: "maticmum",
      [Network.ASTAR_MAINNET]: "astar-mainnet",
      [Network.POLYGONZKEVM_MAINNET]: "polygonzkevm-mainnet",
      [Network.POLYGONZKEVM_TESTNET]: "polygonzkevm-testnet"
    };
    CustomNetworks = {
      "arbitrum-goerli": {
        chainId: 421613,
        name: "arbitrum-goerli"
      },
      "astar-mainnet": {
        chainId: 592,
        name: "astar-mainnet"
      },
      sepolia: {
        chainId: 11155111,
        name: "sepolia"
      },
      "polygonzkevm-mainnet": {
        chainId: 1101,
        name: "polygonzkevm-mainnet"
      },
      "polygonzkevm-testnet": {
        chainId: 1442,
        name: "polygonzkevm-testnet"
      }
    };
    ETH_NULL_VALUE = "0x";
    ETH_NULL_ADDRESS = "0x0000000000000000000000000000000000000000";
    AlchemyConfig = class {
      constructor(config2) {
        this.apiKey = (config2 === null || config2 === void 0 ? void 0 : config2.apiKey) || DEFAULT_ALCHEMY_API_KEY;
        this.network = (config2 === null || config2 === void 0 ? void 0 : config2.network) || DEFAULT_NETWORK;
        this.maxRetries = (config2 === null || config2 === void 0 ? void 0 : config2.maxRetries) || DEFAULT_MAX_RETRIES;
        this.url = config2 === null || config2 === void 0 ? void 0 : config2.url;
        this.authToken = config2 === null || config2 === void 0 ? void 0 : config2.authToken;
        this.batchRequests = (config2 === null || config2 === void 0 ? void 0 : config2.batchRequests) || false;
        this.requestTimeout = (config2 === null || config2 === void 0 ? void 0 : config2.requestTimeout) || DEFAULT_REQUEST_TIMEOUT;
      }
      _getRequestUrl(apiType) {
        if (this.url !== void 0) {
          return this.url;
        } else if (apiType === AlchemyApiType.NFT) {
          return getAlchemyNftHttpUrl(this.network, this.apiKey);
        } else if (apiType === AlchemyApiType.WEBHOOK) {
          return getAlchemyWebhookHttpUrl();
        } else {
          return getAlchemyHttpUrl(this.network, this.apiKey);
        }
      }
      getProvider() {
        if (!this._baseAlchemyProvider) {
          this._baseAlchemyProvider = (() => __awaiter$1(this, void 0, void 0, function* () {
            const { AlchemyProvider: AlchemyProvider2 } = yield Promise.resolve().then(() => (init_alchemy_provider_deeb5501(), alchemy_provider_deeb5501_exports));
            return new AlchemyProvider2(this);
          }))();
        }
        return this._baseAlchemyProvider;
      }
      getWebSocketProvider() {
        if (!this._baseAlchemyWssProvider) {
          this._baseAlchemyWssProvider = (() => __awaiter$1(this, void 0, void 0, function* () {
            const { AlchemyWebSocketProvider: AlchemyWebSocketProvider2 } = yield Promise.resolve().then(() => (init_alchemy_websocket_provider_cf92d428(), alchemy_websocket_provider_cf92d428_exports));
            return new AlchemyWebSocketProvider2(this);
          }))();
        }
        return this._baseAlchemyWssProvider;
      }
    };
    version$12 = "logger/5.7.0";
    _permanentCensorErrors2 = false;
    _censorErrors2 = false;
    LogLevels2 = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    _logLevel2 = LogLevels2["default"];
    _globalLogger2 = null;
    _normalizeError2 = _checkNormalize2();
    (function(LogLevel3) {
      LogLevel3["DEBUG"] = "DEBUG";
      LogLevel3["INFO"] = "INFO";
      LogLevel3["WARNING"] = "WARNING";
      LogLevel3["ERROR"] = "ERROR";
      LogLevel3["OFF"] = "OFF";
    })(LogLevel$1 || (LogLevel$1 = {}));
    (function(ErrorCode3) {
      ErrorCode3["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode3["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode3["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode3["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode3["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode3["TIMEOUT"] = "TIMEOUT";
      ErrorCode3["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode3["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode3["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode3["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode3["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode3["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode3["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode3["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode3["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode3["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode3["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode3["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode3["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode2 || (ErrorCode2 = {}));
    HEX2 = "0123456789abcdef";
    Logger$1 = class {
      constructor(version11) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version11,
          writable: false
        });
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels2[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel2 > LogLevels2[level]) {
          return;
        }
        console.log.apply(console, args);
      }
      debug(...args) {
        this._log(Logger$1.levels.DEBUG, args);
      }
      info(...args) {
        this._log(Logger$1.levels.INFO, args);
      }
      warn(...args) {
        this._log(Logger$1.levels.WARNING, args);
      }
      makeError(message, code, params) {
        if (_censorErrors2) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = Logger$1.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
          const value = params[key];
          try {
            if (value instanceof Uint8Array) {
              let hex = "";
              for (let i = 0; i < value.length; i++) {
                hex += HEX2[value[i] >> 4];
                hex += HEX2[value[i] & 15];
              }
              messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
          }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
          case ErrorCode2.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            const fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode2.CALL_EXCEPTION:
          case ErrorCode2.INSUFFICIENT_FUNDS:
          case ErrorCode2.MISSING_NEW:
          case ErrorCode2.NONCE_EXPIRED:
          case ErrorCode2.REPLACEMENT_UNDERPRICED:
          case ErrorCode2.TRANSACTION_REPLACED:
          case ErrorCode2.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key) {
          error[key] = params[key];
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name, value) {
        return this.throwError(message, Logger$1.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      }
      assert(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      }
      checkNormalize(message) {
        if (_normalizeError2) {
          this.throwError("platform missing String.prototype.normalize", Logger$1.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError2
          });
        }
      }
      checkSafeUint53(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, Logger$1.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      }
      checkArgumentCount(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, Logger$1.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, Logger$1.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", Logger$1.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger$1.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", Logger$1.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger2) {
          _globalLogger2 = new Logger$1(version$12);
        }
        return _globalLogger2;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", Logger$1.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors2) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", Logger$1.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors2 = !!censorship;
        _permanentCensorErrors2 = !!permanent;
      }
      static setLogLevel(logLevel) {
        const level = LogLevels2[logLevel.toLowerCase()];
        if (level == null) {
          Logger$1.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel2 = level;
      }
      static from(version11) {
        return new Logger$1(version11);
      }
    };
    Logger$1.errors = ErrorCode2;
    Logger$1.levels = LogLevel$1;
    version9 = "properties/5.7.0";
    __awaiter4 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger14 = new Logger$1(version9);
    opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
    IS_BROWSER = typeof window !== "undefined" && window !== null;
    CoreNamespace = class {
      constructor(config2) {
        this.config = config2;
      }
      getBalance(addressOrName, blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getBalance(addressOrName, blockTag);
        });
      }
      isContractAddress(address) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const code = yield provider.getCode(address);
          return code !== "0x";
        });
      }
      getCode(addressOrName, blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getCode(addressOrName, blockTag);
        });
      }
      getStorageAt(addressOrName, position, blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getStorageAt(addressOrName, position, blockTag);
        });
      }
      getTransactionCount(addressOrName, blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getTransactionCount(addressOrName, blockTag);
        });
      }
      getBlock(blockHashOrBlockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getBlock(blockHashOrBlockTag);
        });
      }
      getBlockWithTransactions(blockHashOrBlockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getBlockWithTransactions(blockHashOrBlockTag);
        });
      }
      getNetwork() {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getNetwork();
        });
      }
      getBlockNumber() {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getBlockNumber();
        });
      }
      getGasPrice() {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getGasPrice();
        });
      }
      getFeeData() {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getFeeData();
        });
      }
      ready() {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.ready;
        });
      }
      call(transaction, blockTag) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.call(transaction, blockTag);
        });
      }
      estimateGas(transaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.estimateGas(transaction);
        });
      }
      getTransaction(transactionHash) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getTransaction(transactionHash);
        });
      }
      getTransactionReceipt(transactionHash) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getTransactionReceipt(transactionHash);
        });
      }
      sendTransaction(signedTransaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.sendTransaction(signedTransaction);
        });
      }
      waitForTransaction(transactionHash, confirmations, timeout) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.waitForTransaction(transactionHash, confirmations, timeout);
        });
      }
      getLogs(filter) {
        return __awaiter$1(this, void 0, void 0, function* () {
          return getLogs(this.config, filter);
        });
      }
      send(method, params) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.send(method, params);
        });
      }
      findContractDeployer(contractAddress) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const currentBlockNum = yield provider.getBlockNumber();
          if ((yield provider.getCode(contractAddress, currentBlockNum)) === ETH_NULL_VALUE) {
            throw new Error(`Contract '${contractAddress}' does not exist`);
          }
          const firstBlock = yield binarySearchFirstBlock(0, currentBlockNum + 1, contractAddress, this.config);
          const txReceipts = yield getTransactionReceipts(this.config, {
            blockNumber: toHex(firstBlock)
          }, "findContractDeployer");
          const matchingReceipt = (_a = txReceipts.receipts) === null || _a === void 0 ? void 0 : _a.find((receipt) => receipt.contractAddress === contractAddress.toLowerCase());
          return {
            deployerAddress: matchingReceipt === null || matchingReceipt === void 0 ? void 0 : matchingReceipt.from,
            blockNumber: firstBlock
          };
        });
      }
      getTokenBalances(addressOrName, contractAddressesOrOptions) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const address = yield provider._getAddress(addressOrName);
          if (Array.isArray(contractAddressesOrOptions)) {
            if (contractAddressesOrOptions.length > 1500) {
              throw new Error("You cannot pass in more than 1500 contract addresses to getTokenBalances()");
            }
            if (contractAddressesOrOptions.length === 0) {
              throw new Error("getTokenBalances() requires at least one contractAddress when using an array");
            }
            return provider._send("alchemy_getTokenBalances", [address, contractAddressesOrOptions], "getTokenBalances");
          } else {
            const tokenType = contractAddressesOrOptions === void 0 ? TokenBalanceType.ERC20 : contractAddressesOrOptions.type;
            const params = [address, tokenType];
            if ((contractAddressesOrOptions === null || contractAddressesOrOptions === void 0 ? void 0 : contractAddressesOrOptions.type) === TokenBalanceType.ERC20 && contractAddressesOrOptions.pageKey) {
              params.push({ pageKey: contractAddressesOrOptions.pageKey });
            }
            return provider._send("alchemy_getTokenBalances", params, "getTokenBalances");
          }
        });
      }
      getTokensForOwner(addressOrName, options) {
        var _a;
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const address = yield provider._getAddress(addressOrName);
          const params = [
            address,
            (_a = options === null || options === void 0 ? void 0 : options.contractAddresses) !== null && _a !== void 0 ? _a : TokenBalanceType.ERC20
          ];
          if (options === null || options === void 0 ? void 0 : options.pageKey) {
            params.push({ pageKey: options.pageKey });
          }
          const response = yield provider._send("alchemy_getTokenBalances", params, "getTokensForOwner");
          const formattedBalances = response.tokenBalances.map((balance) => ({
            contractAddress: balance.contractAddress,
            rawBalance: import_bignumber9.BigNumber.from(balance.tokenBalance).toString()
          }));
          const metadataPromises = yield Promise.allSettled(response.tokenBalances.map((token2) => provider._send(
            "alchemy_getTokenMetadata",
            [token2.contractAddress],
            "getTokensForOwner",
            true
          )));
          const metadata = metadataPromises.map((p) => p.status === "fulfilled" ? p.value : {
            name: null,
            symbol: null,
            decimals: null,
            logo: null
          });
          const ownedTokens = formattedBalances.map((balance, index2) => Object.assign(Object.assign(Object.assign({}, balance), metadata[index2]), { balance: metadata[index2].decimals !== null ? formatUnits(balance.rawBalance, metadata[index2].decimals) : void 0 }));
          return {
            tokens: ownedTokens.map(nullsToUndefined),
            pageKey: response.pageKey
          };
        });
      }
      getTokenMetadata(address) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider._send("alchemy_getTokenMetadata", [address], "getTokenMetadata");
        });
      }
      getAssetTransfers(params) {
        return __awaiter$1(this, void 0, void 0, function* () {
          return getAssetTransfers(this.config, params);
        });
      }
      getTransactionReceipts(params) {
        return __awaiter$1(this, void 0, void 0, function* () {
          return getTransactionReceipts(this.config, params);
        });
      }
      resolveName(name) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.resolveName(name);
        });
      }
      lookupAddress(address) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.lookupAddress(address);
        });
      }
    };
    DebugNamespace = class {
      constructor(config2) {
        this.config = config2;
      }
      traceCall(transaction, blockIdentifier, tracer) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const params = [transaction, blockIdentifier, parseTracerParams(tracer)];
          return provider._send("debug_traceCall", params, "traceCall");
        });
      }
      traceTransaction(transactionHash, tracer, timeout) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const params = [transactionHash, parseTracerParams(tracer, timeout)];
          return provider._send("debug_traceTransaction", params, "traceTransaction");
        });
      }
      traceBlock(blockIdentifier, tracer) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          let method;
          let params;
          if ((0, import_bytes10.isHexString)(blockIdentifier, 32)) {
            method = "debug_traceBlockByHash";
            params = [blockIdentifier, parseTracerParams(tracer)];
          } else {
            method = "debug_traceBlockByNumber";
            const block = typeof blockIdentifier === "number" ? (0, import_bytes10.hexStripZeros)((0, import_bytes10.hexValue)(blockIdentifier)) : blockIdentifier;
            params = [block, parseTracerParams(tracer)];
          }
          return provider._send(method, params, "traceBlock");
        });
      }
    };
    (function(LogLevel3) {
      LogLevel3[LogLevel3["DEBUG"] = 0] = "DEBUG";
      LogLevel3[LogLevel3["INFO"] = 1] = "INFO";
      LogLevel3[LogLevel3["WARN"] = 2] = "WARN";
      LogLevel3[LogLevel3["ERROR"] = 3] = "ERROR";
      LogLevel3[LogLevel3["SILENT"] = 4] = "SILENT";
    })(LogLevel2 || (LogLevel2 = {}));
    logLevelStringToEnum = {
      debug: LogLevel2.DEBUG,
      info: LogLevel2.INFO,
      warn: LogLevel2.WARN,
      error: LogLevel2.ERROR,
      silent: LogLevel2.SILENT
    };
    logLevelToConsoleFn = {
      [LogLevel2.DEBUG]: "log",
      [LogLevel2.INFO]: "info",
      [LogLevel2.WARN]: "warn",
      [LogLevel2.ERROR]: "error"
    };
    DEFAULT_LOG_LEVEL = LogLevel2.INFO;
    Logger14 = class {
      constructor() {
        this._logLevel = DEFAULT_LOG_LEVEL;
      }
      get logLevel() {
        return this._logLevel;
      }
      set logLevel(val) {
        if (!(val in LogLevel2)) {
          throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        }
        this._logLevel = val;
      }
      debug(...args) {
        this._log(LogLevel2.DEBUG, ...args);
      }
      info(...args) {
        this._log(LogLevel2.INFO, ...args);
      }
      warn(...args) {
        this._log(LogLevel2.WARN, ...args);
      }
      error(...args) {
        this._log(LogLevel2.ERROR, ...args);
      }
      _log(logLevel, ...args) {
        if (logLevel < this._logLevel) {
          return;
        }
        const now = new Date().toISOString();
        const method = logLevelToConsoleFn[logLevel];
        if (method) {
          console[method](`[${now}] Alchemy:`, ...args.map(stringify));
        } else {
          throw new Error(`Logger received an invalid logLevel (value: ${logLevel})`);
        }
      }
    };
    loggerClient = new Logger14();
    VERSION = "2.9.2";
    DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1e3;
    DEFAULT_BACKOFF_MULTIPLIER = 1.5;
    DEFAULT_BACKOFF_MAX_DELAY_MS = 30 * 1e3;
    DEFAULT_BACKOFF_MAX_ATTEMPTS = 5;
    ExponentialBackoff = class {
      constructor(maxAttempts = DEFAULT_BACKOFF_MAX_ATTEMPTS) {
        this.maxAttempts = maxAttempts;
        this.initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;
        this.backoffMultiplier = DEFAULT_BACKOFF_MULTIPLIER;
        this.maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;
        this.numAttempts = 0;
        this.currentDelayMs = 0;
        this.isInBackoff = false;
      }
      backoff() {
        if (this.numAttempts >= this.maxAttempts) {
          return Promise.reject(new Error(`Exceeded maximum number of attempts: ${this.maxAttempts}`));
        }
        if (this.isInBackoff) {
          return Promise.reject(new Error("A backoff operation is already in progress"));
        }
        const backoffDelayWithJitterMs = this.withJitterMs(this.currentDelayMs);
        if (backoffDelayWithJitterMs > 0) {
          logDebug("ExponentialBackoff.backoff", `Backing off for ${backoffDelayWithJitterMs}ms`);
        }
        this.currentDelayMs *= this.backoffMultiplier;
        this.currentDelayMs = Math.max(this.currentDelayMs, this.initialDelayMs);
        this.currentDelayMs = Math.min(this.currentDelayMs, this.maxDelayMs);
        this.numAttempts += 1;
        return new Promise((resolve) => {
          this.isInBackoff = true;
          setTimeout(() => {
            this.isInBackoff = false;
            resolve();
          }, backoffDelayWithJitterMs);
        });
      }
      withJitterMs(delayMs) {
        return Math.min(delayMs + (Math.random() - 0.5) * delayMs, this.maxDelayMs);
      }
    };
    NftNamespace = class {
      constructor(config2) {
        this.config = config2;
      }
      getNftMetadata(contractAddress, tokenId, optionsOrTokenType, tokenUriTimeoutInMs) {
        let options;
        if (typeof optionsOrTokenType === "object") {
          options = {
            tokenType: optionsOrTokenType.tokenType,
            tokenUriTimeoutInMs: optionsOrTokenType.tokenUriTimeoutInMs,
            refreshCache: optionsOrTokenType.refreshCache
          };
        } else {
          options = {
            tokenType: optionsOrTokenType,
            tokenUriTimeoutInMs
          };
        }
        return getNftMetadata(this.config, contractAddress, tokenId, options);
      }
      getNftMetadataBatch(tokens, options) {
        return getNftMetadataBatch(this.config, tokens, options);
      }
      getContractMetadata(contractAddress) {
        return getContractMetadata(this.config, contractAddress);
      }
      getContractMetadataBatch(contractAddresses) {
        return getContractMetadataBatch(this.config, contractAddresses);
      }
      getNftsForOwnerIterator(owner, options) {
        return getNftsForOwnerIterator(this.config, owner, options);
      }
      getNftsForOwner(owner, options) {
        return getNftsForOwner(this.config, owner, options);
      }
      getNftsForContract(contractAddress, options) {
        return getNftsForContract(this.config, contractAddress, options);
      }
      getNftsForContractIterator(contractAddress, options) {
        return getNftsForContractIterator(this.config, contractAddress, options);
      }
      getOwnersForContract(contractAddress, options) {
        return getOwnersForContract(this.config, contractAddress, options);
      }
      getOwnersForNft(contractAddress, tokenId, options) {
        return getOwnersForNft(this.config, contractAddress, tokenId, options);
      }
      getContractsForOwner(owner, options) {
        return getContractsForOwner(this.config, owner, options);
      }
      getTransfersForOwner(owner, category, options) {
        return getTransfersForOwner(this.config, owner, category, options);
      }
      getTransfersForContract(contract, options) {
        return getTransfersForContract(this.config, contract, options);
      }
      getMintedNfts(owner, options) {
        return __awaiter$1(this, void 0, void 0, function* () {
          return getMintedNfts(this.config, owner, options);
        });
      }
      checkNftOwnership(owner, contractAddresses) {
        return checkNftOwnership(this.config, owner, contractAddresses);
      }
      verifyNftOwnership(owner, contractAddress) {
        return verifyNftOwnership(this.config, owner, contractAddress);
      }
      isSpamContract(contractAddress) {
        return isSpamContract(this.config, contractAddress);
      }
      getSpamContracts() {
        return getSpamContracts(this.config);
      }
      getFloorPrice(contractAddress) {
        return getFloorPrice(this.config, contractAddress);
      }
      getNftSales(options) {
        return getNftSales(this.config, options);
      }
      computeRarity(contractAddress, tokenId, refreshCache) {
        return computeRarity(this.config, contractAddress, tokenId, refreshCache);
      }
      searchContractMetadata(query) {
        return searchContractMetadata(this.config, query);
      }
      summarizeNftAttributes(contractAddress, refreshCache) {
        return summarizeNftAttributes(this.config, contractAddress, refreshCache);
      }
      refreshNftMetadata(contractAddress, tokenId) {
        return refreshNftMetadata(this.config, contractAddress, tokenId);
      }
      refreshContract(contractAddress) {
        return refreshContract(this.config, contractAddress);
      }
    };
    NotifyNamespace = class {
      constructor(config2) {
        this.config = config2;
      }
      getAllWebhooks() {
        return __awaiter$1(this, void 0, void 0, function* () {
          this.verifyConfig();
          const response = yield this.sendWebhookRequest("team-webhooks", "getAllWebhooks", {});
          return {
            webhooks: parseRawWebhookResponse(response),
            totalCount: response.data.length
          };
        });
      }
      getAddresses(webhookOrId, options) {
        return __awaiter$1(this, void 0, void 0, function* () {
          this.verifyConfig();
          const webhookId = typeof webhookOrId === "string" ? webhookOrId : webhookOrId.id;
          const response = yield this.sendWebhookRequest("webhook-addresses", "getAddresses", {
            webhook_id: webhookId,
            limit: options === null || options === void 0 ? void 0 : options.limit,
            after: options === null || options === void 0 ? void 0 : options.pageKey
          });
          return parseRawAddressActivityResponse(response);
        });
      }
      getGraphqlQuery(webhookOrId) {
        return __awaiter$1(this, void 0, void 0, function* () {
          this.verifyConfig();
          const webhookId = typeof webhookOrId === "string" ? webhookOrId : webhookOrId.id;
          const response = yield this.sendWebhookRequest("dashboard-webhook-graphql-query", "getGraphqlQuery", {
            webhook_id: webhookId
          });
          return parseRawCustomGraphqlWebhookResponse(response);
        });
      }
      getNftFilters(webhookOrId, options) {
        return __awaiter$1(this, void 0, void 0, function* () {
          this.verifyConfig();
          const webhookId = typeof webhookOrId === "string" ? webhookOrId : webhookOrId.id;
          const response = yield this.sendWebhookRequest("webhook-nft-filters", "getNftFilters", {
            webhook_id: webhookId,
            limit: options === null || options === void 0 ? void 0 : options.limit,
            after: options === null || options === void 0 ? void 0 : options.pageKey
          });
          return parseRawNftFiltersResponse(response);
        });
      }
      updateWebhook(webhookOrId, update) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const webhookId = typeof webhookOrId === "string" ? webhookOrId : webhookOrId.id;
          let restApiName;
          let methodName;
          let method;
          let data;
          if ("isActive" in update) {
            restApiName = "update-webhook";
            methodName = "updateWebhook";
            method = "PUT";
            data = {
              webhook_id: webhookId,
              is_active: update.isActive
            };
          } else if ("addFilters" in update || "removeFilters" in update) {
            restApiName = "update-webhook-nft-filters";
            methodName = "updateWebhookNftFilters";
            method = "PATCH";
            data = {
              webhook_id: webhookId,
              nft_filters_to_add: update.addFilters ? update.addFilters.map(nftFilterToParam) : [],
              nft_filters_to_remove: update.removeFilters ? update.removeFilters.map(nftFilterToParam) : []
            };
          } else if ("addMetadataFilters" in update || "removeMetadataFilters" in update) {
            restApiName = "update-webhook-nft-metadata-filters";
            methodName = "updateWebhookNftMetadataFilters";
            method = "PATCH";
            data = {
              webhook_id: webhookId,
              nft_metadata_filters_to_add: update.addMetadataFilters ? update.addMetadataFilters.map(nftFilterToParam) : [],
              nft_metadata_filters_to_remove: update.removeMetadataFilters ? update.removeMetadataFilters.map(nftFilterToParam) : []
            };
          } else if ("addAddresses" in update || "removeAddresses" in update) {
            restApiName = "update-webhook-addresses";
            methodName = "webhook:updateWebhookAddresses";
            method = "PATCH";
            data = {
              webhook_id: webhookId,
              addresses_to_add: yield this.resolveAddresses(update.addAddresses),
              addresses_to_remove: yield this.resolveAddresses(update.removeAddresses)
            };
          } else if ("newAddresses" in update) {
            restApiName = "update-webhook-addresses";
            methodName = "webhook:updateWebhookAddress";
            method = "PUT";
            data = {
              webhook_id: webhookId,
              addresses: yield this.resolveAddresses(update.newAddresses)
            };
          } else {
            throw new Error("Invalid `update` param passed into `updateWebhook`");
          }
          yield this.sendWebhookRequest(restApiName, methodName, {}, {
            method,
            data
          });
        });
      }
      createWebhook(url, type, params) {
        return __awaiter$1(this, void 0, void 0, function* () {
          let appId;
          if (type === WebhookType.MINED_TRANSACTION || type === WebhookType.DROPPED_TRANSACTION) {
            if (!("appId" in params)) {
              throw new Error("Transaction Webhooks require an app id.");
            }
            appId = params.appId;
          }
          let network = NETWORK_TO_WEBHOOK_NETWORK.get(this.config.network);
          let nftFilterObj;
          let addresses;
          let graphqlQuery;
          if (type === WebhookType.NFT_ACTIVITY || type === WebhookType.NFT_METADATA_UPDATE) {
            if (!("filters" in params) || params.filters.length === 0) {
              throw new Error("Nft Activity Webhooks require a non-empty array input.");
            }
            network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;
            const filters = params.filters.map((filter) => filter.tokenId ? {
              contract_address: filter.contractAddress,
              token_id: import_bignumber9.BigNumber.from(filter.tokenId).toString()
            } : {
              contract_address: filter.contractAddress
            });
            nftFilterObj = type === WebhookType.NFT_ACTIVITY ? { nft_filters: filters } : { nft_metadata_filters: filters };
          } else if (type === WebhookType.ADDRESS_ACTIVITY) {
            if (params === void 0 || !("addresses" in params) || params.addresses.length === 0) {
              throw new Error("Address Activity Webhooks require a non-empty array input.");
            }
            network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;
            addresses = yield this.resolveAddresses(params.addresses);
          } else if (type == WebhookType.GRAPHQL) {
            if (params === void 0 || !("graphqlQuery" in params) || params.graphqlQuery.length === 0) {
              throw new Error("Custom Webhooks require a non-empty graphql query.");
            }
            network = params.network ? NETWORK_TO_WEBHOOK_NETWORK.get(params.network) : network;
            graphqlQuery = params.graphqlQuery;
          }
          const data = Object.assign(Object.assign(Object.assign(Object.assign({ network, webhook_type: type, webhook_url: url }, appId && { app_id: appId }), nftFilterObj), addresses && { addresses }), graphqlQuery && { graphql_query: graphqlQuery });
          const response = yield this.sendWebhookRequest("create-webhook", "createWebhook", {}, {
            method: "POST",
            data
          });
          return parseRawWebhook(response.data);
        });
      }
      deleteWebhook(webhookOrId) {
        return __awaiter$1(this, void 0, void 0, function* () {
          this.verifyConfig();
          const webhookId = typeof webhookOrId === "string" ? webhookOrId : webhookOrId.id;
          const response = yield this.sendWebhookRequest("delete-webhook", "deleteWebhook", {
            webhook_id: webhookId
          }, {
            method: "DELETE"
          });
          if ("message" in response) {
            throw new Error(`Webhook not found. Failed to delete webhook: ${webhookId}`);
          }
        });
      }
      verifyConfig() {
        if (this.config.authToken === void 0) {
          throw new Error("Using the Notify API requires setting the Alchemy Auth Token in the settings object when initializing Alchemy.");
        }
      }
      sendWebhookRequest(restApiName, methodName, params, overrides) {
        return requestHttpWithBackoff(this.config, AlchemyApiType.WEBHOOK, restApiName, methodName, params, Object.assign(Object.assign({}, overrides), { headers: Object.assign({ "X-Alchemy-Token": this.config.authToken }, overrides === null || overrides === void 0 ? void 0 : overrides.headers) }));
      }
      resolveAddresses(addresses) {
        return __awaiter$1(this, void 0, void 0, function* () {
          if (addresses === void 0) {
            return [];
          }
          const resolvedAddresses = [];
          const provider = yield this.config.getProvider();
          for (const address of addresses) {
            const rawAddress = yield provider.resolveName(address);
            if (rawAddress === null) {
              throw new Error(`Unable to resolve the ENS address: ${address}`);
            }
            resolvedAddresses.push(rawAddress);
          }
          return resolvedAddresses;
        });
      }
    };
    WEBHOOK_NETWORK_TO_NETWORK = {
      ETH_MAINNET: Network.ETH_MAINNET,
      ETH_GOERLI: Network.ETH_GOERLI,
      ETH_SEPOLIA: Network.ETH_SEPOLIA,
      ETH_ROPSTEN: Network.ETH_ROPSTEN,
      ETH_RINKEBY: Network.ETH_RINKEBY,
      ETH_KOVAN: Network.ETH_KOVAN,
      MATIC_MAINNET: Network.MATIC_MAINNET,
      MATIC_MUMBAI: Network.MATIC_MUMBAI,
      ARB_MAINNET: Network.ARB_MAINNET,
      ARB_GOERLI: Network.ARB_GOERLI,
      ARB_RINKEBY: Network.ARB_RINKEBY,
      OPT_MAINNET: Network.OPT_MAINNET,
      OPT_GOERLI: Network.OPT_GOERLI,
      OPT_KOVAN: Network.OPT_KOVAN
    };
    NETWORK_TO_WEBHOOK_NETWORK = Object.keys(Network).reduce((map, key) => {
      if (key in WEBHOOK_NETWORK_TO_NETWORK) {
        map.set(WEBHOOK_NETWORK_TO_NETWORK[key], key);
      }
      return map;
    }, /* @__PURE__ */ new Map());
    GAS_OPTIMIZED_TX_FEE_MULTIPLES = [0.9, 1, 1.1, 1.2, 1.3];
    TransactNamespace = class {
      constructor(config2) {
        this.config = config2;
      }
      sendPrivateTransaction(signedTransaction, maxBlockNumber, options) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const hexBlockNumber = maxBlockNumber ? toHex(maxBlockNumber) : void 0;
          return provider._send("eth_sendPrivateTransaction", [
            {
              tx: signedTransaction,
              maxBlockNumber: hexBlockNumber,
              preferences: options
            }
          ], "sendPrivateTransaction");
        });
      }
      cancelPrivateTransaction(transactionHash) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider._send("eth_cancelPrivateTransaction", [
            {
              txHash: transactionHash
            }
          ], "cancelPrivateTransaction");
        });
      }
      simulateAssetChangesBundle(transactions, blockIdentifier) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const params = blockIdentifier !== void 0 ? [transactions, blockIdentifier] : [transactions];
          const res = yield provider._send("alchemy_simulateAssetChangesBundle", params, "simulateAssetChangesBundle");
          return nullsToUndefined(res);
        });
      }
      simulateAssetChanges(transaction, blockIdentifier) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const params = blockIdentifier !== void 0 ? [transaction, blockIdentifier] : [transaction];
          const res = yield provider._send("alchemy_simulateAssetChanges", params, "simulateAssetChanges");
          return nullsToUndefined(res);
        });
      }
      simulateExecutionBundle(transactions, blockIdentifier) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const params = blockIdentifier !== void 0 ? [transactions, blockIdentifier] : [transactions];
          const res = provider._send("alchemy_simulateExecutionBundle", params, "simulateExecutionBundle");
          return nullsToUndefined(res);
        });
      }
      simulateExecution(transaction, blockIdentifier) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const params = blockIdentifier !== void 0 ? [transaction, blockIdentifier] : [transaction];
          const res = provider._send("alchemy_simulateExecution", params, "simulateExecution");
          return nullsToUndefined(res);
        });
      }
      getTransaction(transactionHash) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.getTransaction(transactionHash);
        });
      }
      sendTransaction(signedTransaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.sendTransaction(signedTransaction);
        });
      }
      estimateGas(transaction) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.estimateGas(transaction);
        });
      }
      getMaxPriorityFeePerGas() {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const feeHex = yield provider._send("eth_maxPriorityFeePerGas", [], "getMaxPriorityFeePerGas");
          return fromHex(feeHex);
        });
      }
      waitForTransaction(transactionHash, confirmations, timeout) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider.waitForTransaction(transactionHash, confirmations, timeout);
        });
      }
      sendGasOptimizedTransaction(transactionOrSignedTxs, wallet) {
        return __awaiter$1(this, void 0, void 0, function* () {
          if (Array.isArray(transactionOrSignedTxs)) {
            return this._sendGasOptimizedTransaction(transactionOrSignedTxs, "sendGasOptimizedTransactionPreSigned");
          }
          let gasLimit;
          let priorityFee;
          let baseFee;
          const provider = yield this.config.getProvider();
          try {
            gasLimit = yield this.estimateGas(transactionOrSignedTxs);
            priorityFee = yield this.getMaxPriorityFeePerGas();
            const currentBlock = yield provider.getBlock("latest");
            baseFee = currentBlock.baseFeePerGas.toNumber();
          } catch (e) {
            throw new Error(`Failed to estimate gas for transaction: ${e}`);
          }
          const gasSpreadTransactions = generateGasSpreadTransactions(transactionOrSignedTxs, gasLimit.toNumber(), baseFee, priorityFee);
          const signedTransactions = yield Promise.all(gasSpreadTransactions.map((tx) => wallet.signTransaction(tx)));
          return this._sendGasOptimizedTransaction(signedTransactions, "sendGasOptimizedTransactionGenerated");
        });
      }
      getGasOptimizedTransactionStatus(trackingId) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider._send("alchemy_getGasOptimizedTransactionStatus", [trackingId], "getGasOptimizedTransactionStatus");
        });
      }
      _sendGasOptimizedTransaction(signedTransactions, methodName) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          return provider._send("alchemy_sendGasOptimizedTransaction", [
            {
              rawTransactions: signedTransactions
            }
          ], methodName);
        });
      }
    };
    ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = "alchemy-pending-transactions";
    ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE = "alchemy-mined-transactions";
    ALCHEMY_EVENT_TYPES = [
      ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,
      ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE
    ];
    Event = class {
      constructor(tag, listener, once) {
        this.listener = listener;
        this.tag = tag;
        this.once = once;
        this._lastBlockNumber = -2;
        this._inflight = false;
      }
      get event() {
        switch (this.type) {
          case "tx":
            return this.hash;
          case "filter":
            return this.filter;
          default:
            return this.tag;
        }
      }
      get type() {
        return this.tag.split(":")[0];
      }
      get hash() {
        const comps = this.tag.split(":");
        if (comps[0] !== "tx") {
          throw new Error("Not a transaction event");
        }
        return comps[1];
      }
      get filter() {
        const comps = this.tag.split(":");
        if (comps[0] !== "filter") {
          throw new Error("Not a transaction event");
        }
        const address = comps[1];
        const topics = deserializeTopics(comps[2]);
        const filter = {};
        if (topics.length > 0) {
          filter.topics = topics;
        }
        if (address && address !== "*") {
          filter.address = address;
        }
        return filter;
      }
      pollable() {
        const PollableEvents = ["block", "network", "pending", "poll"];
        return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
      }
    };
    EthersEvent = class extends Event {
      get fromAddress() {
        const comps = this.tag.split(":");
        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
          return void 0;
        }
        if (comps[1] && comps[1] !== "*") {
          return deserializeAddressField(comps[1]);
        } else {
          return void 0;
        }
      }
      get toAddress() {
        const comps = this.tag.split(":");
        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
          return void 0;
        }
        if (comps[2] && comps[2] !== "*") {
          return deserializeAddressField(comps[2]);
        } else {
          return void 0;
        }
      }
      get hashesOnly() {
        const comps = this.tag.split(":");
        if (!ALCHEMY_EVENT_TYPES.includes(comps[0])) {
          return void 0;
        }
        if (comps[3] && comps[3] !== "*") {
          return comps[3] === "true";
        } else {
          return void 0;
        }
      }
      get includeRemoved() {
        const comps = this.tag.split(":");
        if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {
          return void 0;
        }
        if (comps[2] && comps[2] !== "*") {
          return comps[2] === "true";
        } else {
          return void 0;
        }
      }
      get addresses() {
        const comps = this.tag.split(":");
        if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {
          return void 0;
        }
        if (comps[1] && comps[1] !== "*") {
          return deserializeAddressesField(comps[1]);
        } else {
          return void 0;
        }
      }
    };
    WebSocketNamespace = class {
      constructor(config2) {
        this.config = config2;
      }
      on(eventName, listener) {
        void (() => __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getWebSocketProvider();
          const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);
          provider.on(processedEvent, listener);
        }))();
        return this;
      }
      once(eventName, listener) {
        void (() => __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getWebSocketProvider();
          const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);
          provider.once(processedEvent, listener);
        }))();
        return this;
      }
      off(eventName, listener) {
        void (() => __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getWebSocketProvider();
          const processedEvent = yield this._resolveEnsAlchemyEvent(eventName);
          return provider.off(processedEvent, listener);
        }))();
        return this;
      }
      removeAllListeners(eventName) {
        void (() => __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getWebSocketProvider();
          const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : void 0;
          provider.removeAllListeners(processedEvent);
        }))();
        return this;
      }
      listenerCount(eventName) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getWebSocketProvider();
          const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : void 0;
          return provider.listenerCount(processedEvent);
        });
      }
      listeners(eventName) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getWebSocketProvider();
          const processedEvent = eventName ? yield this._resolveEnsAlchemyEvent(eventName) : void 0;
          return provider.listeners(processedEvent);
        });
      }
      _resolveEnsAlchemyEvent(eventName) {
        return __awaiter$1(this, void 0, void 0, function* () {
          if (!isAlchemyEvent(eventName)) {
            return eventName;
          }
          if (eventName.method === AlchemySubscription.MINED_TRANSACTIONS && eventName.addresses) {
            const processedAddresses = [];
            for (const address of eventName.addresses) {
              if (address.to) {
                address.to = yield this._resolveNameOrError(address.to);
              }
              if (address.from) {
                address.from = yield this._resolveNameOrError(address.from);
              }
              processedAddresses.push(address);
            }
            eventName.addresses = processedAddresses;
          } else if (eventName.method === AlchemySubscription.PENDING_TRANSACTIONS) {
            if (eventName.fromAddress) {
              if (typeof eventName.fromAddress === "string") {
                eventName.fromAddress = yield this._resolveNameOrError(eventName.fromAddress);
              } else {
                eventName.fromAddress = yield Promise.all(eventName.fromAddress.map((address) => this._resolveNameOrError(address)));
              }
            }
            if (eventName.toAddress) {
              if (typeof eventName.toAddress === "string") {
                eventName.toAddress = yield this._resolveNameOrError(eventName.toAddress);
              } else {
                eventName.toAddress = yield Promise.all(eventName.toAddress.map((address) => this._resolveNameOrError(address)));
              }
            }
          }
          return eventName;
        });
      }
      _resolveNameOrError(name) {
        return __awaiter$1(this, void 0, void 0, function* () {
          const provider = yield this.config.getProvider();
          const resolved = yield provider.resolveName(name);
          if (resolved === null) {
            throw new Error(`Unable to resolve the ENS address: ${name}`);
          }
          return resolved;
        });
      }
    };
    Alchemy = class {
      constructor(settings) {
        this.config = new AlchemyConfig(settings);
        this.core = new CoreNamespace(this.config);
        this.nft = new NftNamespace(this.config);
        this.ws = new WebSocketNamespace(this.config);
        this.transact = new TransactNamespace(this.config);
        this.notify = new NotifyNamespace(this.config);
        this.debug = new DebugNamespace(this.config);
      }
    };
    Wallet2 = class extends Wallet {
      constructor(privateKey, alchemyOrProvider) {
        let superProvider;
        if (alchemyOrProvider && import_abstract_provider3.Provider.isProvider(alchemyOrProvider)) {
          superProvider = alchemyOrProvider;
        }
        super(privateKey, superProvider);
        if (alchemyOrProvider && !import_abstract_provider3.Provider.isProvider(alchemyOrProvider)) {
          this.alchemyProviderPromise = alchemyOrProvider.config.getProvider();
        }
      }
      getBalance(blockTag) {
        return this.getWallet().then((wallet) => wallet.getBalance(blockTag));
      }
      getTransactionCount(blockTag) {
        return this.getWallet().then((wallet) => wallet.getTransactionCount(blockTag));
      }
      estimateGas(transaction) {
        return this.getWallet().then((wallet) => wallet.estimateGas(transaction));
      }
      call(transaction, blockTag) {
        return this.getWallet().then((wallet) => wallet.call(transaction, blockTag));
      }
      populateTransaction(transaction) {
        return this.getWallet().then((wallet) => wallet.populateTransaction(transaction));
      }
      sendTransaction(transaction) {
        return this.getWallet().then((wallet) => wallet.sendTransaction(transaction));
      }
      getChainId() {
        return this.getWallet().then((wallet) => wallet.getChainId());
      }
      getGasPrice() {
        return this.getWallet().then((wallet) => wallet.getGasPrice());
      }
      getFeeData() {
        return this.getWallet().then((wallet) => wallet.getFeeData());
      }
      resolveName(name) {
        return this.getWallet().then((wallet) => wallet.resolveName(name));
      }
      getWallet() {
        return __awaiter$1(this, void 0, void 0, function* () {
          if (!this.alchemyProviderPromise) {
            return this.connect(this.provider);
          }
          return this.connect(yield this.alchemyProviderPromise);
        });
      }
    };
    Contract2 = class extends Contract {
    };
    ContractFactory2 = class extends ContractFactory {
    };
  }
});

// ../node_modules/alchemy-sdk/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Alchemy: () => Alchemy,
  AlchemySubscription: () => AlchemySubscription,
  AssetTransfersCategory: () => AssetTransfersCategory,
  AssetTransfersOrder: () => AssetTransfersOrder,
  BigNumber: () => import_bignumber10.BigNumber,
  CommitmentLevel: () => CommitmentLevel,
  Contract: () => Contract2,
  ContractFactory: () => ContractFactory2,
  DebugCallType: () => DebugCallType,
  DebugTracerType: () => DebugTracerType,
  DecodingAuthority: () => DecodingAuthority,
  GasOptimizedTransactionStatus: () => GasOptimizedTransactionStatus,
  GetTransfersForOwnerTransferType: () => GetTransfersForOwnerTransferType,
  Network: () => Network,
  NftExcludeFilters: () => NftExcludeFilters,
  NftFilters: () => NftFilters,
  NftOrdering: () => NftOrdering,
  NftSaleMarketplace: () => NftSaleMarketplace,
  NftSaleTakerType: () => NftSaleTakerType,
  NftSpamClassification: () => NftSpamClassification,
  NftTokenType: () => NftTokenType,
  OpenSeaSafelistRequestStatus: () => OpenSeaSafelistRequestStatus,
  RefreshState: () => RefreshState,
  SimulateAssetType: () => SimulateAssetType,
  SimulateChangeType: () => SimulateChangeType,
  SortingOrder: () => SortingOrder,
  TokenBalanceType: () => TokenBalanceType,
  Utils: () => utils_exports2,
  Wallet: () => Wallet2,
  WebhookType: () => WebhookType,
  WebhookVersion: () => WebhookVersion,
  fromHex: () => fromHex,
  isHex: () => isHex,
  setLogLevel: () => setLogLevel,
  toHex: () => toHex
});
var import_bignumber10, import_axios4;
var init_esm = __esm({
  "../node_modules/alchemy-sdk/dist/esm/index.js"() {
    init_utils3();
    init_index_8bd23ae5();
    import_bignumber10 = __toESM(require_lib3());
    import_axios4 = __toESM(require_axios2());
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/alchemy-rpc.js
var require_alchemy_rpc = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/alchemy-rpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildAlchemyUrl = exports.buildAlchemyClient = exports.alchemySupportedChains = void 0;
    var alchemy_sdk_1 = (init_esm(), __toCommonJS(esm_exports));
    var _chains_1 = require_chains();
    var ALCHEMY_NETWORKS = {
      [_chains_1.Chains.ETHEREUM.chainId]: alchemy_sdk_1.Network.ETH_MAINNET,
      [_chains_1.Chains.ETHEREUM_GOERLI.chainId]: alchemy_sdk_1.Network.ETH_GOERLI,
      [_chains_1.Chains.ETHEREUM_SEPOLIA.chainId]: alchemy_sdk_1.Network.ETH_SEPOLIA,
      [_chains_1.Chains.POLYGON.chainId]: alchemy_sdk_1.Network.MATIC_MAINNET,
      [_chains_1.Chains.OPTIMISM.chainId]: alchemy_sdk_1.Network.OPT_MAINNET,
      [_chains_1.Chains.ARBITRUM.chainId]: alchemy_sdk_1.Network.ARB_MAINNET,
      [_chains_1.Chains.ASTAR.chainId]: alchemy_sdk_1.Network.ASTAR_MAINNET,
      [_chains_1.Chains.POLYGON_ZKEVM.chainId]: alchemy_sdk_1.Network.POLYGONZKEVM_MAINNET
    };
    function alchemySupportedChains() {
      return Object.keys(ALCHEMY_NETWORKS).map(Number);
    }
    exports.alchemySupportedChains = alchemySupportedChains;
    function buildAlchemyClient(alchemyKey, chainId) {
      return new alchemy_sdk_1.Alchemy({
        apiKey: alchemyKey,
        network: ALCHEMY_NETWORKS[chainId]
      });
    }
    exports.buildAlchemyClient = buildAlchemyClient;
    function buildAlchemyUrl(alchemyKey, protocol, chainId) {
      const alchemyNetwork = ALCHEMY_NETWORKS[chainId];
      return `${protocol}://${alchemyNetwork}.g.alchemy.com/v2/${alchemyKey}`;
    }
    exports.buildAlchemyUrl = buildAlchemyUrl;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/alchemy-provider.js
var require_alchemy_provider2 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/alchemy-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlchemyProviderSource = void 0;
    var base_http_provider_1 = require_base_http_provider();
    var base_web_socket_provider_1 = require_base_web_socket_provider();
    var alchemy_rpc_1 = require_alchemy_rpc();
    var AlchemyProviderSource = class {
      constructor(key, protocol, onChains) {
        this.key = key;
        this.protocol = protocol;
        this.supported = onChains ?? (0, alchemy_rpc_1.alchemySupportedChains)();
      }
      supportedClients() {
        const support = { ethers: true, viem: true };
        return Object.fromEntries(this.supported.map((chainId) => [chainId, support]));
      }
      getEthersProvider({ chainId }) {
        const url = (0, alchemy_rpc_1.buildAlchemyUrl)(this.key, this.protocol, chainId);
        return this.protocol === "https" ? (0, base_http_provider_1.buildEthersProviderForHttpSource)(url, chainId) : (0, base_web_socket_provider_1.buildEthersProviderForWebSocketSource)(url, chainId);
      }
      getViemTransport({ chainId }) {
        const url = (0, alchemy_rpc_1.buildAlchemyUrl)(this.key, this.protocol, chainId);
        return this.protocol === "https" ? (0, base_http_provider_1.buildViemTransportForHttpSource)(url, chainId) : (0, base_web_socket_provider_1.buildViemTransportForWebSocketSource)(url, chainId);
      }
    };
    exports.AlchemyProviderSource = AlchemyProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/http-provider.js
var require_http_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/http-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpProviderSource = void 0;
    var base_http_provider_1 = require_base_http_provider();
    var HttpProviderSource = class extends base_http_provider_1.BaseHttpProvider {
      constructor(url, chains) {
        super();
        this.url = url;
        this.chains = chains;
        if (chains.length === 0)
          throw new Error("Must support at least one chain");
      }
      supportedChains() {
        return this.chains;
      }
      calculateUrl(chainId) {
        return this.url;
      }
    };
    exports.HttpProviderSource = HttpProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/utils.js
var require_utils12 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sourcesWithSupport = exports.combineClientSupport = void 0;
    function combineClientSupport(sources) {
      const result = {};
      for (const source of sources) {
        for (const [chainIdString, support] of Object.entries(source.supportedClients())) {
          const chainId = Number(chainIdString);
          const current = result[chainId] ?? { ethers: false, viem: false };
          result[chainId] = {
            ethers: current.ethers || support.ethers,
            viem: current.viem || support.viem
          };
        }
      }
      return result;
    }
    exports.combineClientSupport = combineClientSupport;
    function sourcesWithSupport(chainId, sources, support) {
      return sources.filter((source) => source.supportedClients()[chainId]?.[support]);
    }
    exports.sourcesWithSupport = sourcesWithSupport;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/fallback-provider.js
var require_fallback_provider2 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/fallback-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FallbackSource = void 0;
    var providers_1 = require_lib22();
    var viem_1 = require_cjs2();
    var utils_1 = require_utils12();
    var FallbackSource = class {
      constructor(sources, config2) {
        this.sources = sources;
        this.config = config2;
        if (sources.length === 0)
          throw new Error("Need at least one source to setup the provider source");
      }
      supportedClients() {
        return (0, utils_1.combineClientSupport)(this.sources);
      }
      getEthersProvider({ chainId }) {
        const sources = (0, utils_1.sourcesWithSupport)(chainId, this.sources, "ethers");
        if (sources.length === 0)
          throw new Error(`Chain with id ${chainId} not supported`);
        const config2 = sources.map((source, i) => ({
          provider: source.getEthersProvider({ chainId }),
          priority: this.config?.ethers?.prioritizeByOrder === false ? 0 : i
        }));
        return new providers_1.FallbackProvider(config2, this.config?.ethers?.quorum);
      }
      getViemTransport({ chainId }) {
        const sources = (0, utils_1.sourcesWithSupport)(chainId, this.sources, "viem");
        if (sources.length === 0)
          throw new Error(`Chain with id ${chainId} not supported`);
        const transports = sources.map((source) => source.getViemTransport({ chainId }));
        return (0, viem_1.fallback)(transports, this.config?.viem);
      }
    };
    exports.FallbackSource = FallbackSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/public-providers.js
var require_public_providers = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/public-providers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PublicRPCsSource = void 0;
    var _chains_1 = require_chains();
    var http_provider_1 = require_http_provider();
    var fallback_provider_1 = require_fallback_provider2();
    var PublicRPCsSource = class extends fallback_provider_1.FallbackSource {
      constructor(params) {
        super(buildSources(calculateRPCs(params?.publicRPCs)), params?.config);
      }
    };
    exports.PublicRPCsSource = PublicRPCsSource;
    function buildSources(publicRPCs) {
      return publicRPCs.map(({ chainId, publicRPC }) => new http_provider_1.HttpProviderSource(publicRPC, [chainId]));
    }
    function calculateRPCs(publicRPCs) {
      const rpcsByChain = publicRPCs ? Object.entries(publicRPCs).map(([chainId, rpcs]) => [Number(chainId), rpcs]) : (0, _chains_1.getAllChains)().filter((chain) => chain.publicRPCs.length > 0).map(({ chainId, publicRPCs: publicRPCs2 }) => [chainId, publicRPCs2]);
      return rpcsByChain.flatMap(([chainId, publicRPCs2]) => publicRPCs2.map((publicRPC) => ({ publicRPC, chainId: Number(chainId) })));
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/prioritized-provider-source-combinator.js
var require_prioritized_provider_source_combinator = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/prioritized-provider-source-combinator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrioritizedProviderSourceCombinator = void 0;
    var utils_1 = require_utils12();
    var PrioritizedProviderSourceCombinator = class {
      constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
          throw new Error("Need at least one source to setup the provider source");
      }
      supportedClients() {
        let result = {};
        for (const source of this.sources) {
          result = { ...source.supportedClients(), ...result };
        }
        return result;
      }
      getEthersProvider({ chainId }) {
        const sources = (0, utils_1.sourcesWithSupport)(chainId, this.sources, "ethers");
        if (sources.length === 0)
          throw new Error(`Chain with id ${chainId} not supported`);
        return sources[0].getEthersProvider({ chainId });
      }
      getViemTransport({ chainId }) {
        const sources = (0, utils_1.sourcesWithSupport)(chainId, this.sources, "ethers");
        if (sources.length === 0)
          throw new Error(`Chain with id ${chainId} not supported`);
        return sources[0].getViemTransport({ chainId });
      }
    };
    exports.PrioritizedProviderSourceCombinator = PrioritizedProviderSourceCombinator;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/infura-provider.js
var require_infura_provider2 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/infura-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InfuraProviderSource = void 0;
    var _chains_1 = require_chains();
    var base_http_provider_1 = require_base_http_provider();
    var SUPPORTED_CHAINS = {
      [_chains_1.Chains.ETHEREUM.chainId]: "https://mainnet.infura.io/v3/",
      [_chains_1.Chains.ETHEREUM_GOERLI.chainId]: "https://goerli.infura.io/v3/",
      [_chains_1.Chains.ETHEREUM_SEPOLIA.chainId]: "https://sepolia.infura.io/v3/",
      [_chains_1.Chains.ARBITRUM.chainId]: "https://arbitrum-mainnet.infura.io/v3/",
      [_chains_1.Chains.AURORA.chainId]: "https://aurora-mainnet.infura.io/v3/",
      [_chains_1.Chains.AVALANCHE.chainId]: "https://avalanche-mainnet.infura.io/v3/",
      [_chains_1.Chains.CELO.chainId]: "https://celo-mainnet.infura.io/v3/",
      [_chains_1.Chains.OPTIMISM.chainId]: "https://optimism-mainnet.infura.io/v3/",
      [_chains_1.Chains.POLYGON.chainId]: "https://polygon-mainnet.infura.io/v3/",
      [_chains_1.Chains.POLYGON_MUMBAI.chainId]: "https://polygon-mumbai.infura.io/v3/"
    };
    var InfuraProviderSource = class extends base_http_provider_1.BaseHttpProvider {
      constructor(key, onChains) {
        super();
        this.key = key;
        this.supported = onChains ?? Object.keys(SUPPORTED_CHAINS).map(Number);
      }
      supportedChains() {
        return this.supported;
      }
      calculateUrl(chainId) {
        return SUPPORTED_CHAINS[chainId] + this.key;
      }
    };
    exports.InfuraProviderSource = InfuraProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/llama-nodes-provider.js
var require_llama_nodes_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/llama-nodes-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LlamaNodesProviderSource = void 0;
    var _chains_1 = require_chains();
    var base_http_provider_1 = require_base_http_provider();
    var SUPPORTED_CHAINS = {
      [_chains_1.Chains.ETHEREUM.chainId]: "https://eth.llamarpc.com",
      [_chains_1.Chains.POLYGON.chainId]: "https://polygon.llamarpc.com",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "https://binance.llamarpc.com",
      [_chains_1.Chains.ARBITRUM.chainId]: "https://arbitrum.llamarpc.com",
      [_chains_1.Chains.OPTIMISM.chainId]: "https://optimism.llamarpc.com"
    };
    var LlamaNodesProviderSource = class extends base_http_provider_1.BaseHttpProvider {
      constructor(key, onChains) {
        super();
        this.key = key;
        this.supported = onChains ?? Object.keys(SUPPORTED_CHAINS).map(Number);
      }
      supportedChains() {
        return this.supported;
      }
      calculateUrl(chainId) {
        let url = SUPPORTED_CHAINS[chainId];
        if (this.key) {
          url += `/rpc/${this.key}`;
        }
        return url;
      }
    };
    exports.LlamaNodesProviderSource = LlamaNodesProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/updatable-provider.js
var require_updatable_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/updatable-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpdatableProviderSource = void 0;
    var UpdatableProviderSource = class {
      constructor(underlying) {
        this.underlying = underlying;
      }
      supportedClients() {
        return this.underlying()?.supportedClients() ?? {};
      }
      getEthersProvider({ chainId }) {
        const provider = this.underlying();
        if (!provider) {
          throw new Error(`Provider is not set yet`);
        }
        return provider.getEthersProvider({ chainId });
      }
      getViemTransport({ chainId }) {
        throw new Error("We do not support updatable providers for viem at the moment");
      }
    };
    exports.UpdatableProviderSource = UpdatableProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/web-sockets-provider.js
var require_web_sockets_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/web-sockets-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketProviderSource = void 0;
    var base_web_socket_provider_1 = require_base_web_socket_provider();
    var WebSocketProviderSource = class extends base_web_socket_provider_1.BaseWebSocketProvider {
      constructor(url, chains) {
        super();
        this.url = url;
        this.chains = chains;
        if (chains.length === 0)
          throw new Error("Must support at least one chain");
      }
      supportedChains() {
        return this.chains;
      }
      calculateUrl(chainId) {
        return this.url;
      }
    };
    exports.WebSocketProviderSource = WebSocketProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-service.js
var require_provider_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProviderService = void 0;
    var viem_1 = require_cjs2();
    var ProviderService = class {
      constructor(source) {
        this.source = source;
        this.viemPublicClients = /* @__PURE__ */ new Map();
      }
      supportedChains() {
        return Object.entries(this.source.supportedClients()).filter(([chainId, support]) => support.ethers || support.viem).map(([chainId]) => Number(chainId));
      }
      supportedClients() {
        return this.source.supportedClients();
      }
      getEthersProvider({ chainId }) {
        return this.source.getEthersProvider({ chainId });
      }
      getViemPublicClient({ chainId }) {
        if (!this.viemPublicClients.has(chainId)) {
          const transport = this.source.getViemTransport({ chainId });
          const client = (0, viem_1.createPublicClient)({ transport });
          this.viemPublicClients.set(chainId, client);
        }
        return this.viemPublicClients.get(chainId);
      }
    };
    exports.ProviderService = ProviderService;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/ethers-provider.js
var require_ethers_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/ethers-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthersProviderSource = void 0;
    var EthersProviderSource = class {
      constructor(provider) {
        this.provider = provider;
      }
      supportedClients() {
        return { [this.provider.network.chainId]: { ethers: true, viem: false } };
      }
      getEthersProvider({ chainId }) {
        return this.provider;
      }
      getViemTransport(_) {
        throw new Error("Not supported");
      }
    };
    exports.EthersProviderSource = EthersProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/node-real-provider.js
var require_node_real_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/node-real-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeRealProviderSource = void 0;
    var _chains_1 = require_chains();
    var base_http_provider_1 = require_base_http_provider();
    var SUPPORTED_CHAINS = {
      [_chains_1.Chains.ETHEREUM.chainId]: "https://eth-mainnet.nodereal.io/v1/",
      [_chains_1.Chains.ETHEREUM_GOERLI.chainId]: "https://eth-goerli.nodereal.io/v1/",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "https://bsc-mainnet.nodereal.io/v1/",
      [_chains_1.Chains.POLYGON.chainId]: "https://polygon-mainnet.nodereal.io/v1/",
      [_chains_1.Chains.OPTIMISM.chainId]: "https://opt-mainnet.nodereal.io/v1/"
    };
    var NodeRealProviderSource = class extends base_http_provider_1.BaseHttpProvider {
      constructor(key, onChains) {
        super();
        this.key = key;
        this.supported = onChains ?? Object.keys(SUPPORTED_CHAINS).map(Number);
      }
      supportedChains() {
        return this.supported;
      }
      calculateUrl(chainId) {
        return SUPPORTED_CHAINS[chainId] + this.key;
      }
    };
    exports.NodeRealProviderSource = NodeRealProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/get-block-provider.js
var require_get_block_provider = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/get-block-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GetBlockProviderSource = void 0;
    var base_http_provider_1 = require_base_http_provider();
    var GetBlockProviderSource = class extends base_http_provider_1.BaseHttpProvider {
      constructor(accessTokens) {
        super();
        this.accessTokens = accessTokens;
        this.supported = Object.keys(accessTokens).map(Number);
      }
      supportedChains() {
        return this.supported;
      }
      calculateUrl(chainId) {
        return `https://go.getblock.io/${this.accessTokens[chainId]}/`;
      }
    };
    exports.GetBlockProviderSource = GetBlockProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/ankr-provider.js
var require_ankr_provider2 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/ankr-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnkrProviderSource = void 0;
    var _chains_1 = require_chains();
    var base_http_provider_1 = require_base_http_provider();
    var SUPPORTED_CHAINS = {
      [_chains_1.Chains.POLYGON.chainId]: "https://rpc.ankr.com/polygon",
      [_chains_1.Chains.AVALANCHE.chainId]: "https://rpc.ankr.com/avalanche",
      [_chains_1.Chains.ETHEREUM.chainId]: "https://rpc.ankr.com/eth",
      [_chains_1.Chains.ETHEREUM_GOERLI.chainId]: "https://rpc.ankr.com/eth_goerli",
      [_chains_1.Chains.ETHEREUM_SEPOLIA.chainId]: "https://rpc.ankr.com/eth_sepolia",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "https://rpc.ankr.com/bsc",
      [_chains_1.Chains.FANTOM.chainId]: "https://rpc.ankr.com/fantom",
      [_chains_1.Chains.ARBITRUM.chainId]: "https://rpc.ankr.com/arbitrum",
      [_chains_1.Chains.OPTIMISM.chainId]: "https://rpc.ankr.com/optimism",
      [_chains_1.Chains.CELO.chainId]: "https://rpc.ankr.com/celo",
      [_chains_1.Chains.GNOSIS.chainId]: "https://rpc.ankr.com/gnosis",
      [_chains_1.Chains.POLYGON_ZKEVM.chainId]: "https://rpc.ankr.com/polygon_zkevm",
      [_chains_1.Chains.HARMONY_SHARD_0.chainId]: "https://rpc.ankr.com/harmony",
      [_chains_1.Chains.MOONBEAM.chainId]: "https://rpc.ankr.com/moonbeam",
      [_chains_1.Chains.BIT_TORRENT.chainId]: "https://rpc.ankr.com/bttc",
      [_chains_1.Chains.BASE.chainId]: "https://rpc.ankr.com/base",
      [_chains_1.Chains.KLAYTN.chainId]: "https://rpc.ankr.com/klaytn"
    };
    var AnkrProviderSource = class extends base_http_provider_1.BaseHttpProvider {
      constructor(key, onChains) {
        super();
        this.key = key;
        this.supported = onChains ?? Object.keys(SUPPORTED_CHAINS).map(Number);
      }
      supportedChains() {
        return this.supported;
      }
      calculateUrl(chainId) {
        let url = SUPPORTED_CHAINS[chainId];
        if (this.key) {
          url += `/${this.key}`;
        }
        return url;
      }
    };
    exports.AnkrProviderSource = AnkrProviderSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/provider-builder.js
var require_provider_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/provider-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildProviderService = void 0;
    var eip1993_provider_1 = require_eip1993_provider();
    var alchemy_provider_1 = require_alchemy_provider2();
    var public_providers_1 = require_public_providers();
    var fallback_provider_1 = require_fallback_provider2();
    var prioritized_provider_source_combinator_1 = require_prioritized_provider_source_combinator();
    var infura_provider_1 = require_infura_provider2();
    var http_provider_1 = require_http_provider();
    var llama_nodes_provider_1 = require_llama_nodes_provider();
    var updatable_provider_1 = require_updatable_provider();
    var web_sockets_provider_1 = require_web_sockets_provider();
    var provider_service_1 = require_provider_service();
    var ethers_provider_1 = require_ethers_provider();
    var node_real_provider_1 = require_node_real_provider();
    var get_block_provider_1 = require_get_block_provider();
    var ankr_provider_1 = require_ankr_provider2();
    function buildProviderService(params) {
      const source = buildSource(params?.source);
      return new provider_service_1.ProviderService(source);
    }
    exports.buildProviderService = buildProviderService;
    function buildSource(source) {
      switch (source?.type) {
        case void 0:
          return new public_providers_1.PublicRPCsSource();
        case "eip-1993":
          return new eip1993_provider_1.EIP1993ProviderSource(source.instance);
        case "ethers":
          return new ethers_provider_1.EthersProviderSource(source.instance);
        case "updatable":
          return new updatable_provider_1.UpdatableProviderSource(() => {
            const input = source.provider();
            return input ? buildSource(input) : void 0;
          });
        case "custom":
          return source.instance;
        case "public-rpcs":
          return new public_providers_1.PublicRPCsSource({ publicRPCs: source.rpcsPerChain, config: source.config });
        case "alchemy":
          return new alchemy_provider_1.AlchemyProviderSource(source.key, source.protocol ?? "https", source.onChains);
        case "llama-nodes":
          return new llama_nodes_provider_1.LlamaNodesProviderSource(source.key, source.onChains);
        case "ankr":
          return new ankr_provider_1.AnkrProviderSource(source.key, source.onChains);
        case "infura":
          return new infura_provider_1.InfuraProviderSource(source.key, source.onChains);
        case "node-real":
          return new node_real_provider_1.NodeRealProviderSource(source.key, source.onChains);
        case "get-block":
          return new get_block_provider_1.GetBlockProviderSource(source.accessTokens);
        case "http":
          return new http_provider_1.HttpProviderSource(source.url, source.supportedChains);
        case "web-socket":
          return new web_sockets_provider_1.WebSocketProviderSource(source.url, source.supportedChains);
        case "fallback":
          return new fallback_provider_1.FallbackSource(source.sources.map(buildSource), source.config);
        case "prioritized":
          return new prioritized_provider_source_combinator_1.PrioritizedProviderSourceCombinator(source.sources.map(buildSource));
      }
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/requirements-and-support.js
var require_requirements_and_support = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/requirements-and-support.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeRequirementsCompatible = exports.couldSupportMeetRequirements = exports.doesResponseMeetRequirements = exports.validateRequirements = exports.combineSupportRecords = exports.combineSupportInChains = exports.combineSourcesSupport = exports.calculateFieldRequirements = exports.calculateFieldRequirementsPerChain = void 0;
    var _chains_1 = require_chains();
    function calculateFieldRequirementsPerChain(supportRecord, requirements) {
      const result = {};
      for (const chainId in supportRecord) {
        result[chainId] = calculateFieldRequirements(supportRecord[chainId], requirements);
      }
      return result;
    }
    exports.calculateFieldRequirementsPerChain = calculateFieldRequirementsPerChain;
    function calculateFieldRequirements(supportRecord, requirements) {
      const result = {};
      const fields = /* @__PURE__ */ new Set([...Object.keys(supportRecord ?? {}), ...Object.keys(requirements?.requirements ?? {})]);
      for (const field of fields) {
        const requirement = requirements?.requirements?.[field] ?? requirements?.default ?? "best effort";
        result[field] = requirement === "can ignore" || supportRecord?.[field] !== "present" ? requirement : "required";
      }
      return result;
    }
    exports.calculateFieldRequirements = calculateFieldRequirements;
    function combineSourcesSupport(sources, extractSupport) {
      const allChains = (0, _chains_1.chainsUnion)(sources.map((source) => Object.keys(extractSupport(source)).map(Number)));
      const result = {};
      for (const chainId of allChains) {
        const supports = sources.map((source) => extractSupport(source)[chainId]).filter((support) => !!support);
        result[chainId] = combineSupportRecords(supports);
      }
      return result;
    }
    exports.combineSourcesSupport = combineSourcesSupport;
    function combineSupportInChains(chainIds, support) {
      const supportsInChains = chainIds.map((chainId) => support[chainId]).filter((support2) => !!support2);
      return combineSupportRecords(supportsInChains);
    }
    exports.combineSupportInChains = combineSupportInChains;
    function combineSupportRecords(supports) {
      const result = supports[0];
      for (let i = 1; i < supports.length; i++) {
        const sourceSupport = supports[i];
        const allKeys = [.../* @__PURE__ */ new Set([...Object.keys(sourceSupport), ...Object.keys(result)])];
        for (const key of allKeys) {
          if (result[key] !== sourceSupport[key]) {
            result[key] = "optional";
          }
        }
      }
      return result;
    }
    exports.combineSupportRecords = combineSupportRecords;
    function validateRequirements(support, chains, requirements) {
      if (!requirements)
        return;
      const supportRecord = combineSupportInChains(chains, support);
      if (!couldSupportMeetRequirements(supportRecord, requirements)) {
        throw new Error(`The provided field requirements cannot be met for all chains`);
      }
    }
    exports.validateRequirements = validateRequirements;
    function doesResponseMeetRequirements(response, requirements) {
      const fieldRequirements = calculateFieldRequirements(void 0, requirements);
      for (const field in fieldRequirements) {
        if (fieldRequirements[field] === "required" && !(field in (response ?? {}))) {
          return false;
        }
      }
      return true;
    }
    exports.doesResponseMeetRequirements = doesResponseMeetRequirements;
    function couldSupportMeetRequirements(chainSupport, requirements) {
      if (!requirements)
        return true;
      const fieldRequirements = calculateFieldRequirements(chainSupport, requirements);
      for (const key in fieldRequirements) {
        if (fieldRequirements[key] === "required" && chainSupport?.[key] !== "present" && chainSupport?.[key] !== "optional") {
          return false;
        }
      }
      return true;
    }
    exports.couldSupportMeetRequirements = couldSupportMeetRequirements;
    function makeRequirementsCompatible(supportRecord, chains, requirements) {
      if (!requirements)
        return requirements;
      const newRequirements = {};
      const isPropertyPresentOrOptionalInAllChains = (field) => chains.every((chainId) => !!supportRecord[chainId]?.[field]);
      for (const field in requirements.requirements) {
        if (requirements.requirements[field] !== "required" || isPropertyPresentOrOptionalInAllChains(field)) {
          newRequirements[field] = requirements.requirements[field];
        }
      }
      return { requirements: newRequirements, default: requirements.default };
    }
    exports.makeRequirementsCompatible = makeRequirementsCompatible;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/fastest-gas-price-source-combinator.js
var require_fastest_gas_price_source_combinator = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/fastest-gas-price-source-combinator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FastestGasPriceSourceCombinator = void 0;
    var requirements_and_support_1 = require_requirements_and_support();
    var FastestGasPriceSourceCombinator = class {
      constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
          throw new Error("No sources were specified");
      }
      supportedSpeeds() {
        return (0, requirements_and_support_1.combineSourcesSupport)(this.sources, (source) => source.supportedSpeeds());
      }
      async getGasPrice({ chainId, config: config2 }) {
        const sourcesInChain = this.sources.filter((source) => chainId in source.supportedSpeeds() && (0, requirements_and_support_1.couldSupportMeetRequirements)(source.supportedSpeeds()[chainId], config2?.fields));
        if (sourcesInChain.length === 0)
          throw new Error(`Chain with id ${chainId} cannot support the given requirements`);
        const gasResults = sourcesInChain.map((source) => source.getGasPrice({ chainId, config: config2 }).then((response) => failIfResponseDoesNotMeetRequirements(response, config2?.fields)));
        return Promise.any(gasResults);
      }
    };
    exports.FastestGasPriceSourceCombinator = FastestGasPriceSourceCombinator;
    function failIfResponseDoesNotMeetRequirements(response, requirements) {
      if (!(0, requirements_and_support_1.doesResponseMeetRequirements)(response, requirements)) {
        throw new Error("Failed to meet requirements");
      }
      return response;
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/open-ocean-gas-price-source.js
var require_open_ocean_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/open-ocean-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenOceanGasPriceSource = void 0;
    var _chains_1 = require_chains();
    var SUPPORTED_CHAINS = [
      _chains_1.Chains.ETHEREUM,
      _chains_1.Chains.POLYGON,
      _chains_1.Chains.BNB_CHAIN,
      _chains_1.Chains.FANTOM,
      _chains_1.Chains.AVALANCHE,
      _chains_1.Chains.HECO,
      _chains_1.Chains.OKC,
      _chains_1.Chains.GNOSIS,
      _chains_1.Chains.ARBITRUM,
      _chains_1.Chains.OPTIMISM,
      _chains_1.Chains.CRONOS,
      _chains_1.Chains.MOONRIVER,
      _chains_1.Chains.BOBA,
      _chains_1.Chains.POLYGON_ZKEVM,
      _chains_1.Chains.KAVA,
      _chains_1.Chains.CELO,
      _chains_1.Chains.BASE
    ];
    var OpenOceanGasPriceSource = class {
      constructor(fetchService) {
        this.fetchService = fetchService;
      }
      supportedSpeeds() {
        const support = { standard: "present", fast: "present", instant: "present" };
        return Object.fromEntries(SUPPORTED_CHAINS.map(({ chainId }) => [Number(chainId), support]));
      }
      async getGasPrice({ chainId, config: config2 }) {
        const response = await this.fetchService.fetch(`https://ethapi.openocean.finance/v2/${chainId}/gas-price`, { timeout: config2?.timeout });
        const body = await response.json();
        const result = typeof body.standard === "string" || typeof body.standard === "number" ? {
          standard: stringToLegacyGasPrice(body, "standard"),
          fast: stringToLegacyGasPrice(body, "fast"),
          instant: stringToLegacyGasPrice(body, "instant")
        } : {
          standard: toEip1159GasPrice(body, "standard"),
          fast: toEip1159GasPrice(body, "fast"),
          instant: toEip1159GasPrice(body, "instant")
        };
        return result;
      }
    };
    exports.OpenOceanGasPriceSource = OpenOceanGasPriceSource;
    function toEip1159GasPrice(body, key) {
      const { maxPriorityFeePerGas, maxFeePerGas } = body[key];
      return {
        maxFeePerGas: `${maxFeePerGas}`,
        maxPriorityFeePerGas: `${maxPriorityFeePerGas}`
      };
    }
    function stringToLegacyGasPrice(body, key) {
      return { gasPrice: `${body[key]}` };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/prioritized-gas-price-source-combinator.js
var require_prioritized_gas_price_source_combinator = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/prioritized-gas-price-source-combinator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrioritizedGasPriceSourceCombinator = void 0;
    var requirements_and_support_1 = require_requirements_and_support();
    var PrioritizedGasPriceSourceCombinator = class {
      constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
          throw new Error("No sources were specified");
      }
      supportedSpeeds() {
        return (0, requirements_and_support_1.combineSourcesSupport)(this.sources, (source) => source.supportedSpeeds());
      }
      async getGasPrice({ chainId, config: config2 }) {
        const sourcesInChain = this.sources.filter((source) => chainId in source.supportedSpeeds() && (0, requirements_and_support_1.couldSupportMeetRequirements)(source.supportedSpeeds()[chainId], config2?.fields));
        if (sourcesInChain.length === 0)
          throw new Error(`Chain with id ${chainId} cannot support the given requirements`);
        const gasResults = sourcesInChain.map((source) => source.getGasPrice({ chainId, config: config2 }).catch(() => ({})));
        return new Promise(async (resolve, reject) => {
          for (let i = 0; i < gasResults.length; i++) {
            const response = await gasResults[i];
            if (Object.keys(response).length > 0 && (0, requirements_and_support_1.doesResponseMeetRequirements)(response, config2?.fields)) {
              resolve(response);
            }
          }
          reject(new Error("Could not fetch gas prices that met the given requirements"));
        });
      }
    };
    exports.PrioritizedGasPriceSourceCombinator = PrioritizedGasPriceSourceCombinator;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/rpc-gas-price-source.js
var require_rpc_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/rpc-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RPCGasPriceSource = void 0;
    var timeouts_1 = require_timeouts();
    var RPCGasPriceSource = class {
      constructor(providerService) {
        this.providerService = providerService;
      }
      supportedSpeeds() {
        const support = { standard: "present" };
        return Object.fromEntries(this.providerService.supportedChains().map((chainId) => [Number(chainId), support]));
      }
      async getGasPrice({ chainId, config: config2 }) {
        const feeData = await (0, timeouts_1.timeoutPromise)(this.providerService.getEthersProvider({ chainId }).getFeeData(), config2?.timeout);
        const gasPrice = !!feeData.maxFeePerGas && !!feeData.maxPriorityFeePerGas ? { standard: { maxFeePerGas: feeData.maxFeePerGas.toString(), maxPriorityFeePerGas: feeData.maxPriorityFeePerGas.toString() } } : { standard: { gasPrice: feeData.gasPrice.toString() } };
        return gasPrice;
      }
    };
    exports.RPCGasPriceSource = RPCGasPriceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/viem.js
var require_viem = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/viem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapTxToViemTx = void 0;
    function mapTxToViemTx(tx) {
      return {
        ...tx,
        data: tx.data,
        to: tx.to,
        from: tx.from,
        value: tx.value ? BigInt(tx.value) : void 0,
        gasPrice: tx.gasPrice ? BigInt(tx.gasPrice) : void 0,
        maxFeePerGas: tx.maxFeePerGas ? BigInt(tx.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: tx.maxPriorityFeePerGas ? BigInt(tx.maxPriorityFeePerGas) : void 0
      };
    }
    exports.mapTxToViemTx = mapTxToViemTx;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-service.js
var require_gas_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GasService = void 0;
    var _chains_1 = require_chains();
    var timeouts_1 = require_timeouts();
    var requirements_and_support_1 = require_requirements_and_support();
    var viem_1 = require_viem();
    var GasService = class {
      constructor({ providerService, gasPriceSource }) {
        this.providerService = providerService;
        this.gasPriceSource = gasPriceSource;
      }
      supportedChains() {
        return (0, _chains_1.chainsIntersection)(this.providerService.supportedChains(), Object.keys(this.gasPriceSource.supportedSpeeds()).map(Number));
      }
      supportedSpeeds() {
        const supportedChains = this.supportedChains();
        const entries = Object.entries(this.gasPriceSource.supportedSpeeds()).filter(([chainId]) => supportedChains.includes(Number(chainId)));
        return Object.fromEntries(entries);
      }
      estimateGas({ chainId, tx, config: config2 }) {
        const promise = this.estimateGasInternal(chainId, tx);
        return (0, timeouts_1.timeoutPromise)(promise, config2?.timeout);
      }
      async getQuickGasCalculator({ chainId, config: config2 }) {
        (0, requirements_and_support_1.validateRequirements)(this.supportedSpeeds(), [chainId], config2?.fields);
        const support = this.supportedSpeeds()[chainId];
        const gasPriceData = await (0, timeouts_1.timeoutPromise)(this.gasPriceSource.getGasPrice({ chainId, config: config2 }), config2?.timeout);
        if (!(0, requirements_and_support_1.doesResponseMeetRequirements)(gasPriceData, config2?.fields)) {
          throw new Error("Failed to fetch gas prices that meet the given requirements");
        }
        return {
          supportedSpeeds: () => support,
          getGasPrice: () => gasPriceData,
          calculateGasCost: ({ gasEstimation }) => {
            const result = {};
            for (const [speed, gasPriceForSpeed] of Object.entries(gasPriceData)) {
              const actualGasPrice = "maxFeePerGas" in gasPriceForSpeed ? gasPriceForSpeed.maxFeePerGas : gasPriceForSpeed.gasPrice;
              const gasCostNativeToken = (BigInt(gasEstimation) * BigInt(actualGasPrice)).toString();
              result[speed] = { gasCostNativeToken, ...gasPriceForSpeed };
            }
            return result;
          }
        };
      }
      async getGasPrice({ chainId, config: config2 }) {
        const gasCalculator = await this.getQuickGasCalculator({ chainId, config: config2 });
        return gasCalculator.getGasPrice();
      }
      async calculateGasCost({ chainId, gasEstimation, tx, config: config2 }) {
        const gasCalculator = await this.getQuickGasCalculator({ chainId, config: config2 });
        return gasCalculator.calculateGasCost({ gasEstimation, tx });
      }
      estimateGasInternal(chainId, tx) {
        const viemTx = (0, viem_1.mapTxToViemTx)(tx);
        const viemSupported = this.providerService.supportedClients()[chainId]?.viem;
        return viemSupported ? this.providerService.getViemPublicClient({ chainId }).estimateGas({
          ...viemTx,
          account: viemTx.from
        }).then((estimate) => estimate.toString()) : this.providerService.getEthersProvider({ chainId }).estimateGas(tx).then((estimate) => estimate.toString());
      }
    };
    exports.GasService = GasService;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/owlracle-gas-price-source.js
var require_owlracle_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/owlracle-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OwlracleGasPriceSource = void 0;
    var _chains_1 = require_chains();
    var CHAINS = {
      [_chains_1.Chains.ETHEREUM.chainId]: "eth",
      [_chains_1.Chains.AVALANCHE.chainId]: "avax",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "bsc",
      [_chains_1.Chains.POLYGON.chainId]: "poly",
      [_chains_1.Chains.ARBITRUM.chainId]: "arb",
      [_chains_1.Chains.OPTIMISM.chainId]: "opt",
      [_chains_1.Chains.CRONOS.chainId]: "cro",
      [_chains_1.Chains.FANTOM.chainId]: "ftm",
      [_chains_1.Chains.AURORA.chainId]: "aurora",
      [_chains_1.Chains.MOONRIVER.chainId]: "movr",
      [_chains_1.Chains.HECO.chainId]: "ht",
      [_chains_1.Chains.CELO.chainId]: "celo",
      [_chains_1.Chains.HARMONY_SHARD_0.chainId]: "one",
      [_chains_1.Chains.FUSE.chainId]: "fuse"
    };
    var DEFAULT_CONFIG = {
      blocks: 200,
      percentile: 0.3,
      accept: {
        standard: 60,
        fast: 90,
        instant: 95
      }
    };
    var OwlracleGasPriceSource = class {
      constructor(fetchService, apiKey, config2) {
        this.fetchService = fetchService;
        this.apiKey = apiKey;
        this.config = { ...DEFAULT_CONFIG, ...config2 };
      }
      supportedSpeeds() {
        const support = { standard: "present", fast: "present", instant: "present" };
        return Object.fromEntries(Object.keys(CHAINS).map((chainId) => [Number(chainId), support]));
      }
      async getGasPrice({ chainId, config: config2 }) {
        const key = CHAINS[chainId];
        const accept = [this.config.accept.standard, this.config.accept.fast, this.config.accept.instant].join(",");
        const response = await this.fetchService.fetch(`https://api.owlracle.info/v3/${key}/gas?apikey=${this.apiKey}&reportwei=true&feeinusd=false&accept=${accept}&percentile=${this.config.percentile}&blocks=${this.config.blocks}`, { timeout: config2?.timeout });
        const { speeds } = await response.json();
        const [standard, fast, instant] = speeds;
        return {
          standard: filterOutExtraData(standard),
          fast: filterOutExtraData(fast),
          instant: filterOutExtraData(instant)
        };
      }
    };
    exports.OwlracleGasPriceSource = OwlracleGasPriceSource;
    function filterOutExtraData(result) {
      return "maxFeePerGas" in result ? { maxFeePerGas: result.maxFeePerGas, maxPriorityFeePerGas: result.maxPriorityFeePerGas } : { gasPrice: result.gasPrice };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/eth-gas-station-gas-price-source.js
var require_eth_gas_station_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/eth-gas-station-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthGasStationGasPriceSource = void 0;
    var _chains_1 = require_chains();
    var viem_1 = require_cjs2();
    var EthGasStationGasPriceSource = class {
      constructor(fetchService) {
        this.fetchService = fetchService;
      }
      supportedSpeeds() {
        const support = { standard: "present", fast: "present", instant: "present" };
        return { [_chains_1.Chains.ETHEREUM.chainId]: support };
      }
      async getGasPrice({ chainId, config: config2 }) {
        const response = await this.fetchService.fetch("https://api.ethgasstation.info/api/fee-estimate", { timeout: config2?.timeout });
        const { nextBaseFee, priorityFee: { standard, fast, instant } } = await response.json();
        return {
          standard: calculateGas(nextBaseFee, standard),
          fast: calculateGas(nextBaseFee, fast),
          instant: calculateGas(nextBaseFee, instant)
        };
      }
    };
    exports.EthGasStationGasPriceSource = EthGasStationGasPriceSource;
    function calculateGas(baseFee, priorityFee) {
      return {
        maxFeePerGas: (0, viem_1.parseUnits)(`${baseFee + priorityFee}`, 9).toString(),
        maxPriorityFeePerGas: (0, viem_1.parseUnits)(`${priorityFee}`, 9).toString()
      };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/etherscan-gas-price-source.js
var require_etherscan_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/etherscan-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherscanGasPriceSource = void 0;
    var _chains_1 = require_chains();
    var viem_1 = require_cjs2();
    var CHAINS = {
      [_chains_1.Chains.ETHEREUM.chainId]: "etherscan.io",
      [_chains_1.Chains.POLYGON.chainId]: "polygonscan.com",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "bscscan.com",
      [_chains_1.Chains.FANTOM.chainId]: "ftmscan.com"
    };
    var EtherscanGasPriceSource = class {
      constructor(fetchService, apiKeys) {
        this.fetchService = fetchService;
        this.apiKeys = apiKeys;
      }
      supportedSpeeds() {
        const support = { standard: "present", fast: "present", instant: "present" };
        return Object.fromEntries(Object.keys(CHAINS).map((chainId) => [Number(chainId), support]));
      }
      async getGasPrice({ chainId, config: config2 }) {
        let url = `https://api.${CHAINS[chainId]}/api?module=gastracker&action=gasoracle`;
        if (this.apiKeys?.[chainId]) {
          url += `&apikey=${this.apiKeys[chainId]} `;
        }
        const response = await this.fetchService.fetch(url, { timeout: config2?.timeout });
        const { result: { SafeGasPrice, ProposeGasPrice, FastGasPrice, suggestBaseFee } } = await response.json();
        return {
          standard: calculateGas(SafeGasPrice, suggestBaseFee),
          fast: calculateGas(ProposeGasPrice, suggestBaseFee),
          instant: calculateGas(FastGasPrice, suggestBaseFee)
        };
      }
    };
    exports.EtherscanGasPriceSource = EtherscanGasPriceSource;
    function calculateGas(price, baseFee) {
      const gasPrice = (0, viem_1.parseUnits)(price, 9);
      if (!baseFee)
        return { gasPrice: gasPrice.toString() };
      const base = (0, viem_1.parseUnits)(baseFee, 9);
      return {
        maxFeePerGas: gasPrice.toString(),
        maxPriorityFeePerGas: (gasPrice - base).toString()
      };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/polygon-gas-station-gas-price-source.js
var require_polygon_gas_station_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/polygon-gas-station-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PolygonGasStationGasPriceSource = void 0;
    var _chains_1 = require_chains();
    var viem_1 = require_cjs2();
    var PolygonGasStationGasPriceSource = class {
      constructor(fetchService) {
        this.fetchService = fetchService;
      }
      supportedSpeeds() {
        const support = { standard: "present", fast: "present", instant: "present" };
        return { [_chains_1.Chains.POLYGON.chainId]: support };
      }
      async getGasPrice({ chainId, config: config2 }) {
        const response = await this.fetchService.fetch("https://gasstation-mainnet.matic.network/v2", { timeout: config2?.timeout });
        const { safeLow, standard, fast } = await response.json();
        return {
          standard: calculateGas(safeLow),
          fast: calculateGas(standard),
          instant: calculateGas(fast)
        };
      }
    };
    exports.PolygonGasStationGasPriceSource = PolygonGasStationGasPriceSource;
    function calculateGas(gas) {
      return {
        maxFeePerGas: (0, viem_1.parseUnits)(gas.maxFee.toFixed(9), 9).toString(),
        maxPriorityFeePerGas: (0, viem_1.parseUnits)(gas.maxPriorityFee.toFixed(9), 9).toString()
      };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/utils.js
var require_utils13 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitInChunks = exports.toTrimmedHex = exports.fromTokenInChain = exports.toTokenInChain = exports.ruleOfThree = exports.filterRejectedResults = exports.amountToUSD = exports.toUnits = exports.timeToSeconds = exports.calculateDeadline = exports.mulDivByNumber = exports.addPercentage = exports.substractPercentage = exports.isSameAddress = exports.wait = void 0;
    var ms_1 = __importDefault(require_dist());
    var viem_1 = require_cjs2();
    function wait2(time) {
      return new Promise((resolve) => setTimeout(resolve, (0, ms_1.default)(`${time}`)));
    }
    exports.wait = wait2;
    function isSameAddress(address1, address2) {
      return !!address1 && !!address2 && address1.toLowerCase() === address2.toLowerCase();
    }
    exports.isSameAddress = isSameAddress;
    function substractPercentage(amount, slippagePercentage, rounding) {
      const percentage = mulDivByNumber(amount, slippagePercentage, 100, rounding);
      return BigInt(amount) - percentage;
    }
    exports.substractPercentage = substractPercentage;
    function addPercentage(amount, slippagePercentage, rounding) {
      const percentage = mulDivByNumber(amount, slippagePercentage, 100, rounding);
      return BigInt(amount) + percentage;
    }
    exports.addPercentage = addPercentage;
    var PRECISION = 1e7;
    function mulDivByNumber(amount, mul, div, rounding) {
      const round = (num) => BigInt(Math.round(num * PRECISION));
      const numerator = BigInt(amount) * round(mul);
      const denominator = round(div);
      const result = numerator / denominator;
      return numerator % denominator !== 0n && rounding === "up" ? result + 1n : result;
    }
    exports.mulDivByNumber = mulDivByNumber;
    function calculateDeadline(txValidFor) {
      return txValidFor ? Math.floor((Date.now() + (0, ms_1.default)(txValidFor)) / 1e3) : void 0;
    }
    exports.calculateDeadline = calculateDeadline;
    function timeToSeconds(time) {
      return Math.floor((0, ms_1.default)(time) / 1e3);
    }
    exports.timeToSeconds = timeToSeconds;
    function toUnits(amount, decimals, precision = 5) {
      const units = (0, viem_1.formatUnits)(BigInt(amount), decimals);
      const regex = new RegExp("^-?\\d+(?:.\\d{0," + (precision || -1) + "})?");
      return units.match(regex)[0];
    }
    exports.toUnits = toUnits;
    var USD_PRECISION = 8;
    function amountToUSD(decimals, amount, usdPrice, precision = 3) {
      if (!!usdPrice) {
        const priceBN = (0, viem_1.parseUnits)(`${usdPrice.toFixed(USD_PRECISION)}`, USD_PRECISION);
        const magnitude = (0, viem_1.parseUnits)("1", decimals);
        const amountUSDBN = priceBN * BigInt(amount) / magnitude;
        return toUnits(amountUSDBN.toString(), USD_PRECISION, precision);
      }
      return void 0;
    }
    exports.amountToUSD = amountToUSD;
    async function filterRejectedResults(promises) {
      const results = await Promise.allSettled(promises);
      return results.filter((result) => result.status === "fulfilled").map(({ value }) => value);
    }
    exports.filterRejectedResults = filterRejectedResults;
    function ruleOfThree({ a, matchA, b }) {
      const matchABN = BigInt(matchA);
      const bBN = BigInt(b);
      if (bBN === 0n || matchABN === 0n)
        return 0n;
      return bBN * matchABN / BigInt(a);
    }
    exports.ruleOfThree = ruleOfThree;
    function toTokenInChain(chainId, address) {
      return `${chainId}:${address}`;
    }
    exports.toTokenInChain = toTokenInChain;
    function fromTokenInChain(tokenInChain) {
      const [chainId, address] = tokenInChain.split(":");
      return { chainId: parseInt(chainId), address };
    }
    exports.fromTokenInChain = fromTokenInChain;
    function toTrimmedHex(value) {
      const trimmed = (0, viem_1.trim)((0, viem_1.toHex)(value));
      return trimmed.startsWith("0x0") && trimmed !== "0x0" ? trimmed.replace("0x0", "0x") : trimmed;
    }
    exports.toTrimmedHex = toTrimmedHex;
    function splitInChunks(list, chunkSize) {
      const result = [];
      for (let i = 0; i < list.length; i += chunkSize) {
        result.push(list.slice(i, i + chunkSize));
      }
      return result;
    }
    exports.splitInChunks = splitInChunks;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/utils.js
var require_utils14 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEIP1159Compatible = void 0;
    function isEIP1159Compatible(gasPriceForSpeed) {
      const keys = Object.keys(gasPriceForSpeed);
      if (keys.length === 0) {
        throw new Error(`Found a gas price result with nothing on it. This shouldn't happen`);
      }
      const gasPrice = gasPriceForSpeed[keys[0]];
      if ("maxFeePerGas" in gasPrice) {
        return true;
      }
      return false;
    }
    exports.isEIP1159Compatible = isEIP1159Compatible;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/aggregator-gas-price-source.js
var require_aggregator_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/aggregator-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AggregatorGasPriceSource = void 0;
    var requirements_and_support_1 = require_requirements_and_support();
    var timeouts_1 = require_timeouts();
    var utils_1 = require_utils13();
    var utils_2 = require_utils14();
    var AggregatorGasPriceSource = class {
      constructor(logsService, sources, method) {
        this.sources = sources;
        this.method = method;
        this.logger = logsService.getLogger({ name: "AggregatorGasPriceSource" });
        if (sources.length === 0)
          throw new Error("No sources were specified");
      }
      supportedSpeeds() {
        return (0, requirements_and_support_1.combineSourcesSupport)(this.sources, (source) => source.supportedSpeeds());
      }
      async getGasPrice({ chainId, config: config2 }) {
        const sourcesInChain = this.sources.filter((source) => chainId in source.supportedSpeeds() && (0, requirements_and_support_1.couldSupportMeetRequirements)(source.supportedSpeeds()[chainId], config2?.fields));
        if (sourcesInChain.length === 0)
          throw new Error(`Chain with id ${chainId} cannot support the given requirements`);
        const promises = sourcesInChain.map((source) => (0, timeouts_1.timeoutPromise)(source.getGasPrice({ chainId, config: config2 }), config2?.timeout, { reduceBy: "100" }));
        const results = await (0, utils_1.filterRejectedResults)(promises);
        if (results.length === 0) {
          for (const promise of promises) {
            await promise.catch((e) => this.logger.debug(`Gas price source failed with '${e}'`));
          }
          throw new Error("Failed to calculate gas on all sources");
        }
        const validResults = results.filter((response) => (0, requirements_and_support_1.doesResponseMeetRequirements)(response, config2?.fields));
        if (validResults.length === 0)
          throw new Error("Could not fetch gas prices that met the given requirements");
        const resultsToAggregate = resultsWithMaxSpeed(validResults);
        const result = this.aggregate(resultsToAggregate);
        return result;
      }
      aggregate(results) {
        const is1559 = results.some(utils_2.isEIP1159Compatible);
        if (is1559) {
          const collected = collectBySpeed(results.filter(utils_2.isEIP1159Compatible));
          return aggregate(true, collected, this.method);
        } else {
          const collected = collectBySpeed(results.filter((result) => !(0, utils_2.isEIP1159Compatible)(result)));
          return aggregate(false, collected, this.method);
        }
      }
    };
    exports.AggregatorGasPriceSource = AggregatorGasPriceSource;
    function resultsWithMaxSpeed(results) {
      const maxSpeeds = results.reduce((accum, curr) => Object.keys(accum).length >= Object.keys(curr).length ? accum : curr);
      const speedsId = (result) => Object.keys(result).join("-");
      const maxSpeedsId = speedsId(maxSpeeds);
      return results.filter((result) => maxSpeedsId === speedsId(result));
    }
    function collectBySpeed(array) {
      const collected = {};
      for (const gasPrice of array) {
        for (const speed in gasPrice) {
          if (!(speed in collected))
            collected[speed] = [];
          collected[speed].push(gasPrice[speed]);
        }
      }
      return collected;
    }
    function aggregate(is1559, bySpeed, method) {
      const result = {};
      for (const speed in bySpeed) {
        result[speed] = aggregateBySpeed(is1559, bySpeed[speed], method);
      }
      return result;
    }
    function aggregateBySpeed(is1559, toAggregate, method) {
      return is1559 ? aggregate1559(toAggregate, method) : aggregateLegacy(toAggregate, method);
    }
    function aggregate1559(toAggregate, method) {
      switch (method) {
        case "median":
          return medianByProperty(toAggregate, "maxFeePerGas");
        case "max":
          return maxByProperty(toAggregate, "maxFeePerGas");
        case "min":
          return minByProperty(toAggregate, "maxFeePerGas");
      }
    }
    function aggregateLegacy(toAggregate, method) {
      switch (method) {
        case "median":
          return medianByProperty(toAggregate, "gasPrice");
        case "max":
          return maxByProperty(toAggregate, "gasPrice");
        case "min":
          return minByProperty(toAggregate, "gasPrice");
      }
    }
    function medianByProperty(array, property) {
      const sorted = array.sort((a, b) => BigInt(a[property]) <= BigInt(b[property]) ? -1 : 1);
      return sorted[Math.floor(Math.max(sorted.length - 1, 0) / 2)];
    }
    function maxByProperty(array, property) {
      return array.reduce((accum, curr) => BigInt(accum[property]) >= BigInt(curr[property]) ? accum : curr);
    }
    function minByProperty(array, property) {
      return array.reduce((accum, curr) => BigInt(accum[property]) <= BigInt(curr[property]) ? accum : curr);
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/paraswap-gas-price-source.js
var require_paraswap_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/paraswap-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParaswapGasPriceSource = void 0;
    var _chains_1 = require_chains();
    var SUPPORTED_CHAINS = [
      _chains_1.Chains.ETHEREUM,
      _chains_1.Chains.POLYGON,
      _chains_1.Chains.BNB_CHAIN,
      _chains_1.Chains.AVALANCHE,
      _chains_1.Chains.FANTOM,
      _chains_1.Chains.ARBITRUM,
      _chains_1.Chains.OPTIMISM,
      _chains_1.Chains.BASE
    ];
    var ParaswapGasPriceSource = class {
      constructor(fetchService) {
        this.fetchService = fetchService;
      }
      supportedSpeeds() {
        const support = { standard: "present", fast: "present", instant: "present" };
        return Object.fromEntries(SUPPORTED_CHAINS.map(({ chainId }) => [Number(chainId), support]));
      }
      async getGasPrice({ chainId, config: config2 }) {
        const response = await this.fetchService.fetch(`https://api.paraswap.io/prices/gas/${chainId}?eip1559=false`, { timeout: config2?.timeout });
        const body = await response.json();
        return {
          standard: stringToLegacyGasPrice(body, "average"),
          fast: stringToLegacyGasPrice(body, "fast"),
          instant: stringToLegacyGasPrice(body, "fastest")
        };
      }
    };
    exports.ParaswapGasPriceSource = ParaswapGasPriceSource;
    function stringToLegacyGasPrice(body, key) {
      return { gasPrice: `${body[key]}` };
    }
  }
});

// ../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "../node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// ../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice2 = Array.prototype.slice;
    var toStr2 = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind2(that) {
      var target = this;
      if (typeof target !== "function" || toStr2.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice2.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice2.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice2.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../node_modules/has/src/index.js
var require_src = __commonJS({
  "../node_modules/has/src/index.js"(exports, module) {
    "use strict";
    var bind2 = require_function_bind();
    module.exports = bind2.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// ../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen2 = doEval2("%AsyncGenerator%");
        if (gen2 && getProto) {
          value = getProto(gen2.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind2 = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind2.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
    var $replace = bind2.call(Function.call, String.prototype.replace);
    var $strSlice = bind2.call(Function.call, String.prototype.slice);
    var $exec = bind2.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number3, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number3 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind2 = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind2, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// ../node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):../node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):../node_modules/object-inspect/util.inspect"() {
  }
});

// ../node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr2(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr2(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr2(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr2(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr2(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr2(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr2(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr2(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr2(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size3, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size3 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// ../node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// ../node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../node_modules/qs/lib/utils.js
var require_utils15 = __commonJS({
  "../node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// ../node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS({
  "../node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils15();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify3 = function stringify4(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder3, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder3 && !encodeValuesOnly ? encoder3(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder3) {
          var keyValue = encodeValuesOnly ? prefix : encoder3(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder3(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder3) {
          obj = utils.maybeMap(obj, encoder3);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify4(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder3,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify3(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils15();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index2 = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index2) && root !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
            obj = [];
            obj[index2] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../node_modules/qs/lib/index.js
var require_lib23 = __commonJS({
  "../node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify3 = require_stringify2();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify: stringify3
    };
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/errors.js
var require_errors3 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FailedToGenerateAnyQuotesError = exports.FailedToGenerateQuoteError = exports.SourceInvalidConfigOrContextError = exports.SourceNoBuyOrdersError = exports.SourceNoSwapAndTransferError = exports.SourceNotOnChainError = exports.SourceNotFoundError = void 0;
    var _chains_1 = require_chains();
    var SourceNotFoundError = class extends Error {
      constructor(sourceId) {
        super(`Could not find a source with id '${sourceId}'`);
      }
    };
    exports.SourceNotFoundError = SourceNotFoundError;
    var SourceNotOnChainError = class extends Error {
      constructor(sourceId, chainId) {
        super(`Source with id '${sourceId}' does not support chain with id ${chainId}`);
      }
    };
    exports.SourceNotOnChainError = SourceNotOnChainError;
    var SourceNoSwapAndTransferError = class extends Error {
      constructor(sourceId) {
        super(`Source with id '${sourceId}' does not support swap & transfer, but a recipient different from the taker address was set`);
      }
    };
    exports.SourceNoSwapAndTransferError = SourceNoSwapAndTransferError;
    var SourceNoBuyOrdersError = class extends Error {
      constructor(sourceId) {
        super(`Source with id '${sourceId}' does not support buy orders`);
      }
    };
    exports.SourceNoBuyOrdersError = SourceNoBuyOrdersError;
    var SourceInvalidConfigOrContextError = class extends Error {
      constructor(sourceId) {
        super(`The current context or config is not valid for source with id '${sourceId}'`);
      }
    };
    exports.SourceInvalidConfigOrContextError = SourceInvalidConfigOrContextError;
    var FailedToGenerateQuoteError = class extends Error {
      constructor(sourceName, chainId, sellToken, buyToken, error) {
        const context2 = error ? ` with error ${JSON.stringify(error)}` : "";
        const chain = (0, _chains_1.getChainByKey)(chainId)?.name ?? `chain with id ${chainId}`;
        super(`${sourceName}: failed to calculate a quote between ${sellToken} and ${buyToken} on ${chain}${context2}`);
      }
    };
    exports.FailedToGenerateQuoteError = FailedToGenerateQuoteError;
    var FailedToGenerateAnyQuotesError = class extends Error {
      constructor(chainId, sellToken, buyToken) {
        const chain = (0, _chains_1.getChainByKey)(chainId)?.name ?? `chain with id ${chainId}`;
        super(`Failed to calculate a quote between ${sellToken} and ${buyToken} on ${chain}`);
      }
    };
    exports.FailedToGenerateAnyQuotesError = FailedToGenerateAnyQuotesError;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/constants.js
var require_constants = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint = exports.Addresses = void 0;
    var Addresses;
    (function(Addresses2) {
      Addresses2["NATIVE_TOKEN"] = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
      Addresses2["ZERO_ADDRESS"] = "0x0000000000000000000000000000000000000000";
    })(Addresses = exports.Addresses || (exports.Addresses = {}));
    exports.Uint = {
      MAX_256: 2n ** 256n - 1n
    };
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/utils.js
var require_utils16 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checksum = exports.calculateAllowanceTarget = exports.addQuoteSlippage = exports.failed = void 0;
    var viem_1 = require_cjs2();
    var utils_1 = require_utils13();
    var errors_1 = require_errors3();
    var constants_1 = require_constants();
    function failed(metadata, chain, sellToken, buyToken, error) {
      throw new errors_1.FailedToGenerateQuoteError(metadata.name, chain.chainId, sellToken, buyToken, error);
    }
    exports.failed = failed;
    function addQuoteSlippage(quote, type, slippagePercentage) {
      return type === "sell" ? {
        ...quote,
        type,
        minBuyAmount: BigInt((0, utils_1.substractPercentage)(quote.buyAmount, slippagePercentage, "up")),
        maxSellAmount: quote.sellAmount
      } : {
        ...quote,
        type,
        maxSellAmount: BigInt((0, utils_1.addPercentage)(quote.sellAmount, slippagePercentage, "up")),
        minBuyAmount: quote.buyAmount
      };
    }
    exports.addQuoteSlippage = addQuoteSlippage;
    function calculateAllowanceTarget(sellToken, allowanceTarget) {
      return (0, utils_1.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : allowanceTarget;
    }
    exports.calculateAllowanceTarget = calculateAllowanceTarget;
    function checksum(address) {
      return (0, viem_1.getAddress)(address);
    }
    exports.checksum = checksum;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/changelly-quote-source.js
var require_changelly_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/changelly-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChangellyQuoteSource = exports.CHANGELLY_METADATA = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var utils_1 = require_utils16();
    var constants_1 = require_constants();
    var utils_2 = require_utils13();
    exports.CHANGELLY_METADATA = {
      name: "Changelly DEX",
      supports: {
        chains: [_chains_1.Chains.ETHEREUM, _chains_1.Chains.OPTIMISM, _chains_1.Chains.ARBITRUM, _chains_1.Chains.BNB_CHAIN, _chains_1.Chains.POLYGON, _chains_1.Chains.FANTOM, _chains_1.Chains.AVALANCHE].map(({ chainId }) => chainId),
        swapAndTransfer: true,
        buyOrders: false
      },
      logoURI: "ipfs://Qmbnnx5bD1wytBna4oY8DaL1cw5c5mTStwUMqLCoLt3yHR"
    };
    var ChangellyQuoteSource = class {
      getMetadata() {
        return exports.CHANGELLY_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout } }, config: config2 }) {
        const queryParams = {
          fromTokenAddress: sellToken,
          toTokenAddress: buyToken,
          amount: order.sellAmount.toString(),
          slippage: slippagePercentage * 10,
          recipientAddress: recipient && !(0, utils_2.isSameAddress)(recipient, takeFrom) ? recipient : void 0,
          skipValidation: config2.disableValidation,
          takerAddress: config2.disableValidation ? void 0 : takeFrom
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `https://dex-api.changelly.com/v1/${chain.chainId}/quote?${queryString}`;
        const headers = { "X-Api-Key": config2.apiKey };
        const response = await fetchService.fetch(url, { timeout, headers });
        if (!response.ok) {
          (0, utils_1.failed)(exports.CHANGELLY_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const { amount_out_total, estimate_gas_total, calldata, to } = await response.json();
        const quote = {
          sellAmount: order.sellAmount,
          buyAmount: BigInt(amount_out_total),
          estimatedGas: BigInt(estimate_gas_total),
          allowanceTarget: (0, utils_1.calculateAllowanceTarget)(sellToken, to),
          tx: {
            to,
            calldata,
            value: (0, utils_2.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN) ? order.sellAmount : 0n
          }
        };
        return (0, utils_1.addQuoteSlippage)(quote, order.type, slippagePercentage);
      }
      isConfigAndContextValid(config2) {
        return !!config2?.apiKey;
      }
    };
    exports.ChangellyQuoteSource = ChangellyQuoteSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/changelly-gas-price-source.js
var require_changelly_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/changelly-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChangellyGasPriceSource = void 0;
    var changelly_quote_source_1 = require_changelly_quote_source();
    var viem_1 = require_cjs2();
    var ChangellyGasPriceSource = class {
      constructor(fetchService, apiKey) {
        this.fetchService = fetchService;
        this.apiKey = apiKey;
      }
      supportedSpeeds() {
        const support = { standard: "present", fast: "present", instant: "present" };
        return Object.fromEntries(changelly_quote_source_1.CHANGELLY_METADATA.supports.chains.map((chainId) => [Number(chainId), support]));
      }
      async getGasPrice({ chainId, config: config2 }) {
        const response = await this.fetchService.fetch(`https://dex-api.changelly.com/v1/${chainId}/gasprices`, {
          timeout: config2?.timeout,
          headers: { "X-Api-Key": this.apiKey }
        });
        const body = await response.json();
        return {
          standard: calculateGas(body, "low"),
          fast: calculateGas(body, "medium"),
          instant: calculateGas(body, "high")
        };
      }
    };
    exports.ChangellyGasPriceSource = ChangellyGasPriceSource;
    function calculateGas(result, value) {
      return {
        gasPrice: (0, viem_1.parseUnits)(result[value], 9).toString()
      };
    }
  }
});

// ../node_modules/@mean-finance/sdk/node_modules/lru-cache/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "../node_modules/@mean-finance/sdk/node_modules/lru-cache/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        constructor() {
          __publicField(this, "onabort");
          __publicField(this, "_onabort", []);
          __publicField(this, "reason");
          __publicField(this, "aborted", false);
        }
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          __publicField(this, "signal", new AS());
          warnACPolyfill();
        }
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size3) {
        super(size3);
        this.fill(0);
      }
    };
    var _constructing;
    var _Stack = class {
      constructor(max2, HeapCls) {
        __publicField(this, "heap");
        __publicField(this, "length");
        if (!__privateGet(_Stack, _constructing)) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max2);
        this.length = 0;
      }
      static create(max2) {
        const HeapCls = getUintArray(max2);
        if (!HeapCls)
          return [];
        __privateSet(_Stack, _constructing, true);
        const s = new _Stack(max2, HeapCls);
        __privateSet(_Stack, _constructing, false);
        return s;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var Stack = _Stack;
    _constructing = new WeakMap();
    __privateAdd(Stack, _constructing, false);
    var _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _initializeTTLTracking, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, _initializeSizeTracking, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, _indexes, indexes_fn, _rindexes, rindexes_fn, _isValidIndex, isValidIndex_fn, _evict, evict_fn, _backgroundFetch, backgroundFetch_fn, _isBackgroundFetch, isBackgroundFetch_fn, _connect, connect_fn, _moveToTail, moveToTail_fn;
    var _LRUCache = class {
      constructor(options) {
        __privateAdd(this, _initializeTTLTracking);
        __privateAdd(this, _initializeSizeTracking);
        __privateAdd(this, _indexes);
        __privateAdd(this, _rindexes);
        __privateAdd(this, _isValidIndex);
        __privateAdd(this, _evict);
        __privateAdd(this, _backgroundFetch);
        __privateAdd(this, _isBackgroundFetch);
        __privateAdd(this, _connect);
        __privateAdd(this, _moveToTail);
        __privateAdd(this, _max, void 0);
        __privateAdd(this, _maxSize, void 0);
        __privateAdd(this, _dispose, void 0);
        __privateAdd(this, _disposeAfter, void 0);
        __privateAdd(this, _fetchMethod, void 0);
        __publicField(this, "ttl");
        __publicField(this, "ttlResolution");
        __publicField(this, "ttlAutopurge");
        __publicField(this, "updateAgeOnGet");
        __publicField(this, "updateAgeOnHas");
        __publicField(this, "allowStale");
        __publicField(this, "noDisposeOnSet");
        __publicField(this, "noUpdateTTL");
        __publicField(this, "maxEntrySize");
        __publicField(this, "sizeCalculation");
        __publicField(this, "noDeleteOnFetchRejection");
        __publicField(this, "noDeleteOnStaleGet");
        __publicField(this, "allowStaleOnFetchAbort");
        __publicField(this, "allowStaleOnFetchRejection");
        __publicField(this, "ignoreFetchAbort");
        __privateAdd(this, _size, void 0);
        __privateAdd(this, _calculatedSize, void 0);
        __privateAdd(this, _keyMap, void 0);
        __privateAdd(this, _keyList, void 0);
        __privateAdd(this, _valList, void 0);
        __privateAdd(this, _next, void 0);
        __privateAdd(this, _prev, void 0);
        __privateAdd(this, _head, void 0);
        __privateAdd(this, _tail, void 0);
        __privateAdd(this, _free, void 0);
        __privateAdd(this, _disposed, void 0);
        __privateAdd(this, _sizes, void 0);
        __privateAdd(this, _starts, void 0);
        __privateAdd(this, _ttls, void 0);
        __privateAdd(this, _hasDispose, void 0);
        __privateAdd(this, _hasFetchMethod, void 0);
        __privateAdd(this, _hasDisposeAfter, void 0);
        __privateAdd(this, _updateItemAge, () => {
        });
        __privateAdd(this, _statusTTL, () => {
        });
        __privateAdd(this, _setItemTTL, () => {
        });
        __privateAdd(this, _isStale, () => false);
        __privateAdd(this, _removeItemSize, (_i) => {
        });
        __privateAdd(this, _addItemSize, (_i, _s, _st) => {
        });
        __privateAdd(this, _requireSize, (_k, _v, size3, sizeCalculation) => {
          if (size3 || sizeCalculation) {
            throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
          }
          return 0;
        });
        const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max2 !== 0 && !isPosInt(max2)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max2 ? getUintArray(max2) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max2);
        }
        __privateSet(this, _max, max2);
        __privateSet(this, _maxSize, maxSize);
        this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        __privateSet(this, _fetchMethod, fetchMethod);
        __privateSet(this, _hasFetchMethod, !!fetchMethod);
        __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
        __privateSet(this, _keyList, new Array(max2).fill(void 0));
        __privateSet(this, _valList, new Array(max2).fill(void 0));
        __privateSet(this, _next, new UintArray(max2));
        __privateSet(this, _prev, new UintArray(max2));
        __privateSet(this, _head, 0);
        __privateSet(this, _tail, 0);
        __privateSet(this, _free, Stack.create(max2));
        __privateSet(this, _size, 0);
        __privateSet(this, _calculatedSize, 0);
        if (typeof dispose === "function") {
          __privateSet(this, _dispose, dispose);
        }
        if (typeof disposeAfter === "function") {
          __privateSet(this, _disposeAfter, disposeAfter);
          __privateSet(this, _disposed, []);
        } else {
          __privateSet(this, _disposeAfter, void 0);
          __privateSet(this, _disposed, void 0);
        }
        __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
        __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (__privateGet(this, _maxSize) !== 0) {
            if (!isPosInt(__privateGet(this, _maxSize))) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          __privateMethod(this, _initializeSizeTracking, initializeSizeTracking_fn).call(this);
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      static unsafeExposeInternals(c) {
        return {
          starts: __privateGet(c, _starts),
          ttls: __privateGet(c, _ttls),
          sizes: __privateGet(c, _sizes),
          keyMap: __privateGet(c, _keyMap),
          keyList: __privateGet(c, _keyList),
          valList: __privateGet(c, _valList),
          next: __privateGet(c, _next),
          prev: __privateGet(c, _prev),
          get head() {
            return __privateGet(c, _head);
          },
          get tail() {
            return __privateGet(c, _tail);
          },
          free: __privateGet(c, _free),
          isBackgroundFetch: (p) => {
            var _a;
            return __privateMethod(_a = c, _isBackgroundFetch, isBackgroundFetch_fn).call(_a, p);
          },
          backgroundFetch: (k, index2, options, context2) => {
            var _a;
            return __privateMethod(_a = c, _backgroundFetch, backgroundFetch_fn).call(_a, k, index2, options, context2);
          },
          moveToTail: (index2) => {
            var _a;
            return __privateMethod(_a = c, _moveToTail, moveToTail_fn).call(_a, index2);
          },
          indexes: (options) => {
            var _a;
            return __privateMethod(_a = c, _indexes, indexes_fn).call(_a, options);
          },
          rindexes: (options) => {
            var _a;
            return __privateMethod(_a = c, _rindexes, rindexes_fn).call(_a, options);
          },
          isStale: (index2) => {
            var _a;
            return __privateGet(_a = c, _isStale).call(_a, index2);
          }
        };
      }
      get max() {
        return __privateGet(this, _max);
      }
      get maxSize() {
        return __privateGet(this, _maxSize);
      }
      get calculatedSize() {
        return __privateGet(this, _calculatedSize);
      }
      get size() {
        return __privateGet(this, _size);
      }
      get fetchMethod() {
        return __privateGet(this, _fetchMethod);
      }
      get dispose() {
        return __privateGet(this, _dispose);
      }
      get disposeAfter() {
        return __privateGet(this, _disposeAfter);
      }
      getRemainingTTL(key) {
        return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
      }
      *entries() {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      *rentries() {
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      *keys() {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      *rkeys() {
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      *values() {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      *rvalues() {
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions = {}) {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, __privateGet(this, _keyList)[i], this)) {
            return this.get(__privateGet(this, _keyList)[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      purgeStale() {
        let deleted = false;
        for (const i of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
          if (__privateGet(this, _isStale).call(this, i)) {
            this.delete(__privateGet(this, _keyList)[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of __privateMethod(this, _indexes, indexes_fn).call(this, { allowStale: true })) {
          const key = __privateGet(this, _keyList)[i];
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
            entry.ttl = __privateGet(this, _ttls)[i];
            const age = perf.now() - __privateGet(this, _starts)[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (__privateGet(this, _sizes)) {
            entry.size = __privateGet(this, _sizes)[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      set(k, v, setOptions = {}) {
        var _a, _b;
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size3 = __privateGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size3 > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k);
          return this;
        }
        let index2 = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k);
        if (index2 === void 0) {
          index2 = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _evict, evict_fn).call(this, false) : __privateGet(this, _size);
          __privateGet(this, _keyList)[index2] = k;
          __privateGet(this, _valList)[index2] = v;
          __privateGet(this, _keyMap).set(k, index2);
          __privateGet(this, _next)[__privateGet(this, _tail)] = index2;
          __privateGet(this, _prev)[index2] = __privateGet(this, _tail);
          __privateSet(this, _tail, index2);
          __privateWrapper(this, _size)._++;
          __privateGet(this, _addItemSize).call(this, index2, size3, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index2);
          const oldVal = __privateGet(this, _valList)[index2];
          if (v !== oldVal) {
            if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
            } else if (!noDisposeOnSet) {
              if (__privateGet(this, _hasDispose)) {
                (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, oldVal, k, "set");
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                __privateGet(this, _disposed)?.push([oldVal, k, "set"]);
              }
            }
            __privateGet(this, _removeItemSize).call(this, index2);
            __privateGet(this, _addItemSize).call(this, index2, size3, status);
            __privateGet(this, _valList)[index2] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !__privateGet(this, _ttls)) {
          __privateMethod(this, _initializeTTLTracking, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _ttls)) {
          if (!noUpdateTTL) {
            __privateGet(this, _setItemTTL).call(this, index2, ttl, start);
          }
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index2);
        }
        if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt?.shift()) {
            (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
          }
        }
        return this;
      }
      pop() {
        var _a;
        try {
          while (__privateGet(this, _size)) {
            const val = __privateGet(this, _valList)[__privateGet(this, _head)];
            __privateMethod(this, _evict, evict_fn).call(this, true);
            if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
            const dt = __privateGet(this, _disposed);
            let task;
            while (task = dt?.shift()) {
              (_a = __privateGet(this, _disposeAfter)) == null ? void 0 : _a.call(this, ...task);
            }
          }
        }
      }
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index2 = __privateGet(this, _keyMap).get(k);
        if (index2 !== void 0) {
          const v = __privateGet(this, _valList)[index2];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!__privateGet(this, _isStale).call(this, index2)) {
            if (updateAgeOnHas) {
              __privateGet(this, _updateItemAge).call(this, index2);
            }
            if (status) {
              status.has = "hit";
              __privateGet(this, _statusTTL).call(this, status, index2);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            __privateGet(this, _statusTTL).call(this, status, index2);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index2 = __privateGet(this, _keyMap).get(k);
        if (index2 !== void 0 && (allowStale || !__privateGet(this, _isStale).call(this, index2))) {
          const v = __privateGet(this, _valList)[index2];
          return __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        }
      }
      async fetch(k, fetchOptions = {}) {
        const {
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size: size3 = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context: context2,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!__privateGet(this, _hasFetchMethod)) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size: size3,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index2 = __privateGet(this, _keyMap).get(k);
        if (index2 === void 0) {
          if (status)
            status.fetch = "miss";
          const p = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k, index2, options, context2);
          return p.__returned = p;
        } else {
          const v = __privateGet(this, _valList)[index2];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = __privateGet(this, _isStale).call(this, index2);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index2);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index2);
            }
            if (status)
              __privateGet(this, _statusTTL).call(this, status, index2);
            return v;
          }
          const p = __privateMethod(this, _backgroundFetch, backgroundFetch_fn).call(this, k, index2, options, context2);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index2 = __privateGet(this, _keyMap).get(k);
        if (index2 !== void 0) {
          const value = __privateGet(this, _valList)[index2];
          const fetching = __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, value);
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index2);
          if (__privateGet(this, _isStale).call(this, index2)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            __privateMethod(this, _moveToTail, moveToTail_fn).call(this, index2);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index2);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      delete(k) {
        var _a, _b;
        let deleted = false;
        if (__privateGet(this, _size) !== 0) {
          const index2 = __privateGet(this, _keyMap).get(k);
          if (index2 !== void 0) {
            deleted = true;
            if (__privateGet(this, _size) === 1) {
              this.clear();
            } else {
              __privateGet(this, _removeItemSize).call(this, index2);
              const v = __privateGet(this, _valList)[index2];
              if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
                if (__privateGet(this, _hasDispose)) {
                  (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v, k, "delete");
                }
                if (__privateGet(this, _hasDisposeAfter)) {
                  __privateGet(this, _disposed)?.push([v, k, "delete"]);
                }
              }
              __privateGet(this, _keyMap).delete(k);
              __privateGet(this, _keyList)[index2] = void 0;
              __privateGet(this, _valList)[index2] = void 0;
              if (index2 === __privateGet(this, _tail)) {
                __privateSet(this, _tail, __privateGet(this, _prev)[index2]);
              } else if (index2 === __privateGet(this, _head)) {
                __privateSet(this, _head, __privateGet(this, _next)[index2]);
              } else {
                __privateGet(this, _next)[__privateGet(this, _prev)[index2]] = __privateGet(this, _next)[index2];
                __privateGet(this, _prev)[__privateGet(this, _next)[index2]] = __privateGet(this, _prev)[index2];
              }
              __privateWrapper(this, _size)._--;
              __privateGet(this, _free).push(index2);
            }
          }
        }
        if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)?.length) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt?.shift()) {
            (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
          }
        }
        return deleted;
      }
      clear() {
        var _a, _b;
        for (const index2 of __privateMethod(this, _rindexes, rindexes_fn).call(this, { allowStale: true })) {
          const v = __privateGet(this, _valList)[index2];
          if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = __privateGet(this, _keyList)[index2];
            if (__privateGet(this, _hasDispose)) {
              (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v, k, "delete");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              __privateGet(this, _disposed)?.push([v, k, "delete"]);
            }
          }
        }
        __privateGet(this, _keyMap).clear();
        __privateGet(this, _valList).fill(void 0);
        __privateGet(this, _keyList).fill(void 0);
        if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
          __privateGet(this, _ttls).fill(0);
          __privateGet(this, _starts).fill(0);
        }
        if (__privateGet(this, _sizes)) {
          __privateGet(this, _sizes).fill(0);
        }
        __privateSet(this, _head, 0);
        __privateSet(this, _tail, 0);
        __privateGet(this, _free).length = 0;
        __privateSet(this, _calculatedSize, 0);
        __privateSet(this, _size, 0);
        if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt?.shift()) {
            (_b = __privateGet(this, _disposeAfter)) == null ? void 0 : _b.call(this, ...task);
          }
        }
      }
    };
    var LRUCache = _LRUCache;
    _max = new WeakMap();
    _maxSize = new WeakMap();
    _dispose = new WeakMap();
    _disposeAfter = new WeakMap();
    _fetchMethod = new WeakMap();
    _size = new WeakMap();
    _calculatedSize = new WeakMap();
    _keyMap = new WeakMap();
    _keyList = new WeakMap();
    _valList = new WeakMap();
    _next = new WeakMap();
    _prev = new WeakMap();
    _head = new WeakMap();
    _tail = new WeakMap();
    _free = new WeakMap();
    _disposed = new WeakMap();
    _sizes = new WeakMap();
    _starts = new WeakMap();
    _ttls = new WeakMap();
    _hasDispose = new WeakMap();
    _hasFetchMethod = new WeakMap();
    _hasDisposeAfter = new WeakMap();
    _initializeTTLTracking = new WeakSet();
    initializeTTLTracking_fn = function() {
      const ttls = new ZeroArray(__privateGet(this, _max));
      const starts = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _ttls, ttls);
      __privateSet(this, _starts, starts);
      __privateSet(this, _setItemTTL, (index2, ttl, start = perf.now()) => {
        starts[index2] = ttl !== 0 ? start : 0;
        ttls[index2] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (__privateGet(this, _isStale).call(this, index2)) {
              this.delete(__privateGet(this, _keyList)[index2]);
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      });
      __privateSet(this, _updateItemAge, (index2) => {
        starts[index2] = ttls[index2] !== 0 ? perf.now() : 0;
      });
      __privateSet(this, _statusTTL, (status, index2) => {
        if (ttls[index2]) {
          const ttl = ttls[index2];
          const start = starts[index2];
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          status.remainingTTL = status.now + ttl - start;
        }
      });
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index2 = __privateGet(this, _keyMap).get(key);
        if (index2 === void 0) {
          return 0;
        }
        return ttls[index2] === 0 || starts[index2] === 0 ? Infinity : starts[index2] + ttls[index2] - (cachedNow || getNow());
      };
      __privateSet(this, _isStale, (index2) => {
        return ttls[index2] !== 0 && starts[index2] !== 0 && (cachedNow || getNow()) - starts[index2] > ttls[index2];
      });
    };
    _updateItemAge = new WeakMap();
    _statusTTL = new WeakMap();
    _setItemTTL = new WeakMap();
    _isStale = new WeakMap();
    _initializeSizeTracking = new WeakSet();
    initializeSizeTracking_fn = function() {
      const sizes = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _sizes, sizes);
      __privateSet(this, _removeItemSize, (index2) => {
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index2]);
        sizes[index2] = 0;
      });
      __privateSet(this, _requireSize, (k, v, size3, sizeCalculation) => {
        if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
          return 0;
        }
        if (!isPosInt(size3)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size3 = sizeCalculation(v, k);
            if (!isPosInt(size3)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size3;
      });
      __privateSet(this, _addItemSize, (index2, size3, status) => {
        sizes[index2] = size3;
        if (__privateGet(this, _maxSize)) {
          const maxSize = __privateGet(this, _maxSize) - sizes[index2];
          while (__privateGet(this, _calculatedSize) > maxSize) {
            __privateMethod(this, _evict, evict_fn).call(this, true);
          }
        }
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index2]);
        if (status) {
          status.entrySize = size3;
          status.totalCalculatedSize = __privateGet(this, _calculatedSize);
        }
      });
    };
    _removeItemSize = new WeakMap();
    _addItemSize = new WeakMap();
    _requireSize = new WeakMap();
    _indexes = new WeakSet();
    indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i = __privateGet(this, _tail); true; ) {
          if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _head)) {
            break;
          } else {
            i = __privateGet(this, _prev)[i];
          }
        }
      }
    };
    _rindexes = new WeakSet();
    rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i = __privateGet(this, _head); true; ) {
          if (!__privateMethod(this, _isValidIndex, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _tail)) {
            break;
          } else {
            i = __privateGet(this, _next)[i];
          }
        }
      }
    };
    _isValidIndex = new WeakSet();
    isValidIndex_fn = function(index2) {
      return index2 !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index2]) === index2;
    };
    _evict = new WeakSet();
    evict_fn = function(free) {
      var _a;
      const head = __privateGet(this, _head);
      const k = __privateGet(this, _keyList)[head];
      const v = __privateGet(this, _valList)[head];
      if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
        if (__privateGet(this, _hasDispose)) {
          (_a = __privateGet(this, _dispose)) == null ? void 0 : _a.call(this, v, k, "evict");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          __privateGet(this, _disposed)?.push([v, k, "evict"]);
        }
      }
      __privateGet(this, _removeItemSize).call(this, head);
      if (free) {
        __privateGet(this, _keyList)[head] = void 0;
        __privateGet(this, _valList)[head] = void 0;
        __privateGet(this, _free).push(head);
      }
      if (__privateGet(this, _size) === 1) {
        __privateSet(this, _head, __privateSet(this, _tail, 0));
        __privateGet(this, _free).length = 0;
      } else {
        __privateSet(this, _head, __privateGet(this, _next)[head]);
      }
      __privateGet(this, _keyMap).delete(k);
      __privateWrapper(this, _size)._--;
      return head;
    };
    _backgroundFetch = new WeakSet();
    backgroundFetch_fn = function(k, index2, options, context2) {
      const v = index2 === void 0 ? void 0 : __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _isBackgroundFetch, isBackgroundFetch_fn).call(this, v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context: context2
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (__privateGet(this, _valList)[index2] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
            } else {
              this.delete(k);
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (__privateGet(this, _valList)[index2] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            this.delete(k);
          } else if (!allowStaleAborted) {
            __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        var _a;
        const fmp = (_a = __privateGet(this, _fetchMethod)) == null ? void 0 : _a.call(this, k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res();
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index2 === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index2 = __privateGet(this, _keyMap).get(k);
      } else {
        __privateGet(this, _valList)[index2] = bf;
      }
      return bf;
    };
    _isBackgroundFetch = new WeakSet();
    isBackgroundFetch_fn = function(p) {
      if (!__privateGet(this, _hasFetchMethod))
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    };
    _connect = new WeakSet();
    connect_fn = function(p, n) {
      __privateGet(this, _prev)[n] = p;
      __privateGet(this, _next)[p] = n;
    };
    _moveToTail = new WeakSet();
    moveToTail_fn = function(index2) {
      if (index2 !== __privateGet(this, _tail)) {
        if (index2 === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index2]);
        } else {
          __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _prev)[index2], __privateGet(this, _next)[index2]);
        }
        __privateMethod(this, _connect, connect_fn).call(this, __privateGet(this, _tail), index2);
        __privateSet(this, _tail, index2);
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/concurrent-lru-cache.js
var require_concurrent_lru_cache = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/concurrent-lru-cache.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConcurrentLRUCache = exports.ContextlessConcurrentLRUCache = void 0;
    var ms_1 = __importDefault(require_dist());
    var lru_cache_1 = require_cjs3();
    var timeouts_1 = require_timeouts();
    var ContextlessConcurrentLRUCache = class {
      constructor({ calculate, config: config2 }) {
        this.cache = new ConcurrentLRUCache({
          calculate: (_, keys) => calculate(keys),
          config: config2
        });
      }
      async getOrCalculateSingle({ key, expirationConfig, timeout }) {
        return this.cache.getOrCalculateSingle({ context: void 0, key, expirationConfig, timeout });
      }
      async getOrCalculate({ keys, expirationConfig, timeout }) {
        return this.cache.getOrCalculate({ context: void 0, keys, expirationConfig, timeout });
      }
      holdsValidValue(key, expirationConfig) {
        return this.cache.holdsValidValue(key, expirationConfig);
      }
      holdsValidValues(keys, expirationConfig) {
        return this.cache.holdsValidValues(keys, expirationConfig);
      }
    };
    exports.ContextlessConcurrentLRUCache = ContextlessConcurrentLRUCache;
    var ConcurrentLRUCache = class {
      constructor({ calculate, config: config2 }) {
        this.beingCalculated = /* @__PURE__ */ new Map();
        const isInvalid = config2.expiration.useCachedValue !== "always" && config2.expiration.useCachedValueIfCalculationFailed !== "always" && (0, ms_1.default)(config2.expiration.useCachedValue.ifUnder) > (0, ms_1.default)(config2.expiration.useCachedValueIfCalculationFailed.ifUnder);
        if (isInvalid)
          throw new Error(`'useCachedValue' must be lower or equal than 'useCachedValueIfCalculationFailed'`);
        this.calculate = calculate;
        this.storableKeyMapper = (key) => key.toString().toLowerCase();
        this.expirationConfig = config2.expiration;
        this.cache = new lru_cache_1.LRUCache({ max: config2.maxSize });
      }
      async getOrCalculateSingle({ key, context: context2, expirationConfig, timeout }) {
        const result = await this.getOrCalculate({ keys: [key], context: context2, expirationConfig, timeout });
        return result[key];
      }
      async getOrCalculate({ keys, context: context2, expirationConfig, timeout }) {
        const options = { ...this.expirationConfig, ...expirationConfig };
        const storableKeys = Object.fromEntries(keys.map((key) => [key, this.storableKeyMapper(key)]));
        const now = Date.now();
        const useCachedValue = ({ lastUpdated }) => options.useCachedValue === "always" || lastUpdated >= now - (0, ms_1.default)(options.useCachedValue.ifUnder);
        const notInCache = [];
        const result = {};
        for (const key of keys) {
          const valueInCache = this.cache.get(storableKeys[key]);
          if (valueInCache && useCachedValue(valueInCache)) {
            result[key] = valueInCache.value;
          } else {
            notInCache.push(key);
          }
        }
        if (notInCache.length === 0)
          return result;
        const toCalculate = notInCache.filter((key) => !this.beingCalculated.has(storableKeys[key]));
        if (toCalculate.length > 0) {
          const calculated = (0, timeouts_1.timeoutPromise)(this.calculate(context2, toCalculate), timeout);
          for (const key of toCalculate) {
            const storableKey = storableKeys[key];
            const promise = calculated.then((result2) => {
              const value = result2[key];
              if (value !== void 0) {
                this.cache.set(storableKey, { lastUpdated: Date.now(), value });
              }
            }).catch(() => {
            }).finally(() => this.beingCalculated.delete(storableKey));
            this.beingCalculated.set(storableKey, promise);
          }
        }
        const calculationPromises = notInCache.map((key) => this.beingCalculated.get(storableKeys[key]));
        await Promise.all(calculationPromises);
        const nowAgain = Date.now();
        const useCachedValueIfCalculationFailed = ({ lastUpdated }) => options.useCachedValueIfCalculationFailed === "always" || lastUpdated >= nowAgain - (0, ms_1.default)(options.useCachedValueIfCalculationFailed.ifUnder);
        for (const key of notInCache) {
          const storableKey = storableKeys[key];
          const valueInCache = this.cache.get(storableKey);
          if (valueInCache) {
            if (useCachedValueIfCalculationFailed(valueInCache)) {
              result[key] = valueInCache.value;
            } else {
              this.cache.delete(storableKey);
            }
          }
        }
        return result;
      }
      holdsValidValue(key, expirationConfig) {
        const { [key]: holdsValidValue } = this.holdsValidValues([key], expirationConfig);
        return holdsValidValue;
      }
      holdsValidValues(keys, expirationConfig) {
        const options = { ...this.expirationConfig, ...expirationConfig };
        const now = Date.now();
        const isValidEntry = ({ lastUpdated }) => options.useCachedValue === "always" || lastUpdated >= now - (0, ms_1.default)(options.useCachedValue.ifUnder);
        const entries = keys.map((key) => {
          const entry = this.cache.get(this.storableKeyMapper(key));
          const holdsValidValue = entry ? isValidEntry(entry) : false;
          return [key, holdsValidValue];
        });
        return Object.fromEntries(entries);
      }
      populate(values) {
        const now = Date.now();
        for (const key in values) {
          const storableKey = this.storableKeyMapper(key);
          this.cache.set(storableKey, { lastUpdated: now, value: values[key] });
        }
      }
    };
    exports.ConcurrentLRUCache = ConcurrentLRUCache;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/cached-gas-price-source.js
var require_cached_gas_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/gas-price-sources/cached-gas-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedGasPriceSource = void 0;
    var concurrent_lru_cache_1 = require_concurrent_lru_cache();
    var requirements_and_support_1 = require_requirements_and_support();
    var CachedGasPriceSource = class {
      constructor({ underlying, expiration, maxSize }) {
        this.underlying = underlying;
        this.cache = new concurrent_lru_cache_1.ConcurrentLRUCache({
          calculate: (config2, [cacheId]) => this.fromCacheKey(cacheId, config2),
          config: {
            expiration: expiration.default,
            maxSize: maxSize ?? Object.keys(underlying.supportedSpeeds()).length
          }
        });
        this.expirationOverrides = expiration.overrides ?? {};
      }
      supportedSpeeds() {
        return this.underlying.supportedSpeeds();
      }
      async getGasPrice({ chainId, config: config2 }) {
        const expirationConfig = this.expirationOverrides[chainId];
        const key = this.toCacheKey(chainId, config2?.fields);
        const gasPrice = await this.cache.getOrCalculateSingle({
          key,
          context: config2,
          expirationConfig,
          timeout: config2?.timeout
        });
        return gasPrice;
      }
      toCacheKey(chainId, requirements) {
        const support = this.underlying.supportedSpeeds()[chainId];
        const fieldRequirements = (0, requirements_and_support_1.calculateFieldRequirements)(support, requirements);
        const requiredFields = Object.entries(fieldRequirements).filter(([, requirement]) => requirement === "required").map(([field]) => field).sort().join(",");
        return `${chainId}-${requiredFields}`;
      }
      async fromCacheKey(cacheId, config2) {
        const [chainIdString, requiredFieldsText] = cacheId.split("-");
        const requiredFields = requiredFieldsText.length > 0 ? requiredFieldsText.split(",") : [];
        const requirements = Object.fromEntries(requiredFields.map((field) => [field, "required"]));
        const gasPrice = await this.underlying.getGasPrice({
          chainId: Number(chainIdString),
          config: { ...config2, fields: { requirements, default: "best effort" } }
        });
        return { [cacheId]: gasPrice };
      }
    };
    exports.CachedGasPriceSource = CachedGasPriceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/gas-builder.js
var require_gas_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/gas-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildGasService = void 0;
    var fastest_gas_price_source_combinator_1 = require_fastest_gas_price_source_combinator();
    var open_ocean_gas_price_source_1 = require_open_ocean_gas_price_source();
    var prioritized_gas_price_source_combinator_1 = require_prioritized_gas_price_source_combinator();
    var rpc_gas_price_source_1 = require_rpc_gas_price_source();
    var gas_service_1 = require_gas_service();
    var owlracle_gas_price_source_1 = require_owlracle_gas_price_source();
    var eth_gas_station_gas_price_source_1 = require_eth_gas_station_gas_price_source();
    var etherscan_gas_price_source_1 = require_etherscan_gas_price_source();
    var polygon_gas_station_gas_price_source_1 = require_polygon_gas_station_gas_price_source();
    var aggregator_gas_price_source_1 = require_aggregator_gas_price_source();
    var paraswap_gas_price_source_1 = require_paraswap_gas_price_source();
    var changelly_gas_price_source_1 = require_changelly_gas_price_source();
    var cached_gas_price_source_1 = require_cached_gas_price_source();
    function buildGasService(params, logsService, fetchService, providerService, multicallService) {
      const sourceInput = params?.source?.type === "cached" ? params.source.underlyingSource : params?.source;
      const gasPriceSource = buildSource(sourceInput, { logsService, fetchService, multicallService, providerService });
      return new gas_service_1.GasService({ providerService, gasPriceSource });
    }
    exports.buildGasService = buildGasService;
    function buildSource(source, { logsService, providerService, multicallService, fetchService }) {
      switch (source?.type) {
        case void 0:
          return new aggregator_gas_price_source_1.AggregatorGasPriceSource(logsService, calculatePublicSources({ fetchService, providerService }), "median");
        case "open-ocean":
          return new open_ocean_gas_price_source_1.OpenOceanGasPriceSource(fetchService);
        case "cached":
          const underlying = buildSource(source.underlyingSource, { logsService, fetchService, providerService, multicallService });
          return new cached_gas_price_source_1.CachedGasPriceSource({
            underlying,
            expiration: { default: source.config.expiration, overrides: source.config.expiration.overrides },
            maxSize: source.config.maxSize
          });
        case "paraswap":
          return new paraswap_gas_price_source_1.ParaswapGasPriceSource(fetchService);
        case "rpc":
          return new rpc_gas_price_source_1.RPCGasPriceSource(providerService);
        case "eth-gas-station":
          return new eth_gas_station_gas_price_source_1.EthGasStationGasPriceSource(fetchService);
        case "polygon-gas-station":
          return new polygon_gas_station_gas_price_source_1.PolygonGasStationGasPriceSource(fetchService);
        case "etherscan":
          return new etherscan_gas_price_source_1.EtherscanGasPriceSource(fetchService, source.keys);
        case "owlracle":
          return new owlracle_gas_price_source_1.OwlracleGasPriceSource(fetchService, source.key);
        case "changelly":
          return new changelly_gas_price_source_1.ChangellyGasPriceSource(fetchService, source.key);
        case "custom":
          return source.instance;
        case "aggregate":
          return new aggregator_gas_price_source_1.AggregatorGasPriceSource(logsService, calculateSources(source.sources, { fetchService, multicallService, providerService, logsService }), source.by);
        case "fastest":
          return new fastest_gas_price_source_combinator_1.FastestGasPriceSourceCombinator(calculateSources(source.sources, { fetchService, multicallService, providerService, logsService }));
        case "prioritized":
          return new prioritized_gas_price_source_combinator_1.PrioritizedGasPriceSourceCombinator(source.sources.map((source2) => buildSource(source2, { logsService, fetchService, multicallService, providerService })));
      }
    }
    function calculateSources(sources, { providerService, multicallService, fetchService, logsService }) {
      return sources.map((source) => buildSource(source, { logsService, fetchService, multicallService, providerService }));
    }
    function calculatePublicSources({ providerService, fetchService }) {
      const openOcean = new open_ocean_gas_price_source_1.OpenOceanGasPriceSource(fetchService);
      const rpc = new rpc_gas_price_source_1.RPCGasPriceSource(providerService);
      const ethGasStation = new eth_gas_station_gas_price_source_1.EthGasStationGasPriceSource(fetchService);
      const polygonGasStation = new polygon_gas_station_gas_price_source_1.PolygonGasStationGasPriceSource(fetchService);
      const etherscan = new etherscan_gas_price_source_1.EtherscanGasPriceSource(fetchService);
      const paraswap = new paraswap_gas_price_source_1.ParaswapGasPriceSource(fetchService);
      return [openOcean, rpc, ethGasStation, polygonGasStation, etherscan, paraswap];
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/multicall/multicall-service.js
var require_multicall_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/multicall/multicall-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MulticallService = void 0;
    var _chains_1 = require_chains();
    var viem_1 = require_cjs2();
    var alchemy_sdk_1 = (init_esm(), __toCommonJS(esm_exports));
    var ADDRESS = "0xcA11bde05977b3631167028862bE2a173976CA11";
    var MulticallService = class {
      constructor(providerService, client = "viem") {
        this.providerService = providerService;
        this.client = client;
      }
      supportedChains() {
        return (0, _chains_1.chainsIntersection)(this.providerService.supportedChains(), SUPPORTED_CHAINS);
      }
      async readOnlyMulticall(args) {
        if (args.calls.length === 0)
          return [];
        return this.multicall({ ...args, allowFailure: false });
      }
      async tryReadOnlyMulticall(args) {
        if (args.calls.length === 0)
          return [];
        const results = await this.multicall({ ...args, allowFailure: true });
        return results.map(({ error, status, result }) => status === "success" ? { status, result } : { status, error: error.message });
      }
      async multicall(args) {
        const viemSupported = this.providerService.supportedClients()[args.chainId]?.viem;
        return viemSupported && this.client === "viem" ? this.viemMulticall(args) : this.ethersMulticall(args);
      }
      async viemMulticall({ chainId, calls, at, allowFailure, batching }) {
        return this.providerService.getViemPublicClient({ chainId }).multicall({
          allowFailure,
          multicallAddress: ADDRESS,
          contracts: calls.map(({ address, abi, functionName, args }) => ({
            address,
            abi: "humanReadable" in abi ? (0, viem_1.parseAbi)(abi.humanReadable) : abi.json,
            functionName,
            args
          })),
          blockNumber: at?.block?.number ? BigInt(at.block.number) : void 0,
          batchSize: batching?.maxSizeInBytes ?? 0
        });
      }
      async ethersMulticall({ chainId, calls, at, allowFailure, batching }) {
        const batchSize = batching?.maxSizeInBytes ?? Infinity;
        const blockNumber = at?.block?.number ? BigInt(at.block.number) : void 0;
        const chunkedCalls = [[]];
        let currentChunk = 0;
        let currentChunkSize = 0;
        for (let i = 0; i < calls.length; i++) {
          const { abi, address, args, functionName } = calls[i];
          const jsonAbi = "humanReadable" in abi ? (0, viem_1.parseAbi)(abi.humanReadable) : abi.json;
          try {
            const callData = (0, viem_1.encodeFunctionData)({
              abi: jsonAbi,
              args,
              functionName
            });
            currentChunkSize += callData.length;
            if (batchSize > 0 && currentChunkSize > batchSize) {
              currentChunk++;
              currentChunkSize = (callData.length - 2) / 2;
              chunkedCalls[currentChunk] = [];
            }
            chunkedCalls[currentChunk] = [
              ...chunkedCalls[currentChunk],
              {
                allowFailure: true,
                callData,
                target: address
              }
            ];
          } catch (err) {
            const error = (0, viem_1.getContractError)(err, {
              abi: jsonAbi,
              address,
              args,
              docsPath: "/docs/contract/multicall",
              functionName
            });
            if (!allowFailure)
              throw error;
            chunkedCalls[currentChunk] = [
              ...chunkedCalls[currentChunk],
              {
                allowFailure: true,
                callData: "0x",
                target: address
              }
            ];
          }
        }
        const provider = this.providerService.getEthersProvider({ chainId });
        const contract = new alchemy_sdk_1.Contract(ADDRESS, SMALL_ABI, provider);
        const results = await Promise.all(chunkedCalls.map((calls2) => contract.callStatic.aggregate3(calls2, { blockTag: blockNumber }).then((results2) => results2.map(([success, returnData]) => ({ success, returnData })))));
        return results.flat().map(({ returnData, success }, i) => {
          const flatennedCalls = chunkedCalls.flat();
          const { callData } = flatennedCalls[i];
          const { abi, address, functionName, args } = calls[i];
          const jsonAbi = "humanReadable" in abi ? (0, viem_1.parseAbi)(abi.humanReadable) : abi.json;
          try {
            if (callData === "0x")
              throw new viem_1.AbiDecodingZeroDataError();
            if (!success)
              throw new viem_1.RawContractError({ data: returnData });
            const result = (0, viem_1.decodeFunctionResult)({
              abi: jsonAbi,
              args,
              data: returnData,
              functionName
            });
            return allowFailure ? { result, status: "success" } : result;
          } catch (err) {
            const error = (0, viem_1.getContractError)(err, {
              abi: jsonAbi,
              address,
              args,
              docsPath: "/docs/contract/multicall",
              functionName
            });
            if (!allowFailure)
              throw error;
            return { error, result: void 0, status: "failure" };
          }
        });
      }
    };
    exports.MulticallService = MulticallService;
    var SUPPORTED_CHAINS = [
      1,
      3,
      4,
      5,
      10,
      14,
      16,
      18,
      19,
      25,
      30,
      31,
      40,
      42,
      56,
      66,
      69,
      97,
      100,
      106,
      108,
      114,
      122,
      128,
      137,
      250,
      288,
      321,
      420,
      592,
      1088,
      1284,
      1285,
      1287,
      2001,
      4002,
      8217,
      9e3,
      9001,
      42161,
      42170,
      42220,
      42262,
      43113,
      43114,
      44787,
      59144,
      71401,
      71402,
      80001,
      84531,
      421611,
      421613,
      11155111,
      1313161554,
      16666e5
    ];
    var SMALL_ABI = [
      "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) payable returns (tuple(bool success, bytes returnData)[] returnData)"
    ];
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/multicall-builder.js
var require_multicall_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/multicall-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildMulticallService = void 0;
    var multicall_service_1 = require_multicall_service();
    function buildMulticallService(providerService) {
      return new multicall_service_1.MulticallService(providerService);
    }
    exports.buildMulticallService = buildMulticallService;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/defi-llama.js
var require_defi_llama = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/defi-llama.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toChainId = exports.DefiLlamaClient = void 0;
    var constants_1 = require_constants();
    var _chains_1 = require_chains();
    var utils_1 = require_utils13();
    var CHAIN_ID_TO_KEY = {
      [_chains_1.Chains.ETHEREUM.chainId]: "ethereum",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "bsc",
      [_chains_1.Chains.POLYGON.chainId]: "polygon",
      [_chains_1.Chains.AVALANCHE.chainId]: "avax",
      [_chains_1.Chains.FANTOM.chainId]: "fantom",
      [_chains_1.Chains.GNOSIS.chainId]: "xdai",
      [_chains_1.Chains.HECO.chainId]: "heco",
      [_chains_1.Chains.ARBITRUM.chainId]: "arbitrum",
      [_chains_1.Chains.OPTIMISM.chainId]: "optimism",
      [_chains_1.Chains.CELO.chainId]: "celo",
      [_chains_1.Chains.CRONOS.chainId]: "cronos",
      [_chains_1.Chains.BOBA.chainId]: "boba",
      [_chains_1.Chains.MOONRIVER.chainId]: "moonriver",
      [_chains_1.Chains.OKC.chainId]: "okexchain",
      [_chains_1.Chains.ONTOLOGY.chainId]: "ontology",
      [_chains_1.Chains.KLAYTN.chainId]: "klaytn",
      [_chains_1.Chains.AURORA.chainId]: "aurora",
      [_chains_1.Chains.HARMONY_SHARD_0.chainId]: "harmony",
      [_chains_1.Chains.MOONBEAM.chainId]: "moonbeam",
      [_chains_1.Chains.VELAS.chainId]: "velas",
      [_chains_1.Chains.ROOTSTOCK.chainId]: "rsk",
      [_chains_1.Chains.EVMOS.chainId]: "evmos",
      [_chains_1.Chains.CANTO.chainId]: "canto",
      [_chains_1.Chains.POLYGON_ZKEVM.chainId]: "polygon_zkevm",
      [_chains_1.Chains.KAVA.chainId]: "kava",
      [_chains_1.Chains.BASE.chainId]: "base",
      [_chains_1.Chains.LINEA.chainId]: "linea"
    };
    var KEY_TO_CHAIN_ID = Object.fromEntries(Object.entries(CHAIN_ID_TO_KEY).map(([chainId, key]) => [key, parseInt(chainId)]));
    var DefiLlamaClient = class {
      constructor(fetch2) {
        this.fetch = fetch2;
      }
      supportedChains() {
        return Object.keys(CHAIN_ID_TO_KEY).map(Number);
      }
      getCurrentTokenData({ addresses, config: config2 }) {
        return this.fetchAndMapTokens({
          baseUrl: "https://coins.llama.fi/prices/current/",
          addresses,
          config: config2
        });
      }
      getHistoricalTokenData({ addresses, timestamp, searchWidth, config: config2 }) {
        const extraParams = searchWidth && { searchWidth };
        return this.fetchAndMapTokens({
          baseUrl: `https://coins.llama.fi/prices/historical/${timestamp}/`,
          addresses,
          extraParams,
          config: config2
        });
      }
      async getBulkHistoricalTokenData({ addresses, searchWidth, config: config2 }) {
        searchWidth = searchWidth ?? "6h";
        const aggregatedByTokenId = aggregateTimestampsByTokenId(addresses);
        const batches = splitCoinsIntoBatches(searchWidth, aggregatedByTokenId);
        const coins = {};
        const promises = batches.map(async (batch) => {
          const response = await this.fetch.fetch(batch, { timeout: config2?.timeout });
          const body = await response.json();
          for (const [tokenId, { prices }] of Object.entries(body.coins)) {
            if (!(tokenId in coins))
              coins[tokenId] = [];
            coins[tokenId].push(...prices.map(({ timestamp, price }) => ({ price, closestTimestamp: timestamp })));
          }
        });
        await Promise.allSettled(promises);
        const result = {};
        for (const chainId in addresses) {
          result[chainId] = {};
          for (const { token: token2, timestamp } of addresses[chainId]) {
            if (!(token2 in result[chainId]))
              result[chainId][token2] = {};
            const tokenId = toTokenId(Number(chainId), token2);
            const allResults = coins[tokenId] ?? [];
            const bestResult = findClosestToTimestamp(allResults, timestamp);
            if (bestResult && Math.abs(bestResult.closestTimestamp - timestamp) <= (0, utils_1.timeToSeconds)(searchWidth)) {
              result[chainId][token2][timestamp] = bestResult;
            }
          }
        }
        return result;
      }
      async fetchAndMapTokens({ baseUrl, addresses, extraParams, config: config2 }) {
        const tokenIds = Object.entries(addresses).flatMap(([chainId, addresses2]) => addresses2.map((address) => toTokenId(Number(chainId), address)));
        const coins = await this.fetchTokens(baseUrl, tokenIds, config2, extraParams);
        const result = Object.fromEntries(Object.keys(addresses).map((chainId) => [chainId, {}]));
        for (const [tokenId, token2] of Object.entries(coins)) {
          const { chainId, address } = fromTokenId(tokenId);
          if (!(0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN)) {
            result[chainId][address] = { decimals: 18, ...token2 };
          } else {
            const nativeTokens = addresses[chainId].filter((address2) => (0, utils_1.isSameAddress)(address2, constants_1.Addresses.NATIVE_TOKEN));
            for (const nativeToken of nativeTokens) {
              result[chainId][nativeToken] = { decimals: 18, ...token2 };
            }
          }
        }
        return result;
      }
      async fetchTokens(baseUrl, tokens, config2, extraParams = {}) {
        const chunks = (0, utils_1.splitInChunks)(tokens, 30);
        const extraParamsString = "?" + Object.entries(extraParams).map(([key, value]) => `${key}=${value}`).join("&=");
        const requests = chunks.map(async (chunk) => {
          const url = baseUrl + chunk.join(",") + extraParamsString;
          try {
            const response = await this.fetch.fetch(url, { timeout: config2?.timeout });
            const { coins } = await response.json();
            return coins;
          } catch {
            throw new Error("Request to Defi Llama API failed");
          }
        });
        const responses = await Promise.all(requests);
        return responses.reduce((accum, curr) => ({ ...accum, ...curr }), {});
      }
    };
    exports.DefiLlamaClient = DefiLlamaClient;
    var DEFI_LLAMA_NATIVE_TOKEN = "0x0000000000000000000000000000000000000000";
    var MAPPINGS = {};
    function splitCoinsIntoBatches(searchWidth, aggregatedByTokenId) {
      const searchWidthParam = searchWidth ? `&searchWidth=${searchWidth}` : "";
      const toURL = (coins) => `https://coins.llama.fi/batchHistorical?&coins=${encodeURIComponent(JSON.stringify(coins))}${searchWidthParam}`;
      const batches = [];
      let inBatch = {};
      for (const { tokenId, timestamps } of aggregatedByTokenId) {
        const ifAddedToBatch = { ...inBatch, [tokenId]: timestamps };
        const url = toURL(ifAddedToBatch);
        if (url.length > 2048) {
          if (Object.keys(inBatch).length > 0) {
            batches.push(toURL(inBatch));
            inBatch = {};
          } else {
            const chunks = (0, utils_1.splitInChunks)(timestamps, 140);
            batches.push(...chunks.map((chunk) => toURL({ [tokenId]: chunk })));
          }
        } else {
          inBatch = ifAddedToBatch;
        }
      }
      if (Object.keys(inBatch).length > 0) {
        batches.push(toURL(inBatch));
      }
      return batches;
    }
    function aggregateTimestampsByTokenId(addresses) {
      const aggregatedByTokenId = {};
      for (const chainId in addresses) {
        for (const { token: token2, timestamp } of addresses[chainId]) {
          const tokenId = toTokenId(Number(chainId), token2);
          if (!(tokenId in aggregatedByTokenId))
            aggregatedByTokenId[tokenId] = [];
          aggregatedByTokenId[tokenId].push(timestamp);
        }
      }
      return Object.entries(aggregatedByTokenId).map(([tokenId, timestamps]) => ({ tokenId, timestamps })).sort((a, b) => a.timestamps.length - b.timestamps.length);
    }
    function findClosestToTimestamp(allResults, timestamp) {
      if (allResults.length == 0)
        return void 0;
      let min2 = allResults[0];
      for (let i = 1; i < allResults.length; i++) {
        if (Math.abs(allResults[i].closestTimestamp - timestamp) < Math.abs(min2.closestTimestamp - timestamp)) {
          min2 = allResults[i];
        }
      }
      return min2;
    }
    function toTokenId(chainId, address) {
      const key = CHAIN_ID_TO_KEY[chainId];
      const mappedNativeToken = (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? `${key}:${DEFI_LLAMA_NATIVE_TOKEN}` : `${key}:${address}`;
      return MAPPINGS[mappedNativeToken] ?? mappedNativeToken;
    }
    function fromTokenId(tokenId) {
      const mappedTokenId = MAPPINGS[tokenId] ?? tokenId;
      const [key, address] = mappedTokenId.split(":");
      return {
        chainId: KEY_TO_CHAIN_ID[key],
        address: address.replaceAll(DEFI_LLAMA_NATIVE_TOKEN, constants_1.Addresses.NATIVE_TOKEN)
      };
    }
    function toChainId(key) {
      return KEY_TO_CHAIN_ID[key.toLowerCase()];
    }
    exports.toChainId = toChainId;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/defi-llama-metadata-source.js
var require_defi_llama_metadata_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/defi-llama-metadata-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefiLlamaMetadataSource = void 0;
    var defi_llama_1 = require_defi_llama();
    var DefiLlamaMetadataSource = class {
      constructor(fetch2) {
        this.defiLlama = new defi_llama_1.DefiLlamaClient(fetch2);
      }
      async getMetadata(params) {
        const result = {};
        const data = await this.defiLlama.getCurrentTokenData(params);
        for (const [chainIdString, tokens] of Object.entries(data)) {
          const chainId = Number(chainIdString);
          result[chainId] = {};
          for (const [address, { confidence, timestamp, price, ...metadata }] of Object.entries(tokens)) {
            result[chainId][address] = metadata;
          }
        }
        return result;
      }
      supportedProperties() {
        const properties = { symbol: "present", decimals: "present" };
        return Object.fromEntries(this.defiLlama.supportedChains().map((chainId) => [chainId, properties]));
      }
    };
    exports.DefiLlamaMetadataSource = DefiLlamaMetadataSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-service.js
var require_metadata_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetadataService = void 0;
    var requirements_and_support_1 = require_requirements_and_support();
    var timeouts_1 = require_timeouts();
    var MetadataService = class {
      constructor(metadataSource) {
        this.metadataSource = metadataSource;
      }
      supportedChains() {
        return Object.keys(this.supportedProperties()).map(Number);
      }
      supportedProperties() {
        return this.metadataSource.supportedProperties();
      }
      async getMetadataForChain({ chainId, addresses, config: config2 }) {
        const byChainId = { [chainId]: addresses };
        const result = await this.getMetadata({ addresses: byChainId, config: config2 });
        return result[chainId] ?? {};
      }
      async getMetadata({ addresses, config: config2 }) {
        const chains = Object.keys(addresses).map(Number);
        (0, requirements_and_support_1.validateRequirements)(this.supportedProperties(), chains, config2?.fields);
        const response = await (0, timeouts_1.timeoutPromise)(this.metadataSource.getMetadata({ addresses, config: config2 }), config2?.timeout);
        validateResponse(addresses, response, config2?.fields);
        return response;
      }
    };
    exports.MetadataService = MetadataService;
    function validateResponse(request, response, requirements) {
      for (const chainId in request) {
        for (const token2 of request[chainId]) {
          if (!(0, requirements_and_support_1.doesResponseMeetRequirements)(response[chainId]?.[token2], requirements)) {
            throw new Error("Failed to fetch metadata that meets the given requirements");
          }
        }
      }
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/abis/erc20.js
var require_erc20 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/abis/erc20.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERC20_ABI = void 0;
    exports.ERC20_ABI = [
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function name() view returns (string)",
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address owner, address spender) view returns (uint256)",
      "function transferFrom(address sender, address recipient, uint amount)"
    ];
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/rpc-metadata-source.js
var require_rpc_metadata_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/rpc-metadata-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RPCMetadataSource = void 0;
    var _chains_1 = require_chains();
    var constants_1 = require_constants();
    var utils_1 = require_utils13();
    var timeouts_1 = require_timeouts();
    var requirements_and_support_1 = require_requirements_and_support();
    var erc20_1 = require_erc20();
    var SUPPORT = { symbol: "present", decimals: "present", name: "present" };
    var RPCMetadataSource = class {
      constructor(multicallService) {
        this.multicallService = multicallService;
      }
      async getMetadata({ addresses, config: config2 }) {
        const promises = Object.entries(addresses).map(async ([chainId, addresses2]) => [
          Number(chainId),
          await (0, timeouts_1.timeoutPromise)(this.fetchMetadataInChain(Number(chainId), addresses2, config2?.fields), config2?.timeout, { reduceBy: "100" })
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
      }
      supportedProperties() {
        return Object.fromEntries(this.multicallService.supportedChains().map((chainId) => [chainId, SUPPORT]));
      }
      async fetchMetadataInChain(chainId, addresses, requirements) {
        const chain = (0, _chains_1.getChainByKey)(chainId);
        const addressesWithoutNativeToken = addresses.filter((address) => !(0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN));
        const fieldRequirements = (0, requirements_and_support_1.calculateFieldRequirements)(SUPPORT, requirements);
        const fieldsToFetch = Object.entries(fieldRequirements).filter(([, requirement]) => requirement !== "can ignore").map(([field]) => field);
        if (fieldsToFetch.length === 0)
          return {};
        const calls = [];
        for (const field of fieldsToFetch) {
          calls.push(...addressesWithoutNativeToken.map((address) => ({ address, functionName: field, abi: { humanReadable: erc20_1.ERC20_ABI } })));
        }
        const multicallResults = await this.multicallService.readOnlyMulticall({ chainId, calls });
        const result = {};
        for (let i = 0; i < addressesWithoutNativeToken.length; i++) {
          const address = addressesWithoutNativeToken[i];
          const tokenMetadata = Object.fromEntries(fieldsToFetch.map((field, j) => [field, multicallResults[addressesWithoutNativeToken.length * j + i]]));
          result[address] = tokenMetadata;
        }
        if (addressesWithoutNativeToken.length !== addresses.length) {
          const nativeResult = {};
          if (fieldsToFetch.includes("symbol")) {
            nativeResult.symbol = chain?.nativeCurrency?.symbol ?? "???";
          }
          if (fieldsToFetch.includes("decimals")) {
            nativeResult.decimals = 18;
          }
          if (fieldsToFetch.includes("name")) {
            nativeResult.name = chain?.nativeCurrency?.name ?? "Unknown";
          }
          result[constants_1.Addresses.NATIVE_TOKEN] = nativeResult;
        }
        return result;
      }
    };
    exports.RPCMetadataSource = RPCMetadataSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/cached-metadata-source.js
var require_cached_metadata_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/cached-metadata-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedMetadataSource = void 0;
    var concurrent_lru_cache_1 = require_concurrent_lru_cache();
    var requirements_and_support_1 = require_requirements_and_support();
    var CachedMetadataSource = class {
      constructor(source, config2) {
        this.source = source;
        this.cache = new concurrent_lru_cache_1.ConcurrentLRUCache({
          calculate: (context2, tokensInChain) => this.fetchMetadata(tokensInChain, context2),
          config: config2
        });
      }
      async getMetadata({ addresses, config: config2 }) {
        const chainIds = Object.keys(addresses).map(Number);
        const support = (0, requirements_and_support_1.combineSupportInChains)(chainIds, this.supportedProperties());
        const fieldRequirements = (0, requirements_and_support_1.calculateFieldRequirements)(support, config2?.fields);
        const requiredFields = Object.entries(fieldRequirements).filter(([, requirement]) => requirement === "required").map(([field]) => field);
        const tokensInChain = addressesToTokensInChain(addresses, requiredFields);
        const tokens = await this.cache.getOrCalculate({
          context: config2,
          keys: tokensInChain,
          timeout: config2?.timeout
        });
        return tokenInChainRecordToChainAndAddress(tokens);
      }
      supportedProperties() {
        return this.source.supportedProperties();
      }
      async fetchMetadata(tokensInChain, context2) {
        const { addresses, requiredFields } = tokensInChainToAddresses(tokensInChain);
        const requirements = Object.fromEntries(requiredFields.map((field) => [field, "required"]));
        const metadata = await this.source.getMetadata({
          addresses,
          config: { timeout: context2?.timeout, fields: { requirements, default: "best effort" } }
        });
        return chainAndAddressRecordToTokenInChain(metadata, requiredFields);
      }
    };
    exports.CachedMetadataSource = CachedMetadataSource;
    function addressesToTokensInChain(addresses, requiredFields) {
      return Object.entries(addresses).flatMap(([chainId, addresses2]) => addresses2.map((address) => toTokenInChain(Number(chainId), address, requiredFields)));
    }
    function tokensInChainToAddresses(tokensInChain) {
      const result = {};
      let requiredFieldsResult = [];
      for (const tokenInChain of tokensInChain) {
        const { chainId, address, requiredFields } = fromTokenInChain(tokenInChain);
        requiredFieldsResult = requiredFields;
        if (chainId in result) {
          result[chainId].push(address);
        } else {
          result[chainId] = [address];
        }
      }
      return { addresses: result, requiredFields: requiredFieldsResult };
    }
    function tokenInChainRecordToChainAndAddress(record) {
      const result = {};
      for (const [tokenInChain, token2] of Object.entries(record)) {
        const { chainId, address } = fromTokenInChain(tokenInChain);
        if (!(chainId in result)) {
          result[chainId] = {};
        }
        result[chainId][address] = token2;
      }
      return result;
    }
    function chainAndAddressRecordToTokenInChain(record, requiredFields) {
      const entries = Object.entries(record).flatMap(([chainId, record2]) => Object.entries(record2).map(([address, token2]) => [
        toTokenInChain(Number(chainId), address, requiredFields),
        token2
      ]));
      return Object.fromEntries(entries);
    }
    function toTokenInChain(chainId, address, requiredFields) {
      return `${chainId}-${address}-${requiredFields.join(",")}`;
    }
    function fromTokenInChain(tokenInChain) {
      const [chainId, address, requiredFields] = tokenInChain.split("-");
      return {
        chainId: Number(chainId),
        address,
        requiredFields: requiredFields.length > 0 ? requiredFields.split(",") : []
      };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/fallback-metadata-source.js
var require_fallback_metadata_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/fallback-metadata-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FallbackMetadataSource = void 0;
    var timeouts_1 = require_timeouts();
    var requirements_and_support_1 = require_requirements_and_support();
    var FallbackMetadataSource = class {
      constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
          throw new Error("Need at least one source to setup a fallback token source");
      }
      getMetadata({ addresses, config: config2 }) {
        return new Promise((resolve, reject) => {
          const chainsInRequest = Object.keys(addresses).map(Number);
          const sources = this.sources.filter((source) => doesSourceSupportAtLeastOneChain(source, chainsInRequest));
          if (sources.length === 0) {
            reject(new Error(`Couldn't find sources that supported the given chains`));
          }
          const result = {};
          const requirements = (0, requirements_and_support_1.calculateFieldRequirementsPerChain)(this.supportedProperties(), config2?.fields);
          const requestTracker = buildRequestTracker(sources, addresses, requirements);
          const handleFulfil = (source) => {
            updateCounterWhenSourceFulfilled(source, requestTracker);
            const status = checkStatus(requestTracker);
            if (status === "finished") {
              resolve(result);
            } else if (status === "error") {
              reject(new Error("Could not find metadata for the given addresses"));
            }
          };
          sources.forEach(async (source) => {
            const addressesForSource = getAddressesForSource(source, addresses);
            const reducedTimeout = (0, timeouts_1.reduceTimeout)(config2?.timeout, "100");
            try {
              const filteredRequirements = (0, requirements_and_support_1.makeRequirementsCompatible)(source.supportedProperties(), Object.keys(addressesForSource).map(Number), config2?.fields);
              const sourceResult = await (0, timeouts_1.timeoutPromise)(source.getMetadata({
                addresses: addressesForSource,
                config: { timeout: reducedTimeout, fields: filteredRequirements }
              }), reducedTimeout);
              for (const [chainIdString, metadataRecord] of Object.entries(sourceResult)) {
                const chainId = Number(chainIdString);
                const metadatas = Object.entries(metadataRecord);
                if (!(chainId in result) && metadatas.length > 0)
                  result[chainId] = {};
                for (const [address, metadata] of metadatas) {
                  result[chainId][address] = { ...result[chainId][address], ...metadata };
                  for (const tokenProperty in metadata) {
                    const property = tokenProperty;
                    requestTracker?.[chainId]?.[property]?.tokens?.delete(address);
                  }
                }
              }
            } catch {
            } finally {
              handleFulfil(source);
            }
          });
        });
      }
      supportedProperties() {
        return (0, requirements_and_support_1.combineSourcesSupport)(this.sources, (source) => source.supportedProperties());
      }
    };
    exports.FallbackMetadataSource = FallbackMetadataSource;
    function buildRequestTracker(sources, addresses, fieldRequirements) {
      const requestTracker = {};
      for (const chainId in addresses) {
        const addressesInChain = addresses[chainId];
        requestTracker[chainId] = Object.fromEntries(Object.entries(fieldRequirements[chainId]).map(([property, requirement]) => [
          property,
          { sources: 0, tokens: new Set(addressesInChain), requirement }
        ]));
        for (const source of sources) {
          const supportedProperties2 = source.supportedProperties();
          if (chainId in supportedProperties2) {
            for (const property in supportedProperties2[chainId]) {
              requestTracker[chainId][property].sources += 1;
            }
          }
        }
      }
      return requestTracker;
    }
    function updateCounterWhenSourceFulfilled(source, requestTracker) {
      const supportedProperties2 = source.supportedProperties();
      for (const [chainId, properties] of Object.entries(supportedProperties2)) {
        if (chainId in requestTracker) {
          for (const property in properties) {
            requestTracker[Number(chainId)][property].sources -= 1;
          }
        }
      }
    }
    function checkStatus(requestTracker) {
      let result = "finished";
      for (const chainId in requestTracker) {
        for (const { sources, tokens, requirement } of Object.values(requestTracker[chainId])) {
          if (sources === 0 && tokens.size > 0 && requirement === "required") {
            return "error";
          } else if (sources > 0 && tokens.size > 0 && requirement !== "can ignore") {
            result = "continue";
          }
        }
      }
      return result;
    }
    function getAddressesForSource(source, addresses) {
      const chainsForSource = new Set(Object.keys(source.supportedProperties()));
      const filteredEntries = Object.entries(addresses).filter(([chainId]) => chainsForSource.has(chainId)).map(([chainId, addresses2]) => [Number(chainId), addresses2]);
      return Object.fromEntries(filteredEntries);
    }
    function doesSourceSupportAtLeastOneChain(source, chainIds) {
      return Object.keys(source.supportedProperties()).map(Number).some((chainId) => chainIds.includes(chainId));
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/portals-fi.js
var require_portals_fi = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/portals-fi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PortalsFiClient = exports.PORTALS_FI_SUPPORTED_CHAINS = exports.PORTALS_FI_KEY_TO_CHAIN_ID = exports.PORTALS_FI_CHAIN_ID_TO_KEY = void 0;
    var _chains_1 = require_chains();
    var constants_1 = require_constants();
    var utils_1 = require_utils13();
    exports.PORTALS_FI_CHAIN_ID_TO_KEY = {
      [_chains_1.Chains.ETHEREUM.chainId]: "ethereum",
      [_chains_1.Chains.OPTIMISM.chainId]: "optimism",
      [_chains_1.Chains.FANTOM.chainId]: "fantom",
      [_chains_1.Chains.ARBITRUM.chainId]: "arbitrum",
      [_chains_1.Chains.POLYGON.chainId]: "polygon",
      [_chains_1.Chains.AVALANCHE.chainId]: "avalanche",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "bsc",
      [_chains_1.Chains.BASE.chainId]: "base"
    };
    exports.PORTALS_FI_KEY_TO_CHAIN_ID = Object.fromEntries(Object.entries(exports.PORTALS_FI_CHAIN_ID_TO_KEY).map(([chainId, key]) => [key, Number(chainId)]));
    exports.PORTALS_FI_SUPPORTED_CHAINS = Object.keys(exports.PORTALS_FI_CHAIN_ID_TO_KEY).map(Number);
    var PortalsFiClient = class {
      constructor(fetch2) {
        this.fetch = fetch2;
      }
      async getData({ addresses, config: config2 }) {
        const tokenIds = Object.entries(addresses).flatMap(([chainId, addresses2]) => addresses2.map((address) => toTokenId(Number(chainId), address)));
        const data = await this.fetchData(tokenIds, config2);
        const result = Object.fromEntries(Object.keys(addresses).map((chainId) => [chainId, {}]));
        for (const chainIdString in addresses) {
          const chainId = Number(chainIdString);
          for (const address of addresses[chainId]) {
            const tokenId = toTokenId(chainId, address);
            if (tokenId in data) {
              result[chainId][address] = data[tokenId];
            }
          }
        }
        return result;
      }
      supportedChains() {
        return Object.keys(exports.PORTALS_FI_CHAIN_ID_TO_KEY).map(Number);
      }
      async fetchData(tokens, config2) {
        const chunkSize = 50;
        const chunks = [...Array(Math.ceil(tokens.length / chunkSize))].map((_) => tokens.splice(0, chunkSize));
        const requests = chunks.map(async (chunk) => {
          const params = chunk.map((tokenId) => `addresses=${tokenId}`).join("&");
          const url = `https://api.portals.fi/v2/tokens?${params}`;
          try {
            const response = await this.fetch.fetch(url, { timeout: config2?.timeout });
            const result = await response.json();
            return Object.fromEntries(result.tokens.map(({ key, name, decimals, symbol, price }) => [key, { name, decimals, symbol, price }]));
          } catch {
            throw new Error("Request to Portals Fi API failed");
          }
        });
        const responses = await Promise.all(requests);
        return responses.reduce((accum, curr) => ({ ...accum, ...curr }), {});
      }
    };
    exports.PortalsFiClient = PortalsFiClient;
    var PORTAS_FI_NATIVE_TOKEN = "0x0000000000000000000000000000000000000000";
    var MAPPINGS = {};
    function toTokenId(chainId, address) {
      const key = exports.PORTALS_FI_CHAIN_ID_TO_KEY[chainId];
      const mappedNativeToken = (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? `${key}:${PORTAS_FI_NATIVE_TOKEN}` : `${key}:${address}`;
      return (MAPPINGS[mappedNativeToken] ?? mappedNativeToken).toLowerCase();
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/portals-fi-metadata-source.js
var require_portals_fi_metadata_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/portals-fi-metadata-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PortalsFiMetadataSource = void 0;
    var portals_fi_1 = require_portals_fi();
    var PortalsFiMetadataSource = class {
      constructor(fetch2) {
        this.portalsFi = new portals_fi_1.PortalsFiClient(fetch2);
      }
      async getMetadata(params) {
        const result = {};
        const data = await this.portalsFi.getData(params);
        for (const [chainIdString, tokens] of Object.entries(data)) {
          const chainId = Number(chainIdString);
          result[chainId] = {};
          for (const [address, { price, ...metadata }] of Object.entries(tokens)) {
            result[chainId][address] = metadata;
          }
        }
        return result;
      }
      supportedProperties() {
        const properties = { symbol: "present", decimals: "present", name: "present" };
        return Object.fromEntries(this.portalsFi.supportedChains().map((chainId) => [chainId, properties]));
      }
    };
    exports.PortalsFiMetadataSource = PortalsFiMetadataSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/changelly-metadata-source.js
var require_changelly_metadata_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/metadata/metadata-sources/changelly-metadata-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChangellyMetadataSource = void 0;
    var changelly_quote_source_1 = require_changelly_quote_source();
    var ChangellyMetadataSource = class {
      constructor(fetchService, apiKey) {
        this.fetchService = fetchService;
        this.apiKey = apiKey;
      }
      supportedProperties() {
        const support = { symbol: "present", decimals: "present", name: "present" };
        return Object.fromEntries(changelly_quote_source_1.CHANGELLY_METADATA.supports.chains.map((chainId) => [Number(chainId), support]));
      }
      async getMetadata({ addresses, config: config2 }) {
        const allChains = Object.keys(addresses).map(Number);
        const allAddresses = [
          ...new Set(Object.values(addresses).flat().map((address) => address.toLowerCase()))
        ];
        const body = { filter: { addresses: allAddresses, chain_ids: allChains }, paging: { page: 1, page_size: 0 } };
        const response = await this.fetchService.fetch(`https://dex-api.changelly.com/v2/tokens/list`, {
          method: "POST",
          body: JSON.stringify(body),
          headers: { "X-Api-Key": this.apiKey },
          timeout: config2?.timeout
        });
        const { tokens } = await response.json();
        const resultByKey = Object.fromEntries(tokens.map(({ chainId, address, ...metadata }) => [`${chainId}-${address.toLowerCase()}`, metadata]));
        const result = {};
        for (const [chainId, tokenAddresses] of Object.entries(addresses)) {
          result[Number(chainId)] = Object.fromEntries(tokenAddresses.map((address) => [address, resultByKey[`${chainId}-${address.toLowerCase()}`]]));
        }
        return result;
      }
    };
    exports.ChangellyMetadataSource = ChangellyMetadataSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/metadata-builder.js
var require_metadata_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/metadata-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildMetadataService = void 0;
    var defi_llama_metadata_source_1 = require_defi_llama_metadata_source();
    var metadata_service_1 = require_metadata_service();
    var rpc_metadata_source_1 = require_rpc_metadata_source();
    var cached_metadata_source_1 = require_cached_metadata_source();
    var fallback_metadata_source_1 = require_fallback_metadata_source();
    var portals_fi_metadata_source_1 = require_portals_fi_metadata_source();
    var changelly_metadata_source_1 = require_changelly_metadata_source();
    function buildMetadataService(params, fetchService, multicallService) {
      const source = buildSource(params?.source, { fetchService, multicallService });
      return new metadata_service_1.MetadataService(source);
    }
    exports.buildMetadataService = buildMetadataService;
    function buildSource(source, { fetchService, multicallService }) {
      switch (source?.type) {
        case void 0:
          const defiLlama = new defi_llama_metadata_source_1.DefiLlamaMetadataSource(fetchService);
          const portalsFi = new portals_fi_metadata_source_1.PortalsFiMetadataSource(fetchService);
          const rpc = new rpc_metadata_source_1.RPCMetadataSource(multicallService);
          return new fallback_metadata_source_1.FallbackMetadataSource([defiLlama, portalsFi, rpc]);
        case "defi-llama":
          return new defi_llama_metadata_source_1.DefiLlamaMetadataSource(fetchService);
        case "portals-fi":
          return new portals_fi_metadata_source_1.PortalsFiMetadataSource(fetchService);
        case "changelly":
          return new changelly_metadata_source_1.ChangellyMetadataSource(fetchService, source.apiKey);
        case "cached":
          const underlying = buildSource(source.underlyingSource, { fetchService, multicallService });
          return new cached_metadata_source_1.CachedMetadataSource(underlying, source.config);
        case "rpc-multicall":
          return new rpc_metadata_source_1.RPCMetadataSource(multicallService);
        case "custom":
          return source.instance;
        case "aggregate":
          return new fallback_metadata_source_1.FallbackMetadataSource(source.sources.map((source2) => buildSource(source2, { fetchService, multicallService })));
      }
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/base/always-valid-source.js
var require_always_valid_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/base/always-valid-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlwaysValidConfigAndContextSource = void 0;
    var AlwaysValidConfigAndContextSource = class {
      isConfigAndContextValid(config2) {
        return true;
      }
    };
    exports.AlwaysValidConfigAndContextSource = AlwaysValidConfigAndContextSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/odos-quote-source.js
var require_odos_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/odos-quote-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OdosQuoteSource = void 0;
    var _chains_1 = require_chains();
    var constants_1 = require_constants();
    var utils_1 = require_utils16();
    var utils_2 = require_utils13();
    var always_valid_source_1 = require_always_valid_source();
    var ODOS_METADATA = {
      name: "Odos",
      supports: {
        chains: [
          _chains_1.Chains.ETHEREUM.chainId,
          _chains_1.Chains.POLYGON.chainId,
          _chains_1.Chains.ARBITRUM.chainId,
          _chains_1.Chains.OPTIMISM.chainId,
          _chains_1.Chains.AVALANCHE.chainId,
          _chains_1.Chains.BNB_CHAIN.chainId,
          _chains_1.Chains.FANTOM.chainId,
          _chains_1.Chains.BASE_GOERLI.chainId,
          _chains_1.Chains.BASE.chainId
        ],
        swapAndTransfer: false,
        buyOrders: false
      },
      logoURI: "ipfs://Qma71evDJfVUSBU53qkf8eDDysUgojsZNSnFRWa4qWragz"
    };
    var MEAN_REFERRAL_CODE = 1533410238;
    var OdosQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return ODOS_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, accounts: { takeFrom }, config: { slippagePercentage, timeout } }, config: config2 }) {
        const checksummedSell = checksumAndMapIfNecessary(sellToken);
        const checksummedBuy = checksumAndMapIfNecessary(buyToken);
        const quoteBody = {
          chainId: chain.chainId,
          inputTokens: [{ tokenAddress: checksummedSell, amount: order.sellAmount.toString() }],
          outputTokens: [{ tokenAddress: checksummedBuy, proportion: 1 }],
          userAddr: (0, utils_1.checksum)(takeFrom),
          slippageLimitPercent: slippagePercentage,
          sourceWhitelist: config2?.sourceAllowlist,
          sourceBlacklist: config2?.sourceDenylist,
          simulate: !config2.disableValidation,
          pathViz: false,
          disableRFQs: !config2?.supportRFQs,
          referralCode: config2?.referralCode ?? MEAN_REFERRAL_CODE
        };
        const quoteResponse = await fetchService.fetch("https://api.odos.xyz/sor/quote/v2", {
          body: JSON.stringify(quoteBody),
          method: "POST",
          headers: { "Content-Type": "application/json" },
          timeout
        });
        if (!quoteResponse.ok) {
          (0, utils_1.failed)(ODOS_METADATA, chain, sellToken, buyToken, await quoteResponse.text());
        }
        const { pathId, outAmounts: [outputTokenAmount] } = await quoteResponse.json();
        const assembleResponse = await fetchService.fetch("https://api.odos.xyz/sor/assemble", {
          body: JSON.stringify({ userAddr: takeFrom, pathId }),
          method: "POST",
          headers: { "Content-Type": "application/json" },
          timeout
        });
        if (!assembleResponse.ok) {
          (0, utils_1.failed)(ODOS_METADATA, chain, sellToken, buyToken, await assembleResponse.text());
        }
        const { gasEstimate, transaction: { data, to, value } } = await assembleResponse.json();
        const quote = {
          sellAmount: order.sellAmount,
          buyAmount: BigInt(outputTokenAmount),
          calldata: data,
          estimatedGas: BigInt(gasEstimate),
          allowanceTarget: (0, utils_1.calculateAllowanceTarget)(sellToken, to),
          tx: {
            to,
            calldata: data,
            value: BigInt(value)
          }
        };
        return (0, utils_1.addQuoteSlippage)(quote, "sell", slippagePercentage);
      }
    };
    exports.OdosQuoteSource = OdosQuoteSource;
    function checksumAndMapIfNecessary(address) {
      return (0, utils_2.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? "0x0000000000000000000000000000000000000000" : (0, utils_1.checksum)(address);
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/paraswap-quote-source.js
var require_paraswap_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/paraswap-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParaswapQuoteSource = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var utils_1 = require_utils13();
    var always_valid_source_1 = require_always_valid_source();
    var utils_2 = require_utils16();
    var PARASWAP_METADATA = {
      name: "Paraswap",
      supports: {
        chains: [
          _chains_1.Chains.ETHEREUM.chainId,
          _chains_1.Chains.POLYGON.chainId,
          _chains_1.Chains.BNB_CHAIN.chainId,
          _chains_1.Chains.AVALANCHE.chainId,
          _chains_1.Chains.FANTOM.chainId,
          _chains_1.Chains.ARBITRUM.chainId,
          _chains_1.Chains.OPTIMISM.chainId,
          _chains_1.Chains.POLYGON_ZKEVM.chainId,
          _chains_1.Chains.BASE.chainId
        ],
        swapAndTransfer: true,
        buyOrders: true
      },
      logoURI: "ipfs://QmVtj4RwZ5MMfKpbfv8qXksb5WYBJsQXkaZXLq7ipvMNW5"
    };
    var ParaswapQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return PARASWAP_METADATA;
      }
      async quote({ components: { fetchService }, request, config: config2 }) {
        const route = await this.getPrice(fetchService, request, config2);
        const isWrapOrUnwrap = this.isWrapingOrUnwrapingWithWToken(request.chain, route);
        const { data, value } = await this.getQuote(fetchService, { ...request, route, isWrapOrUnwrap }, config2);
        const quote = {
          sellAmount: BigInt(route.srcAmount),
          buyAmount: BigInt(route.destAmount),
          estimatedGas: BigInt(route.gasCost),
          allowanceTarget: (0, utils_2.calculateAllowanceTarget)(request.sellToken, route.tokenTransferProxy),
          tx: {
            to: route.contractAddress,
            calldata: data,
            value
          }
        };
        const usedSlippage = isWrapOrUnwrap ? 0 : request.config.slippagePercentage;
        return (0, utils_2.addQuoteSlippage)(quote, request.order.type, usedSlippage);
      }
      async getPrice(fetchService, { chain, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { timeout }, external: { tokenData } }, config2) {
        const amount = order.type === "sell" ? order.sellAmount : order.buyAmount;
        const { sellToken: sellTokenDataResult, buyToken: buyTokenDataResult } = await tokenData.request();
        const queryParams = {
          network: chain.chainId,
          srcToken: sellToken,
          destToken: buyToken,
          amount,
          side: order.type.toUpperCase(),
          srcDecimals: sellTokenDataResult.decimals,
          destDecimals: buyTokenDataResult.decimals,
          includeDEXS: config2.sourceAllowlist,
          includeContractMethods: !!recipient && !(0, utils_1.isSameAddress)(takeFrom, recipient) ? ["simpleSwap", "multiSwap", "megaSwap"] : void 0
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `https://apiv5.paraswap.io/prices?${queryString}`;
        const response = await fetchService.fetch(url, { timeout });
        if (!response.ok) {
          (0, utils_2.failed)(PARASWAP_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const { priceRoute } = await response.json();
        return priceRoute;
      }
      async getQuote(fetchService, { chain, sellToken, buyToken, order, route, accounts: { takeFrom, recipient }, config: { slippagePercentage, txValidFor, timeout }, isWrapOrUnwrap, external: { tokenData } }, config2) {
        const { sellToken: sellTokenDataResult, buyToken: buyTokenDataResult } = await tokenData.request();
        const url = `https://apiv5.paraswap.io/transactions/${chain.chainId}?ignoreChecks=true`;
        const receiver = !!recipient && takeFrom !== recipient ? recipient : void 0;
        let body = {
          srcToken: sellToken,
          srcDecimals: sellTokenDataResult.decimals,
          destToken: buyToken,
          destDecimals: buyTokenDataResult.decimals,
          priceRoute: route,
          userAddress: takeFrom,
          receiver,
          partner: config2.referrer?.name,
          partnerAddress: config2.referrer?.address,
          partnerFeeBps: 0,
          deadline: (0, utils_1.calculateDeadline)(txValidFor)
        };
        if (isWrapOrUnwrap) {
          const amount = order.type === "sell" ? order.sellAmount : order.buyAmount;
          body = { ...body, srcAmount: amount.toString(), destAmount: amount.toString() };
        } else if (order.type === "sell") {
          body = { ...body, srcAmount: order.sellAmount.toString(), slippage: slippagePercentage * 100 };
        } else {
          body = { ...body, destAmount: order.buyAmount.toString(), slippage: slippagePercentage * 100 };
        }
        const response = await fetchService.fetch(url, {
          method: "POST",
          headers: { Accept: "application/json", "Content-Type": "application/json" },
          body: JSON.stringify(body),
          timeout
        });
        if (!response.ok) {
          (0, utils_2.failed)(PARASWAP_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const { data, value } = await response.json();
        return { data, value: BigInt(value ?? 0) };
      }
      isWrapingOrUnwrapingWithWToken(chain, priceRoute) {
        return priceRoute.bestRoute?.[0]?.percent === 100 && priceRoute.bestRoute[0].swaps?.[0]?.swapExchanges?.[0]?.percent === 100 && (0, utils_1.isSameAddress)(chain.wToken, priceRoute.bestRoute[0].swaps[0].swapExchanges[0].poolAddresses?.[0]);
      }
    };
    exports.ParaswapQuoteSource = ParaswapQuoteSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/0x-quote-source.js
var require_x_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/0x-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZRXQuoteSource = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var utils_1 = require_utils13();
    var utils_2 = require_utils16();
    var ZRX_API = {
      [_chains_1.Chains.ETHEREUM.chainId]: "https://api.0x.org",
      [_chains_1.Chains.OPTIMISM.chainId]: "https://optimism.api.0x.org",
      [_chains_1.Chains.POLYGON.chainId]: "https://polygon.api.0x.org",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "https://bsc.api.0x.org",
      [_chains_1.Chains.FANTOM.chainId]: "https://fantom.api.0x.org",
      [_chains_1.Chains.CELO.chainId]: "https://celo.api.0x.org",
      [_chains_1.Chains.AVALANCHE.chainId]: "https://avalanche.api.0x.org",
      [_chains_1.Chains.ARBITRUM.chainId]: "https://arbitrum.api.0x.org",
      [_chains_1.Chains.BASE.chainId]: "https://base.api.0x.org",
      [_chains_1.Chains.ETHEREUM_GOERLI.chainId]: "https://goerli.api.0x.org",
      [_chains_1.Chains.POLYGON_MUMBAI.chainId]: "https://mumbai.api.0x.org"
    };
    var ZRX_METADATA = {
      name: "0x/Matcha",
      supports: {
        chains: Object.keys(ZRX_API).map(Number),
        swapAndTransfer: false,
        buyOrders: true
      },
      logoURI: "ipfs://QmPQY4siKEJHZGW5F4JDBrUXCBFqfpnKzPA2xDmboeuZzL"
    };
    var ZRXQuoteSource = class {
      getMetadata() {
        return ZRX_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom } }, config: config2 }) {
        const api = ZRX_API[chain.chainId];
        const queryParams = {
          sellToken,
          buyToken,
          takerAddress: takeFrom,
          skipValidation: config2.disableValidation,
          slippagePercentage: slippagePercentage / 100,
          enableSlippageProtection: false,
          affiliateAddress: config2.referrer?.address,
          sellAmount: order.type === "sell" ? order.sellAmount.toString() : void 0,
          buyAmount: order.type === "buy" ? order.buyAmount.toString() : void 0
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `${api}/swap/v1/quote?${queryString}`;
        const headers = {
          ["0x-api-key"]: config2.apiKey
        };
        const response = await fetchService.fetch(url, { timeout, headers });
        if (!response.ok) {
          (0, utils_2.failed)(ZRX_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const { data, buyAmount, sellAmount, to, allowanceTarget, estimatedGas, value } = await response.json();
        const quote = {
          sellAmount: BigInt(sellAmount),
          buyAmount: BigInt(buyAmount),
          estimatedGas: BigInt(estimatedGas),
          allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, allowanceTarget),
          tx: {
            calldata: data,
            to,
            value: BigInt(value ?? 0)
          }
        };
        return (0, utils_2.addQuoteSlippage)(quote, order.type, (0, utils_1.isSameAddress)(to, chain.wToken) ? 0 : slippagePercentage);
      }
      isConfigAndContextValid(config2) {
        return !!config2?.apiKey;
      }
    };
    exports.ZRXQuoteSource = ZRXQuoteSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/1inch-quote-source.js
var require_inch_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/1inch-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OneInchQuoteSource = exports.ONE_INCH_METADATA = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var utils_1 = require_utils16();
    var utils_2 = require_utils13();
    exports.ONE_INCH_METADATA = {
      name: "1inch",
      supports: {
        chains: [
          _chains_1.Chains.ETHEREUM.chainId,
          _chains_1.Chains.BNB_CHAIN.chainId,
          _chains_1.Chains.POLYGON.chainId,
          _chains_1.Chains.OPTIMISM.chainId,
          _chains_1.Chains.ARBITRUM.chainId,
          _chains_1.Chains.GNOSIS.chainId,
          _chains_1.Chains.AVALANCHE.chainId,
          _chains_1.Chains.FANTOM.chainId,
          _chains_1.Chains.KLAYTN.chainId,
          _chains_1.Chains.AURORA.chainId,
          _chains_1.Chains.BASE.chainId
        ],
        swapAndTransfer: true,
        buyOrders: false
      },
      logoURI: "ipfs://QmNr5MnyZKUv7rMhMyZPbxPbtc1A1yAVAqEEgVbep1hdBx"
    };
    var OneInchQuoteSource = class {
      getMetadata() {
        return exports.ONE_INCH_METADATA;
      }
      async quote(params) {
        const { toAmount, to, data, value, gas } = await this.getQuote(params);
        const quote = {
          sellAmount: params.request.order.sellAmount,
          buyAmount: BigInt(toAmount),
          estimatedGas: gas ? BigInt(gas) : void 0,
          allowanceTarget: (0, utils_1.calculateAllowanceTarget)(params.request.sellToken, to),
          tx: {
            to,
            calldata: data,
            value: BigInt(value ?? 0)
          }
        };
        return (0, utils_1.addQuoteSlippage)(quote, params.request.order.type, params.request.config.slippagePercentage);
      }
      async getQuote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom, recipient } }, config: config2 }) {
        const queryParams = {
          src: sellToken,
          dst: buyToken,
          amount: order.sellAmount.toString(),
          from: takeFrom,
          slippage: slippagePercentage,
          disableEstimate: config2.disableValidation,
          receiver: !!recipient && !(0, utils_2.isSameAddress)(takeFrom, recipient) ? recipient : void 0,
          referrer: config2.referrer?.address,
          protocols: config2.sourceAllowlist
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `${getUrl2(config2)}/${chain.chainId}/swap?${queryString}`;
        const response = await fetchService.fetch(url, { timeout, headers: getHeaders(config2) });
        if (!response.ok) {
          (0, utils_1.failed)(exports.ONE_INCH_METADATA, chain, sellToken, buyToken, await response.text() || `Failed with status ${response.status}`);
        }
        const { toAmount, tx: { to, data, value, gas } } = await response.json();
        return { toAmount, to, data, value, gas };
      }
      isConfigAndContextValid(config2) {
        return !!config2 && (!!config2.apiKey || !!config2.customUrl);
      }
    };
    exports.OneInchQuoteSource = OneInchQuoteSource;
    function getUrl2(config2) {
      return config2.customUrl ?? "https://api.1inch.dev/swap/v5.2";
    }
    function getHeaders(config2) {
      const headers = {
        accept: "application/json"
      };
      if (config2.apiKey) {
        headers["Authorization"] = `Bearer ${config2.apiKey}`;
      }
      return headers;
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/uniswap-quote-source.js
var require_uniswap_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/uniswap-quote-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UniswapQuoteSource = void 0;
    var _chains_1 = require_chains();
    var constants_1 = require_constants();
    var utils_1 = require_utils13();
    var utils_2 = require_utils16();
    var always_valid_source_1 = require_always_valid_source();
    var viem_1 = require_cjs2();
    var ROUTER_ADDRESS = {
      [_chains_1.Chains.ETHEREUM.chainId]: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45",
      [_chains_1.Chains.OPTIMISM.chainId]: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45",
      [_chains_1.Chains.POLYGON.chainId]: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45",
      [_chains_1.Chains.ARBITRUM.chainId]: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45",
      [_chains_1.Chains.CELO.chainId]: "0x5615CDAb10dc425a742d643d949a7F474C01abc4",
      [_chains_1.Chains.ETHEREUM_GOERLI.chainId]: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45",
      [_chains_1.Chains.POLYGON_MUMBAI.chainId]: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2",
      [_chains_1.Chains.BASE.chainId]: "0x2626664c2603336E57B271c5C0b26F421741e481",
      [_chains_1.Chains.AVALANCHE.chainId]: "0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE"
    };
    var UNISWAP_METADATA = {
      name: "Uniswap",
      supports: {
        chains: Object.keys(ROUTER_ADDRESS).map(Number),
        swapAndTransfer: true,
        buyOrders: true
      },
      logoURI: "ipfs://QmNa3YBYAYS5qSCLuXataV5XCbtxP9ZB4rHUfomRxrpRhJ"
    };
    var UniswapQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return UNISWAP_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, config: { slippagePercentage, timeout, txValidFor }, accounts: { takeFrom, recipient } } }) {
        const amount = order.type === "sell" ? order.sellAmount : order.buyAmount;
        const isSellTokenNativeToken = (0, utils_1.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN);
        const isBuyTokenNativeToken = (0, utils_1.isSameAddress)(buyToken, constants_1.Addresses.NATIVE_TOKEN);
        const router = ROUTER_ADDRESS[chain.chainId];
        recipient = recipient ?? takeFrom;
        const url = `https://api.uniswap.org/v1/quote?protocols=v2,v3,mixed&tokenInAddress=${mapToWTokenIfNecessary(chain, sellToken)}&tokenInChainId=${chain.chainId}&tokenOutAddress=${mapToWTokenIfNecessary(chain, buyToken)}&tokenOutChainId=${chain.chainId}&amount=${amount.toString()}&type=${order.type === "sell" ? "exactIn" : "exactOut"}&recipient=${isBuyTokenNativeToken ? router : recipient}&deadline=${(0, utils_1.timeToSeconds)(txValidFor ?? "3h")}&slippageTolerance=${slippagePercentage}`;
        const headers = {
          origin: "https://app.uniswap.org",
          referer: "https://app.uniswap.org/"
        };
        const response = await fetchService.fetch(url, { headers, timeout });
        if (!response.ok) {
          (0, utils_2.failed)(UNISWAP_METADATA, chain, sellToken, buyToken, await response.text());
        }
        let { quote: quoteAmount, methodParameters: { calldata }, gasUseEstimate } = await response.json();
        const value = isSellTokenNativeToken && order.type === "sell" ? order.sellAmount : void 0;
        const buyAmount = order.type === "sell" ? BigInt(quoteAmount) : order.buyAmount;
        if (isBuyTokenNativeToken) {
          const minBuyAmount = calculateMinBuyAmount(order.type, buyAmount, slippagePercentage);
          const unwrapData = (0, viem_1.encodeFunctionData)({
            abi: ROUTER_ABI,
            functionName: "unwrapWETH9",
            args: [minBuyAmount, recipient]
          });
          const multicallData = (0, viem_1.encodeFunctionData)({
            abi: ROUTER_ABI,
            functionName: "multicall",
            args: [[calldata, unwrapData]]
          });
          calldata = multicallData;
          gasUseEstimate = BigInt(gasUseEstimate) + 12500n;
        }
        const quote = {
          sellAmount: order.type === "sell" ? order.sellAmount : BigInt(quoteAmount),
          buyAmount,
          estimatedGas: BigInt(gasUseEstimate),
          allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, router),
          tx: {
            to: router,
            calldata,
            value
          }
        };
        return (0, utils_2.addQuoteSlippage)(quote, order.type, slippagePercentage);
      }
    };
    exports.UniswapQuoteSource = UniswapQuoteSource;
    function calculateMinBuyAmount(type, buyAmount, slippagePercentage) {
      return type === "sell" ? BigInt((0, utils_1.substractPercentage)(buyAmount, slippagePercentage, "up")) : buyAmount;
    }
    function mapToWTokenIfNecessary(chain, address) {
      return (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? chain.wToken : address;
    }
    var ROUTER_HUMAN_READABLE_ABI = [
      "function unwrapWETH9(uint256 amountMinimum, address recipient) payable",
      "function multicall(bytes[] data) payable returns (bytes[] memory results)"
    ];
    var ROUTER_ABI = (0, viem_1.parseAbi)(ROUTER_HUMAN_READABLE_ABI);
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/open-ocean-quote-source.js
var require_open_ocean_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/open-ocean-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OpenOceanQuoteSource = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var viem_1 = require_cjs2();
    var utils_1 = require_utils16();
    var always_valid_source_1 = require_always_valid_source();
    var SUPPORTED_CHAINS = {
      [_chains_1.Chains.ETHEREUM.chainId]: "eth",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "bsc",
      [_chains_1.Chains.POLYGON.chainId]: "polygon",
      [_chains_1.Chains.FANTOM.chainId]: "fantom",
      [_chains_1.Chains.AVALANCHE.chainId]: "avax",
      [_chains_1.Chains.HECO.chainId]: "heco",
      [_chains_1.Chains.OKC.chainId]: "okc",
      [_chains_1.Chains.GNOSIS.chainId]: "xdai",
      [_chains_1.Chains.ARBITRUM.chainId]: "arbitrum",
      [_chains_1.Chains.OPTIMISM.chainId]: "optimism",
      [_chains_1.Chains.CRONOS.chainId]: "cronos",
      [_chains_1.Chains.MOONRIVER.chainId]: "moonriver",
      [_chains_1.Chains.BOBA.chainId]: "boba",
      [_chains_1.Chains.ONTOLOGY.chainId]: "ont",
      [_chains_1.Chains.AURORA.chainId]: "aurora",
      [_chains_1.Chains.HARMONY_SHARD_0.chainId]: "harmony",
      [_chains_1.Chains.POLYGON_ZKEVM.chainId]: "polygon_zkevm",
      [_chains_1.Chains.KAVA.chainId]: "kava",
      [_chains_1.Chains.CELO.chainId]: "celo",
      [_chains_1.Chains.LINEA.chainId]: "linea",
      [_chains_1.Chains.BASE.chainId]: "base"
    };
    var OPEN_OCEAN_METADATA = {
      name: "Open Ocean",
      supports: {
        chains: Object.keys(SUPPORTED_CHAINS).map(Number),
        swapAndTransfer: true,
        buyOrders: false
      },
      logoURI: "ipfs://QmP7bVENjMmobmjJcPFX6VbFTmj6pKmFNqv7Qkyqui44dT"
    };
    var OpenOceanQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return OPEN_OCEAN_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout }, external }, config: config2 }) {
        const [{ sellToken: sellTokenDataResult }, gasPriceResult] = await Promise.all([external.tokenData.request(), external.gasPrice.request()]);
        const legacyGasPrice = eip1159ToLegacy(gasPriceResult);
        const gasPrice = parseFloat((0, viem_1.formatUnits)(legacyGasPrice, 9));
        const amount = (0, viem_1.formatUnits)(order.sellAmount, sellTokenDataResult.decimals);
        const chainKey = SUPPORTED_CHAINS[chain.chainId];
        const queryParams = {
          inTokenAddress: sellToken,
          outTokenAddress: buyToken,
          amount,
          slippage: slippagePercentage,
          gasPrice,
          account: recipient ?? takeFrom,
          referrer: config2.referrer?.address,
          enabledDexIds: config2.sourceAllowlist
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `https://open-api.openocean.finance/v3/${chainKey}/swap_quote?${queryString}`;
        const response = await fetchService.fetch(url, { timeout });
        if (!response.ok) {
          (0, utils_1.failed)(OPEN_OCEAN_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const { data: { outAmount, estimatedGas, minOutAmount, to, value, data } } = await response.json();
        return {
          sellAmount: order.sellAmount,
          maxSellAmount: order.sellAmount,
          buyAmount: BigInt(outAmount),
          minBuyAmount: BigInt(minOutAmount),
          type: "sell",
          estimatedGas: BigInt(estimatedGas),
          allowanceTarget: (0, utils_1.calculateAllowanceTarget)(sellToken, to),
          tx: {
            to,
            calldata: data,
            value: BigInt(value ?? 0)
          }
        };
      }
    };
    exports.OpenOceanQuoteSource = OpenOceanQuoteSource;
    function eip1159ToLegacy(gasPrice) {
      if ("gasPrice" in gasPrice) {
        return BigInt(gasPrice.gasPrice);
      }
      return BigInt(gasPrice.maxFeePerGas);
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/li-fi-quote-source.js
var require_li_fi_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/li-fi-quote-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LiFiQuoteSource = void 0;
    var _chains_1 = require_chains();
    var constants_1 = require_constants();
    var utils_1 = require_utils13();
    var always_valid_source_1 = require_always_valid_source();
    var utils_2 = require_utils16();
    var LI_FI_METADATA = {
      name: "LI.FI",
      supports: {
        chains: [
          _chains_1.Chains.ETHEREUM.chainId,
          _chains_1.Chains.POLYGON.chainId,
          _chains_1.Chains.BNB_CHAIN.chainId,
          _chains_1.Chains.GNOSIS.chainId,
          _chains_1.Chains.FANTOM.chainId,
          _chains_1.Chains.OKC.chainId,
          _chains_1.Chains.AVALANCHE.chainId,
          _chains_1.Chains.ARBITRUM.chainId,
          _chains_1.Chains.OPTIMISM.chainId,
          _chains_1.Chains.MOONRIVER.chainId,
          _chains_1.Chains.MOONBEAM.chainId,
          _chains_1.Chains.CELO.chainId,
          _chains_1.Chains.FUSE.chainId,
          _chains_1.Chains.CRONOS.chainId,
          _chains_1.Chains.VELAS.chainId,
          _chains_1.Chains.AURORA.chainId,
          _chains_1.Chains.EVMOS.chainId,
          _chains_1.Chains.POLYGON_ZKEVM.chainId,
          _chains_1.Chains.BASE.chainId
        ],
        swapAndTransfer: true,
        buyOrders: false
      },
      logoURI: "ipfs://QmUgcnaNxsgQdjBjytxvXfeSfsDryh9bF4mNaz1Bp5QwJ4"
    };
    var LiFiQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return LI_FI_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout } }, config: config2 }) {
        const mappedSellToken = mapNativeToken(sellToken);
        const mappedBuyToken = mapNativeToken(buyToken);
        let url = `https://li.quest/v1/quote?fromChain=${chain.chainId}&toChain=${chain.chainId}&fromToken=${mappedSellToken}&toToken=${mappedBuyToken}&fromAddress=${takeFrom}&toAddress=${recipient ?? takeFrom}&fromAmount=${order.sellAmount.toString()}&slippage=${slippagePercentage / 100}`;
        if (config2.referrer) {
          url += `&integrator=${config2.referrer.name}`;
          url += `&referrer=${config2.referrer.address}`;
        }
        const response = await fetchService.fetch(url, { timeout });
        if (!response.ok) {
          (0, utils_2.failed)(LI_FI_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const { estimate: { approvalAddress, toAmountMin, toAmount, gasCosts }, transactionRequest: { to, data, value } } = await response.json();
        const estimatedGas = gasCosts.reduce((accum, { estimate }) => accum + BigInt(estimate), 0n);
        return {
          sellAmount: order.sellAmount,
          maxSellAmount: order.sellAmount,
          buyAmount: BigInt(toAmount),
          minBuyAmount: BigInt(toAmountMin),
          type: "sell",
          estimatedGas,
          allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, approvalAddress),
          tx: {
            to,
            calldata: data,
            value: BigInt(value ?? 0)
          }
        };
      }
    };
    exports.LiFiQuoteSource = LiFiQuoteSource;
    function mapNativeToken(address) {
      return (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? "0x0000000000000000000000000000000000000000" : address;
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/kyberswap-quote-source.js
var require_kyberswap_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/kyberswap-quote-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KyberswapQuoteSource = void 0;
    var _chains_1 = require_chains();
    var constants_1 = require_constants();
    var utils_1 = require_utils13();
    var always_valid_source_1 = require_always_valid_source();
    var utils_2 = require_utils16();
    var SUPPORTED_CHAINS = {
      [_chains_1.Chains.ARBITRUM.chainId]: "arbitrum",
      [_chains_1.Chains.AURORA.chainId]: "aurora",
      [_chains_1.Chains.AVALANCHE.chainId]: "avalanche",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "bsc",
      [_chains_1.Chains.BIT_TORRENT.chainId]: "bttc",
      [_chains_1.Chains.CRONOS.chainId]: "cronos",
      [_chains_1.Chains.ETHEREUM.chainId]: "ethereum",
      [_chains_1.Chains.FANTOM.chainId]: "fantom",
      [_chains_1.Chains.OASIS_EMERALD.chainId]: "oasis",
      [_chains_1.Chains.POLYGON.chainId]: "polygon",
      [_chains_1.Chains.VELAS.chainId]: "velas",
      [_chains_1.Chains.OPTIMISM.chainId]: "optimism",
      [_chains_1.Chains.LINEA.chainId]: "linea",
      [_chains_1.Chains.BASE.chainId]: "base",
      [_chains_1.Chains.POLYGON_ZKEVM.chainId]: "polygon-zkevm"
    };
    var KYBERSWAP_METADATA = {
      name: "Kyberswap",
      supports: {
        chains: Object.keys(SUPPORTED_CHAINS).map(Number),
        swapAndTransfer: true,
        buyOrders: false
      },
      logoURI: "ipfs://QmNcTVyqeVtNoyrT546VgJTD4vsZEkWp6zhDJ4qhgKkhbK"
    };
    var KyberswapQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return KYBERSWAP_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout, txValidFor } }, config: config2 }) {
        const chainKey = SUPPORTED_CHAINS[chain.chainId];
        const headers = config2.referrer?.name ? { "x-client-id": config2.referrer?.name } : void 0;
        const url = `https://aggregator-api.kyberswap.com/${chainKey}/api/v1/routes?tokenIn=${sellToken}&tokenOut=${buyToken}&amountIn=${order.sellAmount.toString()}&saveGas=0&gasInclude=true`;
        const routeResponse = await fetchService.fetch(url, { timeout, headers });
        if (!routeResponse.ok) {
          (0, utils_2.failed)(KYBERSWAP_METADATA, chain, sellToken, buyToken, await routeResponse.text());
        }
        const { data: { routeSummary } } = await routeResponse.json();
        const buildResponse = await fetchService.fetch(`https://aggregator-api.kyberswap.com/${chainKey}/api/v1/route/build`, {
          timeout,
          headers,
          method: "POST",
          body: JSON.stringify({
            routeSummary,
            slippageTolerance: slippagePercentage * 100,
            recipient: recipient ?? takeFrom,
            deadline: txValidFor ? (0, utils_1.calculateDeadline)(txValidFor) : void 0,
            source: config2.referrer?.name,
            sender: takeFrom,
            skipSimulateTransaction: config2.disableValidation
          })
        });
        if (!buildResponse.ok) {
          (0, utils_2.failed)(KYBERSWAP_METADATA, chain, sellToken, buyToken, await buildResponse.text());
        }
        const { data: { amountOut, gas, data, routerAddress } } = await buildResponse.json();
        if (!data) {
          (0, utils_2.failed)(KYBERSWAP_METADATA, chain, sellToken, buyToken, "Failed to calculate a quote");
        }
        const value = (0, utils_1.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN) ? order.sellAmount : 0n;
        const quote = {
          sellAmount: order.sellAmount,
          buyAmount: BigInt(amountOut),
          estimatedGas: BigInt(gas),
          allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, routerAddress),
          tx: {
            to: routerAddress,
            calldata: data,
            value
          }
        };
        return (0, utils_2.addQuoteSlippage)(quote, order.type, slippagePercentage);
      }
    };
    exports.KyberswapQuoteSource = KyberswapQuoteSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/firebird-quote-source.js
var require_firebird_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/firebird-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FirebirdQuoteSource = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var constants_1 = require_constants();
    var utils_1 = require_utils13();
    var utils_2 = require_utils16();
    var FIREBIRD_METADATA = {
      name: "Firebird",
      supports: {
        chains: [
          _chains_1.Chains.ETHEREUM.chainId,
          _chains_1.Chains.FANTOM.chainId,
          _chains_1.Chains.CRONOS.chainId,
          _chains_1.Chains.POLYGON.chainId,
          _chains_1.Chains.BNB_CHAIN.chainId,
          _chains_1.Chains.AVALANCHE.chainId,
          _chains_1.Chains.ARBITRUM.chainId,
          _chains_1.Chains.OPTIMISM.chainId,
          _chains_1.Chains.CANTO.chainId,
          _chains_1.Chains.BASE.chainId
        ],
        swapAndTransfer: true,
        buyOrders: false
      },
      logoURI: "ipfs://QmXJ92XHRWGzRFyUYYt5THiBVTiLwB1KAV35H5UyA3a8Yf"
    };
    var FirebirdQuoteSource = class {
      getMetadata() {
        return FIREBIRD_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout, txValidFor } }, config: config2 }) {
        const headers = { "API-KEY": config2.apiKey };
        const queryParams = {
          chainId: chain.chainId,
          from: sellToken,
          to: buyToken,
          amount: order.sellAmount.toString(),
          slippage: slippagePercentage / 100,
          receiver: recipient ?? takeFrom,
          saveGas: 0,
          gasInclude: 1,
          dexes: config2.sourceAllowlist,
          source: config2.referrer?.name,
          ref: config2.referrer?.address,
          deadline: txValidFor && (0, utils_1.calculateDeadline)(txValidFor)
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `https://router.firebird.finance/aggregator/v2/quote?${queryString}`;
        const quoteResponse = await fetchService.fetch(url, { timeout, headers });
        if (!quoteResponse.ok) {
          (0, utils_2.failed)(FIREBIRD_METADATA, chain, sellToken, buyToken, await quoteResponse.text());
        }
        const encodeResponse = await fetchService.fetch(`https://router.firebird.finance/aggregator/v2/encode`, {
          method: "POST",
          headers,
          body: JSON.stringify(await quoteResponse.json())
        });
        if (!quoteResponse.ok) {
          (0, utils_2.failed)(FIREBIRD_METADATA, chain, sellToken, buyToken, await encodeResponse.text());
        }
        const { encodedData: { router, data }, maxReturn: { totalGas, totalTo } } = await encodeResponse.json();
        const quote = {
          sellAmount: order.sellAmount,
          buyAmount: BigInt(totalTo),
          estimatedGas: BigInt(totalGas),
          allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, router),
          tx: {
            to: router,
            calldata: data,
            value: (0, utils_1.isSameAddress)(constants_1.Addresses.NATIVE_TOKEN, sellToken) ? order.sellAmount : 0n
          }
        };
        return (0, utils_2.addQuoteSlippage)(quote, "sell", slippagePercentage);
      }
      isConfigAndContextValid(config2) {
        return !!config2?.apiKey;
      }
    };
    exports.FirebirdQuoteSource = FirebirdQuoteSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/rango-quote-source.js
var require_rango_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/rango-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RangoQuoteSource = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var constants_1 = require_constants();
    var utils_1 = require_utils13();
    var utils_2 = require_utils16();
    var viem_1 = require_cjs2();
    var SUPPORTED_CHAINS = {
      [_chains_1.Chains.ETHEREUM.chainId]: "ETH",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "BNB",
      [_chains_1.Chains.POLYGON.chainId]: "POLYGON",
      [_chains_1.Chains.FANTOM.chainId]: "FANTOM",
      [_chains_1.Chains.ARBITRUM.chainId]: "ARBITRUM",
      [_chains_1.Chains.CELO.chainId]: "CELO",
      [_chains_1.Chains.OKC.chainId]: "OKC",
      [_chains_1.Chains.MOONRIVER.chainId]: "MOONRIVER",
      [_chains_1.Chains.MOONBEAM.chainId]: "MOONBEAM",
      [_chains_1.Chains.OPTIMISM.chainId]: "OPTIMISM",
      [_chains_1.Chains.GNOSIS.chainId]: "GNOSIS",
      [_chains_1.Chains.HARMONY_SHARD_0.chainId]: "HARMONY",
      [_chains_1.Chains.AVALANCHE.chainId]: "AVAX_CCHAIN",
      [_chains_1.Chains.FUSE.chainId]: "FUSE",
      [_chains_1.Chains.CRONOS.chainId]: "CRONOS",
      [_chains_1.Chains.BOBA.chainId]: "BOBA",
      [_chains_1.Chains.AURORA.chainId]: "AURORA",
      [_chains_1.Chains.HECO.chainId]: "HECO",
      [_chains_1.Chains.EVMOS.chainId]: "EVMOS",
      [_chains_1.Chains.POLYGON_ZKEVM.chainId]: "POLYGONZK"
    };
    var RANGO_METADATA = {
      name: "Rango",
      supports: {
        chains: Object.keys(SUPPORTED_CHAINS).map(Number),
        swapAndTransfer: true,
        buyOrders: false
      },
      logoURI: "ipfs://QmTvX3XyrFDSiDAKPJg9xFgn8DgQbp31wYWE8q7VhaR2c7"
    };
    var RangoQuoteSource = class {
      getMetadata() {
        return RANGO_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, accounts: { takeFrom, recipient }, config: { slippagePercentage, timeout }, external: { tokenData } }, config: config2 }) {
        const { sellToken: sellTokenDataResult, buyToken: buyTokenDataResult } = await tokenData.request();
        const chainKey = SUPPORTED_CHAINS[chain.chainId];
        const queryParams = {
          apiKey: config2.apiKey,
          from: mapToChainId(chainKey, sellToken, sellTokenDataResult),
          to: mapToChainId(chainKey, buyToken, buyTokenDataResult),
          amount: order.sellAmount.toString(),
          fromAddress: takeFrom,
          toAddress: recipient ?? takeFrom,
          disableEstimate: config2.disableValidation,
          slippage: slippagePercentage,
          referrerAddress: config2.referrer?.address
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `https://api.rango.exchange/basic/swap?${queryString}`;
        const response = await fetchService.fetch(url, { timeout });
        if (!response.ok) {
          (0, utils_2.failed)(RANGO_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const { requestId, route: { outputAmount, outputAmountMin, fee }, tx: { txTo, txData, value, gasLimit, gasPrice, approveData } } = await response.json();
        const gasCost = BigInt(fee.find((fee2) => fee2.name === "Network Fee")?.amount ?? 0);
        const estimatedGas = gasLimit ? BigInt(gasLimit) : gasCost / BigInt(gasPrice ?? 1);
        let allowanceTarget = constants_1.Addresses.ZERO_ADDRESS;
        if (approveData) {
          const { args } = (0, viem_1.decodeFunctionData)({ abi: ABI, data: approveData });
          allowanceTarget = args[0];
        }
        const tx = {
          to: txTo,
          calldata: txData,
          value: BigInt(value ?? 0)
        };
        return {
          sellAmount: order.sellAmount,
          maxSellAmount: order.sellAmount,
          buyAmount: BigInt(outputAmount),
          minBuyAmount: BigInt(outputAmountMin),
          type: "sell",
          estimatedGas,
          allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, allowanceTarget),
          tx,
          customData: { requestId }
        };
      }
      isConfigAndContextValid(config2) {
        return !!config2?.apiKey;
      }
    };
    exports.RangoQuoteSource = RangoQuoteSource;
    function mapToChainId(chainKey, address, metadata) {
      return (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? `${chainKey}.${metadata.symbol}` : `${chainKey}.${metadata.symbol}--${address}`;
    }
    var ABI = (0, viem_1.parseAbi)(["function approve(address spender, uint256 value) returns (bool success)"]);
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/mean-finance-quote-source.js
var require_mean_finance_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/mean-finance-quote-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeanFinanceQuoteSource = exports.MEAN_FINANCE_SUPPORTED_CHAINS = void 0;
    var _chains_1 = require_chains();
    var utils_1 = require_utils16();
    var always_valid_source_1 = require_always_valid_source();
    exports.MEAN_FINANCE_SUPPORTED_CHAINS = [
      _chains_1.Chains.ETHEREUM,
      _chains_1.Chains.OPTIMISM,
      _chains_1.Chains.POLYGON,
      _chains_1.Chains.BNB_CHAIN,
      _chains_1.Chains.ARBITRUM,
      _chains_1.Chains.GNOSIS,
      _chains_1.Chains.BASE,
      _chains_1.Chains.BASE_GOERLI
    ].map(({ chainId }) => chainId);
    var MEAN_METADATA = {
      name: "Mean Finance",
      supports: {
        chains: exports.MEAN_FINANCE_SUPPORTED_CHAINS,
        buyOrders: true,
        swapAndTransfer: true
      },
      logoURI: "ipfs://QmUUbaZvrD8Ymr2nV6db4Cbtd1aMCiSP7MoyvBv9LTnrmP"
    };
    var MeanFinanceQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return MEAN_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, config: { slippagePercentage, timeout, txValidFor }, accounts: { takeFrom, recipient }, order, external, ...request }, config: config2 }) {
        const url = `https://api.mean.finance/v1/swap/networks/${chain.chainId}/quotes/mean-finance`;
        const stringOrder = order.type === "sell" ? { type: "sell", sellAmount: order.sellAmount.toString() } : { type: "buy", buyAmount: order.buyAmount.toString() };
        const body = {
          ...request,
          order: stringOrder,
          slippagePercentage,
          takerAddress: takeFrom,
          recipient,
          txValidFor,
          quoteTimeout: timeout,
          sourceConfig: config2
        };
        const response = await fetchService.fetch(url, {
          method: "POST",
          body: JSON.stringify(body),
          timeout
        });
        if (!response.ok) {
          (0, utils_1.failed)(MEAN_METADATA, chain, request.sellToken, request.buyToken, await response.text());
        }
        const { sellAmount, buyAmount, maxSellAmount, minBuyAmount, estimatedGas, source: { allowanceTarget }, tx: { to, value, data } } = await response.json();
        return {
          sellAmount: BigInt(sellAmount),
          maxSellAmount: BigInt(maxSellAmount),
          buyAmount: BigInt(buyAmount),
          minBuyAmount: BigInt(minBuyAmount),
          estimatedGas: BigInt(estimatedGas),
          allowanceTarget: (0, utils_1.calculateAllowanceTarget)(request.sellToken, allowanceTarget),
          type: order.type,
          tx: {
            calldata: data,
            to,
            value: BigInt(value ?? 0)
          }
        };
      }
    };
    exports.MeanFinanceQuoteSource = MeanFinanceQuoteSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/wido-quote-source.js
var require_wido_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/wido-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WidoQuoteSource = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var utils_1 = require_utils16();
    var always_valid_source_1 = require_always_valid_source();
    var SUPPORTED_CHAINS = [
      _chains_1.Chains.ETHEREUM,
      _chains_1.Chains.POLYGON,
      _chains_1.Chains.BNB_CHAIN,
      _chains_1.Chains.AVALANCHE,
      _chains_1.Chains.ARBITRUM,
      _chains_1.Chains.OPTIMISM,
      _chains_1.Chains.FANTOM,
      _chains_1.Chains.AURORA
    ].map(({ chainId }) => chainId);
    var WIDO_METADATA = {
      name: "Wido",
      supports: {
        chains: SUPPORTED_CHAINS,
        swapAndTransfer: true,
        buyOrders: false
      },
      logoURI: "ipfs://QmVA2eTK8SBnF2iqUdxvTEUgZbcjBq47P1QejQCRSd9im7"
    };
    var WidoQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return WIDO_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom, recipient } }, config: config2 }) {
        const queryParams = {
          from_chain_id: chain.chainId,
          from_token: sellToken,
          to_chain_id: chain.chainId,
          to_token: buyToken,
          slippage_percentage: slippagePercentage / 100,
          amount: order.sellAmount.toString(),
          user: takeFrom,
          validate: !config2.disableValidation,
          partner: config2.referrer?.address,
          recipient
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const quoteUrl = `https://api.joinwido.com/quote_v2?${queryString}`;
        const allowanceUrl = `https://api.joinwido.com/contract_address?chain_id=${chain.chainId}&from_token=${sellToken}&to_chain_id=${chain.chainId}&to_token=${buyToken}`;
        try {
          const [{ to, value, data, to_token_amount, min_to_token_amount }, { spender: allowanceTarget }] = await Promise.all([
            fetch2(fetchService, quoteUrl, timeout),
            fetch2(fetchService, allowanceUrl, timeout)
          ]);
          return {
            sellAmount: BigInt(order.sellAmount),
            maxSellAmount: BigInt(order.sellAmount),
            buyAmount: BigInt(to_token_amount),
            minBuyAmount: BigInt(min_to_token_amount),
            type: "sell",
            estimatedGas: void 0,
            allowanceTarget: (0, utils_1.calculateAllowanceTarget)(sellToken, allowanceTarget),
            tx: {
              calldata: data,
              to,
              value: BigInt(value ?? 0)
            }
          };
        } catch (e) {
          (0, utils_1.failed)(WIDO_METADATA, chain, sellToken, buyToken, e.message);
        }
      }
    };
    exports.WidoQuoteSource = WidoQuoteSource;
    function fetch2(fetchService, url, timeout) {
      return fetchService.fetch(url, {
        timeout,
        headers: {
          "user-agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36"
        }
      }).then((response) => response.json());
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/portals-fi-quote-source.js
var require_portals_fi_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/portals-fi-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PortalsFiQuoteSource = exports.PORTALS_FI_METADATA = void 0;
    var qs_1 = __importDefault(require_lib23());
    var constants_1 = require_constants();
    var portals_fi_1 = require_portals_fi();
    var utils_1 = require_utils13();
    var utils_2 = require_utils16();
    var always_valid_source_1 = require_always_valid_source();
    exports.PORTALS_FI_METADATA = {
      name: "Portals.fi",
      supports: {
        chains: portals_fi_1.PORTALS_FI_SUPPORTED_CHAINS,
        swapAndTransfer: false,
        buyOrders: false
      },
      logoURI: "ipfs://QmYJiiZAxFHSJb37y25unRUyWioTH6odKWmEZ1psD1DyuL"
    };
    var PortalsFiQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return exports.PORTALS_FI_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, accounts: { takeFrom }, config: { slippagePercentage, timeout } }, config: config2 }) {
        const mappedSellToken = mapToken(chain, sellToken);
        const mappedBuyToken = mapToken(chain, buyToken);
        const queryParams = {
          sender: takeFrom,
          inputToken: mappedSellToken,
          inputAmount: order.sellAmount.toString(),
          outputToken: mappedBuyToken,
          slippageTolerancePercentage: slippagePercentage,
          validate: !config2.disableValidation,
          partner: config2.referrer?.address,
          feePercentage: config2.referrer ? 0 : void 0
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `https://api.portals.fi/v2/portal?${queryString}`;
        const response = await fetchService.fetch(url, { timeout });
        if (!response.ok) {
          (0, utils_2.failed)(exports.PORTALS_FI_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const { context: { outputAmount, minOutputAmount, value }, tx: { to, data, gasLimit } } = await response.json();
        return {
          sellAmount: order.sellAmount,
          maxSellAmount: order.sellAmount,
          buyAmount: BigInt(outputAmount),
          minBuyAmount: BigInt(minOutputAmount),
          type: "sell",
          estimatedGas: gasLimit ? BigInt(gasLimit) : void 0,
          allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, to),
          tx: {
            to,
            calldata: data,
            value: BigInt(value ?? 0)
          }
        };
      }
    };
    exports.PortalsFiQuoteSource = PortalsFiQuoteSource;
    function mapToken(chain, address) {
      const chainKey = portals_fi_1.PORTALS_FI_CHAIN_ID_TO_KEY[chain.chainId];
      const mapped = (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : address;
      return `${chainKey}:${mapped}`;
    }
  }
});

// ../node_modules/crypto-js/core.js
var require_core = __commonJS({
  "../node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof window.self !== "undefined" && window.self.crypto) {
          crypto2 = window.self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words2, sigBytes) {
            words2 = this.words = words2 || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words2.length * 4;
            }
          },
          toString: function(encoder3) {
            return (encoder3 || Hex7).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words2 = this.words;
            var sigBytes = this.sigBytes;
            words2[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words2.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words2 = [];
            for (var i = 0; i < nBytes; i += 4) {
              words2.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words2, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex7 = C_enc.Hex = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words2[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words2 = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words2[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words2, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words2[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words2 = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words2[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words2, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash4 = this._doFinalize();
            return hash4;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// ../node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "../node_modules/crypto-js/x64-core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          init: function(words2, sigBytes) {
            words2 = this.words = words2 || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words2.length * 8;
            }
          },
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            var words2 = clone.words = this.words.slice(0);
            var wordsLength = words2.length;
            for (var i = 0; i < wordsLength; i++) {
              words2[i] = words2[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  }
});

// ../node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "../node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words2 = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words2[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words2, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  }
});

// ../node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "../node_modules/crypto-js/enc-utf16.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words2[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words2 = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words2[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words2, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words2[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words2 = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words2[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words2, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  }
});

// ../node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "../node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          stringify: function(wordArray) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words2[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words2[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words2[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words2 = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words2[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words2, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  }
});

// ../node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "../node_modules/crypto-js/enc-base64url.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64url = C_enc.Base64url = {
          stringify: function(wordArray, urlSafe = true) {
            var words2 = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words2[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words2[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words2[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str, urlSafe = true) {
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words2 = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words2[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words2, nBytes);
        }
      })();
      return CryptoJS.enc.Base64url;
    });
  }
});

// ../node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "../node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash4 = this._hash;
            var H = hash4.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash4;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  }
});

// ../node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "../node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// ../node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "../node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA2562 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA2562);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA2562);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// ../node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "../node_modules/crypto-js/sha224.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA2562 = C_algo.SHA256;
        var SHA2242 = C_algo.SHA224 = SHA2562.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash4 = SHA2562._doFinalize.call(this);
            hash4.sigBytes -= 4;
            return hash4;
          }
        });
        C.SHA224 = SHA2562._createHelper(SHA2242);
        C.HmacSHA224 = SHA2562._createHmacHelper(SHA2242);
      })();
      return CryptoJS.SHA224;
    });
  }
});

// ../node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "../node_modules/crypto-js/sha512.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wil;
              var Wih;
              var Wi = W[i];
              if (i < 16) {
                Wih = Wi.high = M[offset + i * 2] | 0;
                Wil = Wi.low = M[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash4 = this._hash.toX32();
            return hash4;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  }
});

// ../node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "../node_modules/crypto-js/sha384.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash4 = SHA512._doFinalize.call(this);
            hash4.sigBytes -= 16;
            return hash4;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  }
});

// ../node_modules/crypto-js/sha3.js
var require_sha33 = __commonJS({
  "../node_modules/crypto-js/sha3.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  }
});

// ../node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "../node_modules/crypto-js/ripemd160.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash4 = this._hash;
            var H = hash4.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash4;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
  }
});

// ../node_modules/crypto-js/hmac.js
var require_hmac2 = __commonJS({
  "../node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC2 = C_algo.HMAC = Base.extend({
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  }
});

// ../node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "../node_modules/crypto-js/pbkdf2.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC2 = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac2 = HMAC2.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac2.update(salt).finalize(blockIndex);
              hmac2.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac2.finalize(intermediate);
                hmac2.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  }
});

// ../node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "../node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  }
});

// ../node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "../node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            processBlock: function(words2, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words2, offset, blockSize);
              cipher.encryptBlock(words2, offset);
              this._prevBlock = words2.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            processBlock: function(words2, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words2.slice(offset, offset + blockSize);
              cipher.decryptBlock(words2, offset);
              xorBlock.call(this, words2, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words2, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words2[offset + i] ^= block[i];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words2, offset) {
            this._mode.processBlock(words2, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// ../node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "../node_modules/crypto-js/mode-cfb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words2, offset, blockSize, cipher);
            this._prevBlock = words2.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words2.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words2, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words2, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words2[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  }
});

// ../node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "../node_modules/crypto-js/mode-ctr.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words2[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  }
});

// ../node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "../node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words2[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  }
});

// ../node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "../node_modules/crypto-js/mode-ofb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words2, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words2[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  }
});

// ../node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "../node_modules/crypto-js/mode-ecb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words2, offset) {
            this._cipher.encryptBlock(words2, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words2, offset) {
            this._cipher.decryptBlock(words2, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  }
});

// ../node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "../node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  }
});

// ../node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "../node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  }
});

// ../node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "../node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  }
});

// ../node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "../node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          for (var i = data.sigBytes - 1; i >= 0; i--) {
            if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
              data.sigBytes = i + 1;
              break;
            }
          }
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  }
});

// ../node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "../node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  }
});

// ../node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "../node_modules/crypto-js/format-hex.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(undefined2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex7 = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex7);
          },
          parse: function(input) {
            var ciphertext = Hex7.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  }
});

// ../node_modules/crypto-js/aes.js
var require_aes = __commonJS({
  "../node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  }
});

// ../node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "../node_modules/crypto-js/tripledes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i = 0; i < 8; i++) {
                f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  }
});

// ../node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "../node_modules/crypto-js/rc4.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) {
              S[i] = i;
            }
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  }
});

// ../node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "../node_modules/crypto-js/rabbit.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV2 = iv.words;
              var IV_0 = IV2[0];
              var IV_1 = IV2[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  }
});

// ../node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "../node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV2 = iv.words;
              var IV_0 = IV2[0];
              var IV_1 = IV2[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  }
});

// ../node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "../node_modules/crypto-js/index.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha33(), require_ripemd160(), require_hmac2(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS;
    });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/okx-dex-quote-source.js
var require_okx_dex_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/okx-dex-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OKXDexQuoteSource = void 0;
    var qs_1 = __importDefault(require_lib23());
    var crypto_js_1 = __importDefault(require_crypto_js());
    var _chains_1 = require_chains();
    var utils_1 = require_utils16();
    var constants_1 = require_constants();
    var utils_2 = require_utils13();
    var SUPPORTED_CHAINS = [
      _chains_1.Chains.ETHEREUM,
      _chains_1.Chains.OPTIMISM,
      _chains_1.Chains.POLYGON,
      _chains_1.Chains.BNB_CHAIN,
      _chains_1.Chains.OKC,
      _chains_1.Chains.AVALANCHE,
      _chains_1.Chains.FANTOM,
      _chains_1.Chains.ARBITRUM,
      _chains_1.Chains.LINEA,
      _chains_1.Chains.BASE
    ];
    var OKX_DEX_METADATA = {
      name: "OKX Dex",
      supports: {
        chains: SUPPORTED_CHAINS.map(({ chainId }) => chainId),
        swapAndTransfer: false,
        buyOrders: false
      },
      logoURI: "ipfs://QmarS9mPPLegvNaazZ8Kqg1gLvkbsvQE2tkdF6uZCvBrFn"
    };
    var OKXDexQuoteSource = class {
      getMetadata() {
        return OKX_DEX_METADATA;
      }
      async quote({ components, request, config: config2 }) {
        const [approvalTargetResponse, quoteResponse] = await Promise.all([
          calculateApprovalTarget({ components, request, config: config2 }),
          calculateQuote({ components, request, config: config2 })
        ]);
        const { data: [{ routerResult: { toTokenAmount }, tx: { minReceiveAmount, to, value, data, gas } }] } = quoteResponse;
        const { data: [{ dexContractAddress: approvalTarget }] } = approvalTargetResponse;
        return {
          sellAmount: request.order.sellAmount,
          maxSellAmount: request.order.sellAmount,
          buyAmount: BigInt(toTokenAmount),
          minBuyAmount: BigInt(minReceiveAmount),
          estimatedGas: BigInt(gas),
          allowanceTarget: approvalTarget,
          type: "sell",
          tx: {
            calldata: data,
            to,
            value: BigInt(value ?? 0)
          }
        };
      }
      isConfigAndContextValid(config2) {
        return !!config2?.apiKey && !!config2?.passphrase && !!config2?.secretKey;
      }
    };
    exports.OKXDexQuoteSource = OKXDexQuoteSource;
    async function calculateApprovalTarget({ components: { fetchService }, request: { chain, sellToken, buyToken, config: { timeout } }, config: config2 }) {
      if ((0, utils_2.isSameAddress)(sellToken, constants_1.Addresses.NATIVE_TOKEN)) {
        return { data: [{ dexContractAddress: constants_1.Addresses.ZERO_ADDRESS }] };
      }
      const queryParams = {
        chainId: chain.chainId,
        tokenContractAddress: sellToken,
        approveAmount: constants_1.Uint.MAX_256
      };
      const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
      const path = `/api/v5/dex/aggregator/approve-transaction?${queryString}`;
      return fetch2({
        sellToken,
        buyToken,
        chain,
        path,
        timeout,
        config: config2,
        fetchService
      });
    }
    async function calculateQuote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom } }, config: config2 }) {
      const queryParams = {
        chainId: chain.chainId,
        amount: order.sellAmount.toString(),
        fromTokenAddress: sellToken,
        toTokenAddress: buyToken,
        slippage: slippagePercentage / 100,
        userWalletAddress: takeFrom,
        referrerAddress: config2.referrer?.address,
        feePercent: config2.referrer?.address ? 0 : void 0
      };
      const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
      const path = `/api/v5/dex/aggregator/swap?${queryString}`;
      return fetch2({
        sellToken,
        buyToken,
        chain,
        path,
        timeout,
        config: config2,
        fetchService
      });
    }
    async function fetch2({ sellToken, buyToken, chain, path, fetchService, config: config2, timeout }) {
      const timestamp = new Date().toISOString();
      const toHash = timestamp + "GET" + path;
      const signed = crypto_js_1.default.HmacSHA256(toHash, config2.secretKey);
      const base64 = signed.toString(crypto_js_1.default.enc.Base64);
      const headers = {
        ["OK-ACCESS-KEY"]: config2.apiKey,
        ["OK-ACCESS-PASSPHRASE"]: config2.passphrase,
        ["OK-ACCESS-TIMESTAMP"]: timestamp,
        ["OK-ACCESS-SIGN"]: base64
      };
      const url = `https://www.okx.com${path}`;
      const response = await fetchService.fetch(url, { timeout, headers });
      if (!response.ok) {
        (0, utils_1.failed)(OKX_DEX_METADATA, chain, sellToken, buyToken, await response.text());
      }
      return response.json();
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/bebop-quote-source.js
var require_bebop_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/bebop-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BebopQuoteSource = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var utils_1 = require_utils13();
    var utils_2 = require_utils16();
    var always_valid_source_1 = require_always_valid_source();
    var NETWORK_KEY = {
      [_chains_1.Chains.ETHEREUM.chainId]: "ethereum",
      [_chains_1.Chains.POLYGON.chainId]: "polygon",
      [_chains_1.Chains.ARBITRUM.chainId]: "arbitrum"
    };
    var BEBOP_METADATA = {
      name: "Bebop",
      supports: {
        chains: Object.keys(NETWORK_KEY).map(Number),
        swapAndTransfer: true,
        buyOrders: true
      },
      logoURI: "ipfs://QmTMusok8SqDoa1MDGgZ3xohrPTnY6j2xxR5jPphBDaUDi"
    };
    var BebopQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return BEBOP_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom, recipient } }, config: config2 }) {
        const queryParams = {
          sell_tokens: [(0, utils_2.checksum)(sellToken)],
          buy_tokens: [(0, utils_2.checksum)(buyToken)],
          sell_amounts: order.type === "sell" ? [order.sellAmount.toString()] : void 0,
          buy_amounts: order.type === "buy" ? [order.buyAmount.toString()] : void 0,
          taker_address: takeFrom,
          receiver_address: recipient && !(0, utils_1.isSameAddress)(recipient, takeFrom) ? recipient : void 0,
          source: config2.referrer?.name,
          skip_validation: config2.disableValidation,
          gasless: false
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `https://api.bebop.xyz/${NETWORK_KEY[chain.chainId]}/v2/quote?${queryString}`;
        const response = await fetchService.fetch(url, { timeout });
        if (!response.ok) {
          (0, utils_2.failed)(BEBOP_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const { toSign: { taker_amounts, maker_amounts }, approvalTarget, tx: { to, value, data, gas } } = await response.json();
        const quote = {
          sellAmount: BigInt(taker_amounts[0]),
          buyAmount: BigInt(maker_amounts[0]),
          estimatedGas: BigInt(gas),
          allowanceTarget: (0, utils_2.calculateAllowanceTarget)(sellToken, approvalTarget),
          tx: {
            calldata: data,
            to,
            value: BigInt(value ?? 0)
          }
        };
        return (0, utils_2.addQuoteSlippage)(quote, order.type, slippagePercentage);
      }
    };
    exports.BebopQuoteSource = BebopQuoteSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/xy-finance-quote-source.js
var require_xy_finance_quote_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/xy-finance-quote-source.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XYFinanceQuoteSource = void 0;
    var qs_1 = __importDefault(require_lib23());
    var _chains_1 = require_chains();
    var utils_1 = require_utils16();
    var always_valid_source_1 = require_always_valid_source();
    var SUPPORTED_CHAINS = [
      _chains_1.Chains.ETHEREUM,
      _chains_1.Chains.BNB_CHAIN,
      _chains_1.Chains.POLYGON,
      _chains_1.Chains.FANTOM,
      _chains_1.Chains.CRONOS,
      _chains_1.Chains.AVALANCHE,
      _chains_1.Chains.ARBITRUM,
      _chains_1.Chains.OPTIMISM,
      _chains_1.Chains.ASTAR,
      _chains_1.Chains.MOONRIVER,
      _chains_1.Chains.KLAYTN,
      _chains_1.Chains.POLYGON_ZKEVM,
      _chains_1.Chains.LINEA,
      _chains_1.Chains.BASE
    ];
    var XY_FINANCE_METADATA = {
      name: "XY Finance",
      supports: {
        chains: SUPPORTED_CHAINS.map(({ chainId }) => chainId),
        swapAndTransfer: true,
        buyOrders: false
      },
      logoURI: "ipfs://Qmeuf9xMFE66UBeBNb9SneyyqSNAhsiNXiHES1vCvpyrFS"
    };
    var XYFinanceQuoteSource = class extends always_valid_source_1.AlwaysValidConfigAndContextSource {
      getMetadata() {
        return XY_FINANCE_METADATA;
      }
      async quote({ components: { fetchService }, request: { chain, sellToken, buyToken, order, config: { slippagePercentage, timeout }, accounts: { takeFrom, recipient } }, config: config2 }) {
        const queryParams = {
          srcChainId: chain.chainId,
          srcQuoteTokenAddress: sellToken,
          srcQuoteTokenAmount: order.sellAmount.toString(),
          dstChainId: chain.chainId,
          dstQuoteTokenAddress: buyToken,
          slippage: slippagePercentage,
          receiver: recipient ?? takeFrom,
          affiliate: config2.referrer?.address,
          srcSwapProvider: "XY DexAggregator"
        };
        const queryString = qs_1.default.stringify(queryParams, { skipNulls: true, arrayFormat: "comma" });
        const url = `https://aggregator-api.xy.finance/v1/buildTx?${queryString}`;
        const response = await fetchService.fetch(url, { timeout });
        if (!response.ok) {
          (0, utils_1.failed)(XY_FINANCE_METADATA, chain, sellToken, buyToken, await response.text());
        }
        const result = await response.json();
        const { route: { dstQuoteTokenAmount, minReceiveAmount, contractAddress, estimatedGas }, tx: { to, data, value } } = result;
        return {
          sellAmount: order.sellAmount,
          maxSellAmount: order.sellAmount,
          buyAmount: BigInt(dstQuoteTokenAmount),
          minBuyAmount: BigInt(minReceiveAmount),
          estimatedGas: estimatedGas ?? BigInt(estimatedGas),
          allowanceTarget: (0, utils_1.calculateAllowanceTarget)(sellToken, contractAddress),
          type: "sell",
          tx: {
            calldata: data,
            to,
            value: BigInt(value ?? 0)
          }
        };
      }
    };
    exports.XYFinanceQuoteSource = XYFinanceQuoteSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/source-registry.js
var require_source_registry = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/source-registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SOURCES_METADATA = exports.QUOTE_SOURCES = void 0;
    var odos_quote_source_1 = require_odos_quote_source();
    var paraswap_quote_source_1 = require_paraswap_quote_source();
    var _0x_quote_source_1 = require_x_quote_source();
    var _1inch_quote_source_1 = require_inch_quote_source();
    var uniswap_quote_source_1 = require_uniswap_quote_source();
    var open_ocean_quote_source_1 = require_open_ocean_quote_source();
    var li_fi_quote_source_1 = require_li_fi_quote_source();
    var kyberswap_quote_source_1 = require_kyberswap_quote_source();
    var firebird_quote_source_1 = require_firebird_quote_source();
    var rango_quote_source_1 = require_rango_quote_source();
    var changelly_quote_source_1 = require_changelly_quote_source();
    var mean_finance_quote_source_1 = require_mean_finance_quote_source();
    var wido_quote_source_1 = require_wido_quote_source();
    var portals_fi_quote_source_1 = require_portals_fi_quote_source();
    var okx_dex_quote_source_1 = require_okx_dex_quote_source();
    var bebop_quote_source_1 = require_bebop_quote_source();
    var xy_finance_quote_source_1 = require_xy_finance_quote_source();
    exports.QUOTE_SOURCES = {
      bebop: new bebop_quote_source_1.BebopQuoteSource(),
      paraswap: new paraswap_quote_source_1.ParaswapQuoteSource(),
      "xy-finance": new xy_finance_quote_source_1.XYFinanceQuoteSource(),
      "0x": new _0x_quote_source_1.ZRXQuoteSource(),
      "1inch": new _1inch_quote_source_1.OneInchQuoteSource(),
      uniswap: new uniswap_quote_source_1.UniswapQuoteSource(),
      "open-ocean": new open_ocean_quote_source_1.OpenOceanQuoteSource(),
      "li-fi": new li_fi_quote_source_1.LiFiQuoteSource(),
      kyberswap: new kyberswap_quote_source_1.KyberswapQuoteSource(),
      odos: new odos_quote_source_1.OdosQuoteSource(),
      firebird: new firebird_quote_source_1.FirebirdQuoteSource(),
      rango: new rango_quote_source_1.RangoQuoteSource(),
      changelly: new changelly_quote_source_1.ChangellyQuoteSource(),
      "mean-finance": new mean_finance_quote_source_1.MeanFinanceQuoteSource(),
      wido: new wido_quote_source_1.WidoQuoteSource(),
      "portals-fi": new portals_fi_quote_source_1.PortalsFiQuoteSource(),
      "okx-dex": new okx_dex_quote_source_1.OKXDexQuoteSource()
    };
    exports.SOURCES_METADATA = Object.fromEntries(Object.entries(exports.QUOTE_SOURCES).map(([sourceId, source]) => [sourceId, source.getMetadata()]));
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/triggerable-promise.js
var require_triggerable_promise = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/triggerable-promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TriggerablePromise = void 0;
    var TriggerablePromise = class {
      constructor(trigger) {
        this.trigger = trigger;
      }
      request() {
        if (!this.promise) {
          this.promise = this.trigger();
        }
        return this.promise;
      }
    };
    exports.TriggerablePromise = TriggerablePromise;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/wrappers/buy-to-sell-order-wrapper.js
var require_buy_to_sell_order_wrapper = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/wrappers/buy-to-sell-order-wrapper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buyToSellOrderWrapper = void 0;
    var triggerable_promise_1 = require_triggerable_promise();
    function buyToSellOrderWrapper(source) {
      return {
        getMetadata: () => {
          const { supports: originalSupport, ...originalMetadata } = source.getMetadata();
          return {
            ...originalMetadata,
            supports: {
              ...originalSupport,
              buyOrders: true
            }
          };
        },
        quote: ({ components, request, config: config2 }) => {
          if (request.order.type === "sell") {
            return source.quote({ components, request, config: config2 });
          } else {
            return executeBuyOrderAsSellOrder(request, (request2) => source.quote({ components, request: request2, config: config2 }));
          }
        },
        isConfigAndContextValid: (config2) => {
          return source.isConfigAndContextValid(config2);
        }
      };
    }
    exports.buyToSellOrderWrapper = buyToSellOrderWrapper;
    async function executeBuyOrderAsSellOrder(request, quote) {
      if (request.order.type === "sell") {
        throw new Error("We should not be able to get here");
      }
      const sellOrder = {
        ...request,
        order: { type: "sell", sellAmount: request.order.buyAmount },
        sellToken: request.buyToken,
        buyToken: request.sellToken,
        external: {
          gasPrice: request.external.gasPrice,
          tokenData: new triggerable_promise_1.TriggerablePromise(() => request.external.tokenData.request().then(({ sellToken, buyToken }) => ({ sellToken: buyToken, buyToken: sellToken })))
        }
      };
      const testSellQuote = await quote(sellOrder);
      return quote({ ...request, order: { type: "sell", sellAmount: testSellQuote.buyAmount } });
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/wrappers/forced-timeout-wrapper.js
var require_forced_timeout_wrapper = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-sources/wrappers/forced-timeout-wrapper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forcedTimeoutWrapper = void 0;
    var timeouts_1 = require_timeouts();
    function forcedTimeoutWrapper(source) {
      return {
        getMetadata: () => source.getMetadata(),
        quote: ({ components, request, config: config2 }) => {
          const description = `Quote ${request.sellToken} => ${request.buyToken} on ${request.chain.name} for source ${source.getMetadata().name}`;
          return (0, timeouts_1.timeoutPromise)(source.quote({ components, request, config: config2 }), request.config.timeout, { description });
        },
        isConfigAndContextValid: (config2) => {
          return source.isConfigAndContextValid(config2);
        }
      };
    }
    exports.forcedTimeoutWrapper = forcedTimeoutWrapper;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/source-lists/local-source-list.js
var require_local_source_list = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/source-lists/local-source-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LocalSourceList = void 0;
    var _chains_1 = require_chains();
    var source_registry_1 = require_source_registry();
    var buy_to_sell_order_wrapper_1 = require_buy_to_sell_order_wrapper();
    var forced_timeout_wrapper_1 = require_forced_timeout_wrapper();
    var errors_1 = require_errors3();
    var LocalSourceList = class {
      constructor({ providerService, fetchService }) {
        this.sources = source_registry_1.QUOTE_SOURCES;
        this.providerService = providerService;
        this.fetchService = fetchService;
      }
      supportedSources() {
        const entries = Object.entries(this.sources).map(([sourceId, source]) => [sourceId, source.getMetadata()]);
        return Object.fromEntries(entries);
      }
      async getQuote(request) {
        if (!(request.sourceId in this.sources)) {
          throw new errors_1.SourceNotFoundError(request.sourceId);
        }
        const sourceRequest = mapRequestToSourceRequest(request);
        const source = this.getSourceForRequest(request);
        const config2 = request.sourceConfig;
        if (!source.isConfigAndContextValid(config2)) {
          throw new errors_1.SourceInvalidConfigOrContextError(request.sourceId);
        }
        const response = await source.quote({
          components: { providerService: this.providerService, fetchService: this.fetchService },
          config: config2,
          request: sourceRequest
        });
        return mapSourceResponseToResponse({ request, source, response });
      }
      getSourceForRequest(request) {
        let source = this.sources[request.sourceId];
        if (request.order.type === "buy" && !source.getMetadata().supports.buyOrders) {
          if (request.estimateBuyOrdersWithSellOnlySources) {
            source = (0, buy_to_sell_order_wrapper_1.buyToSellOrderWrapper)(source);
          } else {
            throw new errors_1.SourceNoBuyOrdersError(request.sourceId);
          }
        }
        return (0, forced_timeout_wrapper_1.forcedTimeoutWrapper)(source);
      }
    };
    exports.LocalSourceList = LocalSourceList;
    async function mapSourceResponseToResponse({ source, request, response }) {
      const tx = {
        to: response.tx.to,
        value: response.tx.value?.toString(),
        data: response.tx.calldata,
        from: request.takerAddress
      };
      const recipient = request.recipient && source.getMetadata().supports.swapAndTransfer ? request.recipient : request.takerAddress;
      return {
        sellAmount: response.sellAmount.toString(),
        buyAmount: response.buyAmount.toString(),
        maxSellAmount: response.maxSellAmount.toString(),
        minBuyAmount: response.minBuyAmount.toString(),
        estimatedGas: response.estimatedGas?.toString(),
        recipient,
        source: {
          id: request.sourceId,
          allowanceTarget: response.allowanceTarget,
          name: source.getMetadata().name,
          logoURI: source.getMetadata().logoURI,
          customData: response.customData
        },
        type: response.type,
        tx
      };
    }
    function mapOrderToBigNumber(request) {
      return request.order.type === "sell" ? { type: "sell", sellAmount: BigInt(request.order.sellAmount) } : { type: "buy", buyAmount: BigInt(request.order.buyAmount) };
    }
    function mapRequestToSourceRequest(request) {
      return {
        chain: (0, _chains_1.getChainByKeyOrFail)(request.chainId),
        sellToken: request.sellToken,
        buyToken: request.buyToken,
        order: mapOrderToBigNumber(request),
        config: {
          slippagePercentage: request.slippagePercentage,
          txValidFor: request.txValidFor,
          timeout: request.quoteTimeout
        },
        accounts: {
          takeFrom: request.takerAddress,
          recipient: request.recipient
        },
        external: request.external
      };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-compare.js
var require_quote_compare = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-compare.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compareQuotesBy = exports.chooseQuotesBy = exports.sortQuotesBy = exports.COMPARE_USING = exports.COMPARE_BY = void 0;
    var utils_1 = require_utils13();
    exports.COMPARE_BY = [
      "least-gas",
      "most-swapped",
      "most-swapped-accounting-for-gas"
    ];
    exports.COMPARE_USING = ["sell/buy amounts", "max sell/min buy amounts"];
    function sortQuotesBy(quotes, sortBy, using) {
      const compareFtn = getCompareFtn(sortBy);
      return quotes.sort((q1, q2) => compareFtn(q1, q2, using));
    }
    exports.sortQuotesBy = sortQuotesBy;
    function chooseQuotesBy(quotes, sortBy, using) {
      if (quotes.length === 0)
        throw new Error(`There are no quotes to choose from`);
      const compareFtn = getCompareFtn(sortBy);
      return quotes.reduce((q1, q2) => compareFtn(q1, q2, using) <= 0 ? q1 : q2);
    }
    exports.chooseQuotesBy = chooseQuotesBy;
    function compareQuotesBy(sortBy, using) {
      const compareFtn = getCompareFtn(sortBy);
      return (quote1, quote2) => compareFtn(quote1, quote2, using);
    }
    exports.compareQuotesBy = compareQuotesBy;
    function getCompareFtn(compareBy) {
      let prioritizedCompareFns;
      switch (compareBy) {
        case "most-swapped-accounting-for-gas":
          prioritizedCompareFns = [compareMostProfit, compareByMostSwapped, compareLeastGas];
          break;
        case "most-swapped":
          prioritizedCompareFns = [compareByMostSwapped, compareLeastGas];
          break;
        case "least-gas":
          prioritizedCompareFns = [compareLeastGas, compareMostProfit, compareByMostSwapped];
          break;
      }
      return mergeCompareFtns(prioritizedCompareFns);
    }
    function amountExtractor(using) {
      return using === "sell/buy amounts" ? ({ sellAmount, buyAmount }) => ({ sellAmount, buyAmount }) : ({ maxSellAmount, minBuyAmount }) => ({ sellAmount: maxSellAmount, buyAmount: minBuyAmount });
    }
    function mergeCompareFtns(prioritizedCompareFns) {
      return (quote1, quote2, using) => prioritizedCompareFns.reduce((accumCompareValue, compare) => accumCompareValue || compare(quote1, quote2, using), 0);
    }
    function compareMostProfit(quote1, quote2, using) {
      const [profit1, profit2] = [calculateProfit(quote1, using), calculateProfit(quote2, using)];
      if (!profit1 || !profit2) {
        if (!profit1 && !profit2) {
          return 0;
        } else if (profit1) {
          return -1;
        } else {
          return 1;
        }
      } else if (profit1 === profit2) {
        return 0;
      } else {
        return profit1 > profit2 ? -1 : 1;
      }
    }
    function compareByMostSwapped(quote1, quote2, using) {
      if (!(0, utils_1.isSameAddress)(quote1.sellToken.address, quote2.sellToken.address) || !(0, utils_1.isSameAddress)(quote1.buyToken.address, quote2.buyToken.address)) {
        const [profit1, profit2] = [calculateProfitWithoutGas(quote1, using), calculateProfitWithoutGas(quote2, using)];
        if (!profit1 || !profit2) {
          if (!profit1 && !profit2) {
            return 0;
          } else if (profit1) {
            return -1;
          } else {
            return 1;
          }
        } else if (profit1 === profit2) {
          return 0;
        } else {
          return profit1 > profit2 ? -1 : 1;
        }
      }
      const extract2 = amountExtractor(using);
      const { sellAmount: sellAmount1, buyAmount: buyAmount1 } = extract2(quote1);
      const { sellAmount: sellAmount2, buyAmount: buyAmount2 } = extract2(quote2);
      const quote1BuyAmountRelativeToQuote2 = (0, utils_1.ruleOfThree)({ a: sellAmount1.amount, matchA: buyAmount1.amount, b: sellAmount2.amount });
      if (BigInt(quote1BuyAmountRelativeToQuote2) > BigInt(buyAmount2.amount)) {
        return -1;
      } else if (BigInt(quote1BuyAmountRelativeToQuote2) < BigInt(buyAmount2.amount)) {
        return 1;
      }
      return 0;
    }
    function compareLeastGas(quote1, quote2) {
      if (!quote1.gas || !quote2.gas) {
        if (!quote1.gas && !quote2.gas) {
          return 0;
        } else if (quote1.gas) {
          return -1;
        } else {
          return 1;
        }
      } else if (BigInt(quote1.gas.estimatedGas) < BigInt(quote2.gas.estimatedGas)) {
        return -1;
      } else if (BigInt(quote1.gas.estimatedGas) > BigInt(quote2.gas.estimatedGas)) {
        return 1;
      }
      return 0;
    }
    function calculateProfit(quote, using) {
      const { sellAmount, buyAmount } = amountExtractor(using)(quote);
      const soldUSD = sellAmount.amountInUSD && Number(sellAmount.amountInUSD);
      const boughtUSD = buyAmount.amountInUSD && Number(buyAmount.amountInUSD);
      const gasCostUSD = quote.gas?.estimatedCostInUSD && Number(quote.gas.estimatedCostInUSD);
      return !soldUSD || !boughtUSD || !gasCostUSD ? void 0 : boughtUSD - soldUSD - gasCostUSD;
    }
    function calculateProfitWithoutGas(quote, using) {
      const { sellAmount, buyAmount } = amountExtractor(using)(quote);
      const soldUSD = sellAmount.amountInUSD && Number(sellAmount.amountInUSD);
      const boughtUSD = buyAmount.amountInUSD && Number(buyAmount.amountInUSD);
      return !soldUSD || !boughtUSD ? void 0 : boughtUSD - soldUSD;
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/quote-service.js
var require_quote_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/quote-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calculateGasDetails = exports.toAmountOfToken = exports.ifNotFailed = exports.QuoteService = void 0;
    var quote_compare_1 = require_quote_compare();
    var _chains_1 = require_chains();
    var utils_1 = require_utils13();
    var constants_1 = require_constants();
    var timeouts_1 = require_timeouts();
    var viem_1 = require_cjs2();
    var triggerable_promise_1 = require_triggerable_promise();
    var requirements_and_support_1 = require_requirements_and_support();
    var errors_1 = require_errors3();
    var REQUIREMENTS = {
      requirements: { symbol: "required", decimals: "required" },
      default: "can ignore"
    };
    var QuoteService = class {
      constructor({ priceService, gasService, metadataService, sourceList, defaultConfig }) {
        this.priceService = priceService;
        this.gasService = gasService;
        this.metadataService = metadataService;
        this.sourceList = sourceList;
        this.defaultConfig = defaultConfig;
      }
      supportedSources() {
        const filterOutUnsupportedChains = this.metadataChainFilter();
        const entries = Object.entries(this.sourceList.supportedSources()).map(([sourceId, metadata]) => [
          sourceId,
          filterOutUnsupportedChains(metadata)
        ]);
        return Object.fromEntries(entries);
      }
      supportedChains() {
        const allChains = Object.values(this.supportedSources()).map(({ supports: { chains } }) => chains);
        return (0, _chains_1.chainsUnion)(allChains);
      }
      supportedSourcesInChain({ chainId }) {
        const sourcesInChain = Object.entries(this.supportedSources()).filter(([, source]) => source.supports.chains.includes(chainId));
        return Object.fromEntries(sourcesInChain);
      }
      supportedGasSpeeds() {
        return this.gasService.supportedSpeeds();
      }
      async getQuote({ sourceId, request, config: config2 }) {
        const sources = this.supportedSources();
        if (!(sourceId in sources)) {
          throw new errors_1.SourceNotFoundError(sourceId);
        }
        const sourceSupport = sources[sourceId].supports;
        const supportedChains = sourceSupport.chains.map((chainId) => chainId);
        if (!supportedChains.includes(request.chainId)) {
          throw new errors_1.SourceNotOnChainError(sourceId, request.chainId);
        }
        const shouldFailBecauseTransferNotSupported = !sourceSupport.swapAndTransfer && !!request.recipient && !(0, utils_1.isSameAddress)(request.takerAddress, request.recipient) && !request.dontFailIfSourceDoesNotSupportTransferAndRecipientIsSet;
        if (shouldFailBecauseTransferNotSupported) {
          throw new errors_1.SourceNoSwapAndTransferError(sourceId);
        }
        const shouldFailBecauseBuyOrderNotSupported = !sourceSupport.buyOrders && request.order.type === "buy" && !request.estimateBuyOrderIfSourceDoesNotSupportIt;
        if (shouldFailBecauseBuyOrderNotSupported) {
          throw new errors_1.SourceNoBuyOrdersError(sourceId);
        }
        const quotes = this.getQuotes({
          request: {
            ...request,
            includeNonTransferSourcesWhenRecipientIsSet: true,
            estimateBuyOrdersWithSellOnlySources: true,
            filters: { includeSources: [sourceId] },
            sourceConfig: {
              global: request.sourceConfig?.global,
              custom: request.sourceConfig?.custom && { [sourceId]: request.sourceConfig.custom }
            }
          },
          config: config2
        });
        if (quotes.length !== 1) {
          throw new Error("This is weird, not sure what happened");
        }
        const quote = await quotes[0];
        if ("failed" in quote) {
          throw new errors_1.FailedToGenerateQuoteError(quote.source.name, request.chainId, request.sellToken, request.buyToken, quote.error);
        }
        return quote;
      }
      estimateQuotes({ request, config: config2 }) {
        const quotes = this.getQuotes({ request: estimatedToQuoteRequest(request), config: config2 });
        return quotes.map((promise) => promise.then((response) => ifNotFailed(response, quoteResponseToEstimated)));
      }
      async estimateAllQuotes({ request, config: config2 }) {
        const allResponses = await this.getAllQuotes({ request: estimatedToQuoteRequest(request), config: config2 });
        return allResponses.map((response) => ifNotFailed(response, quoteResponseToEstimated));
      }
      getQuotes({ request, config: config2 }) {
        const { promises, external } = this.calculateExternalPromises(request, config2);
        const sources = this.calculateSources(request);
        return sources.map((sourceId) => ({
          sourceId,
          response: this.sourceList.getQuote({
            ...request,
            sourceId,
            sourceConfig: this.calculateConfig(sourceId, request.sourceConfig),
            external,
            quoteTimeout: config2?.timeout
          })
        })).map(({ sourceId, response }) => this.listResponseToQuoteResponse({ sourceId, request, response, promises }));
      }
      async getAllQuotes({ request, config: config2 }) {
        const responses = await Promise.all(this.getQuotes({ request, config: config2 }));
        const successfulQuotes = responses.filter((response) => !("failed" in response));
        const failedQuotes = config2?.ignoredFailed === false ? responses.filter((response) => "failed" in response) : [];
        const sortedQuotes = (0, quote_compare_1.sortQuotesBy)(successfulQuotes, config2?.sort?.by ?? "most-swapped-accounting-for-gas", config2?.sort?.using ?? "sell/buy amounts");
        return [...sortedQuotes, ...failedQuotes];
      }
      async getBestQuote({ request, config: config2 }) {
        const allQuotes = await this.getAllQuotes({
          request,
          config: {
            timeout: config2?.timeout,
            sort: config2?.choose,
            ignoredFailed: true
          }
        });
        if (allQuotes.length === 0) {
          throw new errors_1.FailedToGenerateAnyQuotesError(request.chainId, request.sellToken, request.buyToken);
        }
        return allQuotes[0];
      }
      async listResponseToQuoteResponse({ sourceId, request, response: responsePromise, promises }) {
        try {
          const [response, tokens, prices, gasCalculator] = await Promise.all([
            responsePromise,
            promises.tokens,
            promises.prices,
            promises.gasCalculator
          ]);
          const sellToken = { ...tokens[request.sellToken], price: prices?.[request.sellToken]?.price };
          const buyToken = { ...tokens[request.buyToken], price: prices?.[request.buyToken]?.price };
          let gas;
          if (response.estimatedGas) {
            const gasCost = gasCalculator.calculateGasCost({ gasEstimation: response.estimatedGas, tx: response.tx });
            const { gasCostNativeToken, ...gasPrice } = gasCost[request.gasSpeed?.speed ?? "standard"] ?? gasCost["standard"];
            gas = {
              estimatedGas: response.estimatedGas,
              ...calculateGasDetails((0, _chains_1.getChainByKeyOrFail)(request.chainId).nativeCurrency.symbol, gasCostNativeToken, prices[constants_1.Addresses.NATIVE_TOKEN].price)
            };
          }
          return {
            ...response,
            sellToken: { ...sellToken, address: request.sellToken },
            buyToken: { ...buyToken, address: request.buyToken },
            sellAmount: toAmountOfToken(sellToken, sellToken.price, response.sellAmount),
            buyAmount: toAmountOfToken(buyToken, buyToken.price, response.buyAmount),
            maxSellAmount: toAmountOfToken(sellToken, sellToken.price, response.maxSellAmount),
            minBuyAmount: toAmountOfToken(buyToken, buyToken.price, response.minBuyAmount),
            gas
          };
        } catch (e) {
          const metadata = this.supportedSources()[sourceId];
          return {
            failed: true,
            source: {
              id: sourceId,
              name: metadata.name,
              logoURI: metadata.logoURI
            },
            error: e instanceof Error ? e.message : JSON.stringify(e)
          };
        }
      }
      calculateSources({ filters, includeNonTransferSourcesWhenRecipientIsSet, estimateBuyOrdersWithSellOnlySources, ...request }) {
        const sourcesInChain = this.supportedSourcesInChain(request);
        let sourceIds = Object.keys(sourcesInChain);
        if (filters?.includeSources) {
          sourceIds = sourceIds.filter((id4) => filters.includeSources.includes(id4));
        } else if (filters?.excludeSources) {
          sourceIds = sourceIds.filter((id4) => !filters.excludeSources.includes(id4));
        }
        if (request.order.type === "buy" && !estimateBuyOrdersWithSellOnlySources) {
          sourceIds = sourceIds.filter((sourceIds2) => sourcesInChain[sourceIds2].supports.buyOrders);
        }
        if (request.recipient && request.recipient !== request.takerAddress && !includeNonTransferSourcesWhenRecipientIsSet) {
          sourceIds = sourceIds.filter((sourceIds2) => sourcesInChain[sourceIds2].supports.swapAndTransfer);
        }
        return sourceIds;
      }
      calculateExternalPromises(request, config2) {
        const reducedTimeout = (0, timeouts_1.reduceTimeout)(config2?.timeout, "200");
        const selectedGasSpeed = request.gasSpeed?.speed ?? "standard";
        const tokens = this.metadataService.getMetadataForChain({
          chainId: request.chainId,
          addresses: [request.sellToken, request.buyToken],
          config: {
            timeout: reducedTimeout,
            fields: REQUIREMENTS
          }
        }).catch(() => Promise.reject(new Error(`Failed to fetch the quote's tokens`)));
        const emptyPriceResult = { price: 0, closestTimestamp: 0 };
        const prices = this.priceService.getCurrentPricesForChain({
          chainId: request.chainId,
          addresses: [request.sellToken, request.buyToken, constants_1.Addresses.NATIVE_TOKEN],
          config: { timeout: reducedTimeout }
        }).catch(() => ({
          [request.sellToken]: emptyPriceResult,
          [request.buyToken]: emptyPriceResult,
          [constants_1.Addresses.NATIVE_TOKEN]: emptyPriceResult
        }));
        const gasCalculator = this.gasService.getQuickGasCalculator({
          chainId: request.chainId,
          config: {
            timeout: reducedTimeout,
            fields: {
              requirements: {
                [selectedGasSpeed]: request.gasSpeed?.requirement ?? "best effort",
                standard: "required"
              },
              default: "can ignore"
            }
          }
        }).catch(() => Promise.reject(new Error(`Failed to fetch gas data`)));
        return {
          promises: { tokens, prices, gasCalculator },
          external: {
            tokenData: new triggerable_promise_1.TriggerablePromise(() => tokens.then((tokens2) => ({ sellToken: tokens2[request.sellToken], buyToken: tokens2[request.buyToken] }))),
            gasPrice: new triggerable_promise_1.TriggerablePromise(() => gasCalculator.then((calculator) => {
              const gasPrice = calculator.getGasPrice();
              return gasPrice[selectedGasSpeed] ?? gasPrice["standard"];
            }))
          }
        };
      }
      metadataChainFilter() {
        const tokenProperties = this.metadataService.supportedProperties();
        return (metadata) => ({
          ...metadata,
          supports: {
            ...metadata.supports,
            chains: metadata.supports.chains.filter((chainId) => (0, requirements_and_support_1.couldSupportMeetRequirements)(tokenProperties[chainId], REQUIREMENTS))
          }
        });
      }
      calculateConfig(sourceId, sourceConfigs) {
        const id4 = sourceId;
        return {
          ...this.defaultConfig?.global,
          ...this.defaultConfig?.custom?.[id4],
          ...sourceConfigs?.global,
          ...sourceConfigs?.custom?.[id4]
        };
      }
    };
    exports.QuoteService = QuoteService;
    function ifNotFailed(response, mapped) {
      return "failed" in response ? response : mapped(response);
    }
    exports.ifNotFailed = ifNotFailed;
    function toAmountOfToken(token2, price, amount) {
      const amountInUSD = (0, utils_1.amountToUSD)(token2.decimals, amount, price);
      return {
        amount: amount.toString(),
        amountInUnits: (0, viem_1.formatUnits)(BigInt(amount), token2.decimals),
        amountInUSD
      };
    }
    exports.toAmountOfToken = toAmountOfToken;
    function estimatedToQuoteRequest(request) {
      return {
        ...request,
        takerAddress: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"
      };
    }
    function quoteResponseToEstimated({ recipient, tx, ...response }) {
      return response;
    }
    function calculateGasDetails(gasTokenSymbol, gasCostNativeToken, nativeTokenPrice) {
      return {
        estimatedCost: gasCostNativeToken.toString(),
        estimatedCostInUnits: (0, viem_1.formatUnits)(BigInt(gasCostNativeToken), 18).toString(),
        estimatedCostInUSD: (0, utils_1.amountToUSD)(18, gasCostNativeToken, nativeTokenPrice),
        gasTokenPrice: nativeTokenPrice,
        gasTokenSymbol
      };
    }
    exports.calculateGasDetails = calculateGasDetails;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/source-lists/overridable-source-list.js
var require_overridable_source_list = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/source-lists/overridable-source-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OverridableSourceList = void 0;
    var OverridableSourceList = class {
      constructor({ default: defaultSourceList, overrides }) {
        this.defaultSourceList = defaultSourceList;
        this.overrides = {};
        for (const { list, sourceIds } of overrides) {
          for (const sourceId of sourceIds) {
            if (sourceId in this.overrides) {
              throw new Error(`Source with id ${sourceId} was assigned twice`);
            }
            this.overrides[sourceId] = list;
          }
        }
      }
      supportedSources() {
        const sources = this.defaultSourceList.supportedSources();
        for (const [sourceId, sourceList] of Object.entries(this.overrides)) {
          sources[sourceId] = sourceList.supportedSources()[sourceId];
        }
        return sources;
      }
      getQuote(request) {
        return this.getSourceListForId(request.sourceId).getQuote(request);
      }
      getSourceListForId(sourceId) {
        return this.overrides[sourceId] ?? this.defaultSourceList;
      }
    };
    exports.OverridableSourceList = OverridableSourceList;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/source-lists/api-source-list.js
var require_api_source_list = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/source-lists/api-source-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.APISourceList = void 0;
    var timeouts_1 = require_timeouts();
    var APISourceList = class {
      constructor({ fetchService, baseUri, sources }) {
        this.fetchService = fetchService;
        this.baseUri = baseUri;
        this.sources = sources;
      }
      supportedSources() {
        return this.sources;
      }
      async getQuote(request) {
        const reducedTimeout = (0, timeouts_1.reduceTimeout)(request.quoteTimeout, "100");
        const uri = this.baseUri(request);
        const response = await this.fetchService.fetch(uri, {
          method: "POST",
          body: JSON.stringify({
            ...request,
            quoteTimeout: reducedTimeout
          }),
          timeout: request.quoteTimeout
        });
        return response.json();
      }
    };
    exports.APISourceList = APISourceList;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/quote-builder.js
var require_quote_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/quote-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildQuoteService = void 0;
    var local_source_list_1 = require_local_source_list();
    var quote_service_1 = require_quote_service();
    var overridable_source_list_1 = require_overridable_source_list();
    var api_source_list_1 = require_api_source_list();
    function buildQuoteService(params, providerService, fetchService, gasService, metadataService, priceService) {
      const sourceList = buildList(params?.sourceList, { providerService, fetchService });
      return new quote_service_1.QuoteService({
        priceService,
        gasService,
        metadataService,
        sourceList,
        defaultConfig: {
          global: addReferrerIfNotSet(params?.defaultConfig?.global),
          custom: params?.defaultConfig?.custom
        }
      });
    }
    exports.buildQuoteService = buildQuoteService;
    function buildList(list, { providerService, fetchService }) {
      switch (list?.type) {
        case "custom":
          return list.instance;
        case "local":
        case void 0:
          return new local_source_list_1.LocalSourceList({
            providerService,
            fetchService
          });
        case "api":
          return new api_source_list_1.APISourceList({ fetchService, ...list });
        case "overridable-source-list":
          const defaultList = buildList(list.lists.default, { providerService, fetchService });
          const overrides = list.lists.overrides.map(({ list: list2, sourceIds }) => ({
            list: buildList(list2, { providerService, fetchService }),
            sourceIds
          }));
          return new overridable_source_list_1.OverridableSourceList({ default: defaultList, overrides });
      }
    }
    function addReferrerIfNotSet(config2) {
      return { referrer: { address: "0x1a00e1E311009E56e3b0B9Ed6F86f5Ce128a1C01", name: "MeanFinance" }, ...config2 };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/base/single-chain-base-balance-source.js
var require_single_chain_base_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/base/single-chain-base-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleChainBaseBalanceSource = void 0;
    var constants_1 = require_constants();
    var utils_1 = require_utils13();
    var timeouts_1 = require_timeouts();
    var SingleChainBaseBalanceSource = class {
      async getBalancesForTokens({ tokens, config: config2 }) {
        const promises = Object.entries(tokens).map(async ([chainId, tokens2]) => [
          parseInt(chainId),
          await (0, timeouts_1.timeoutPromise)(this.fetchBalancesInChain(Number(chainId), tokens2), config2?.timeout, { reduceBy: "100" })
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
      }
      async getTokensHeldByAccounts({ accounts, config: config2 }) {
        const support = this.supportedQueries();
        for (const chainId in accounts) {
          if (!support[chainId]?.getTokensHeldByAccount) {
            return Promise.reject(new Error("Operation not supported"));
          }
        }
        const promises = Object.entries(accounts).map(async ([chainId, accounts2]) => [
          chainId,
          await (0, timeouts_1.timeoutPromise)(this.fetchTokensHeldByAccountsInChain(Number(chainId), accounts2, config2), config2?.timeout, { reduceBy: "100" })
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
      }
      async fetchBalancesInChain(chainId, tokens, config2) {
        const accountsToFetchNativeToken = [];
        const tokensWithoutNativeToken = {};
        for (const [account, addresses] of Object.entries(tokens)) {
          const addressesWithoutNativeToken = addresses.filter((address) => !(0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN));
          if (addressesWithoutNativeToken.length > 0)
            tokensWithoutNativeToken[account] = addressesWithoutNativeToken;
          if (addresses.length > addressesWithoutNativeToken.length)
            accountsToFetchNativeToken.push(account);
        }
        const erc20Promise = Object.keys(tokensWithoutNativeToken).length > 0 ? this.fetchERC20BalancesForAccountsInChain(chainId, tokensWithoutNativeToken, config2) : Promise.resolve({});
        const nativePromise = accountsToFetchNativeToken.length > 0 ? this.fetchNativeBalancesInChain(chainId, accountsToFetchNativeToken) : Promise.resolve({});
        const [erc20Result, nativeResult] = await Promise.all([erc20Promise, nativePromise]);
        const result = {};
        for (const account in tokens) {
          const lowercasedEntries = Object.entries(erc20Result[account] ?? {}).filter(([, balance]) => isValidBalance(balance)).map(([address, balance]) => [address.toLowerCase(), balance]);
          const lowercased = Object.fromEntries(lowercasedEntries);
          for (const token2 of tokensWithoutNativeToken[account] ?? []) {
            const balance = lowercased[token2.toLowerCase()];
            if (balance) {
              if (!(account in result))
                result[account] = {};
              result[account][token2] = balance;
            }
          }
          if (isValidBalance(nativeResult[account])) {
            const nativeAddressUsed = tokens[account].find((address) => (0, utils_1.isSameAddress)(constants_1.Addresses.NATIVE_TOKEN, address));
            if (!(account in result))
              result[account] = {};
            result[account][nativeAddressUsed] = nativeResult[account];
          }
        }
        return result;
      }
      async fetchTokensHeldByAccountsInChain(chainId, accounts, config2) {
        const erc20Promise = this.fetchERC20TokensHeldByAccountsInChain(chainId, accounts, config2);
        const nativePromise = this.fetchNativeBalancesInChain(chainId, accounts);
        const [erc20Result, nativeResult] = await Promise.all([erc20Promise, nativePromise]);
        const result = {};
        for (const account of accounts) {
          const entries = Object.entries(erc20Result[account]).filter(([, balance]) => isValidBalanceAndNonZero(balance));
          result[account] = Object.fromEntries(entries);
          if (isValidBalanceAndNonZero(nativeResult[account])) {
            result[account][constants_1.Addresses.NATIVE_TOKEN] = nativeResult[account];
          }
        }
        return result;
      }
    };
    exports.SingleChainBaseBalanceSource = SingleChainBaseBalanceSource;
    function isValidBalance(text) {
      return typeof toBigInt(text) === "bigint";
    }
    function isValidBalanceAndNonZero(text) {
      const bn = toBigInt(text);
      return typeof bn === "bigint" && bn > 0n;
    }
    function toBigInt(text) {
      try {
        if (text) {
          return BigInt(text);
        }
      } catch {
      }
      return void 0;
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/rpc-balance-source.js
var require_rpc_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/rpc-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RPCBalanceSource = void 0;
    var _chains_1 = require_chains();
    var single_chain_base_balance_source_1 = require_single_chain_base_balance_source();
    var erc20_1 = require_erc20();
    var RPCBalanceSource = class extends single_chain_base_balance_source_1.SingleChainBaseBalanceSource {
      constructor(providerService, multicallService) {
        super();
        this.providerService = providerService;
        this.multicallService = multicallService;
      }
      supportedQueries() {
        const supportedChains = (0, _chains_1.chainsIntersection)(this.providerService.supportedChains(), this.multicallService.supportedChains());
        const entries = supportedChains.map((chainId) => [chainId, { getBalancesForTokens: true, getTokensHeldByAccount: false }]);
        return Object.fromEntries(entries);
      }
      fetchERC20TokensHeldByAccountsInChain(chainId, accounts, config2) {
        throw new Error("Operation not supported");
      }
      async fetchERC20BalancesForAccountsInChain(chainId, accounts, config2) {
        const pairs = Object.entries(accounts).flatMap(([account, tokens]) => tokens.map((token2) => ({ account, token: token2 })));
        const calls = pairs.map(({ account, token: token2 }) => ({
          address: token2,
          abi: { humanReadable: erc20_1.ERC20_ABI },
          functionName: "balanceOf",
          args: [account]
        }));
        const multicallResults = await this.multicallService.tryReadOnlyMulticall({ chainId, calls });
        const result = {};
        for (let i = 0; i < pairs.length; i++) {
          const multicallResult = multicallResults[i];
          if (multicallResult.status === "failure")
            continue;
          const { account, token: token2 } = pairs[i];
          if (!(account in result))
            result[account] = {};
          result[account][token2] = multicallResult.result.toString();
        }
        return result;
      }
      async fetchNativeBalancesInChain(chainId, accounts, config2) {
        const entries = accounts.map(async (account) => [account, await this.fetchNativeBalanceInChain(chainId, account)]);
        return Object.fromEntries(await Promise.all(entries));
      }
      fetchNativeBalanceInChain(chainId, account) {
        const viemSupported = this.providerService.supportedClients()[chainId]?.viem;
        return viemSupported ? this.providerService.getViemPublicClient({ chainId }).getBalance({ address: account, blockTag: "latest" }).then((balance) => balance.toString()) : this.providerService.getEthersProvider({ chainId }).getBalance(account).then((balance) => balance.toString());
      }
    };
    exports.RPCBalanceSource = RPCBalanceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-service.js
var require_balance_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BalanceService = void 0;
    var timeouts_1 = require_timeouts();
    var BalanceService = class {
      constructor(source) {
        this.source = source;
      }
      supportedChains() {
        return Object.entries(this.supportedQueries()).filter(([, support]) => support.getBalancesForTokens || support.getBalancesForTokens).map(([chainId]) => Number(chainId));
      }
      supportedQueries() {
        return this.source.supportedQueries();
      }
      async getTokensHeldByAccount({ account, chains, config: config2 }) {
        const entries = chains.map((chainId) => [chainId, [account]]);
        const accounts = Object.fromEntries(entries);
        const resultsPerAccounts = await this.getTokensHeldByAccounts({ accounts, config: config2 });
        const result = {};
        for (const chainId of chains) {
          result[chainId] = resultsPerAccounts[chainId][account];
        }
        return result;
      }
      async getBalancesForTokens({ account, tokens, config: config2 }) {
        const entries = Object.entries(tokens).map(([chainId, tokens2]) => [
          Number(chainId),
          { [account]: tokens2 }
        ]);
        const resultsPerAccounts = await this.getBalancesForTokensForAccounts({ tokens: Object.fromEntries(entries), config: config2 });
        const result = {};
        for (const chainId in tokens) {
          result[chainId] = resultsPerAccounts[chainId]?.[account] ?? {};
        }
        return result;
      }
      getTokensHeldByAccounts({ accounts, config: config2 }) {
        return (0, timeouts_1.timeoutPromise)(this.source.getTokensHeldByAccounts({ accounts, config: config2 }), config2?.timeout);
      }
      getBalancesForTokensForAccounts({ tokens, config: config2 }) {
        return (0, timeouts_1.timeoutPromise)(this.source.getBalancesForTokens({ tokens, config: config2 }), config2?.timeout);
      }
    };
    exports.BalanceService = BalanceService;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/base/single-account-and-chain-base-balance-source.js
var require_single_account_and_chain_base_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/base/single-account-and-chain-base-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleAccountAndChainBaseBalanceSource = void 0;
    var single_chain_base_balance_source_1 = require_single_chain_base_balance_source();
    var SingleAccountAndChainBaseBalanceSource = class extends single_chain_base_balance_source_1.SingleChainBaseBalanceSource {
      async fetchERC20TokensHeldByAccountsInChain(chainId, accounts, config2) {
        const entries = accounts.map(async (account) => [account, await this.fetchERC20TokensHeldByAccountInChain(chainId, account, config2)]);
        return Object.fromEntries(await Promise.all(entries));
      }
      async fetchERC20BalancesForAccountsInChain(chainId, accounts, config2) {
        const entries = Object.entries(accounts).map(async ([account, tokens]) => [
          account,
          await this.fetchERC20BalancesForAccountInChain(chainId, account, tokens, config2)
        ]);
        return Object.fromEntries(await Promise.all(entries));
      }
      async fetchNativeBalancesInChain(chainId, accounts, config2) {
        const entries = accounts.map(async (account) => [account, await this.fetchNativeBalanceInChain(chainId, account, config2)]);
        return Object.fromEntries(await Promise.all(entries));
      }
    };
    exports.SingleAccountAndChainBaseBalanceSource = SingleAccountAndChainBaseBalanceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/alchemy-balance-source.js
var require_alchemy_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/alchemy-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlchemyBalanceSource = void 0;
    var alchemy_sdk_1 = (init_esm(), __toCommonJS(esm_exports));
    var alchemy_rpc_1 = require_alchemy_rpc();
    var single_account_and_chain_base_balance_source_1 = require_single_account_and_chain_base_balance_source();
    var timeouts_1 = require_timeouts();
    var AlchemyBalanceSource = class extends single_account_and_chain_base_balance_source_1.SingleAccountAndChainBaseBalanceSource {
      constructor(alchemyKey) {
        super();
        this.alchemyKey = alchemyKey;
      }
      supportedQueries() {
        const entries = (0, alchemy_rpc_1.alchemySupportedChains)().map((chainId) => [chainId, { getBalancesForTokens: true, getTokensHeldByAccount: true }]);
        return Object.fromEntries(entries);
      }
      async fetchERC20TokensHeldByAccountInChain(chainId, account, config2) {
        const allBalances = [];
        let pageKey = void 0;
        do {
          try {
            const result = await (0, timeouts_1.timeoutPromise)((0, alchemy_rpc_1.buildAlchemyClient)(this.alchemyKey, chainId).core.getTokenBalances(account, {
              type: alchemy_sdk_1.TokenBalanceType.ERC20,
              pageKey
            }), config2?.timeout);
            allBalances.push(...result.tokenBalances);
            pageKey = result.pageKey;
          } catch (e) {
            pageKey = void 0;
          }
        } while (!!pageKey);
        return toRecord(allBalances);
      }
      async fetchERC20BalancesForAccountInChain(chainId, account, addresses, config2) {
        const { tokenBalances } = await (0, timeouts_1.timeoutPromise)((0, alchemy_rpc_1.buildAlchemyClient)(this.alchemyKey, chainId).core.getTokenBalances(account, addresses), config2?.timeout);
        return toRecord(tokenBalances);
      }
      fetchNativeBalanceInChain(chainId, account, config2) {
        return (0, timeouts_1.timeoutPromise)((0, alchemy_rpc_1.buildAlchemyClient)(this.alchemyKey, chainId).core.getBalance(account).then((balance) => balance.toString()), config2?.timeout);
      }
    };
    exports.AlchemyBalanceSource = AlchemyBalanceSource;
    function toRecord(balances) {
      return Object.fromEntries(balances.map(({ contractAddress, tokenBalance }) => [contractAddress, tokenBalance ?? "0"]));
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/moralis-balance-source.js
var require_moralis_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/moralis-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MoralisBalanceSource = void 0;
    var _chains_1 = require_chains();
    var utils_1 = require_utils13();
    var single_account_and_chain_base_balance_source_1 = require_single_account_and_chain_base_balance_source();
    var SUPPORTED_CHAINS = [_chains_1.Chains.ETHEREUM, _chains_1.Chains.POLYGON, _chains_1.Chains.BNB_CHAIN, _chains_1.Chains.AVALANCHE, _chains_1.Chains.FANTOM, _chains_1.Chains.ARBITRUM, _chains_1.Chains.CRONOS];
    var MoralisBalanceSource = class extends single_account_and_chain_base_balance_source_1.SingleAccountAndChainBaseBalanceSource {
      constructor(fetchService, apiKey) {
        super();
        this.fetchService = fetchService;
        this.apiKey = apiKey;
      }
      supportedQueries() {
        const entries = SUPPORTED_CHAINS.map(({ chainId }) => [chainId, { getBalancesForTokens: true, getTokensHeldByAccount: true }]);
        return Object.fromEntries(entries);
      }
      async fetchERC20TokensHeldByAccountInChain(chainId, account, config2) {
        const balances = await this.fetch(`https://deep-index.moralis.io/api/v2/${account}/erc20?chain=${chainIdToValidChain(chainId)}`, config2?.timeout);
        return toRecord(balances);
      }
      async fetchERC20BalancesForAccountInChain(chainId, account, addresses, config2) {
        const url = `https://deep-index.moralis.io/api/v2/${account}/erc20?chain=${chainIdToValidChain(chainId)}&token_addresses=${addresses.join(",")}`;
        const balances = await this.fetch(url, config2?.timeout);
        return toRecord(balances);
      }
      async fetchNativeBalanceInChain(chainId, account, config2) {
        const { balance } = await this.fetch(`https://deep-index.moralis.io/api/v2/${account}/balance?chain=${chainIdToValidChain(chainId)}`, config2?.timeout);
        return balance;
      }
      async fetch(url, timeout) {
        const response = await this.fetchService.fetch(url, {
          headers: { "X-API-Key": this.apiKey },
          timeout
        });
        return response.json();
      }
    };
    exports.MoralisBalanceSource = MoralisBalanceSource;
    function chainIdToValidChain(chainId) {
      return (0, utils_1.toTrimmedHex)(chainId);
    }
    function toRecord(balances) {
      return Object.fromEntries(balances.map(({ token_address, balance }) => [token_address, balance]));
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/cached-balance-source.js
var require_cached_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/cached-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedBalanceSource = void 0;
    var concurrent_lru_cache_1 = require_concurrent_lru_cache();
    var CachedBalanceSource = class {
      constructor(source, config2) {
        this.source = source;
        this.cacheHeldByAccount = new concurrent_lru_cache_1.ContextlessConcurrentLRUCache({
          calculate: (keysHeldByAccount) => this.fetchTokensHeldByAccount(keysHeldByAccount),
          config: config2
        });
        this.cacheAmountInChain = new concurrent_lru_cache_1.ContextlessConcurrentLRUCache({
          calculate: (keysTokenInChain) => this.fetchBalancesForTokens(keysTokenInChain),
          config: config2
        });
      }
      supportedQueries() {
        return this.source.supportedQueries();
      }
      async getTokensHeldByAccounts({ accounts, config: config2 }) {
        const support = this.supportedQueries();
        for (const chainId in accounts) {
          if (!support[chainId]?.getTokensHeldByAccount) {
            return Promise.reject(new Error("Operation not supported"));
          }
        }
        const keys = Object.entries(accounts).flatMap(([chainId, accounts2]) => accounts2.map((account) => toKeyHeldByAccount(Number(chainId), account)));
        const cacheResults = await this.cacheHeldByAccount.getOrCalculate({
          keys,
          timeout: config2?.timeout
        });
        const result = {};
        for (const key in cacheResults) {
          const { chainId, account } = fromKeyHeldByAccount(key);
          if (!(chainId in result))
            result[chainId] = {};
          result[chainId][account] = cacheResults[key];
        }
        return result;
      }
      async getBalancesForTokens({ tokens, config: config2 }) {
        const allChainAndAccountPairs = Object.entries(tokens).flatMap(([chainId, tokens2]) => Object.keys(tokens2).map((account) => ({ chainId: Number(chainId), account })));
        const accountsWithHeldByAccount = allChainAndAccountPairs.filter(({ chainId, account }) => this.cacheHeldByAccount.holdsValidValue(toKeyHeldByAccount(chainId, account)));
        const accountsWithoutHeldByAccount = allChainAndAccountPairs.filter(({ chainId, account }) => !this.cacheHeldByAccount.holdsValidValue(toKeyHeldByAccount(chainId, account)));
        const result = {};
        if (accountsWithHeldByAccount.length > 0) {
          const keys = accountsWithHeldByAccount.map(({ chainId, account }) => toKeyHeldByAccount(chainId, account));
          const tokensHeldByAccount = await this.cacheHeldByAccount.getOrCalculate({ keys, timeout: config2?.timeout });
          for (const key of keys) {
            const { chainId, account } = fromKeyHeldByAccount(key);
            if (!(chainId in result))
              result[chainId] = {};
            result[chainId][account] = tokensHeldByAccount[key];
          }
        }
        if (accountsWithoutHeldByAccount.length > 0) {
          const keys = accountsWithoutHeldByAccount.flatMap(({ chainId, account }) => tokens[chainId][account].map((token2) => toKeyTokenInChain(chainId, account, token2)));
          const amountsInChain = await this.cacheAmountInChain.getOrCalculate({
            keys,
            timeout: config2?.timeout
          });
          for (const key in amountsInChain) {
            const { chainId, account, token: token2 } = fromKeyTokenInChain(key);
            if (!(chainId in result))
              result[chainId] = {};
            if (!(account in result[chainId]))
              result[chainId][account] = {};
            result[chainId][account][token2] = amountsInChain[key];
          }
        }
        return result;
      }
      async fetchTokensHeldByAccount(keys) {
        const accounts = {};
        for (const key of keys) {
          const { chainId, account } = fromKeyHeldByAccount(key);
          if (!(chainId in accounts))
            accounts[chainId] = [];
          accounts[chainId].push(account);
        }
        const balances = await this.source.getTokensHeldByAccounts({ accounts });
        const result = {};
        for (const chainId in balances) {
          for (const account in balances[chainId]) {
            const key = toKeyHeldByAccount(Number(chainId), account);
            result[key] = balances[chainId][account];
          }
        }
        return result;
      }
      async fetchBalancesForTokens(keys) {
        const tokens = {};
        for (const key of keys) {
          const { chainId, account, token: token2 } = fromKeyTokenInChain(key);
          if (!(chainId in tokens))
            tokens[chainId] = {};
          if (!(account in tokens[chainId]))
            tokens[chainId][account] = [];
          tokens[chainId][account].push(token2);
        }
        const balances = await this.source.getBalancesForTokens({ tokens });
        const result = {};
        for (const key of keys) {
          const { chainId, account, token: token2 } = fromKeyTokenInChain(key);
          const balance = balances?.[chainId]?.[account]?.[token2];
          if (balance !== void 0) {
            result[key] = balance;
          }
        }
        return result;
      }
    };
    exports.CachedBalanceSource = CachedBalanceSource;
    function toKeyHeldByAccount(chainId, account) {
      return `${chainId}-${account}`;
    }
    function fromKeyHeldByAccount(key) {
      const [chainId, account] = key.split("-");
      return { chainId: Number(chainId), account };
    }
    function toKeyTokenInChain(chainId, account, token2) {
      return `${chainId}-${account}-${token2}`;
    }
    function fromKeyTokenInChain(key) {
      const [chainId, account, token2] = key.split("-");
      return { chainId: Number(chainId), account, token: token2 };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/base/only-tokens-held-balance-source.js
var require_only_tokens_held_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/base/only-tokens-held-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OnlyTokensHeldBalanceSource = void 0;
    var OnlyTokensHeldBalanceSource = class {
      supportedQueries() {
        const entries = this.supportedChains().map((chainId) => [chainId, { getBalancesForTokens: true, getTokensHeldByAccount: true }]);
        return Object.fromEntries(entries);
      }
      async getBalancesForTokens({ tokens, config: config2 }) {
        const entries = Object.entries(tokens).map(([chainId, tokens2]) => [Number(chainId), Object.keys(tokens2)]);
        const tokensHeldByAccount = await this.getTokensHeldByAccounts({ accounts: Object.fromEntries(entries), config: config2 });
        const result = {};
        for (const chainId in tokens) {
          result[chainId] = {};
          for (const account in tokens[chainId]) {
            result[chainId][account] = {};
            for (const token2 of tokens[chainId][account]) {
              result[chainId][account][token2] = tokensHeldByAccount?.[chainId]?.[account]?.[token2] ?? "0";
            }
          }
        }
        return result;
      }
    };
    exports.OnlyTokensHeldBalanceSource = OnlyTokensHeldBalanceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/portals-fi-balance-source.js
var require_portals_fi_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/portals-fi-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PortalsFiBalanceSource = void 0;
    var portals_fi_1 = require_portals_fi();
    var constants_1 = require_constants();
    var utils_1 = require_utils13();
    var only_tokens_held_balance_source_1 = require_only_tokens_held_balance_source();
    var PortalsFiBalanceSource = class extends only_tokens_held_balance_source_1.OnlyTokensHeldBalanceSource {
      constructor(fetchService, key) {
        super();
        this.fetchService = fetchService;
        this.key = key;
      }
      async getTokensHeldByAccounts({ accounts, config: config2 }) {
        const chainsPerAccount = {};
        for (const chainId in accounts) {
          for (const account of accounts[chainId]) {
            if (!(account in chainsPerAccount))
              chainsPerAccount[account] = [];
            chainsPerAccount[account].push(Number(chainId));
          }
        }
        const allResults = await Promise.all(Object.entries(chainsPerAccount).map(([account, chainIds]) => this.fetchTokensHeldByAccount(account, chainIds, config2?.timeout)));
        const merged = {};
        for (const result of allResults) {
          for (const chainId in result) {
            if (!(chainId in merged))
              merged[chainId] = {};
            for (const account in result[chainId]) {
              if (!(account in merged[chainId]))
                merged[chainId][account] = {};
              for (const token2 in result[chainId][account]) {
                merged[chainId][account][token2] = result[chainId][account][token2];
              }
            }
          }
        }
        return merged;
      }
      supportedChains() {
        return portals_fi_1.PORTALS_FI_SUPPORTED_CHAINS;
      }
      async fetchTokensHeldByAccount(account, chains, timeout) {
        const keys = chains.map((chainId) => portals_fi_1.PORTALS_FI_CHAIN_ID_TO_KEY[chainId]).filter((key) => !!key).join("&networks=");
        const response = await this.fetchService.fetch(`https://api.portals.fi/v2/account?ownerAddress=${account}&networks=${keys}`, {
          timeout,
          headers: { "x-api-key": this.key }
        });
        const { balances } = await response.json();
        const result = {};
        for (const { key, rawBalance } of balances) {
          const { chainId, token: token2 } = fromKey(key);
          if (!(chainId in result))
            result[chainId] = {};
          if (!(account in result[chainId]))
            result[chainId][account] = {};
          result[chainId][account][token2] = rawBalance;
        }
        return result;
      }
    };
    exports.PortalsFiBalanceSource = PortalsFiBalanceSource;
    function fromKey(key) {
      const [chainKey, token2] = key.split(":");
      return {
        chainId: portals_fi_1.PORTALS_FI_KEY_TO_CHAIN_ID[chainKey],
        token: (0, utils_1.isSameAddress)(token2, constants_1.Addresses.ZERO_ADDRESS) ? constants_1.Addresses.NATIVE_TOKEN : token2
      };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/1inch-balance-source.js
var require_inch_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/1inch-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OneInchBalanceSource = void 0;
    var only_tokens_held_balance_source_1 = require_only_tokens_held_balance_source();
    var _1inch_quote_source_1 = require_inch_quote_source();
    var OneInchBalanceSource = class extends only_tokens_held_balance_source_1.OnlyTokensHeldBalanceSource {
      constructor(fetchService) {
        super();
        this.fetchService = fetchService;
      }
      async getTokensHeldByAccounts({ accounts, config: config2 }) {
        const accountsInChain = Object.entries(accounts).flatMap(([chainId, accounts2]) => accounts2.map((account) => ({ chainId: Number(chainId), account })));
        const allResults = await Promise.all(accountsInChain.map(async ({ account, chainId }) => ({
          account,
          chainId,
          balances: await this.fetchTokensHeldByAccount(account, chainId, config2?.timeout)
        })));
        const merged = {};
        for (const { chainId, account, balances } of allResults) {
          if (!(chainId in merged))
            merged[chainId] = {};
          merged[chainId][account] = balances;
        }
        return merged;
      }
      supportedChains() {
        return _1inch_quote_source_1.ONE_INCH_METADATA.supports.chains;
      }
      async fetchTokensHeldByAccount(account, chainId, timeout) {
        const response = await this.fetchService.fetch(`https://balances.1inch.io/v1.1/${chainId}/balances/${account}`, {
          timeout
        });
        const balances = await response.json();
        const entries = Object.entries(balances).filter(([, amount]) => BigInt(amount) > 0).map(([token2, amount]) => [token2, BigInt(amount).toString()]);
        return Object.fromEntries(entries);
      }
    };
    exports.OneInchBalanceSource = OneInchBalanceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/magpie.js
var require_magpie = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/magpie.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildMagpieBalanceManagerUrl = exports.magpieSupportedChains = void 0;
    var _chains_1 = require_chains();
    var MAGPIE_NETWORKS = {
      [_chains_1.Chains.ETHEREUM.chainId]: "ethereum",
      [_chains_1.Chains.POLYGON.chainId]: "polygon",
      [_chains_1.Chains.BNB_CHAIN.chainId]: "bsc",
      [_chains_1.Chains.ARBITRUM.chainId]: "arbitrum",
      [_chains_1.Chains.AVALANCHE.chainId]: "avalanche",
      [_chains_1.Chains.OPTIMISM.chainId]: "optimism",
      [_chains_1.Chains.POLYGON_ZKEVM.chainId]: "polygonzk"
    };
    function magpieSupportedChains() {
      return Object.keys(MAGPIE_NETWORKS).map(Number);
    }
    exports.magpieSupportedChains = magpieSupportedChains;
    function buildMagpieBalanceManagerUrl(chainId) {
      const magpieNetwork = MAGPIE_NETWORKS[chainId];
      return `https://api.magpiefi.xyz/balance-manager/${magpieNetwork}`;
    }
    exports.buildMagpieBalanceManagerUrl = buildMagpieBalanceManagerUrl;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/magpie-balance-source.js
var require_magpie_balance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/balance-sources/magpie-balance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MagpieBalanceSource = void 0;
    var only_tokens_held_balance_source_1 = require_only_tokens_held_balance_source();
    var magpie_1 = require_magpie();
    var utils_1 = require_utils13();
    var constants_1 = require_constants();
    var MagpieBalanceSource = class extends only_tokens_held_balance_source_1.OnlyTokensHeldBalanceSource {
      constructor(fetchService) {
        super();
        this.fetchService = fetchService;
      }
      async getTokensHeldByAccounts({ accounts, config: config2 }) {
        const accountsInChain = Object.entries(accounts).flatMap(([chainId, accounts2]) => accounts2.map((account) => ({ chainId: Number(chainId), account })));
        const allResults = await Promise.all(accountsInChain.map(async ({ account, chainId }) => ({
          account,
          chainId,
          balances: await this.fetchTokensHeldByAccount(account, chainId, config2?.timeout)
        })));
        const merged = {};
        for (const { chainId, account, balances } of allResults) {
          if (!(chainId in merged))
            merged[chainId] = {};
          merged[chainId][account] = balances;
        }
        return merged;
      }
      supportedChains() {
        return (0, magpie_1.magpieSupportedChains)();
      }
      async fetchTokensHeldByAccount(account, chainId, timeout) {
        const response = await this.fetchService.fetch(`${(0, magpie_1.buildMagpieBalanceManagerUrl)(chainId)}/balances?walletAddress=${account}`, {
          timeout
        });
        const balances = await response.json();
        return Object.fromEntries(balances.map(({ tokenAddress, amount }) => [mapNativeToken(tokenAddress), amount]));
      }
    };
    exports.MagpieBalanceSource = MagpieBalanceSource;
    function mapNativeToken(address) {
      return (0, utils_1.isSameAddress)(address, constants_1.Addresses.ZERO_ADDRESS) ? constants_1.Addresses.NATIVE_TOKEN : address;
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/balance-builder.js
var require_balance_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/balance-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildBalanceService = void 0;
    var rpc_balance_source_1 = require_rpc_balance_source();
    var balance_service_1 = require_balance_service();
    var alchemy_balance_source_1 = require_alchemy_balance_source();
    var moralis_balance_source_1 = require_moralis_balance_source();
    var cached_balance_source_1 = require_cached_balance_source();
    var portals_fi_balance_source_1 = require_portals_fi_balance_source();
    var _1inch_balance_source_1 = require_inch_balance_source();
    var magpie_balance_source_1 = require_magpie_balance_source();
    function buildBalanceService(params, fetchService, providerService, multicallService) {
      const source = buildSource(params?.source, { fetchService, providerService, multicallService });
      return new balance_service_1.BalanceService(source);
    }
    exports.buildBalanceService = buildBalanceService;
    function buildSource(source, { fetchService, providerService, multicallService }) {
      switch (source?.type) {
        case void 0:
        case "rpc-multicall":
          return new rpc_balance_source_1.RPCBalanceSource(providerService, multicallService);
        case "cached":
          const underlying = buildSource(source.underlyingSource, { fetchService, providerService, multicallService });
          return new cached_balance_source_1.CachedBalanceSource(underlying, source.config);
        case "custom":
          return source.instance;
        case "alchemy":
          return new alchemy_balance_source_1.AlchemyBalanceSource(source.key);
        case "portals-fi":
          return new portals_fi_balance_source_1.PortalsFiBalanceSource(fetchService, source.key);
        case "1inch":
          return new _1inch_balance_source_1.OneInchBalanceSource(fetchService);
        case "magpie":
          return new magpie_balance_source_1.MagpieBalanceSource(fetchService);
        case "moralis":
          return new moralis_balance_source_1.MoralisBalanceSource(fetchService, source.key);
      }
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-sources/rpc-allowance-source.js
var require_rpc_allowance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-sources/rpc-allowance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RPCAllowanceSource = void 0;
    var timeouts_1 = require_timeouts();
    var utils_1 = require_utils13();
    var erc20_1 = require_erc20();
    var RPCAllowanceSource = class {
      constructor(multicallService) {
        this.multicallService = multicallService;
      }
      supportedChains() {
        return this.multicallService.supportedChains();
      }
      async getAllowances({ allowances, config: config2 }) {
        const promises = Object.entries(allowances).map(async ([chainId, checks]) => [
          parseInt(chainId),
          await (0, timeouts_1.timeoutPromise)(this.getAllowancesInChain(parseInt(chainId), checks), config2?.timeout, { reduceBy: "100" })
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
      }
      async getAllowancesInChain(chainId, checks) {
        const calls = checks.map(({ token: token2, owner, spender }) => ({
          address: token2,
          abi: { humanReadable: erc20_1.ERC20_ABI },
          functionName: "allowance",
          args: [owner, spender]
        }));
        const multicallResults = await this.multicallService.tryReadOnlyMulticall({ chainId, calls });
        const result = {};
        for (let i = 0; i < multicallResults.length; i++) {
          const multicallResult = multicallResults[i];
          if (multicallResult.status === "failure")
            continue;
          const { token: token2, owner, spender } = checks[i];
          if (!(token2 in result))
            result[token2] = {};
          if (!(owner in result[token2]))
            result[token2][owner] = {};
          result[token2][owner][spender] = multicallResult.result.toString();
        }
        return result;
      }
    };
    exports.RPCAllowanceSource = RPCAllowanceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-service.js
var require_allowance_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AllowanceService = void 0;
    var timeouts_1 = require_timeouts();
    var AllowanceService = class {
      constructor(source) {
        this.source = source;
      }
      supportedChains() {
        return this.source.supportedChains();
      }
      async getAllowanceInChain({ chainId, token: token2, owner, spender, config: config2 }) {
        const { [spender]: result } = await this.getAllowancesInChain({ chainId, token: token2, owner, spenders: [spender], config: config2 });
        return result;
      }
      async getAllowancesInChain({ chainId, token: token2, owner, spenders, config: config2 }) {
        const allowancesInChain = spenders.map((spender) => ({ token: token2, owner, spender }));
        const result = await this.getMultipleAllowancesInChain({
          chainId,
          check: allowancesInChain,
          config: config2
        });
        return result[token2][owner];
      }
      async getMultipleAllowancesInChain({ chainId, check, config: config2 }) {
        const result = await (0, timeouts_1.timeoutPromise)(this.source.getAllowances({
          allowances: { [chainId]: check },
          config: config2
        }), config2?.timeout);
        return result[chainId] ?? {};
      }
    };
    exports.AllowanceService = AllowanceService;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-sources/cached-allowance-source.js
var require_cached_allowance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-sources/cached-allowance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedAllowanceSource = void 0;
    var concurrent_lru_cache_1 = require_concurrent_lru_cache();
    var CachedAllowanceSource = class {
      constructor(source, config2) {
        this.source = source;
        this.cache = new concurrent_lru_cache_1.ContextlessConcurrentLRUCache({
          calculate: (ownerSpendersInChain) => this.fetchTokens(ownerSpendersInChain),
          config: config2
        });
      }
      supportedChains() {
        return this.source.supportedChains();
      }
      async getAllowances({ allowances, config: config2 }) {
        const keys = allowanceChecksToKeys(allowances);
        const result = await this.cache.getOrCalculate({ keys, timeout: config2?.timeout });
        return keyResultsToResult(result);
      }
      async fetchTokens(keys) {
        const allowances = keysToAllowanceChecks(keys);
        const result = await this.source.getAllowances({ allowances });
        return resultsToKeyResults(result);
      }
    };
    exports.CachedAllowanceSource = CachedAllowanceSource;
    function allowanceChecksToKeys(allowances) {
      return Object.entries(allowances).flatMap(([chainId, checks]) => checks.map(({ token: token2, owner, spender }) => toKey(Number(chainId), token2, owner, spender)));
    }
    function resultsToKeyResults(result) {
      const keyResults = {};
      for (const chainId in result) {
        for (const token2 in result[chainId]) {
          for (const owner in result[chainId][token2]) {
            for (const spender in result[chainId][token2][owner]) {
              const key = toKey(Number(chainId), token2, owner, spender);
              keyResults[key] = result[chainId][token2][owner][spender];
            }
          }
        }
      }
      return keyResults;
    }
    function keysToAllowanceChecks(keys) {
      const result = {};
      for (const key of keys) {
        const { chainId, token: token2, owner, spender } = fromKey(key);
        if (!(chainId in result))
          result[chainId] = [];
        result[chainId].push({ token: token2, owner, spender });
      }
      return result;
    }
    function keyResultsToResult(keyResults) {
      const result = {};
      for (const [key, amount] of Object.entries(keyResults)) {
        const { chainId, token: token2, owner, spender } = fromKey(key);
        if (!(chainId in result))
          result[chainId] = {};
        if (!(token2 in result[chainId]))
          result[chainId][token2] = {};
        if (!(owner in result[chainId][token2]))
          result[chainId][token2][owner] = {};
        result[chainId][token2][owner][spender] = amount;
      }
      return result;
    }
    function toKey(chainId, token2, owner, spender) {
      return `${chainId}-${token2}-${owner}-${spender}`;
    }
    function fromKey(key) {
      const [chainId, token2, owner, spender] = key.split("-");
      return { chainId: Number(chainId), token: token2, owner, spender };
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-sources/alchemy-allowance-source.js
var require_alchemy_allowance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-sources/alchemy-allowance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlchemyAllowanceSource = void 0;
    var timeouts_1 = require_timeouts();
    var utils_1 = require_utils13();
    var alchemy_rpc_1 = require_alchemy_rpc();
    var AlchemyAllowanceSource = class {
      constructor(alchemyKey) {
        this.alchemyKey = alchemyKey;
      }
      supportedChains() {
        return (0, alchemy_rpc_1.alchemySupportedChains)();
      }
      async getAllowances({ allowances, config: config2 }) {
        const promises = Object.entries(allowances).map(async ([chainId, checks]) => [
          parseInt(chainId),
          await (0, timeouts_1.timeoutPromise)(this.fetchAllowancesInChain(parseInt(chainId), checks), config2?.timeout, { reduceBy: "100" })
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
      }
      async fetchAllowancesInChain(chainId, allowances, config2) {
        const allowanceResults = await Promise.all(allowances.map((allowance) => this.fetchAllowanceInChain(chainId, allowance, config2)));
        const result = {};
        for (let i = 0; i < allowanceResults.length; i++) {
          const { token: token2, owner, spender } = allowances[i];
          if (!(token2 in result))
            result[token2] = {};
          if (!(owner in result[token2]))
            result[token2][owner] = {};
          result[token2][owner][spender] = allowanceResults[i];
        }
        return result;
      }
      fetchAllowanceInChain(chainId, { token: token2, owner, spender }, config2) {
        return (0, timeouts_1.timeoutPromise)((0, alchemy_rpc_1.buildAlchemyClient)(this.alchemyKey, chainId).core.send("alchemy_getTokenAllowance", [{ contract: token2, owner, spender }]), config2?.timeout);
      }
    };
    exports.AlchemyAllowanceSource = AlchemyAllowanceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-sources/magpie-allowance-source.js
var require_magpie_allowance_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/allowances/allowance-sources/magpie-allowance-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MagpieAllowanceSource = void 0;
    var timeouts_1 = require_timeouts();
    var utils_1 = require_utils13();
    var magpie_1 = require_magpie();
    var MagpieAllowanceSource = class {
      constructor(fetchService) {
        this.fetchService = fetchService;
      }
      supportedChains() {
        return (0, magpie_1.magpieSupportedChains)();
      }
      async getAllowances({ allowances, config: config2 }) {
        const promises = Object.entries(allowances).map(async ([chainId, checks]) => [
          parseInt(chainId),
          await (0, timeouts_1.timeoutPromise)(this.fetchAllowances(parseInt(chainId), checks), config2?.timeout, { reduceBy: "100" })
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
      }
      async fetchAllowances(chainId, allowances, config2) {
        const allowanceResults = await Promise.all(allowances.map((allowance) => this.fetchAllowance(chainId, allowance, config2)));
        const result = {};
        for (let i = 0; i < allowanceResults.length; i++) {
          const { token: token2, owner, spender } = allowances[i];
          if (!(token2 in result))
            result[token2] = {};
          if (!(owner in result[token2]))
            result[token2][owner] = {};
          result[token2][owner][spender] = allowanceResults[i];
        }
        return result;
      }
      fetchAllowance(chainId, { token: token2, owner, spender }, config2) {
        return this.fetchService.fetch(`${(0, magpie_1.buildMagpieBalanceManagerUrl)(chainId)}/allowance?walletAddress=${owner}&tokenAddress=${token2}&spenderAddress=${spender}`, {
          timeout: config2?.timeout
        }).then((response) => response.json());
      }
    };
    exports.MagpieAllowanceSource = MagpieAllowanceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/allowance-builder.js
var require_allowance_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/allowance-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildAllowanceService = void 0;
    var rpc_allowance_source_1 = require_rpc_allowance_source();
    var allowance_service_1 = require_allowance_service();
    var cached_allowance_source_1 = require_cached_allowance_source();
    var alchemy_allowance_source_1 = require_alchemy_allowance_source();
    var magpie_allowance_source_1 = require_magpie_allowance_source();
    function buildAllowanceService(params, fetchService, multicallService) {
      const source = buildSource(params?.source, { fetchService, multicallService });
      return new allowance_service_1.AllowanceService(source);
    }
    exports.buildAllowanceService = buildAllowanceService;
    function buildSource(source, { fetchService, multicallService }) {
      switch (source?.type) {
        case void 0:
        case "rpc-multicall":
          return new rpc_allowance_source_1.RPCAllowanceSource(multicallService);
        case "cached":
          const underlying = buildSource(source.underlyingSource, { fetchService, multicallService });
          return new cached_allowance_source_1.CachedAllowanceSource(underlying, source.config);
        case "custom":
          return source.instance;
        case "alchemy":
          return new alchemy_allowance_source_1.AlchemyAllowanceSource(source.key);
        case "magpie":
          return new magpie_allowance_source_1.MagpieAllowanceSource(fetchService);
      }
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/defi-llama-price-source.js
var require_defi_llama_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/defi-llama-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefiLlamaPriceSource = void 0;
    var defi_llama_1 = require_defi_llama();
    var DefiLlamaPriceSource = class {
      constructor(fetch2) {
        this.defiLlama = new defi_llama_1.DefiLlamaClient(fetch2);
      }
      supportedQueries() {
        const support = { getCurrentPrices: true, getHistoricalPrices: true, getBulkHistoricalPrices: true };
        const entries = this.defiLlama.supportedChains().map((chainId) => [chainId, support]);
        return Object.fromEntries(entries);
      }
      async getCurrentPrices(params) {
        const result = {};
        const data = await this.defiLlama.getCurrentTokenData(params);
        for (const [chainIdString, tokens] of Object.entries(data)) {
          const chainId = Number(chainIdString);
          result[chainId] = {};
          for (const [address, token2] of Object.entries(tokens)) {
            result[chainId][address] = { price: token2.price, closestTimestamp: token2.timestamp };
          }
        }
        return result;
      }
      async getHistoricalPrices(params) {
        const result = {};
        const data = await this.defiLlama.getHistoricalTokenData(params);
        for (const [chainIdString, tokens] of Object.entries(data)) {
          const chainId = Number(chainIdString);
          result[chainId] = {};
          for (const [address, { price, timestamp }] of Object.entries(tokens)) {
            result[chainId][address] = { price, closestTimestamp: timestamp };
          }
        }
        return result;
      }
      async getBulkHistoricalPrices({ addresses, searchWidth, config: config2 }) {
        return this.defiLlama.getBulkHistoricalTokenData({ addresses, searchWidth, config: config2 });
      }
    };
    exports.DefiLlamaPriceSource = DefiLlamaPriceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-service.js
var require_price_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PriceService = void 0;
    var timeouts_1 = require_timeouts();
    var PriceService = class {
      constructor(priceSource) {
        this.priceSource = priceSource;
      }
      supportedChains() {
        return Object.entries(this.supportedQueries()).filter(([, support]) => support.getCurrentPrices || support.getHistoricalPrices).map(([chainId]) => Number(chainId));
      }
      supportedQueries() {
        return this.priceSource.supportedQueries();
      }
      async getCurrentPricesForChain({ chainId, addresses, config: config2 }) {
        const byChainId = { [chainId]: addresses };
        const result = await this.getCurrentPrices({ addresses: byChainId, config: config2 });
        return result[chainId] ?? {};
      }
      getCurrentPrices({ addresses, config: config2 }) {
        return (0, timeouts_1.timeoutPromise)(this.priceSource.getCurrentPrices({ addresses, config: config2 }), config2?.timeout, {
          description: "Timeouted while fetching current prices"
        });
      }
      async getHistoricalPricesForChain({ chainId, addresses, timestamp, searchWidth, config: config2 }) {
        const byChainId = { [chainId]: addresses };
        const result = await this.getHistoricalPrices({ addresses: byChainId, timestamp, searchWidth, config: config2 });
        return result[chainId] ?? {};
      }
      getHistoricalPrices({ config: config2, searchWidth, ...params }) {
        return (0, timeouts_1.timeoutPromise)(this.priceSource.getHistoricalPrices({ ...params, searchWidth, config: config2 }), config2?.timeout, {
          description: "Timeouted while fetching historical prices"
        });
      }
      getBulkHistoricalPrices({ addresses, searchWidth, config: config2 }) {
        const collectedByChainId = {};
        for (const { chainId, token: token2, timestamp } of addresses) {
          if (!(chainId in collectedByChainId))
            collectedByChainId[chainId] = [];
          collectedByChainId[chainId].push({ token: token2, timestamp });
        }
        return (0, timeouts_1.timeoutPromise)(this.priceSource.getBulkHistoricalPrices({ addresses: collectedByChainId, searchWidth, config: config2 }), config2?.timeout, {
          description: "Timeouted while fetching bulk historical prices"
        });
      }
    };
    exports.PriceService = PriceService;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/cached-price-source.js
var require_cached_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/cached-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CachedPriceSource = void 0;
    var concurrent_lru_cache_1 = require_concurrent_lru_cache();
    var utils_1 = require_utils13();
    var CachedPriceSource = class {
      constructor(source, config2) {
        this.source = source;
        this.cache = new concurrent_lru_cache_1.ConcurrentLRUCache({
          calculate: (context2, tokensInChain) => this.fetchTokens(tokensInChain, context2),
          config: config2
        });
      }
      supportedQueries() {
        return this.source.supportedQueries();
      }
      async getCurrentPrices({ addresses, config: config2 }) {
        const tokensInChain = addressesToTokensInChain(addresses);
        const tokens = await this.cache.getOrCalculate({ keys: tokensInChain, context: config2, timeout: config2?.timeout });
        return tokenInChainRecordToChainAndAddress(tokens);
      }
      getHistoricalPrices({ addresses, timestamp, searchWidth, config: config2 }) {
        return this.source.getHistoricalPrices({ addresses, timestamp, searchWidth, config: config2 });
      }
      getBulkHistoricalPrices({ addresses, searchWidth, config: config2 }) {
        return this.source.getBulkHistoricalPrices({ addresses, searchWidth, config: config2 });
      }
      async fetchTokens(tokensInChain, context2) {
        const addresses = tokensInChainToAddresses(tokensInChain);
        const tokens = await this.source.getCurrentPrices({ addresses, config: { timeout: context2?.timeout } });
        return chainAndAddressRecordToTokenInChain(tokens);
      }
    };
    exports.CachedPriceSource = CachedPriceSource;
    function addressesToTokensInChain(addresses) {
      return Object.entries(addresses).flatMap(([chainId, addresses2]) => addresses2.map((address) => (0, utils_1.toTokenInChain)(parseInt(chainId), address)));
    }
    function tokensInChainToAddresses(tokensInChain) {
      const result = {};
      for (const tokenInChain of tokensInChain) {
        const { chainId, address } = (0, utils_1.fromTokenInChain)(tokenInChain);
        if (chainId in result) {
          result[chainId].push(address);
        } else {
          result[chainId] = [address];
        }
      }
      return result;
    }
    function tokenInChainRecordToChainAndAddress(record) {
      const result = {};
      for (const [tokenInChain, token2] of Object.entries(record)) {
        const { chainId, address } = (0, utils_1.fromTokenInChain)(tokenInChain);
        if (!(chainId in result)) {
          result[chainId] = {};
        }
        result[chainId][address] = token2;
      }
      return result;
    }
    function chainAndAddressRecordToTokenInChain(record) {
      const entries = Object.entries(record).flatMap(([chainId, record2]) => Object.entries(record2).map(([address, token2]) => [(0, utils_1.toTokenInChain)(parseInt(chainId), address), token2]));
      return Object.fromEntries(entries);
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/utils.js
var require_utils17 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nowInSeconds = exports.getSourcesThatSupportRequestOrFail = exports.combineSupport = exports.filterRequestForSource = exports.doesResponseFulfillRequest = exports.fillResponseWithNewResult = void 0;
    function fillResponseWithNewResult(result, newResult) {
      for (const chainId in newResult) {
        for (const address in newResult[chainId]) {
          if (!result[chainId]?.[address]) {
            if (!(chainId in result)) {
              result[chainId] = {};
            }
            result[chainId][address] = newResult[chainId][address];
          }
        }
      }
    }
    exports.fillResponseWithNewResult = fillResponseWithNewResult;
    function doesResponseFulfillRequest(result, request) {
      for (const chainId in request) {
        for (const address of request[chainId]) {
          if (typeof result[chainId]?.[address] === "undefined") {
            return false;
          }
        }
      }
      return true;
    }
    exports.doesResponseFulfillRequest = doesResponseFulfillRequest;
    function doesSourceSupportQueryInAnyOfTheChains(source, query, chains) {
      const support = source.supportedQueries();
      return chains.some((chainId) => support[chainId]?.[query]);
    }
    function filterRequestForSource(request, query, source) {
      const support = source.supportedQueries();
      const entries = Object.entries(request).filter(([chainId]) => support[Number(chainId)]?.[query]);
      return Object.fromEntries(entries);
    }
    exports.filterRequestForSource = filterRequestForSource;
    function combineSupport(sources) {
      const result = {};
      for (const source of sources) {
        for (const [chainIdString, support] of Object.entries(source.supportedQueries())) {
          const chainId = Number(chainIdString);
          const current = result[chainId] ?? { getCurrentPrices: false, getHistoricalPrices: false, getBulkHistoricalPrices: false };
          result[chainId] = {
            getCurrentPrices: current.getCurrentPrices || support.getCurrentPrices,
            getHistoricalPrices: current.getHistoricalPrices || support.getHistoricalPrices,
            getBulkHistoricalPrices: current.getBulkHistoricalPrices || support.getBulkHistoricalPrices
          };
        }
      }
      return result;
    }
    exports.combineSupport = combineSupport;
    function getSourcesThatSupportRequestOrFail(request, sources, query) {
      const chainsInRequest = Object.keys(request).map(Number);
      const sourcesInChain = sources.filter((source) => doesSourceSupportQueryInAnyOfTheChains(source, query, chainsInRequest));
      if (sourcesInChain.length === 0)
        throw new Error(`Current price sources can't support all the given chains`);
      return sourcesInChain;
    }
    exports.getSourcesThatSupportRequestOrFail = getSourcesThatSupportRequestOrFail;
    function nowInSeconds() {
      return Math.floor(Date.now() / 1e3);
    }
    exports.nowInSeconds = nowInSeconds;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/odos-price-source.js
var require_odos_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/odos-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OdosPriceSource = void 0;
    var _chains_1 = require_chains();
    var timeouts_1 = require_timeouts();
    var utils_1 = require_utils13();
    var constants_1 = require_constants();
    var utils_2 = require_utils17();
    var SUPPORTED_CHAINS = [_chains_1.Chains.ETHEREUM, _chains_1.Chains.POLYGON, _chains_1.Chains.OPTIMISM, _chains_1.Chains.AVALANCHE, _chains_1.Chains.ARBITRUM, _chains_1.Chains.BNB_CHAIN, _chains_1.Chains.BASE];
    var OdosPriceSource = class {
      constructor(fetch2) {
        this.fetch = fetch2;
      }
      supportedQueries() {
        const support = { getCurrentPrices: true, getHistoricalPrices: false, getBulkHistoricalPrices: false };
        const entries = SUPPORTED_CHAINS.map(({ chainId }) => chainId).map((chainId) => [chainId, support]);
        return Object.fromEntries(entries);
      }
      async getCurrentPrices({ addresses, config: config2 }) {
        const reducedTimeout = (0, timeouts_1.reduceTimeout)(config2?.timeout, "100");
        const promises = Object.entries(addresses).map(async ([chainId, addresses2]) => [
          Number(chainId),
          await (0, timeouts_1.timeoutPromise)(this.getCurrentPricesInChain(chainId, addresses2, reducedTimeout), reducedTimeout)
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
      }
      getHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
      getBulkHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
      async getCurrentPricesInChain(chainId, addresses, timeout) {
        const params = addresses.map((address) => `token_addresses=${mapToken(address)}`).join("&");
        const url = `https://api.odos.xyz/pricing/token/${chainId}?${params}`;
        const response = await this.fetch.fetch(url, { timeout });
        const body = await response.json();
        const lowercased = toLowerCase(body.tokenPrices);
        return Object.fromEntries(addresses.map((address) => [address, { price: lowercased[mapToken(address.toLowerCase())], closestTimestamp: (0, utils_2.nowInSeconds)() }]));
      }
    };
    exports.OdosPriceSource = OdosPriceSource;
    var ODOS_NATIVE_TOKEN = "0x0000000000000000000000000000000000000000";
    function mapToken(address) {
      return (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? ODOS_NATIVE_TOKEN : address;
    }
    function toLowerCase(prices) {
      return Object.fromEntries(Object.entries(prices).map(([token2, price]) => [token2.toLowerCase(), price]));
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/coingecko-price-source.js
var require_coingecko_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/coingecko-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoingeckoPriceSource = void 0;
    var _chains_1 = require_chains();
    var timeouts_1 = require_timeouts();
    var utils_1 = require_utils13();
    var constants_1 = require_constants();
    var COINGECKO_CHAIN_KEYS = {
      [_chains_1.Chains.ONTOLOGY.chainId]: { chainKey: "ontology", nativeTokenKey: "ontology" },
      [_chains_1.Chains.BIT_TORRENT.chainId]: { chainKey: "bittorrent", nativeTokenKey: "bittorrent" },
      [_chains_1.Chains.BNB_CHAIN.chainId]: { chainKey: "binance-smart-chain", nativeTokenKey: "binancecoin" },
      [_chains_1.Chains.HECO.chainId]: { chainKey: "huobi-token", nativeTokenKey: "huobi-token" },
      [_chains_1.Chains.KLAYTN.chainId]: { chainKey: "klay-token", nativeTokenKey: "klay-token" },
      [_chains_1.Chains.FANTOM.chainId]: { chainKey: "fantom", nativeTokenKey: "fantom" },
      [_chains_1.Chains.OPTIMISM.chainId]: { chainKey: "optimistic-ethereum", nativeTokenKey: "ethereum" },
      [_chains_1.Chains.POLYGON.chainId]: { chainKey: "polygon-pos", nativeTokenKey: "matic-network" },
      [_chains_1.Chains.MOONRIVER.chainId]: { chainKey: "moonriver", nativeTokenKey: "moonriver" },
      [_chains_1.Chains.CRONOS.chainId]: { chainKey: "cronos", nativeTokenKey: "crypto-com-chain" },
      [_chains_1.Chains.AURORA.chainId]: { chainKey: "aurora", nativeTokenKey: "ethereum" },
      [_chains_1.Chains.AVALANCHE.chainId]: { chainKey: "avalanche", nativeTokenKey: "avalanche-2" },
      [_chains_1.Chains.ETHEREUM.chainId]: { chainKey: "ethereum", nativeTokenKey: "ethereum" },
      [_chains_1.Chains.HARMONY_SHARD_0.chainId]: { chainKey: "harmony-shard-0", nativeTokenKey: "harmony" },
      [_chains_1.Chains.EVMOS.chainId]: { chainKey: "evmos", nativeTokenKey: "evmos" },
      [_chains_1.Chains.BOBA.chainId]: { chainKey: "boba", nativeTokenKey: "boba-network" },
      [_chains_1.Chains.CELO.chainId]: { chainKey: "celo", nativeTokenKey: "celo" },
      [_chains_1.Chains.ASTAR.chainId]: { chainKey: "astar", nativeTokenKey: "astar" },
      [_chains_1.Chains.MOONBEAM.chainId]: { chainKey: "moonbeam", nativeTokenKey: "moonbeam" },
      [_chains_1.Chains.OASIS_EMERALD.chainId]: { chainKey: "oasis", nativeTokenKey: "oasis-network" },
      [_chains_1.Chains.ROOTSTOCK.chainId]: { chainKey: "rootstock", nativeTokenKey: "rootstock" },
      [_chains_1.Chains.VELAS.chainId]: { chainKey: "velas", nativeTokenKey: "velas" },
      [_chains_1.Chains.OKC.chainId]: { chainKey: "okex-chain", nativeTokenKey: "oec-token" },
      [_chains_1.Chains.CANTO.chainId]: { chainKey: "canto", nativeTokenKey: "canto" },
      [_chains_1.Chains.FUSE.chainId]: { chainKey: "fuse", nativeTokenKey: "fuse-network-token" },
      [_chains_1.Chains.ARBITRUM.chainId]: { chainKey: "arbitrum-one", nativeTokenKey: "ethereum" },
      [_chains_1.Chains.GNOSIS.chainId]: { chainKey: "xdai", nativeTokenKey: "xdai" },
      [_chains_1.Chains.POLYGON_ZKEVM.chainId]: { chainKey: "polygon-zkevm", nativeTokenKey: "ethereum" },
      [_chains_1.Chains.KAVA.chainId]: { chainKey: "kava", nativeTokenKey: "kava" },
      [_chains_1.Chains.BASE.chainId]: { chainKey: "base", nativeTokenKey: "ethereum" },
      [_chains_1.Chains.LINEA.chainId]: { chainKey: "linea", nativeTokenKey: "ethereum" }
    };
    var CoingeckoPriceSource = class {
      constructor(fetch2) {
        this.fetch = fetch2;
      }
      supportedQueries() {
        const support = { getCurrentPrices: true, getHistoricalPrices: false, getBulkHistoricalPrices: false };
        const entries = Object.keys(COINGECKO_CHAIN_KEYS).map(Number).map((chainId) => [chainId, support]);
        return Object.fromEntries(entries);
      }
      async getCurrentPrices({ addresses, config: config2 }) {
        const reducedTimeout = (0, timeouts_1.reduceTimeout)(config2?.timeout, "100");
        const promises = Object.entries(addresses).map(async ([chainId, addresses2]) => [
          Number(chainId),
          await (0, timeouts_1.timeoutPromise)(this.getCurrentPricesInChain(Number(chainId), addresses2, reducedTimeout), reducedTimeout)
        ]);
        return Object.fromEntries(await (0, utils_1.filterRejectedResults)(promises));
      }
      getHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
      getBulkHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
      async getCurrentPricesInChain(chainId, addresses, timeout) {
        const addressesWithoutNativeToken = addresses.filter((address) => !(0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN));
        const [erc20LowerCased, nativePrice] = await Promise.all([
          this.fetchERC20Prices(chainId, addressesWithoutNativeToken, timeout),
          addressesWithoutNativeToken.length !== addresses.length ? this.fetchNativePrice(chainId, timeout) : void 0
        ]);
        if (nativePrice) {
          erc20LowerCased[constants_1.Addresses.NATIVE_TOKEN.toLowerCase()] = nativePrice;
        }
        return Object.fromEntries(addresses.map((address) => [address, erc20LowerCased[address.toLowerCase()]]));
      }
      async fetchNativePrice(chainId, timeout) {
        const { nativeTokenKey } = COINGECKO_CHAIN_KEYS[chainId];
        const url = `https://api.coingecko.com/api/v3/simple/price?ids=${nativeTokenKey}&vs_currencies=usd&include_last_updated_at=true`;
        const response = await this.fetch.fetch(url, { timeout, headers: { Accept: "application/json" } });
        const body = await response.json();
        return { price: body[nativeTokenKey].usd, closestTimestamp: body[nativeTokenKey].last_updated_at };
      }
      async fetchERC20Prices(chainId, addresses, timeout) {
        if (addresses.length === 0)
          return {};
        const url = `https://api.coingecko.com/api/v3/simple/token_price/${COINGECKO_CHAIN_KEYS[chainId].chainKey}?contract_addresses=${addresses.join(",")}&vs_currencies=usd&include_last_updated_at=true`;
        const response = await this.fetch.fetch(url, { timeout });
        const body = await response.json();
        const entries = Object.entries(body).map(([token2, { usd, last_updated_at }]) => [
          token2.toLowerCase(),
          { price: usd, timestamp: last_updated_at }
        ]);
        return Object.fromEntries(entries);
      }
    };
    exports.CoingeckoPriceSource = CoingeckoPriceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/portals-fi-price-source.js
var require_portals_fi_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/portals-fi-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PortalsFiPriceSource = void 0;
    var portals_fi_1 = require_portals_fi();
    var utils_1 = require_utils17();
    var PortalsFiPriceSource = class {
      constructor(fetch2) {
        this.portalsFi = new portals_fi_1.PortalsFiClient(fetch2);
      }
      supportedQueries() {
        const support = { getCurrentPrices: true, getHistoricalPrices: false, getBulkHistoricalPrices: false };
        const entries = this.portalsFi.supportedChains().map((chainId) => [chainId, support]);
        return Object.fromEntries(entries);
      }
      async getCurrentPrices(params) {
        const result = {};
        const data = await this.portalsFi.getData(params);
        for (const [chainIdString, tokens] of Object.entries(data)) {
          const chainId = Number(chainIdString);
          result[chainId] = {};
          for (const [address, token2] of Object.entries(tokens)) {
            result[chainId][address] = { price: token2.price, closestTimestamp: (0, utils_1.nowInSeconds)() };
          }
        }
        return result;
      }
      getHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
      getBulkHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
    };
    exports.PortalsFiPriceSource = PortalsFiPriceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/moralis-price-source.js
var require_moralis_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/moralis-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MoralisPriceSource = void 0;
    var _chains_1 = require_chains();
    var utils_1 = require_utils13();
    var constants_1 = require_constants();
    var timeouts_1 = require_timeouts();
    var utils_2 = require_utils17();
    var SUPPORTED_CHAINS = [_chains_1.Chains.ETHEREUM, _chains_1.Chains.POLYGON, _chains_1.Chains.BNB_CHAIN, _chains_1.Chains.AVALANCHE, _chains_1.Chains.FANTOM, _chains_1.Chains.ARBITRUM, _chains_1.Chains.CRONOS];
    var MoralisPriceSource = class {
      constructor(fetchService, apiKey) {
        this.fetchService = fetchService;
        this.apiKey = apiKey;
      }
      supportedQueries() {
        const support = { getCurrentPrices: true, getHistoricalPrices: false, getBulkHistoricalPrices: false };
        const entries = SUPPORTED_CHAINS.map(({ chainId }) => chainId).map((chainId) => [chainId, support]);
        return Object.fromEntries(entries);
      }
      async getCurrentPrices({ addresses, config: config2 }) {
        const result = Object.fromEntries(Object.keys(addresses).map((chainId) => [Number(chainId), {}]));
        const reducedTimeout = (0, timeouts_1.reduceTimeout)(config2?.timeout, "100");
        const promises = Object.entries(addresses).flatMap(([chainId, addresses2]) => addresses2.map((address) => ({ chainId: Number(chainId), address }))).map(async ({ chainId, address }) => {
          const price = await this.fetchPrice(Number(chainId), address, { timeout: reducedTimeout });
          if (price) {
            result[chainId][address] = price;
          }
        });
        await Promise.allSettled(promises);
        return result;
      }
      getHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
      getBulkHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
      async fetchPrice(chainId, address, config2) {
        const addressToFetch = (0, utils_1.isSameAddress)(address, constants_1.Addresses.NATIVE_TOKEN) ? (0, _chains_1.getChainByKey)(chainId)?.wToken : address;
        if (!addressToFetch)
          return void 0;
        const body = await this.fetch(`https://deep-index.moralis.io/api/v2/erc20/${addressToFetch.toLowerCase()}/price?chain=${chainIdToValidChain(chainId)}`, config2?.timeout);
        return { price: body.usdPrice, closestTimestamp: (0, utils_2.nowInSeconds)() };
      }
      async fetch(url, timeout) {
        const response = await this.fetchService.fetch(url, {
          headers: { "X-API-Key": this.apiKey },
          timeout
        });
        return response.json();
      }
    };
    exports.MoralisPriceSource = MoralisPriceSource;
    function chainIdToValidChain(chainId) {
      return (0, utils_1.toTrimmedHex)(chainId);
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/prioritized-price-source.js
var require_prioritized_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/prioritized-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrioritizedPriceSource = void 0;
    var timeouts_1 = require_timeouts();
    var utils_1 = require_utils17();
    var PrioritizedPriceSource = class {
      constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
          throw new Error("No sources were specified");
      }
      supportedQueries() {
        return (0, utils_1.combineSupport)(this.sources);
      }
      async getCurrentPrices({ addresses, config: config2 }) {
        return executePrioritized({
          allSources: this.sources,
          fullRequest: addresses,
          query: "getCurrentPrices",
          addressesFromRequest: (request) => request,
          getResult: (source, filteredRequest, sourceTimeout) => source.getCurrentPrices({
            addresses: filteredRequest,
            config: { timeout: sourceTimeout }
          }),
          timeout: config2?.timeout
        });
      }
      getHistoricalPrices({ addresses, timestamp, searchWidth, config: config2 }) {
        return executePrioritized({
          allSources: this.sources,
          fullRequest: addresses,
          query: "getHistoricalPrices",
          addressesFromRequest: (request) => request,
          getResult: (source, filteredRequest, sourceTimeout) => source.getHistoricalPrices({
            addresses: filteredRequest,
            timestamp,
            searchWidth,
            config: { timeout: sourceTimeout }
          }),
          timeout: config2?.timeout
        });
      }
      getBulkHistoricalPrices({ addresses, searchWidth, config: config2 }) {
        return executePrioritized({
          allSources: this.sources,
          fullRequest: addresses,
          query: "getBulkHistoricalPrices",
          addressesFromRequest: (request) => request.map(({ token: token2 }) => token2),
          getResult: (source, filteredRequest, sourceTimeout) => source.getBulkHistoricalPrices({
            addresses: filteredRequest,
            searchWidth,
            config: { timeout: sourceTimeout }
          }),
          timeout: config2?.timeout
        });
      }
    };
    exports.PrioritizedPriceSource = PrioritizedPriceSource;
    async function executePrioritized({ allSources, fullRequest, query, getResult: getResult2, addressesFromRequest, timeout }) {
      const sourcesInChains = (0, utils_1.getSourcesThatSupportRequestOrFail)(fullRequest, allSources, query);
      const addressesPerChain = Object.fromEntries(Object.entries(fullRequest).map(([chainId, request]) => [chainId, addressesFromRequest(request)]));
      const reducedTimeout = (0, timeouts_1.reduceTimeout)(timeout, "100");
      return new Promise(async (resolve) => {
        const result = {};
        const fetchPromises = sourcesInChains.map(
          (source) => (0, timeouts_1.timeoutPromise)(getResult2(source, (0, utils_1.filterRequestForSource)(fullRequest, query, source), reducedTimeout), reducedTimeout, {
            description: "Timeouted while executing a prioritized price query"
          }).catch(() => ({}))
        );
        let i = 0;
        while (!(0, utils_1.doesResponseFulfillRequest)(result, addressesPerChain) && i < fetchPromises.length) {
          const response = await fetchPromises[i];
          (0, utils_1.fillResponseWithNewResult)(result, response);
          i++;
        }
        resolve(result);
      });
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/fastest-price-source.js
var require_fastest_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/fastest-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FastestPriceSource = void 0;
    var timeouts_1 = require_timeouts();
    var utils_1 = require_utils17();
    var FastestPriceSource = class {
      constructor(sources) {
        this.sources = sources;
        if (sources.length === 0)
          throw new Error("No sources were specified");
      }
      supportedQueries() {
        return (0, utils_1.combineSupport)(this.sources);
      }
      getCurrentPrices({ addresses, config: config2 }) {
        return executeFastest({
          allSources: this.sources,
          fullRequest: addresses,
          query: "getCurrentPrices",
          addressesFromRequest: (addresses2) => addresses2,
          getResult: (source, filteredRequest, sourceTimeout) => source.getCurrentPrices({
            addresses: filteredRequest,
            config: { timeout: sourceTimeout }
          }),
          timeout: config2?.timeout
        });
      }
      getHistoricalPrices({ addresses, timestamp, searchWidth, config: config2 }) {
        return executeFastest({
          allSources: this.sources,
          fullRequest: addresses,
          query: "getHistoricalPrices",
          addressesFromRequest: (addresses2) => addresses2,
          getResult: (source, filteredRequest, sourceTimeout) => source.getHistoricalPrices({
            addresses: filteredRequest,
            timestamp,
            searchWidth,
            config: { timeout: sourceTimeout }
          }),
          timeout: config2?.timeout
        });
      }
      getBulkHistoricalPrices({ addresses, searchWidth, config: config2 }) {
        return executeFastest({
          allSources: this.sources,
          fullRequest: addresses,
          query: "getBulkHistoricalPrices",
          addressesFromRequest: (request) => request.map(({ token: token2 }) => token2),
          getResult: (source, filteredRequest, sourceTimeout) => source.getBulkHistoricalPrices({
            addresses: filteredRequest,
            searchWidth,
            config: { timeout: sourceTimeout }
          }),
          timeout: config2?.timeout
        });
      }
    };
    exports.FastestPriceSource = FastestPriceSource;
    async function executeFastest({ allSources, fullRequest, query, getResult: getResult2, addressesFromRequest, timeout }) {
      const sourcesInChains = (0, utils_1.getSourcesThatSupportRequestOrFail)(fullRequest, allSources, query);
      const reducedTimeout = (0, timeouts_1.reduceTimeout)(timeout, "100");
      const addressesPerChain = Object.fromEntries(Object.entries(fullRequest).map(([chainId, request]) => [chainId, addressesFromRequest(request)]));
      return new Promise(async (resolve) => {
        const result = {};
        const allPromises = sourcesInChains.map((source) => (0, timeouts_1.timeoutPromise)(getResult2(source, (0, utils_1.filterRequestForSource)(fullRequest, query, source), reducedTimeout), reducedTimeout).then((response) => {
          (0, utils_1.fillResponseWithNewResult)(result, response);
          if ((0, utils_1.doesResponseFulfillRequest)(result, addressesPerChain)) {
            resolve(result);
          }
        }));
        Promise.allSettled(allPromises).then(() => {
          if (!(0, utils_1.doesResponseFulfillRequest)(result, addressesPerChain)) {
            resolve(result);
          }
        });
      });
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/aggregator-price-source.js
var require_aggregator_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/aggregator-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AggregatorPriceSource = void 0;
    var timeouts_1 = require_timeouts();
    var utils_1 = require_utils13();
    var utils_2 = require_utils17();
    var AggregatorPriceSource = class {
      constructor(sources, method) {
        this.sources = sources;
        this.method = method;
        if (sources.length === 0)
          throw new Error("No sources were specified");
      }
      supportedQueries() {
        return (0, utils_2.combineSupport)(this.sources);
      }
      async getCurrentPrices({ addresses, config: config2 }) {
        const collected = await collectAllResults({
          allSources: this.sources,
          fullRequest: addresses,
          query: "getCurrentPrices",
          getResult: (source, filteredRequest, sourceTimeout) => source.getCurrentPrices({
            addresses: filteredRequest,
            config: { timeout: sourceTimeout }
          }),
          timeout: config2?.timeout
        });
        return this.aggregate(collected, aggregatePrices);
      }
      async getHistoricalPrices({ addresses, timestamp, searchWidth, config: config2 }) {
        const collected = await collectAllResults({
          allSources: this.sources,
          fullRequest: addresses,
          query: "getHistoricalPrices",
          getResult: (source, filteredRequest, sourceTimeout) => source.getHistoricalPrices({
            addresses: filteredRequest,
            timestamp,
            searchWidth,
            config: { timeout: sourceTimeout }
          }),
          timeout: config2?.timeout
        });
        return this.aggregate(collected, aggregatePrices);
      }
      async getBulkHistoricalPrices({ addresses, searchWidth, config: config2 }) {
        const collected = await collectAllResults({
          allSources: this.sources,
          fullRequest: addresses,
          query: "getBulkHistoricalPrices",
          getResult: (source, filteredRequest, sourceTimeout) => source.getBulkHistoricalPrices({
            addresses: filteredRequest,
            searchWidth,
            config: { timeout: sourceTimeout }
          }),
          timeout: config2?.timeout
        });
        return this.aggregate(collected, aggregateBulkHistoricalPrices);
      }
      aggregate(collected, aggregate) {
        const result = {};
        for (const chainId in collected) {
          result[chainId] = {};
          for (const address in collected[chainId]) {
            result[chainId][address] = aggregate(collected[chainId][address], this.method);
          }
        }
        return result;
      }
    };
    exports.AggregatorPriceSource = AggregatorPriceSource;
    async function collectAllResults({ allSources, fullRequest, query, getResult: getResult2, timeout }) {
      const sourcesInChains = (0, utils_2.getSourcesThatSupportRequestOrFail)(fullRequest, allSources, query);
      const reducedTimeout = (0, timeouts_1.reduceTimeout)(timeout, "100");
      const promises = sourcesInChains.map((source) => (0, timeouts_1.timeoutPromise)(getResult2(source, (0, utils_2.filterRequestForSource)(fullRequest, query, source), reducedTimeout), reducedTimeout, {
        description: "Timeouted while executing an aggregated price query"
      }));
      const results = await (0, utils_1.filterRejectedResults)(promises);
      return collect(results);
    }
    function collect(results) {
      const collected = {};
      for (const result of results) {
        for (const chainId in result) {
          if (!(chainId in collected)) {
            collected[chainId] = {};
          }
          for (const address in result[chainId]) {
            if (!(address in collected[chainId])) {
              collected[chainId][address] = [];
            }
            if (typeof result?.[chainId]?.[address] !== "undefined") {
              collected[chainId][address].push(result[chainId][address]);
            }
          }
        }
      }
      return collected;
    }
    function aggregatePrices(results, method) {
      const sorted = results.sort((a, b) => a.price - b.price);
      switch (method) {
        case "median":
          if (sorted.length > 0 && sorted.length % 2 === 0) {
            const middleLow = sorted[sorted.length / 2 - 1];
            const middleHigh = sorted[sorted.length / 2];
            return {
              price: (middleLow.price + middleHigh.price) / 2,
              closestTimestamp: (middleLow.closestTimestamp + middleHigh.closestTimestamp) / 2
            };
          } else {
            return sorted[Math.floor(sorted.length / 2)];
          }
        case "avg":
          const sumPrice = sumAll(results.map(({ price }) => price));
          const sumTimestamp = sumAll(results.map(({ closestTimestamp: timestamp }) => timestamp));
          return {
            price: sumPrice / results.length,
            closestTimestamp: sumTimestamp / results.length
          };
        case "max":
          return sorted[sorted.length - 1];
        case "min":
          return sorted[0];
      }
    }
    function aggregateBulkHistoricalPrices(results, method) {
      const allTimestamps = [...new Set(results.flatMap((result) => Object.keys(result)))].map(Number);
      const collectedByTimestamp = allTimestamps.map((timestamp) => ({ timestamp, results: extractResultInTimestamp(timestamp, results) }));
      return Object.fromEntries(collectedByTimestamp.map(({ timestamp, results: results2 }) => [timestamp, aggregatePrices(results2, method)]));
    }
    function extractResultInTimestamp(timestamp, results) {
      return results.filter((result) => timestamp in result).map((result) => result[timestamp]);
    }
    function sumAll(array) {
      return array.reduce((accum, curr) => accum + curr, 0);
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/mean-finance-price-source.js
var require_mean_finance_price_source = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/price-sources/mean-finance-price-source.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeanFinancePriceSource = void 0;
    var utils_1 = require_utils13();
    var mean_finance_quote_source_1 = require_mean_finance_quote_source();
    var _chains_1 = require_chains();
    var utils_2 = require_utils17();
    var MeanFinancePriceSource = class {
      constructor(fetch2) {
        this.fetch = fetch2;
      }
      supportedQueries() {
        const support = { getCurrentPrices: true, getHistoricalPrices: false, getBulkHistoricalPrices: false };
        const entries = mean_finance_quote_source_1.MEAN_FINANCE_SUPPORTED_CHAINS.filter((chainId) => chainId !== _chains_1.Chains.BASE_GOERLI.chainId).map((chainId) => [chainId, support]);
        return Object.fromEntries(entries);
      }
      async getCurrentPrices({ addresses, config: config2 }) {
        const tokens = Object.entries(addresses).flatMap(([chainId, addresses2]) => addresses2.map((address) => (0, utils_1.toTokenInChain)(Number(chainId), address)));
        const response = await this.fetch.fetch("https://api.mean.finance/v1/prices", {
          body: JSON.stringify({ tokens }),
          method: "POST",
          timeout: config2?.timeout
        });
        const body = await response.json();
        const result = {};
        for (const [tokenInChain, price] of Object.entries(body.tokens)) {
          const { chainId, address } = (0, utils_1.fromTokenInChain)(tokenInChain);
          if (!(chainId in result))
            result[chainId] = {};
          result[chainId][address] = { price, closestTimestamp: (0, utils_2.nowInSeconds)() };
        }
        return result;
      }
      getHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
      getBulkHistoricalPrices(_) {
        return Promise.reject(new Error("Operation not supported"));
      }
    };
    exports.MeanFinancePriceSource = MeanFinancePriceSource;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/price-builder.js
var require_price_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/price-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildPriceService = void 0;
    var defi_llama_price_source_1 = require_defi_llama_price_source();
    var price_service_1 = require_price_service();
    var cached_price_source_1 = require_cached_price_source();
    var odos_price_source_1 = require_odos_price_source();
    var coingecko_price_source_1 = require_coingecko_price_source();
    var portals_fi_price_source_1 = require_portals_fi_price_source();
    var moralis_price_source_1 = require_moralis_price_source();
    var prioritized_price_source_1 = require_prioritized_price_source();
    var fastest_price_source_1 = require_fastest_price_source();
    var aggregator_price_source_1 = require_aggregator_price_source();
    var mean_finance_price_source_1 = require_mean_finance_price_source();
    function buildPriceService(params, fetchService) {
      const source = buildSource(params?.source, { fetchService });
      return new price_service_1.PriceService(source);
    }
    exports.buildPriceService = buildPriceService;
    function buildSource(source, { fetchService }) {
      const coingecko = new coingecko_price_source_1.CoingeckoPriceSource(fetchService);
      const defiLlama = new defi_llama_price_source_1.DefiLlamaPriceSource(fetchService);
      const portalsFi = new portals_fi_price_source_1.PortalsFiPriceSource(fetchService);
      switch (source?.type) {
        case void 0:
          return new prioritized_price_source_1.PrioritizedPriceSource([coingecko, portalsFi, defiLlama]);
        case "defi-llama":
          return defiLlama;
        case "odos":
          return new odos_price_source_1.OdosPriceSource(fetchService);
        case "portals-fi":
          return portalsFi;
        case "mean-finance":
          return new mean_finance_price_source_1.MeanFinancePriceSource(fetchService);
        case "moralis":
          return new moralis_price_source_1.MoralisPriceSource(fetchService, source.key);
        case "coingecko":
          return coingecko;
        case "cached":
          const underlying = buildSource(source.underlyingSource, { fetchService });
          return new cached_price_source_1.CachedPriceSource(underlying, source.config);
        case "prioritized":
          return new prioritized_price_source_1.PrioritizedPriceSource(source.sources.map((source2) => buildSource(source2, { fetchService })));
        case "fastest":
          return new fastest_price_source_1.FastestPriceSource(source.sources.map((source2) => buildSource(source2, { fetchService })));
        case "aggregate":
          return new aggregator_price_source_1.AggregatorPriceSource(source.sources.map((source2) => buildSource(source2, { fetchService })), source.by);
        case "custom":
          return source.instance;
      }
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/abis/permit2-adapter.js
var require_permit2_adapter = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/abis/permit2-adapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = [
      { inputs: [{ internalType: "contract IPermit2", name: "_permit2", type: "address" }], stateMutability: "nonpayable", type: "constructor" },
      { inputs: [{ internalType: "address", name: "target", type: "address" }], name: "AddressEmptyCode", type: "error" },
      { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "AddressInsufficientBalance", type: "error" },
      { inputs: [], name: "FailedInnerCall", type: "error" },
      {
        inputs: [
          { internalType: "uint256", name: "received", type: "uint256" },
          { internalType: "uint256", name: "expected", type: "uint256" }
        ],
        name: "InvalidNativeAmount",
        type: "error"
      },
      {
        inputs: [
          { internalType: "uint256", name: "received", type: "uint256" },
          { internalType: "uint256", name: "expected", type: "uint256" }
        ],
        name: "ReceivedTooLittleTokenOut",
        type: "error"
      },
      { inputs: [{ internalType: "address", name: "token", type: "address" }], name: "SafeERC20FailedOperation", type: "error" },
      {
        inputs: [
          {
            components: [
              { internalType: "bool", name: "success", type: "bool" },
              { internalType: "bytes", name: "result", type: "bytes" },
              { internalType: "uint256", name: "gasSpent", type: "uint256" }
            ],
            internalType: "struct ISimulationAdapter.SimulationResult",
            name: "result",
            type: "tuple"
          }
        ],
        name: "SimulatedCall",
        type: "error"
      },
      {
        inputs: [
          { internalType: "uint256", name: "current", type: "uint256" },
          { internalType: "uint256", name: "deadline", type: "uint256" }
        ],
        name: "TransactionDeadlinePassed",
        type: "error"
      },
      {
        inputs: [],
        name: "NATIVE_TOKEN",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PERMIT2",
        outputs: [{ internalType: "contract IPermit2", name: "", type: "address" }],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              { internalType: "uint256", name: "deadline", type: "uint256" },
              { internalType: "address", name: "tokenIn", type: "address" },
              { internalType: "uint256", name: "maxAmountIn", type: "uint256" },
              { internalType: "uint256", name: "nonce", type: "uint256" },
              { internalType: "bytes", name: "signature", type: "bytes" },
              { internalType: "address", name: "allowanceTarget", type: "address" },
              { internalType: "address", name: "swapper", type: "address" },
              { internalType: "bytes", name: "swapData", type: "bytes" },
              { internalType: "address", name: "tokenOut", type: "address" },
              { internalType: "uint256", name: "amountOut", type: "uint256" },
              {
                components: [
                  { internalType: "address", name: "recipient", type: "address" },
                  { internalType: "uint256", name: "shareBps", type: "uint256" }
                ],
                internalType: "struct Token.DistributionTarget[]",
                name: "transferOut",
                type: "tuple[]"
              },
              { internalType: "address", name: "unspentTokenInRecipient", type: "address" }
            ],
            internalType: "struct ISwapPermit2Adapter.BuyOrderSwapParams",
            name: "_params",
            type: "tuple"
          }
        ],
        name: "buyOrderSwap",
        outputs: [
          { internalType: "uint256", name: "_amountIn", type: "uint256" },
          { internalType: "uint256", name: "_amountOut", type: "uint256" }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                components: [
                  { internalType: "address", name: "token", type: "address" },
                  { internalType: "uint256", name: "amount", type: "uint256" }
                ],
                internalType: "struct IPermit2.TokenPermissions[]",
                name: "tokens",
                type: "tuple[]"
              },
              { internalType: "uint256", name: "nonce", type: "uint256" },
              { internalType: "bytes", name: "signature", type: "bytes" }
            ],
            internalType: "struct IArbitraryExecutionPermit2Adapter.BatchPermit",
            name: "_batchPermit",
            type: "tuple"
          },
          {
            components: [
              { internalType: "address", name: "token", type: "address" },
              { internalType: "address", name: "allowanceTarget", type: "address" }
            ],
            internalType: "struct IArbitraryExecutionPermit2Adapter.AllowanceTarget[]",
            name: "_allowanceTargets",
            type: "tuple[]"
          },
          {
            components: [
              { internalType: "address", name: "target", type: "address" },
              { internalType: "bytes", name: "data", type: "bytes" },
              { internalType: "uint256", name: "value", type: "uint256" }
            ],
            internalType: "struct IArbitraryExecutionPermit2Adapter.ContractCall[]",
            name: "_contractCalls",
            type: "tuple[]"
          },
          {
            components: [
              { internalType: "address", name: "token", type: "address" },
              {
                components: [
                  { internalType: "address", name: "recipient", type: "address" },
                  { internalType: "uint256", name: "shareBps", type: "uint256" }
                ],
                internalType: "struct Token.DistributionTarget[]",
                name: "distribution",
                type: "tuple[]"
              }
            ],
            internalType: "struct IArbitraryExecutionPermit2Adapter.TransferOut[]",
            name: "_transferOut",
            type: "tuple[]"
          },
          { internalType: "uint256", name: "_deadline", type: "uint256" }
        ],
        name: "executeWithBatchPermit",
        outputs: [
          { internalType: "bytes[]", name: "_executionResults", type: "bytes[]" },
          { internalType: "uint256[]", name: "_tokenBalances", type: "uint256[]" }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              { internalType: "address", name: "token", type: "address" },
              { internalType: "uint256", name: "amount", type: "uint256" },
              { internalType: "uint256", name: "nonce", type: "uint256" },
              { internalType: "bytes", name: "signature", type: "bytes" }
            ],
            internalType: "struct IArbitraryExecutionPermit2Adapter.SinglePermit",
            name: "_permit",
            type: "tuple"
          },
          {
            components: [
              { internalType: "address", name: "token", type: "address" },
              { internalType: "address", name: "allowanceTarget", type: "address" }
            ],
            internalType: "struct IArbitraryExecutionPermit2Adapter.AllowanceTarget[]",
            name: "_allowanceTargets",
            type: "tuple[]"
          },
          {
            components: [
              { internalType: "address", name: "target", type: "address" },
              { internalType: "bytes", name: "data", type: "bytes" },
              { internalType: "uint256", name: "value", type: "uint256" }
            ],
            internalType: "struct IArbitraryExecutionPermit2Adapter.ContractCall[]",
            name: "_contractCalls",
            type: "tuple[]"
          },
          {
            components: [
              { internalType: "address", name: "token", type: "address" },
              {
                components: [
                  { internalType: "address", name: "recipient", type: "address" },
                  { internalType: "uint256", name: "shareBps", type: "uint256" }
                ],
                internalType: "struct Token.DistributionTarget[]",
                name: "distribution",
                type: "tuple[]"
              }
            ],
            internalType: "struct IArbitraryExecutionPermit2Adapter.TransferOut[]",
            name: "_transferOut",
            type: "tuple[]"
          },
          { internalType: "uint256", name: "_deadline", type: "uint256" }
        ],
        name: "executeWithPermit",
        outputs: [
          { internalType: "bytes[]", name: "_executionResults", type: "bytes[]" },
          { internalType: "uint256[]", name: "_tokenBalances", type: "uint256[]" }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              { internalType: "uint256", name: "deadline", type: "uint256" },
              { internalType: "address", name: "tokenIn", type: "address" },
              { internalType: "uint256", name: "amountIn", type: "uint256" },
              { internalType: "uint256", name: "nonce", type: "uint256" },
              { internalType: "bytes", name: "signature", type: "bytes" },
              { internalType: "address", name: "allowanceTarget", type: "address" },
              { internalType: "address", name: "swapper", type: "address" },
              { internalType: "bytes", name: "swapData", type: "bytes" },
              { internalType: "address", name: "tokenOut", type: "address" },
              { internalType: "uint256", name: "minAmountOut", type: "uint256" },
              {
                components: [
                  { internalType: "address", name: "recipient", type: "address" },
                  { internalType: "uint256", name: "shareBps", type: "uint256" }
                ],
                internalType: "struct Token.DistributionTarget[]",
                name: "transferOut",
                type: "tuple[]"
              }
            ],
            internalType: "struct ISwapPermit2Adapter.SellOrderSwapParams",
            name: "_params",
            type: "tuple"
          }
        ],
        name: "sellOrderSwap",
        outputs: [
          { internalType: "uint256", name: "_amountIn", type: "uint256" },
          { internalType: "uint256", name: "_amountOut", type: "uint256" }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [{ internalType: "bytes[]", name: "_calls", type: "bytes[]" }],
        name: "simulate",
        outputs: [
          {
            components: [
              { internalType: "bool", name: "success", type: "bool" },
              { internalType: "bytes", name: "result", type: "bytes" },
              { internalType: "uint256", name: "gasSpent", type: "uint256" }
            ],
            internalType: "struct ISimulationAdapter.SimulationResult[]",
            name: "_results",
            type: "tuple[]"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [{ internalType: "bytes", name: "_call", type: "bytes" }],
        name: "simulateAndRevert",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [{ internalType: "bytes4", name: "_interfaceId", type: "bytes4" }],
        name: "supportsInterface",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function"
      },
      { stateMutability: "payable", type: "receive" }
    ];
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/permit2/utils/config.js
var require_config = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/permit2/utils/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PERMIT2_SUPPORTED_CHAINS = exports.WORDS_FOR_NONCE_CALCULATION = exports.PERMIT2_ADAPTER_ADDRESS = exports.PERMIT2_ADDRESS = void 0;
    var _chains_1 = require_chains();
    exports.PERMIT2_ADDRESS = "0x000000000022d473030f116ddee9f6b43ac78ba3";
    exports.PERMIT2_ADAPTER_ADDRESS = "0xA70C8401C058B6198e1cb085091DE13498CEc0dC";
    exports.WORDS_FOR_NONCE_CALCULATION = 10;
    exports.PERMIT2_SUPPORTED_CHAINS = [
      _chains_1.Chains.ETHEREUM,
      _chains_1.Chains.POLYGON,
      _chains_1.Chains.BNB_CHAIN,
      _chains_1.Chains.AVALANCHE,
      _chains_1.Chains.FANTOM,
      _chains_1.Chains.ARBITRUM,
      _chains_1.Chains.OPTIMISM,
      _chains_1.Chains.BASE_GOERLI,
      _chains_1.Chains.MOONRIVER,
      _chains_1.Chains.MOONBEAM,
      _chains_1.Chains.FUSE,
      _chains_1.Chains.EVMOS,
      _chains_1.Chains.CELO,
      _chains_1.Chains.GNOSIS,
      _chains_1.Chains.KAVA,
      _chains_1.Chains.POLYGON_ZKEVM,
      _chains_1.Chains.HECO,
      _chains_1.Chains.OKC
    ].map(({ chainId }) => chainId);
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/permit2/permit2-arbitrary-service.js
var require_permit2_arbitrary_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/permit2/permit2-arbitrary-service.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Permit2ArbitraryService = void 0;
    var viem_1 = require_cjs2();
    var utils_1 = require_utils13();
    var permit2_adapter_1 = __importDefault(require_permit2_adapter());
    var config_1 = require_config();
    var Permit2ArbitraryService = class {
      constructor(permit2Service) {
        this.permit2Service = permit2Service;
        this.contractAddress = config_1.PERMIT2_ADAPTER_ADDRESS;
      }
      preparePermitData(args) {
        return this.permit2Service.preparePermitData({ ...args, spender: config_1.PERMIT2_ADAPTER_ADDRESS });
      }
      prepareBatchPermitData(args) {
        return this.permit2Service.prepareBatchPermitData({ ...args, spender: config_1.PERMIT2_ADAPTER_ADDRESS });
      }
      buildArbitraryCallWithPermit(params) {
        return this.buildArbitraryCallInternal({
          ...params,
          functionName: "executeWithPermit"
        });
      }
      buildArbitraryCallWithBatchPermit(params) {
        return this.buildArbitraryCallInternal({
          ...params,
          functionName: "executeWithBatchPermit"
        });
      }
      buildArbitraryCallWithoutPermit(params) {
        const permitData = {
          tokens: [],
          nonce: 0,
          signature: "0x",
          deadline: (0, utils_1.calculateDeadline)(params.txValidFor)
        };
        return this.buildArbitraryCallInternal({
          ...params,
          permitData,
          functionName: "executeWithBatchPermit"
        });
      }
      buildArbitraryCallInternal({ permitData: { deadline, ...permitData }, calls, allowanceTargets, distribution, functionName }) {
        if (calls.length === 0)
          throw new Error("Must submit at least one call");
        const repeatedToken = findRepeatedKey(distribution ?? {});
        if (repeatedToken)
          throw new Error(`Found token '${repeatedToken}' more than once, with different casing`);
        const allowances = allowanceTargets?.map(({ token: token2, target }) => ({ token: token2, allowanceTarget: target })) ?? [];
        const encodedCalls = calls.map((call2) => "data" in call2 ? {
          target: call2.to,
          data: call2.data,
          value: call2.value ?? 0
        } : {
          target: call2.address,
          data: (0, viem_1.encodeFunctionData)({
            abi: "json" in call2.abi ? call2.abi.json : (0, viem_1.parseAbi)(call2.abi.humanReadable),
            functionName: call2.functionName,
            args: call2.args ?? []
          }),
          value: call2.value ?? 0
        });
        const transferOut = Object.entries(distribution ?? {}).map(([token2, distribution2]) => ({ token: token2, distribution: distribution2 }));
        const totalValue = calls.reduce((sum, { value }) => sum + BigInt(value ?? 0), 0n);
        const data = (0, viem_1.encodeFunctionData)({
          abi: permit2_adapter_1.default,
          functionName,
          args: [permitData, allowances, encodedCalls, transferOut, deadline]
        });
        return {
          to: config_1.PERMIT2_ADAPTER_ADDRESS,
          data,
          value: totalValue.toString()
        };
      }
    };
    exports.Permit2ArbitraryService = Permit2ArbitraryService;
    function findRepeatedKey(object) {
      const keys = /* @__PURE__ */ new Set();
      for (const key in object) {
        const lower = key.toLowerCase();
        if (keys.has(lower)) {
          return key;
        }
        keys.add(lower);
      }
      return void 0;
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/permit2/utils/eip712-types.js
var require_eip712_types = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/permit2/utils/eip712-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PERMIT2_BATCH_TRANSFER_FROM_TYPES = exports.PERMIT2_TRANSFER_FROM_TYPES = void 0;
    exports.PERMIT2_TRANSFER_FROM_TYPES = {
      PermitTransferFrom: [
        { type: "TokenPermissions", name: "permitted" },
        { type: "address", name: "spender" },
        { type: "uint256", name: "nonce" },
        { type: "uint256", name: "deadline" }
      ],
      TokenPermissions: [
        { type: "address", name: "token" },
        { type: "uint256", name: "amount" }
      ]
    };
    exports.PERMIT2_BATCH_TRANSFER_FROM_TYPES = {
      PermitBatchTransferFrom: [
        { type: "TokenPermissions[]", name: "permitted" },
        { type: "address", name: "spender" },
        { type: "uint256", name: "nonce" },
        { type: "uint256", name: "deadline" }
      ],
      TokenPermissions: [
        { type: "address", name: "token" },
        { type: "uint256", name: "amount" }
      ]
    };
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/abis/permit2.js
var require_permit2 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/abis/permit2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PERMIT2_ABI = void 0;
    exports.PERMIT2_ABI = ["function nonceBitmap(address, uint256) view returns(uint256)"];
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/source-lists/index.js
var require_source_lists = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/source-lists/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/quotes/index.js
var require_quotes = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/quotes/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SOURCES_METADATA = exports.compareQuotesBy = exports.chooseQuotesBy = exports.sortQuotesBy = exports.COMPARE_USING = exports.COMPARE_BY = void 0;
    var quote_compare_1 = require_quote_compare();
    Object.defineProperty(exports, "COMPARE_BY", { enumerable: true, get: function() {
      return quote_compare_1.COMPARE_BY;
    } });
    Object.defineProperty(exports, "COMPARE_USING", { enumerable: true, get: function() {
      return quote_compare_1.COMPARE_USING;
    } });
    Object.defineProperty(exports, "sortQuotesBy", { enumerable: true, get: function() {
      return quote_compare_1.sortQuotesBy;
    } });
    Object.defineProperty(exports, "chooseQuotesBy", { enumerable: true, get: function() {
      return quote_compare_1.chooseQuotesBy;
    } });
    Object.defineProperty(exports, "compareQuotesBy", { enumerable: true, get: function() {
      return quote_compare_1.compareQuotesBy;
    } });
    var source_registry_1 = require_source_registry();
    Object.defineProperty(exports, "SOURCES_METADATA", { enumerable: true, get: function() {
      return source_registry_1.SOURCES_METADATA;
    } });
    __exportStar(require_source_lists(), exports);
    __exportStar(require_errors3(), exports);
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/permit2/permit2-quote-service.js
var require_permit2_quote_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/permit2/permit2-quote-service.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Permit2QuoteService = void 0;
    var config_1 = require_config();
    var quotes_1 = require_quotes();
    var quote_service_1 = require_quote_service();
    var utils_1 = require_utils13();
    var viem_1 = require_cjs2();
    var permit2_adapter_1 = __importDefault(require_permit2_adapter());
    var constants_1 = require_constants();
    var alchemy_sdk_1 = (init_esm(), __toCommonJS(esm_exports));
    var Permit2QuoteService = class {
      constructor(permit2Service, quotesService, providerService, gasService) {
        this.permit2Service = permit2Service;
        this.quotesService = quotesService;
        this.providerService = providerService;
        this.gasService = gasService;
        this.contractAddress = config_1.PERMIT2_ADAPTER_ADDRESS;
      }
      preparePermitData(args) {
        return this.permit2Service.preparePermitData({ ...args, spender: this.contractAddress });
      }
      supportedSources() {
        const supportedChains = this.supportedChains();
        const sources = Object.entries(this.quotesService.supportedSources()).map(([sourceId, source]) => [
          sourceId,
          { ...source, supports: { ...source.supports, chains: source.supports.chains.filter((chainId) => supportedChains.includes(chainId)) } }
        ]);
        return Object.fromEntries(sources);
      }
      supportedChains() {
        return config_1.PERMIT2_SUPPORTED_CHAINS;
      }
      supportedSourcesInChain({ chainId }) {
        const sourcesInChain = Object.entries(this.supportedSources()).filter(([, source]) => source.supports.chains.includes(chainId));
        return Object.fromEntries(sourcesInChain);
      }
      supportedGasSpeeds() {
        return this.quotesService.supportedGasSpeeds();
      }
      estimateQuotes({ request, config: config2 }) {
        return this.quotesService.getQuotes({
          request: { ...request, takerAddress: this.contractAddress },
          config: config2
        }).map((promise) => promise.then((response) => (0, quote_service_1.ifNotFailed)(response, mapToUnsigned)));
      }
      async estimateAllQuotes({ request, config: config2 }) {
        const allQuotes = await this.quotesService.getAllQuotes({
          request: { ...request, takerAddress: this.contractAddress },
          config: config2
        });
        return allQuotes.map((response) => (0, quote_service_1.ifNotFailed)(response, mapToUnsigned));
      }
      async verifyAndPrepareQuotes({ chainId, quotes: estimatedQuotes, config: config2, ...quoteData }) {
        const quotes = estimatedQuotes.map((estimatedQuote) => buildRealQuote(quoteData, estimatedQuote));
        const responses = await this.verifyAndCorrect(chainId, quoteData.takerAddress, quotes);
        if (config2?.sort) {
          const successfulQuotes = responses.filter((response) => !("failed" in response));
          const failedQuotes = config2?.ignoredFailed === false ? responses.filter((response) => "failed" in response) : [];
          const sortedQuotes = (0, quotes_1.sortQuotesBy)(successfulQuotes, config2.sort.by, config2.sort.using ?? "sell/buy amounts");
          return [...sortedQuotes, ...failedQuotes];
        }
        const result = config2?.ignoredFailed === false ? responses : responses.filter((response) => !("failed" in response));
        return result;
      }
      async verifyAndCorrect(chainId, takerAddress, quotes) {
        const calls = quotes.map(({ tx }) => tx.data);
        const maxValue = quotes.reduce((max2, { tx: { value } }) => value && max2 < (BigInt(value) ?? 0n) ? BigInt(value) : max2, 0n);
        const [gasCalculator, encodedResults] = await Promise.all([
          this.gasService.getQuickGasCalculator({ chainId, config: { timeout: "2s" } }),
          this.simulate({ chainId, calls, account: takerAddress, value: maxValue })
        ]);
        const decodedResults = encodedResults.map(({ success, result, gasSpent }) => {
          const [amountIn, amountOut] = success ? (0, viem_1.decodeAbiParameters)((0, viem_1.parseAbiParameters)("uint256 amountIn, uint256 amountOut"), result) : [0n, 0n];
          return { success, gasSpent, amountIn, amountOut, rawResult: result };
        });
        return quotes.map((quote, i) => {
          const { success, amountIn, amountOut, gasSpent, rawResult } = decodedResults[i];
          if (!success) {
            return {
              failed: true,
              source: {
                id: quote.source.id,
                name: quote.source.name,
                logoURI: quote.source.logoURI
              },
              error: `Failed with ${rawResult}`
            };
          }
          const sellAmount = (0, quote_service_1.toAmountOfToken)(quote.sellToken, quote.sellToken.price, amountIn);
          const buyAmount = (0, quote_service_1.toAmountOfToken)(quote.buyToken, quote.buyToken.price, amountOut);
          const gasCost = gasCalculator.calculateGasCost({ gasEstimation: gasSpent });
          let gas = void 0;
          if (quote.gas) {
            gas = {
              estimatedGas: gasSpent.toString(),
              ...(0, quote_service_1.calculateGasDetails)(quote.gas.gasTokenSymbol, gasCost["standard"].gasCostNativeToken, quote.gas.gasTokenPrice)
            };
          }
          return { ...quote, sellAmount, buyAmount, gas };
        });
      }
      async simulate({ chainId, calls, account, value }) {
        const viemSupported = this.providerService.supportedClients()[chainId]?.viem;
        if (viemSupported) {
          const { result: result2 } = await this.providerService.getViemPublicClient({ chainId }).simulateContract({
            address: this.contractAddress,
            abi: permit2_adapter_1.default,
            functionName: "simulate",
            args: [calls],
            account,
            value: value ?? 0n
          });
          return result2;
        }
        const provider = this.providerService.getEthersProvider({ chainId });
        const contract = new alchemy_sdk_1.Contract(this.contractAddress, permit2_adapter_1.default, provider);
        const result = await contract.connect(account).callStatic.simulate(calls, { value: value ?? 0 });
        return result.map(({ success, result: result2, gasSpent }) => ({ success, result: result2, gasSpent: gasSpent.toBigInt() }));
      }
    };
    exports.Permit2QuoteService = Permit2QuoteService;
    function buildRealQuote({ takerAddress, recipient, permitData, txValidFor }, { estimatedTx, ...quote }) {
      recipient = recipient ?? takerAddress;
      const deadline = BigInt(permitData?.deadline ?? (0, utils_1.calculateDeadline)(txValidFor) ?? (0, utils_1.calculateDeadline)("1w"));
      const data = quote.type === "sell" ? (0, viem_1.encodeFunctionData)({
        abi: permit2_adapter_1.default,
        functionName: "sellOrderSwap",
        args: [
          {
            deadline,
            tokenIn: mapIfNative(quote.sellToken.address),
            amountIn: BigInt(quote.maxSellAmount.amount),
            nonce: permitData ? BigInt(permitData.nonce) : 0n,
            signature: permitData?.signature ?? "0x",
            allowanceTarget: quote.source.allowanceTarget,
            swapper: estimatedTx.to,
            swapData: estimatedTx.data,
            tokenOut: mapIfNative(quote.buyToken.address),
            minAmountOut: BigInt(quote.minBuyAmount.amount),
            transferOut: [{ recipient, shareBps: 0n }]
          }
        ]
      }) : (0, viem_1.encodeFunctionData)({
        abi: permit2_adapter_1.default,
        functionName: "buyOrderSwap",
        args: [
          {
            deadline,
            tokenIn: mapIfNative(quote.sellToken.address),
            maxAmountIn: BigInt(quote.maxSellAmount.amount),
            nonce: permitData ? BigInt(permitData.nonce) : 0n,
            signature: permitData?.signature ?? "0x",
            allowanceTarget: quote.source.allowanceTarget,
            swapper: estimatedTx.to,
            swapData: estimatedTx.data,
            tokenOut: mapIfNative(quote.buyToken.address),
            amountOut: BigInt(quote.minBuyAmount.amount),
            transferOut: [{ recipient, shareBps: 0n }],
            unspentTokenInRecipient: takerAddress
          }
        ]
      });
      return {
        ...quote,
        recipient,
        tx: {
          ...estimatedTx,
          from: takerAddress,
          to: config_1.PERMIT2_ADAPTER_ADDRESS,
          data
        }
      };
    }
    function mapToUnsigned({ recipient, tx, ...quote }) {
      return {
        ...quote,
        estimatedTx: tx
      };
    }
    function mapIfNative(token2) {
      return (0, utils_1.isSameAddress)(token2, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : token2;
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/permit2/permit2-service.js
var require_permit2_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/permit2/permit2-service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Permit2Service = void 0;
    var permit2_arbitrary_service_1 = require_permit2_arbitrary_service();
    var config_1 = require_config();
    var utils_1 = require_utils13();
    var eip712_types_1 = require_eip712_types();
    var permit2_1 = require_permit2();
    var constants_1 = require_constants();
    var permit2_quote_service_1 = require_permit2_quote_service();
    var Permit2Service = class {
      constructor(multicallService, providerService, quoteService, gasService) {
        this.multicallService = multicallService;
        this.permit2ContractAddress = config_1.PERMIT2_ADDRESS;
        this.arbitrary = new permit2_arbitrary_service_1.Permit2ArbitraryService(this);
        this.quotes = new permit2_quote_service_1.Permit2QuoteService(this, quoteService, providerService, gasService);
      }
      async calculateNonce({ chainId, appId, user }) {
        const words2 = new Array(config_1.WORDS_FOR_NONCE_CALCULATION).fill(0).map((_, i) => BigInt(appId) + BigInt(i));
        const calls = words2.map((word) => ({
          address: config_1.PERMIT2_ADDRESS,
          abi: { humanReadable: permit2_1.PERMIT2_ABI },
          functionName: "nonceBitmap",
          args: [user, word]
        }));
        const results = await this.multicallService.readOnlyMulticall({ chainId, calls });
        for (let i = 0; i < results.length; i++) {
          const result = BigInt(results[i]);
          if (result < constants_1.Uint.MAX_256) {
            return ((words2[i] << 8n) + findUnusedBit(result)).toString();
          }
        }
        throw new Error("No nonce found");
      }
      async preparePermitData({ appId, chainId, spender, token: token2, amount, signerAddress, signatureValidFor }) {
        const nonce = await this.calculateNonce({ chainId, appId, user: signerAddress });
        const deadline = (0, utils_1.calculateDeadline)(signatureValidFor).toString();
        return {
          dataToSign: {
            types: eip712_types_1.PERMIT2_TRANSFER_FROM_TYPES,
            domain: {
              name: "Permit2",
              chainId,
              verifyingContract: config_1.PERMIT2_ADDRESS
            },
            message: {
              permitted: { token: token2, amount: amount.toString() },
              spender,
              nonce,
              deadline
            },
            primaryType: "PermitTransferFrom"
          },
          permitData: {
            token: token2,
            amount: amount.toString(),
            nonce,
            deadline
          }
        };
      }
      async prepareBatchPermitData({ appId, chainId, spender, tokens, signerAddress, signatureValidFor }) {
        const nonce = await this.calculateNonce({ chainId, appId, user: signerAddress });
        const deadline = (0, utils_1.calculateDeadline)(signatureValidFor).toString();
        return {
          dataToSign: {
            types: eip712_types_1.PERMIT2_BATCH_TRANSFER_FROM_TYPES,
            domain: {
              name: "Permit2",
              chainId,
              verifyingContract: config_1.PERMIT2_ADDRESS
            },
            message: {
              permitted: Object.entries(tokens).map(([token2, amount]) => ({ token: token2, amount: amount.toString() })),
              spender,
              nonce,
              deadline
            },
            primaryType: "PermitBatchTransferFrom"
          },
          permitData: {
            nonce,
            deadline,
            tokens: Object.entries(tokens).map(([token2, amount]) => ({ token: token2, amount: amount.toString() }))
          }
        };
      }
    };
    exports.Permit2Service = Permit2Service;
    function findUnusedBit(value) {
      const binaryString = value.toString(2).padStart(256, "0");
      for (let i = 0; i < 256; i++) {
        if (binaryString[binaryString.length - 1 - i] === "0") {
          return BigInt(i);
        }
      }
      throw new Error("Expected to find an unused bit");
    }
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/permit2-builder.js
var require_permit2_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/permit2-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildPermit2Service = void 0;
    var permit2_service_1 = require_permit2_service();
    function buildPermit2Service(multicallService, quoteService, providerService, gasService) {
      return new permit2_service_1.Permit2Service(multicallService, providerService, quoteService, gasService);
    }
    exports.buildPermit2Service = buildPermit2Service;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/abis/companion.js
var require_companion = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/abis/companion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = [
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "InvalidAllowanceTarget",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "received",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "expected",
            type: "uint256"
          }
        ],
        name: "ReceivedTooLittleTokenOut",
        type: "error"
      },
      {
        inputs: [],
        name: "ZeroAddress",
        type: "error"
      },
      {
        inputs: [],
        name: "PERMIT2",
        outputs: [
          {
            internalType: "contract IPermit2",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PROTOCOL_TOKEN",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "allowanceTarget",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "token",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              }
            ],
            internalType: "struct IPermit2.TokenPermissions[]",
            name: "_tokens",
            type: "tuple[]"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_deadline",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "batchPermitTakeFromCaller",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAHub",
            name: "_hub",
            type: "address"
          },
          {
            internalType: "address",
            name: "_from",
            type: "address"
          },
          {
            internalType: "address",
            name: "_to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "_amountOfSwaps",
            type: "uint32"
          },
          {
            internalType: "uint32",
            name: "_swapInterval",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "operator",
                type: "address"
              },
              {
                internalType: "enum IDCAPermissionManager.Permission[]",
                name: "permissions",
                type: "uint8[]"
              }
            ],
            internalType: "struct IDCAPermissionManager.PermissionSet[]",
            name: "_permissions",
            type: "tuple[]"
          },
          {
            internalType: "bytes",
            name: "_miscellaneous",
            type: "bytes"
          }
        ],
        name: "deposit",
        outputs: [
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAHub",
            name: "_hub",
            type: "address"
          },
          {
            internalType: "address",
            name: "_from",
            type: "address"
          },
          {
            internalType: "address",
            name: "_to",
            type: "address"
          },
          {
            internalType: "uint32",
            name: "_amountOfSwaps",
            type: "uint32"
          },
          {
            internalType: "uint32",
            name: "_swapInterval",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "operator",
                type: "address"
              },
              {
                internalType: "enum IDCAPermissionManager.Permission[]",
                name: "permissions",
                type: "uint8[]"
              }
            ],
            internalType: "struct IDCAPermissionManager.PermissionSet[]",
            name: "_permissions",
            type: "tuple[]"
          },
          {
            internalType: "bytes",
            name: "_miscellaneous",
            type: "bytes"
          }
        ],
        name: "depositWithBalanceOnContract",
        outputs: [
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAHub",
            name: "_hub",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "_newSwaps",
            type: "uint32"
          }
        ],
        name: "increasePosition",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAHub",
            name: "_hub",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "_newSwaps",
            type: "uint32"
          }
        ],
        name: "increasePositionWithBalanceOnContract",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAPermissionManager",
            name: "_permissionManager",
            type: "address"
          },
          {
            components: [
              {
                internalType: "uint256",
                name: "tokenId",
                type: "uint256"
              },
              {
                components: [
                  {
                    internalType: "address",
                    name: "operator",
                    type: "address"
                  },
                  {
                    internalType: "enum IDCAPermissionManager.Permission[]",
                    name: "permissions",
                    type: "uint8[]"
                  }
                ],
                internalType: "struct IDCAPermissionManager.PermissionSet[]",
                name: "permissionSets",
                type: "tuple[]"
              }
            ],
            internalType: "struct IDCAPermissionManager.PositionPermissions[]",
            name: "_permissions",
            type: "tuple[]"
          },
          {
            internalType: "uint256",
            name: "_deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "_v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "_r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "_s",
            type: "bytes32"
          }
        ],
        name: "multiPermissionPermit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes[]",
            name: "_data",
            type: "bytes[]"
          }
        ],
        name: "multicall",
        outputs: [
          {
            internalType: "bytes[]",
            name: "_results",
            type: "bytes[]"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAPermissionManager",
            name: "_permissionManager",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "operator",
                type: "address"
              },
              {
                internalType: "enum IDCAPermissionManager.Permission[]",
                name: "permissions",
                type: "uint8[]"
              }
            ],
            internalType: "struct IDCAPermissionManager.PermissionSet[]",
            name: "_permissions",
            type: "tuple[]"
          },
          {
            internalType: "uint256",
            name: "_tokenId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "_v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "_r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "_s",
            type: "bytes32"
          }
        ],
        name: "permissionPermit",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_nonce",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_deadline",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "permitTakeFromCaller",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAHub",
            name: "_hub",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "_newSwaps",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "reducePosition",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_allowanceToken",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "_swapData",
            type: "bytes"
          },
          {
            internalType: "address",
            name: "_tokenOut",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_minTokenOut",
            type: "uint256"
          }
        ],
        name: "runSwap",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_token",
            type: "address"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "sendBalanceOnContractToRecipient",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "sendToRecipient",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_pendingGovernor",
            type: "address"
          }
        ],
        name: "setPendingGovernor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "_token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "takeFromCaller",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAHub",
            name: "_hub",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipientUnswapped",
            type: "address"
          },
          {
            internalType: "address",
            name: "_recipientSwapped",
            type: "address"
          }
        ],
        name: "terminate",
        outputs: [
          {
            internalType: "uint256",
            name: "_unswapped",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_swapped",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAHub",
            name: "_hub",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "withdrawSwapped",
        outputs: [
          {
            internalType: "uint256",
            name: "_swapped",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IDCAHub",
            name: "_hub",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "token",
                type: "address"
              },
              {
                internalType: "uint256[]",
                name: "positionIds",
                type: "uint256[]"
              }
            ],
            internalType: "struct IDCAHubPositionHandler.PositionSet[]",
            name: "_positions",
            type: "tuple[]"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "withdrawSwappedMany",
        outputs: [
          {
            internalType: "uint256[]",
            name: "_withdrawn",
            type: "uint256[]"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        stateMutability: "payable",
        type: "receive"
      }
    ];
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/abis/dca-hub.js
var require_dca_hub = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/abis/dca-hub.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = [
      {
        inputs: [],
        name: "AmountTooBig",
        type: "error"
      },
      {
        inputs: [],
        name: "HighFee",
        type: "error"
      },
      {
        inputs: [],
        name: "HighPlatformFeeRatio",
        type: "error"
      },
      {
        inputs: [],
        name: "IntervalNotAllowed",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidAllowedTokensInput",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidFee",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidInterval",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidMask",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPairs",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPosition",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidToken",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidTokens",
        type: "error"
      },
      {
        inputs: [],
        name: "LiquidityNotReturned",
        type: "error"
      },
      {
        inputs: [],
        name: "NoSwapsToExecute",
        type: "error"
      },
      {
        inputs: [],
        name: "PositionDoesNotMatchToken",
        type: "error"
      },
      {
        inputs: [],
        name: "UnallowedToken",
        type: "error"
      },
      {
        inputs: [],
        name: "UnauthorizedCaller",
        type: "error"
      },
      {
        inputs: [],
        name: "ZeroAddress",
        type: "error"
      },
      {
        inputs: [],
        name: "ZeroAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "ZeroSwaps",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_from",
            type: "address"
          },
          {
            internalType: "address",
            name: "_to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "_amountOfSwaps",
            type: "uint32"
          },
          {
            internalType: "uint32",
            name: "_swapInterval",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "operator",
                type: "address"
              },
              {
                internalType: "enum IDCAPermissionManager.Permission[]",
                name: "permissions",
                type: "uint8[]"
              }
            ],
            internalType: "struct IDCAPermissionManager.PermissionSet[]",
            name: "_permissions",
            type: "tuple[]"
          }
        ],
        name: "deposit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_from",
            type: "address"
          },
          {
            internalType: "address",
            name: "_to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "_amountOfSwaps",
            type: "uint32"
          },
          {
            internalType: "uint32",
            name: "_swapInterval",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          },
          {
            components: [
              {
                internalType: "address",
                name: "operator",
                type: "address"
              },
              {
                internalType: "enum IDCAPermissionManager.Permission[]",
                name: "permissions",
                type: "uint8[]"
              }
            ],
            internalType: "struct IDCAPermissionManager.PermissionSet[]",
            name: "_permissions",
            type: "tuple[]"
          },
          {
            internalType: "bytes",
            name: "_miscellaneous",
            type: "bytes"
          }
        ],
        name: "deposit",
        outputs: [
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "_newAmountOfSwaps",
            type: "uint32"
          }
        ],
        name: "increasePosition",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
          },
          {
            internalType: "uint32",
            name: "_newAmountOfSwaps",
            type: "uint32"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "reducePosition",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipientUnswapped",
            type: "address"
          },
          {
            internalType: "address",
            name: "_recipientSwapped",
            type: "address"
          }
        ],
        name: "terminate",
        outputs: [
          {
            internalType: "uint256",
            name: "_unswapped",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_swapped",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          }
        ],
        name: "userPosition",
        outputs: [
          {
            components: [
              {
                internalType: "contract IERC20Metadata",
                name: "from",
                type: "address"
              },
              {
                internalType: "contract IERC20Metadata",
                name: "to",
                type: "address"
              },
              {
                internalType: "uint32",
                name: "swapInterval",
                type: "uint32"
              },
              {
                internalType: "uint32",
                name: "swapsExecuted",
                type: "uint32"
              },
              {
                internalType: "uint256",
                name: "swapped",
                type: "uint256"
              },
              {
                internalType: "uint32",
                name: "swapsLeft",
                type: "uint32"
              },
              {
                internalType: "uint256",
                name: "remaining",
                type: "uint256"
              },
              {
                internalType: "uint120",
                name: "rate",
                type: "uint120"
              }
            ],
            internalType: "struct IDCAHubPositionHandler.UserPosition",
            name: "_userPosition",
            type: "tuple"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_positionId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "withdrawSwapped",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "token",
                type: "address"
              },
              {
                internalType: "uint256[]",
                name: "positionIds",
                type: "uint256[]"
              }
            ],
            internalType: "struct IDCAHubPositionHandler.PositionSet[]",
            name: "_positions",
            type: "tuple[]"
          },
          {
            internalType: "address",
            name: "_recipient",
            type: "address"
          }
        ],
        name: "withdrawSwappedMany",
        outputs: [
          {
            internalType: "uint256[]",
            name: "_swapped",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/dca/types.js
var require_types2 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/dca/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DCASwapInterval = exports.DCAPermission = void 0;
    var DCAPermission;
    (function(DCAPermission2) {
      DCAPermission2["INCREASE"] = "INCREASE";
      DCAPermission2["REDUCE"] = "REDUCE";
      DCAPermission2["WITHDRAW"] = "WITHDRAW";
      DCAPermission2["TERMINATE"] = "TERMINATE";
    })(DCAPermission = exports.DCAPermission || (exports.DCAPermission = {}));
    var DCASwapInterval;
    (function(DCASwapInterval2) {
      DCASwapInterval2[DCASwapInterval2["ONE_MINUTE"] = 60] = "ONE_MINUTE";
      DCASwapInterval2[DCASwapInterval2["FIVE_MINUTES"] = 300] = "FIVE_MINUTES";
      DCASwapInterval2[DCASwapInterval2["FIFTEEN_MINUTES"] = 900] = "FIFTEEN_MINUTES";
      DCASwapInterval2[DCASwapInterval2["THIRTY_MINUTES"] = 1800] = "THIRTY_MINUTES";
      DCASwapInterval2[DCASwapInterval2["ONE_HOUR"] = 3600] = "ONE_HOUR";
      DCASwapInterval2[DCASwapInterval2["FOUR_HOURS"] = 14400] = "FOUR_HOURS";
      DCASwapInterval2[DCASwapInterval2["ONE_DAY"] = 86400] = "ONE_DAY";
      DCASwapInterval2[DCASwapInterval2["ONE_WEEK"] = 604800] = "ONE_WEEK";
    })(DCASwapInterval = exports.DCASwapInterval || (exports.DCASwapInterval = {}));
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/dca/config.js
var require_config2 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/dca/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.COMPANION_SWAPPER_ADDRESS = exports.COMPANION_ADDRESS = exports.DCA_PERMISSION_MANAGER_ADDRESS = exports.DCA_HUB_ADDRESS = void 0;
    var config_1 = require_config();
    exports.DCA_HUB_ADDRESS = "0xA5AdC5484f9997fBF7D405b9AA62A7d88883C345";
    exports.DCA_PERMISSION_MANAGER_ADDRESS = "0x20bdAE1413659f47416f769a4B27044946bc9923";
    exports.COMPANION_ADDRESS = "0xDf0dbc66f85979a1d54671c4D9e439F306Be27EE";
    exports.COMPANION_SWAPPER_ADDRESS = config_1.PERMIT2_ADAPTER_ADDRESS;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/abis/erc721.js
var require_erc721 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/abis/erc721.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERC721_ABI = void 0;
    exports.ERC721_ABI = ["function ownerOf(uint256 tokenId) view returns (address owner)"];
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/dca/dca-service.js
var require_dca_service = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/dca/dca-service.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DCAService = void 0;
    var qs_1 = __importDefault(require_lib23());
    var viem_1 = require_cjs2();
    var companion_1 = __importDefault(require_companion());
    var dca_hub_1 = __importDefault(require_dca_hub());
    var config_1 = require_config();
    var utils_1 = require_utils13();
    var constants_1 = require_constants();
    var types_1 = require_types2();
    var config_2 = require_config2();
    var erc721_1 = require_erc721();
    var DCAService = class {
      constructor(apiUrl, multicallService, permit2Service, quoteService, fetchService, priceService) {
        this.apiUrl = apiUrl;
        this.multicallService = multicallService;
        this.permit2Service = permit2Service;
        this.quoteService = quoteService;
        this.fetchService = fetchService;
        this.priceService = priceService;
      }
      getAllowanceTarget({ chainId, from, depositWith, usePermit2 }) {
        if (usePermit2) {
          return config_1.PERMIT2_ADDRESS;
        } else if ((0, utils_1.isSameAddress)(from, depositWith)) {
          return config_2.DCA_HUB_ADDRESS;
        } else {
          return config_2.COMPANION_ADDRESS;
        }
      }
      preparePermitData(args) {
        return this.permit2Service.preparePermitData({ ...args, spender: config_2.COMPANION_ADDRESS });
      }
      async buildCreatePositionTx({ chainId, from, to, swapInterval, amountOfSwaps, owner, permissions, deposit }) {
        let depositInfo;
        if ("token" in deposit) {
          const amount = BigInt(deposit.amount);
          depositInfo = { token: deposit.token, amount, value: (0, utils_1.isSameAddress)(deposit.token, constants_1.Addresses.NATIVE_TOKEN) ? amount : 0n };
        } else {
          depositInfo = { token: deposit.permitData.token, amount: BigInt(deposit.permitData.amount), value: 0n };
        }
        const needsSwap = !(0, utils_1.isSameAddress)(depositInfo.token, from.variantId);
        if ("token" in deposit && !needsSwap) {
          return {
            to: config_2.DCA_HUB_ADDRESS,
            data: (0, viem_1.encodeFunctionData)({
              abi: dca_hub_1.default,
              functionName: "deposit",
              args: [
                from.variantId,
                to.variantId,
                depositInfo.amount,
                amountOfSwaps,
                swapInterval,
                owner,
                permissions.map(({ operator, permissions: permissions2 }) => ({
                  operator,
                  permissions: permissions2.map(mapPermission)
                }))
              ]
            })
          };
        }
        const calls = [];
        const recipient = needsSwap ? config_2.COMPANION_SWAPPER_ADDRESS : config_2.COMPANION_ADDRESS;
        if ("permitData" in deposit) {
          calls.push(buildTakeFromCallerWithPermit(deposit.permitData, deposit.signature, recipient));
        } else if (!(0, utils_1.isSameAddress)(depositInfo.token, constants_1.Addresses.NATIVE_TOKEN)) {
          calls.push(buildTakeFromCaller(depositInfo.token, depositInfo.amount, recipient));
        }
        if (needsSwap) {
          const { swapData } = await this.getSwapData({
            request: {
              chainId,
              sellToken: depositInfo.token,
              buyToken: from.variantId,
              order: { type: "sell", sellAmount: depositInfo.amount }
            },
            leftoverRecipient: owner,
            swapConfig: deposit?.swapConfig
          });
          calls.push(swapData);
        }
        calls.push((0, viem_1.encodeFunctionData)({
          abi: companion_1.default,
          functionName: "depositWithBalanceOnContract",
          args: [
            config_2.DCA_HUB_ADDRESS,
            from.variantId,
            to.variantId,
            amountOfSwaps,
            swapInterval,
            owner,
            permissions.map(({ operator, permissions: permissions2 }) => ({
              operator,
              permissions: permissions2.map(mapPermission)
            })),
            "0x"
          ]
        }));
        return buildCompanionMulticall({ calls, value: depositInfo.value });
      }
      async buildIncreasePositionTx({ chainId, positionId, increase, amountOfSwaps, permissionPermit, dcaHub }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_ADDRESS;
        let increaseInfo;
        if (!increase) {
          increaseInfo = { token: constants_1.Addresses.ZERO_ADDRESS, amount: 0n, value: 0n };
        } else if ("token" in increase) {
          const amount = BigInt(increase.amount);
          increaseInfo = { token: increase.token, amount, value: (0, utils_1.isSameAddress)(increase.token, constants_1.Addresses.NATIVE_TOKEN) ? amount : 0n };
        } else {
          increaseInfo = { token: increase.permitData.token, amount: BigInt(increase.permitData.amount), value: 0n };
        }
        const bigIntPositionId = BigInt(positionId);
        const [positionOwner, position] = await this.multicallService.readOnlyMulticall({
          chainId,
          calls: [
            { abi: { humanReadable: erc721_1.ERC721_ABI }, address: config_2.DCA_PERMISSION_MANAGER_ADDRESS, functionName: "ownerOf", args: [bigIntPositionId] },
            { abi: { json: dca_hub_1.default }, address: hubAddress, functionName: "userPosition", args: [bigIntPositionId] }
          ]
        });
        const needsSwap = !(0, utils_1.isSameAddress)(increaseInfo.token, position.from);
        const callHubDirectly = !increase || increaseInfo.amount === 0n || amountOfSwaps === 0 || "token" in increase && !needsSwap;
        if (callHubDirectly) {
          return {
            to: hubAddress,
            data: (0, viem_1.encodeFunctionData)({
              abi: dca_hub_1.default,
              functionName: "increasePosition",
              args: [BigInt(positionId), BigInt(increaseInfo.amount), amountOfSwaps]
            })
          };
        }
        const calls = [];
        const recipient = needsSwap ? config_2.COMPANION_SWAPPER_ADDRESS : config_2.COMPANION_ADDRESS;
        if ("permitData" in increase) {
          calls.push(buildTakeFromCallerWithPermit(increase.permitData, increase.signature, recipient));
        } else if (!(0, utils_1.isSameAddress)(increaseInfo.token, constants_1.Addresses.NATIVE_TOKEN)) {
          calls.push(buildTakeFromCaller(increaseInfo.token, increaseInfo.amount, recipient));
        }
        if (needsSwap) {
          const { swapData } = await this.getSwapData({
            request: {
              chainId,
              sellToken: increaseInfo.token,
              buyToken: position.from,
              order: { type: "sell", sellAmount: increaseInfo.amount }
            },
            leftoverRecipient: positionOwner,
            swapConfig: increase?.swapConfig
          });
          calls.push(swapData);
        }
        if (permissionPermit) {
          calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        calls.push((0, viem_1.encodeFunctionData)({
          abi: companion_1.default,
          functionName: "increasePositionWithBalanceOnContract",
          args: [hubAddress, bigIntPositionId, amountOfSwaps]
        }));
        return buildCompanionMulticall({ calls, value: increaseInfo?.value });
      }
      async buildReducePositionTx({ chainId, positionId, amountOfSwaps, reduce, recipient, permissionPermit, dcaHub }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_ADDRESS;
        const position = await this.getUserPosition(chainId, hubAddress, positionId);
        const shouldConvert = reduce.convertTo && !(0, utils_1.isSameAddress)(position.from, reduce.convertTo);
        if (!shouldConvert) {
          return {
            to: hubAddress,
            data: (0, viem_1.encodeFunctionData)({
              abi: dca_hub_1.default,
              functionName: "reducePosition",
              args: [BigInt(positionId), BigInt(reduce.amount), amountOfSwaps, recipient]
            })
          };
        }
        const calls = [];
        if (permissionPermit) {
          calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        calls.push((0, viem_1.encodeFunctionData)({
          abi: companion_1.default,
          functionName: "reducePosition",
          args: [hubAddress, BigInt(positionId), BigInt(reduce.amount), amountOfSwaps, config_2.COMPANION_SWAPPER_ADDRESS]
        }));
        const outToken = reduce.convertTo;
        const { swapData } = await this.getSwapData({
          request: {
            chainId,
            sellToken: position.from,
            buyToken: outToken,
            order: { type: "sell", sellAmount: reduce.amount }
          },
          leftoverRecipient: recipient,
          swapConfig: reduce?.swapConfig
        });
        calls.push(swapData);
        calls.push(buildSendAllBalance(outToken, recipient));
        return buildCompanionMulticall({ calls });
      }
      async buildReduceToBuyPositionTx({ chainId, positionId, amountOfSwaps, reduce, recipient, permissionPermit, dcaHub }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_ADDRESS;
        const calls = [];
        const position = await this.getUserPosition(chainId, hubAddress, positionId);
        const shouldConvert = reduce.convertTo && !(0, utils_1.isSameAddress)(position.from, reduce.convertTo);
        if (amountOfSwaps === 0 || !shouldConvert) {
          const amount = amountOfSwaps === 0 ? position.remaining : reduce.amountToBuy;
          return this.buildReducePositionTx({
            chainId,
            positionId,
            amountOfSwaps,
            reduce: { amount, convertTo: reduce.convertTo, swapConfig: reduce.swapConfig },
            recipient,
            permissionPermit,
            dcaHub
          });
        }
        if (permissionPermit) {
          calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        const outToken = reduce.convertTo;
        const { bestQuote: buyQuote, swapData } = await this.getSwapData({
          request: {
            chainId,
            sellToken: position.from,
            buyToken: outToken,
            order: { type: "buy", buyAmount: reduce.amountToBuy }
          },
          leftoverRecipient: recipient,
          swapConfig: reduce?.swapConfig
        });
        if (BigInt(buyQuote.maxSellAmount.amount) > position.remaining) {
          throw new Error("Trying to withdraw more than available");
        }
        calls.push((0, viem_1.encodeFunctionData)({
          abi: companion_1.default,
          functionName: "reducePosition",
          args: [hubAddress, BigInt(positionId), BigInt(buyQuote.maxSellAmount.amount), amountOfSwaps, config_2.COMPANION_SWAPPER_ADDRESS]
        }));
        calls.push(swapData);
        calls.push(buildSendAllBalance(outToken, recipient));
        return buildCompanionMulticall({ calls });
      }
      async buildWithdrawPositionTx({ chainId, positionId, withdraw, recipient, permissionPermit, dcaHub }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_ADDRESS;
        const position = await this.getUserPosition(chainId, hubAddress, positionId);
        const shouldConvert = withdraw.convertTo && !(0, utils_1.isSameAddress)(position.to, withdraw.convertTo);
        if (!shouldConvert) {
          return {
            to: hubAddress,
            data: (0, viem_1.encodeFunctionData)({
              abi: dca_hub_1.default,
              functionName: "withdrawSwapped",
              args: [BigInt(positionId), recipient]
            })
          };
        }
        const calls = [];
        if (permissionPermit) {
          calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        calls.push((0, viem_1.encodeFunctionData)({
          abi: companion_1.default,
          functionName: "withdrawSwapped",
          args: [hubAddress, BigInt(positionId), config_2.COMPANION_SWAPPER_ADDRESS]
        }));
        const outToken = withdraw.convertTo;
        const { swapData } = await this.getSwapData({
          request: {
            chainId,
            sellToken: position.to,
            buyToken: outToken,
            order: { type: "sell", sellAmount: position.swapped }
          },
          leftoverRecipient: recipient,
          swapConfig: withdraw?.swapConfig
        });
        calls.push(swapData);
        calls.push(buildSendAllBalance(outToken, recipient));
        return buildCompanionMulticall({ calls });
      }
      async buildTerminatePositionTx({ chainId, positionId, withdraw, recipient, permissionPermit, dcaHub }) {
        const hubAddress = dcaHub ?? config_2.DCA_HUB_ADDRESS;
        const position = await this.getUserPosition(chainId, hubAddress, positionId);
        const shouldConvertUnswapped = position.remaining > 0 && !!withdraw.unswappedConvertTo && !(0, utils_1.isSameAddress)(position.from, withdraw.unswappedConvertTo);
        const shouldConvertSwapped = position.swapped > 0 && !!withdraw.swappedConvertTo && !(0, utils_1.isSameAddress)(position.to, withdraw.swappedConvertTo);
        if (!shouldConvertUnswapped && !shouldConvertSwapped) {
          return {
            to: hubAddress,
            data: (0, viem_1.encodeFunctionData)({
              abi: dca_hub_1.default,
              functionName: "terminate",
              args: [BigInt(positionId), recipient, recipient]
            })
          };
        }
        const calls = [];
        if (permissionPermit) {
          calls.push(buildPermissionPermit(permissionPermit, hubAddress));
        }
        calls.push((0, viem_1.encodeFunctionData)({
          abi: companion_1.default,
          functionName: "terminate",
          args: [
            hubAddress,
            BigInt(positionId),
            shouldConvertUnswapped ? config_2.COMPANION_SWAPPER_ADDRESS : recipient,
            shouldConvertSwapped ? config_2.COMPANION_SWAPPER_ADDRESS : recipient
          ]
        }));
        let unswappedPromise, swappedPromise;
        if (shouldConvertUnswapped) {
          const convertTo = withdraw.unswappedConvertTo;
          unswappedPromise = this.getSwapData({
            request: {
              chainId,
              sellToken: position.from,
              buyToken: convertTo,
              order: { type: "sell", sellAmount: position.remaining }
            },
            leftoverRecipient: recipient,
            swapConfig: withdraw.swapConfig
          }).then(({ swapData }) => calls.push(
            swapData,
            buildSendAllBalance(convertTo, recipient)
          ));
        } else {
          unswappedPromise = Promise.resolve();
        }
        if (shouldConvertSwapped) {
          const convertTo = withdraw.swappedConvertTo;
          swappedPromise = this.getSwapData({
            request: {
              chainId,
              sellToken: position.to,
              buyToken: convertTo,
              order: { type: "sell", sellAmount: position.swapped }
            },
            leftoverRecipient: recipient,
            swapConfig: withdraw.swapConfig
          }).then(({ swapData }) => calls.push(
            swapData,
            buildSendAllBalance(convertTo, recipient)
          ));
        } else {
          swappedPromise = Promise.resolve();
        }
        await Promise.all([unswappedPromise, swappedPromise]);
        return buildCompanionMulticall({ calls });
      }
      async buildMigratePositionTx({ chainId, sourceHub, targetHub, positionId, migration, permissionPermit }) {
        const bigIntPositionId = BigInt(positionId);
        const [positionOwner, position] = await this.multicallService.readOnlyMulticall({
          chainId,
          calls: [
            { abi: { humanReadable: erc721_1.ERC721_ABI }, address: config_2.DCA_PERMISSION_MANAGER_ADDRESS, functionName: "ownerOf", args: [bigIntPositionId] },
            { abi: { json: dca_hub_1.default }, address: sourceHub, functionName: "userPosition", args: [bigIntPositionId] }
          ]
        });
        const newFrom = migration.newFrom?.variantId ?? position.from;
        const shouldConvertUnswapped = migration.useFundsFrom !== "swapped" && position.remaining > 0 && !(0, utils_1.isSameAddress)(position.from, newFrom);
        const shouldConvertSwapped = migration.useFundsFrom !== "unswapped" && position.swapped > 0 && !(0, utils_1.isSameAddress)(position.to, newFrom);
        const calls = [];
        if (permissionPermit) {
          calls.push(buildPermissionPermit(permissionPermit, sourceHub));
        }
        calls.push((0, viem_1.encodeFunctionData)({
          abi: companion_1.default,
          functionName: "terminate",
          args: [
            sourceHub,
            bigIntPositionId,
            shouldConvertUnswapped ? config_2.COMPANION_SWAPPER_ADDRESS : migration.useFundsFrom !== "swapped" ? config_2.COMPANION_ADDRESS : migration.sendUnusedFundsTo,
            shouldConvertSwapped ? config_2.COMPANION_SWAPPER_ADDRESS : migration.useFundsFrom !== "unswapped" ? config_2.COMPANION_ADDRESS : migration.sendUnusedFundsTo
          ]
        }));
        let unswappedPromise, swappedPromise;
        if (shouldConvertUnswapped) {
          unswappedPromise = this.getSwapData({
            request: {
              chainId,
              sellToken: position.from,
              buyToken: newFrom,
              order: { type: "sell", sellAmount: position.remaining }
            },
            leftoverRecipient: positionOwner,
            swapConfig: migration?.swapConfig
          }).then(({ swapData }) => calls.push(swapData));
        } else {
          unswappedPromise = Promise.resolve();
        }
        if (shouldConvertSwapped) {
          swappedPromise = this.getSwapData({
            request: {
              chainId,
              sellToken: position.to,
              buyToken: newFrom,
              order: { type: "sell", sellAmount: position.swapped }
            },
            leftoverRecipient: positionOwner,
            swapConfig: migration?.swapConfig
          }).then(({ swapData }) => calls.push(swapData));
        } else {
          swappedPromise = Promise.resolve();
        }
        await Promise.all([unswappedPromise, swappedPromise]);
        calls.push((0, viem_1.encodeFunctionData)({
          abi: companion_1.default,
          functionName: "depositWithBalanceOnContract",
          args: [
            targetHub,
            newFrom,
            migration.newTo?.variantId ?? position.to,
            position.swapsLeft,
            position.swapInterval,
            positionOwner,
            [],
            "0x"
          ]
        }));
        return buildCompanionMulticall({ calls });
      }
      async getSupportedPairs(args) {
        const params = qs_1.default.stringify({ chains: args?.chains }, { arrayFormat: "comma", skipNulls: true });
        const url = `${this.apiUrl}/v2/dca/pairs/supported?${params}`;
        const response = await this.fetchService.fetch(url, { timeout: args?.config?.timeout });
        const body = await response.json();
        const result = {};
        for (const chainId in body.pairsByNetwork) {
          const { pairs, tokens } = body.pairsByNetwork[chainId];
          result[Number(chainId)] = {
            pairs: pairs.map((pair) => buildPair(Number(chainId), pair, tokens)),
            tokens
          };
        }
        return result;
      }
      async getPositionsByAccount({ accounts, chains, includeHistory, config: config2 }) {
        const params = qs_1.default.stringify({ users: accounts, chains, includeHistory }, { arrayFormat: "comma", skipNulls: true });
        return this.fetchPositions(params, config2?.timeout);
      }
      async getPositionsById({ ids, includeHistory, config: config2 }) {
        const encodedIds = ids.map(({ chainId, hub, positionId }) => `${chainId}-${hub}-${positionId}`);
        const params = qs_1.default.stringify({ ids: encodedIds, includeHistory }, { arrayFormat: "comma", skipNulls: true });
        return this.fetchPositions(params, config2?.timeout);
      }
      async getPairSwaps({ chainId, variantTokenA, variantTokenB, config: config2 }) {
        const url = `${this.apiUrl}/v2/dca/pairs/${chainId}-${variantTokenA}-${variantTokenB}/swaps`;
        const response = await this.fetchService.fetch(url, { timeout: config2?.timeout });
        const { tokenA, tokenB, swaps } = await response.json();
        return {
          tokenA,
          tokenB,
          swaps: swaps.map((swap) => ({
            ...swap,
            ratioAToB: toBigInt(swap.ratioAToB),
            ratioBToA: toBigInt(swap.ratioBToA),
            ratioAToBWithFee: toBigInt(swap.ratioAToBWithFee),
            ratioBToAWithFee: toBigInt(swap.ratioBToAWithFee),
            intervalsInSwap: swap.intervalsInSwap.map(({ seconds }) => seconds)
          }))
        };
      }
      async fetchPositions(params, timeout) {
        const url = `${this.apiUrl}/v2/dca/positions?${params}`;
        const response = await this.fetchService.fetch(url, { timeout });
        const body = await response.json();
        const tokensToFetch = calculateMissingPrices(body);
        const prices = tokensToFetch.length === 0 ? {} : await this.priceService.getBulkHistoricalPrices({ addresses: tokensToFetch, config: { timeout } });
        const result = {};
        for (const chainId in body.positionsByNetwork) {
          const { positions, tokens } = body.positionsByNetwork[chainId];
          result[Number(chainId)] = positions.map((position) => buildPosition(position, tokens, prices[Number(chainId)] ?? {}));
        }
        return result;
      }
      async getSwapData({ request, leftoverRecipient, swapConfig }) {
        const txValidFor = swapConfig?.txValidFor ?? "1w";
        const bestQuote = await this.quoteService.getBestQuote({
          request: {
            ...request,
            slippagePercentage: swapConfig?.slippagePercentage ?? 0.3,
            takerAddress: config_2.COMPANION_SWAPPER_ADDRESS,
            recipient: config_2.COMPANION_SWAPPER_ADDRESS,
            txValidFor,
            filters: { includeSources: ["mean-finance"] },
            sourceConfig: { custom: { ["mean-finance"]: { leftoverRecipient } } }
          },
          config: {
            timeout: "5s"
          }
        });
        const allowanceTargets = (0, utils_1.isSameAddress)(bestQuote.source.allowanceTarget, constants_1.Addresses.ZERO_ADDRESS) ? [] : [{ token: bestQuote.sellToken.address, target: bestQuote.source.allowanceTarget }];
        const tokenOutDistribution = (0, utils_1.isSameAddress)(bestQuote.buyToken.address, constants_1.Addresses.NATIVE_TOKEN) ? constants_1.Addresses.ZERO_ADDRESS : bestQuote.buyToken.address;
        const arbitraryCall = this.permit2Service.arbitrary.buildArbitraryCallWithoutPermit({
          allowanceTargets,
          calls: [{ to: bestQuote.tx.to, data: bestQuote.tx.data, value: bestQuote.tx.value ?? 0 }],
          distribution: { [tokenOutDistribution]: [{ recipient: config_2.COMPANION_ADDRESS, shareBps: 0 }] },
          txValidFor
        });
        const swapData = (0, viem_1.encodeFunctionData)({
          abi: companion_1.default,
          functionName: "runSwap",
          args: [
            constants_1.Addresses.ZERO_ADDRESS,
            BigInt(bestQuote.tx.value ?? 0),
            arbitraryCall.data,
            bestQuote.buyToken.address,
            BigInt(bestQuote.minBuyAmount.amount)
          ]
        });
        return { bestQuote, swapData };
      }
      async getUserPosition(chainId, hubAddress, positionId) {
        const [position] = await this.multicallService.readOnlyMulticall({
          chainId,
          calls: [{ abi: { json: dca_hub_1.default }, address: hubAddress, functionName: "userPosition", args: [BigInt(positionId)] }]
        });
        return { ...position, remaining: BigInt(position.remaining), swapped: BigInt(position.swapped) };
      }
    };
    exports.DCAService = DCAService;
    function buildTakeFromCallerWithPermit({ token: token2, amount, nonce, deadline }, signature, recipient) {
      return (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: "permitTakeFromCaller",
        args: [token2, BigInt(amount), BigInt(nonce), BigInt(deadline), signature, recipient]
      });
    }
    function buildTakeFromCaller(token2, amount, recipient) {
      return (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: "takeFromCaller",
        args: [token2, BigInt(amount), recipient]
      });
    }
    function buildPermissionPermit(permit, hub) {
      const permissionManager = PERMISSION_MANAGER_FOR_HUB[hub.toLowerCase()];
      return (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: "permissionPermit",
        args: [
          permissionManager,
          permit.permissions.map(({ operator, permissions }) => ({
            operator,
            permissions: permissions.map(mapPermission)
          })),
          BigInt(permit.tokenId),
          BigInt(permit.deadline),
          parseInt(permit.v.toString()),
          permit.r,
          permit.s
        ]
      });
    }
    function mapPermission(permission) {
      switch (permission) {
        case types_1.DCAPermission.INCREASE:
          return 0;
        case types_1.DCAPermission.REDUCE:
          return 1;
        case types_1.DCAPermission.WITHDRAW:
          return 2;
        case types_1.DCAPermission.TERMINATE:
          return 3;
      }
    }
    function buildSendAllBalance(token2, recipient) {
      return (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: "sendBalanceOnContractToRecipient",
        args: [token2, recipient]
      });
    }
    async function buildCompanionMulticall({ calls, value }) {
      const data = (0, viem_1.encodeFunctionData)({
        abi: companion_1.default,
        functionName: "multicall",
        args: [calls]
      });
      return { to: config_2.COMPANION_ADDRESS, data, value: value?.toString() };
    }
    function buildPair(chainId, pair, tokens) {
      const tokenA = tokens[pair.tokenA];
      const tokenB = tokens[pair.tokenB];
      return {
        chainId: Number(chainId),
        ...pair,
        swapIntervals: buildSwapIntervals(pair.swapIntervals, tokenA, tokenB)
      };
    }
    function buildSwapIntervals(swapIntervals, tokenA, tokenB) {
      const tokenAVariantIds = tokenA.variants.map(({ id: id4 }) => id4);
      const tokenBVariantIds = tokenB.variants.map(({ id: id4 }) => id4);
      const variantCombinations = tokenAVariantIds.flatMap((tokenAVariantId) => tokenBVariantIds.map((tokenBVariantId) => `${tokenAVariantId}-${tokenBVariantId}`));
      const result = {};
      const allIntervals = Object.keys(types_1.DCASwapInterval).slice(0, 8);
      for (const seconds of allIntervals) {
        const intervalName = types_1.DCASwapInterval[Number(seconds)];
        const nextSwapAvailableAt = {};
        const isStale = {};
        for (const combination of variantCombinations) {
          isStale[combination] = swapIntervals[intervalName]?.stale?.includes(combination) ?? false;
          nextSwapAvailableAt[combination] = swapIntervals[intervalName]?.nextSwapBlockedUntil[combination] ?? 0;
        }
        result[intervalName] = { seconds: Number(seconds), nextSwapAvailableAt, isStale };
      }
      return result;
    }
    function buildPosition(position, tokens, prices) {
      const { variants: fromVariants, ...fromToken } = tokens[position.from.address];
      const { variants: toVariants, ...toToken } = tokens[position.to.address];
      const fromVariant = fromVariants.find(({ id: id4 }) => id4 == position.from.variant.id) ?? position.from.variant;
      const toVariant = toVariants.find(({ id: id4 }) => id4 === position.to.variant.id) ?? position.to.variant;
      const [chainId, hub, tokenId] = position.id.split("-");
      return {
        chainId: Number(chainId),
        hub,
        pair: {
          pairId: toPairId(position.from.address, position.to.address),
          variantPairId: toPairId(position.from.variant.id, position.to.variant.id)
        },
        tokenId: BigInt(tokenId),
        ...position,
        from: {
          ...position.from,
          ...fromToken,
          variant: fromVariant
        },
        to: {
          ...position.to,
          ...toToken,
          variant: toVariant
        },
        swapInterval: position.swapInterval.seconds,
        rate: toBigInt(position.rate),
        funds: {
          swapped: toBigInt(position.funds.swapped),
          remaining: toBigInt(position.funds.remaining),
          toWithdraw: toBigInt(position.funds.toWithdraw)
        },
        yield: position.yield ? {
          swapped: toBigInt(position.yield.swapped),
          remaining: toBigInt(position.yield.remaining),
          toWithdraw: toBigInt(position.yield.toWithdraw)
        } : void 0,
        history: position.history?.map((action) => mapAction(action, position, prices)) ?? []
      };
    }
    function toPairId(address1, address2) {
      const lower1 = address1.toLowerCase();
      const lower2 = address2.toLowerCase();
      const [tokenA, tokenB] = lower1 < lower2 ? [lower1, lower2] : [lower2, lower1];
      return `${tokenA}-${tokenB}`;
    }
    function mapAction(action, position, prices) {
      switch (action.action) {
        case "created":
          return {
            ...action,
            fromPrice: action.fromPrice ?? prices[position.from.address]?.[action.tx.timestamp]?.price,
            rate: toBigInt(action.rate),
            tx: mapActionTx(action.tx)
          };
        case "modified":
          return {
            ...action,
            fromPrice: action.fromPrice ?? prices[position.from.address]?.[action.tx.timestamp]?.price,
            rate: toBigInt(action.rate),
            oldRate: toBigInt(action.oldRate),
            tx: mapActionTx(action.tx)
          };
        case "withdrawn":
          return {
            ...action,
            toPrice: action.toPrice ?? prices[position.to.address]?.[action.tx.timestamp]?.price,
            withdrawn: toBigInt(action.withdrawn),
            yield: action.yield && { withdrawn: toBigInt(action.yield.withdrawn) },
            tx: mapActionTx(action.tx)
          };
        case "terminated":
          return {
            ...action,
            fromPrice: action.fromPrice ?? prices[position.from.address]?.[action.tx.timestamp]?.price,
            toPrice: action.toPrice ?? prices[position.to.address]?.[action.tx.timestamp]?.price,
            withdrawnRemaining: toBigInt(action.withdrawnRemaining),
            withdrawnSwapped: toBigInt(action.withdrawnSwapped),
            yield: action.yield && {
              withdrawnRemaining: toBigInt(action.yield.withdrawnRemaining),
              withdrawnSwapped: toBigInt(action.yield.withdrawnSwapped)
            },
            tx: mapActionTx(action.tx)
          };
        case "swapped":
          return {
            ...action,
            tokenA: {
              address: action.tokenA.address,
              price: action.tokenA.price ?? prices[action.tokenA.address]?.[action.tx.timestamp]?.price
            },
            tokenB: {
              address: action.tokenB.address,
              price: action.tokenB.price ?? prices[action.tokenB.address]?.[action.tx.timestamp]?.price
            },
            rate: toBigInt(action.rate),
            swapped: toBigInt(action.swapped),
            ratioAToB: toBigInt(action.ratioAToB),
            ratioBToA: toBigInt(action.ratioBToA),
            ratioAToBWithFee: toBigInt(action.ratioAToBWithFee),
            ratioBToAWithFee: toBigInt(action.ratioBToAWithFee),
            yield: action.yield && { rate: toBigInt(action.yield.rate) },
            tx: mapActionTx(action.tx)
          };
        case "transferred":
        case "modified permissions":
          return { ...action, tx: mapActionTx(action.tx) };
      }
    }
    function mapActionTx(tx) {
      return {
        ...tx,
        gasPrice: toBigInt(tx.gasPrice),
        l1GasPrice: toBigInt(tx.l1GasPrice),
        overhead: toBigInt(tx.overhead)
      };
    }
    function calculateMissingPrices(response) {
      const toFetch = [];
      for (const chainIdString in response.positionsByNetwork) {
        const chainId = Number(chainIdString);
        for (const position of response.positionsByNetwork[chainId].positions) {
          for (const action of position.history ?? []) {
            switch (action.action) {
              case "created":
              case "modified":
                if (!action.fromPrice) {
                  toFetch.push({ chainId, token: position.from.address, timestamp: action.tx.timestamp });
                }
                break;
              case "withdrawn":
                if (!action.toPrice) {
                  toFetch.push({ chainId, token: position.to.address, timestamp: action.tx.timestamp });
                }
                break;
              case "terminated":
                if (!action.fromPrice) {
                  toFetch.push({ chainId, token: position.from.address, timestamp: action.tx.timestamp });
                }
                if (!action.toPrice) {
                  toFetch.push({ chainId, token: position.to.address, timestamp: action.tx.timestamp });
                }
                break;
              case "swapped": {
                if (!action.tokenA.price) {
                  toFetch.push({ chainId, token: action.tokenA.address, timestamp: action.tx.timestamp });
                }
                if (!action.tokenB.price) {
                  toFetch.push({ chainId, token: action.tokenB.address, timestamp: action.tx.timestamp });
                }
              }
            }
          }
        }
      }
      return toFetch;
    }
    function toBigInt(text) {
      return text === void 0 ? void 0 : BigInt(text);
    }
    var PERMISSION_MANAGER_FOR_HUB = {
      "0xa5adc5484f9997fbf7d405b9aa62a7d88883c345": "0x20bdAE1413659f47416f769a4B27044946bc9923",
      "0x059d306a25c4ce8d7437d25743a8b94520536bd5": "0x6f54391fe0386d506b51d69deeb8b04e0544e088",
      "0x230c63702d1b5034461ab2ca889a30e343d81349": "0xb4edfb45446c6a207643ea846bfa42021ce5ae11",
      "0x24f85583faa9f8bd0b8aa7b1d1f4f53f0f450038": "0x09AdE44D2E60fCa2270fF32Af5a189f40D29837b"
    };
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/dca-builder.js
var require_dca_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/dca-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildDCAService = void 0;
    var dca_service_1 = require_dca_service();
    function buildDCAService(params, { multicallService, permit2Service, quoteService, fetchService, priceService }) {
      return new dca_service_1.DCAService(params?.customAPIUrl ?? "https://api.balmy.xyz", multicallService, permit2Service, quoteService, fetchService, priceService);
    }
    exports.buildDCAService = buildDCAService;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/sdk-builder.js
var require_sdk_builder = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/sdk-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildSDK = void 0;
    var logs_builder_1 = require_logs_builder();
    var fetch_builder_1 = require_fetch_builder();
    var provider_builder_1 = require_provider_builder();
    var gas_builder_1 = require_gas_builder();
    var multicall_builder_1 = require_multicall_builder();
    var metadata_builder_1 = require_metadata_builder();
    var quote_builder_1 = require_quote_builder();
    var balance_builder_1 = require_balance_builder();
    var allowance_builder_1 = require_allowance_builder();
    var price_builder_1 = require_price_builder();
    var permit2_builder_1 = require_permit2_builder();
    var dca_builder_1 = require_dca_builder();
    function buildSDK2(params) {
      const logsService = (0, logs_builder_1.buildLogsService)(params?.logs);
      const fetchService = (0, fetch_builder_1.buildFetchService)(params?.fetch);
      const providerService = (0, provider_builder_1.buildProviderService)(params?.provider);
      const multicallService = (0, multicall_builder_1.buildMulticallService)(providerService);
      const balanceService = (0, balance_builder_1.buildBalanceService)(params?.balances, fetchService, providerService, multicallService);
      const allowanceService = (0, allowance_builder_1.buildAllowanceService)(params?.allowances, fetchService, multicallService);
      const gasService = (0, gas_builder_1.buildGasService)(params?.gas, logsService, fetchService, providerService, multicallService);
      const metadataService = (0, metadata_builder_1.buildMetadataService)(params?.metadata, fetchService, multicallService);
      const priceService = (0, price_builder_1.buildPriceService)(params?.price, fetchService);
      const quoteService = (0, quote_builder_1.buildQuoteService)(params?.quotes, providerService, fetchService, gasService, metadataService, priceService);
      const permit2Service = (0, permit2_builder_1.buildPermit2Service)(multicallService, quoteService, providerService, gasService);
      const dcaService = (0, dca_builder_1.buildDCAService)(params?.dca, { multicallService, permit2Service, quoteService, fetchService, priceService });
      return {
        providerService,
        fetchService,
        multicallService,
        allowanceService,
        balanceService,
        gasService,
        metadataService,
        priceService,
        quoteService,
        logsService,
        permit2Service,
        dcaService
      };
    }
    exports.buildSDK = buildSDK2;
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/builders/index.js
var require_builders = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/builders/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/sdk/index.js
var require_sdk = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/sdk/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildSDK = void 0;
    var sdk_builder_1 = require_sdk_builder();
    Object.defineProperty(exports, "buildSDK", { enumerable: true, get: function() {
      return sdk_builder_1.buildSDK;
    } });
    __exportStar(require_builders(), exports);
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/balances/index.js
var require_balances = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/balances/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/allowances/index.js
var require_allowances = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/allowances/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/fetch/index.js
var require_fetch = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/fetch/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/types.js
var require_types3 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AVAILABLE_GAS_SPEEDS = void 0;
    exports.AVAILABLE_GAS_SPEEDS = ["standard", "fast", "instant"];
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/gas/index.js
var require_gas = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/gas/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AVAILABLE_GAS_SPEEDS = void 0;
    var types_1 = require_types3();
    Object.defineProperty(exports, "AVAILABLE_GAS_SPEEDS", { enumerable: true, get: function() {
      return types_1.AVAILABLE_GAS_SPEEDS;
    } });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/multicall/index.js
var require_multicall2 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/multicall/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/index.js
var require_provider_sources = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/provider-sources/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/providers/index.js
var require_providers = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/providers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_provider_sources(), exports);
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/metadata/index.js
var require_metadata = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/metadata/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/prices/index.js
var require_prices = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/prices/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/logs/index.js
var require_logs = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/logs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/permit2/index.js
var require_permit22 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/permit2/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/dca/index.js
var require_dca = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/dca/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DCASwapInterval = exports.DCAPermission = void 0;
    var types_1 = require_types2();
    Object.defineProperty(exports, "DCAPermission", { enumerable: true, get: function() {
      return types_1.DCAPermission;
    } });
    Object.defineProperty(exports, "DCASwapInterval", { enumerable: true, get: function() {
      return types_1.DCASwapInterval;
    } });
  }
});

// ../node_modules/@mean-finance/sdk/dist/services/index.js
var require_services = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/services/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_balances(), exports);
    __exportStar(require_allowances(), exports);
    __exportStar(require_fetch(), exports);
    __exportStar(require_gas(), exports);
    __exportStar(require_multicall2(), exports);
    __exportStar(require_providers(), exports);
    __exportStar(require_quotes(), exports);
    __exportStar(require_metadata(), exports);
    __exportStar(require_prices(), exports);
    __exportStar(require_logs(), exports);
    __exportStar(require_permit22(), exports);
    __exportStar(require_dca(), exports);
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/deferred.js
var require_deferred = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/deferred.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._resolveSelf = () => {
        };
        this._rejectSelf = () => {
        };
        this.promise = new Promise((resolve, reject) => {
          this._resolveSelf = resolve;
          this._rejectSelf = reject;
        });
      }
      then(onfulfilled, onrejected) {
        return this.promise.then(onfulfilled, onrejected);
      }
      catch(onrejected) {
        return this.promise.catch(onrejected);
      }
      finally(onfinally) {
        return this.promise.finally(onfinally);
      }
      resolve(val) {
        this._resolveSelf(val);
      }
      reject(reason) {
        this._rejectSelf(reason);
      }
    };
    exports.Deferred = Deferred;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/auto-update-cache.js
var require_auto_update_cache = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/auto-update-cache.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutoUpdateCache = void 0;
    var ms_1 = __importDefault(require_dist());
    var DEFAULT_RETRY_TIME = "5Minutes";
    var AutoUpdateCache = class {
      constructor({ calculate, config: config2 }) {
        this.calculate = calculate;
        this.config = config2;
        this.cache = { lastUpdated: 0, value: void 0 };
        const isInvalid = config2.valid && config2.valid !== "always" && (0, ms_1.default)(config2.valid.onlyFor) <= (0, ms_1.default)(config2.update.every);
        if (isInvalid)
          throw new Error(`'onlyFor' must be greater than 'every'`);
        this.update();
      }
      getValue() {
        const now = Date.now();
        const isValid = ({ lastUpdated }) => !this.config.valid || this.config.valid === "always" || this.config.valid.onlyFor && lastUpdated >= now - (0, ms_1.default)(this.config.valid.onlyFor);
        return this.cache && isValid(this.cache) ? this.cache.value : void 0;
      }
      async update() {
        try {
          const result = await this.calculate();
          if (result !== void 0) {
            this.cache = { lastUpdated: Date.now(), value: result };
          }
          setTimeout(() => this.update(), (0, ms_1.default)(this.config.update.every));
        } catch (error) {
          setTimeout(() => this.update(), (0, ms_1.default)(this.config.update.ifFailsTryAgainIn ?? DEFAULT_RETRY_TIME));
        }
      }
    };
    exports.AutoUpdateCache = AutoUpdateCache;
  }
});

// ../node_modules/@mean-finance/sdk/dist/shared/index.js
var require_shared = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/shared/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint = exports.Addresses = exports.defiLlamaToChainId = exports.AutoUpdateCache = exports.splitInChunks = exports.ruleOfThree = exports.filterRejectedResults = exports.calculateDeadline = exports.mulDivByNumber = exports.addPercentage = exports.substractPercentage = exports.isSameAddress = exports.wait = exports.TimeoutError = exports.reduceTimeout = exports.timeoutPromise = exports.ContextlessConcurrentLRUCache = exports.ConcurrentLRUCache = void 0;
    __exportStar(require_deferred(), exports);
    __exportStar(require_triggerable_promise(), exports);
    var concurrent_lru_cache_1 = require_concurrent_lru_cache();
    Object.defineProperty(exports, "ConcurrentLRUCache", { enumerable: true, get: function() {
      return concurrent_lru_cache_1.ConcurrentLRUCache;
    } });
    Object.defineProperty(exports, "ContextlessConcurrentLRUCache", { enumerable: true, get: function() {
      return concurrent_lru_cache_1.ContextlessConcurrentLRUCache;
    } });
    var timeouts_1 = require_timeouts();
    Object.defineProperty(exports, "timeoutPromise", { enumerable: true, get: function() {
      return timeouts_1.timeoutPromise;
    } });
    Object.defineProperty(exports, "reduceTimeout", { enumerable: true, get: function() {
      return timeouts_1.reduceTimeout;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return timeouts_1.TimeoutError;
    } });
    var utils_1 = require_utils13();
    Object.defineProperty(exports, "wait", { enumerable: true, get: function() {
      return utils_1.wait;
    } });
    Object.defineProperty(exports, "isSameAddress", { enumerable: true, get: function() {
      return utils_1.isSameAddress;
    } });
    Object.defineProperty(exports, "substractPercentage", { enumerable: true, get: function() {
      return utils_1.substractPercentage;
    } });
    Object.defineProperty(exports, "addPercentage", { enumerable: true, get: function() {
      return utils_1.addPercentage;
    } });
    Object.defineProperty(exports, "mulDivByNumber", { enumerable: true, get: function() {
      return utils_1.mulDivByNumber;
    } });
    Object.defineProperty(exports, "calculateDeadline", { enumerable: true, get: function() {
      return utils_1.calculateDeadline;
    } });
    Object.defineProperty(exports, "filterRejectedResults", { enumerable: true, get: function() {
      return utils_1.filterRejectedResults;
    } });
    Object.defineProperty(exports, "ruleOfThree", { enumerable: true, get: function() {
      return utils_1.ruleOfThree;
    } });
    Object.defineProperty(exports, "splitInChunks", { enumerable: true, get: function() {
      return utils_1.splitInChunks;
    } });
    var auto_update_cache_1 = require_auto_update_cache();
    Object.defineProperty(exports, "AutoUpdateCache", { enumerable: true, get: function() {
      return auto_update_cache_1.AutoUpdateCache;
    } });
    var defi_llama_1 = require_defi_llama();
    Object.defineProperty(exports, "defiLlamaToChainId", { enumerable: true, get: function() {
      return defi_llama_1.toChainId;
    } });
    var constants_1 = require_constants();
    Object.defineProperty(exports, "Addresses", { enumerable: true, get: function() {
      return constants_1.Addresses;
    } });
    Object.defineProperty(exports, "Uint", { enumerable: true, get: function() {
      return constants_1.Uint;
    } });
  }
});

// ../node_modules/@mean-finance/sdk/dist/index.js
var require_dist3 = __commonJS({
  "../node_modules/@mean-finance/sdk/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_chains(), exports);
    __exportStar(require_sdk(), exports);
    __exportStar(require_services(), exports);
    __exportStar(require_shared(), exports);
  }
});

// ../node_modules/viem/_esm/utils/abi/formatAbiItem.js
function formatAbiItem(abiItem, { includeName = false } = {}) {
  if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
    throw new InvalidDefinitionTypeError(abiItem.type);
  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
  if (!params)
    return "";
  return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
}
function formatAbiParam(param, { includeName }) {
  if (param.type.startsWith("tuple")) {
    return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
  }
  return param.type + (includeName && param.name ? ` ${param.name}` : "");
}
var init_formatAbiItem = __esm({
  "../node_modules/viem/_esm/utils/abi/formatAbiItem.js"() {
    init_abi();
  }
});

// ../node_modules/viem/_esm/utils/data/isHex.js
function isHex2(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
var init_isHex = __esm({
  "../node_modules/viem/_esm/utils/data/isHex.js"() {
  }
});

// ../node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex2(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = __esm({
  "../node_modules/viem/_esm/utils/data/size.js"() {
    init_isHex();
  }
});

// ../node_modules/viem/_esm/errors/version.js
var version10;
var init_version8 = __esm({
  "../node_modules/viem/_esm/errors/version.js"() {
    version10 = "1.16.5";
  }
});

// ../node_modules/viem/_esm/errors/utils.js
var getContractAddress2, getUrl, getVersion;
var init_utils5 = __esm({
  "../node_modules/viem/_esm/errors/utils.js"() {
    init_version8();
    getContractAddress2 = (address) => address;
    getUrl = (url) => url;
    getVersion = () => `viem@${version10}`;
  }
});

// ../node_modules/viem/_esm/errors/base.js
function walk(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk(err.cause, fn);
  return fn ? null : err;
}
var BaseError;
var init_base = __esm({
  "../node_modules/viem/_esm/errors/base.js"() {
    init_utils5();
    BaseError = class extends Error {
      constructor(shortMessage, args = {}) {
        super();
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ViemError"
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: getVersion()
        });
        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath4 = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        this.message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath4 ? [
            `Docs: https://viem.sh${docsPath4}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
          ] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: ${this.version}`
        ].join("\n");
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath4;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
      walk(fn) {
        return walk(this, fn);
      }
    };
  }
});

// ../node_modules/viem/_esm/errors/abi.js
var AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
var init_abi = __esm({
  "../node_modules/viem/_esm/errors/abi.js"() {
    init_formatAbiItem();
    init_size();
    init_base();
    AbiConstructorNotFoundError = class extends BaseError {
      constructor({ docsPath: docsPath4 }) {
        super([
          "A constructor was not found on the ABI.",
          "Make sure you are using the correct ABI and that the constructor exists on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorNotFoundError"
        });
      }
    };
    AbiConstructorParamsNotFoundError = class extends BaseError {
      constructor({ docsPath: docsPath4 }) {
        super([
          "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
          "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorParamsNotFoundError"
        });
      }
    };
    AbiDecodingDataSizeTooSmallError = class extends BaseError {
      constructor({ data, params, size: size3 }) {
        super([`Data size of ${size3} bytes is too small for given parameters.`].join("\n"), {
          metaMessages: [
            `Params: (${formatAbiParams(params, { includeName: true })})`,
            `Data:   ${data} (${size3} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingDataSizeTooSmallError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
        this.params = params;
        this.size = size3;
      }
    };
    AbiDecodingZeroDataError = class extends BaseError {
      constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingZeroDataError"
        });
      }
    };
    AbiEncodingArrayLengthMismatchError = class extends BaseError {
      constructor({ expectedLength, givenLength, type }) {
        super([
          `ABI encoding array length mismatch for type ${type}.`,
          `Expected length: ${expectedLength}`,
          `Given length: ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingArrayLengthMismatchError"
        });
      }
    };
    AbiEncodingBytesSizeMismatchError = class extends BaseError {
      constructor({ expectedSize, value }) {
        super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingBytesSizeMismatchError"
        });
      }
    };
    AbiEncodingLengthMismatchError = class extends BaseError {
      constructor({ expectedLength, givenLength }) {
        super([
          "ABI encoding params/values length mismatch.",
          `Expected length (params): ${expectedLength}`,
          `Given length (values): ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingLengthMismatchError"
        });
      }
    };
    AbiErrorSignatureNotFoundError = class extends BaseError {
      constructor(signature, { docsPath: docsPath4 }) {
        super([
          `Encoded error signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorSignatureNotFoundError"
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.signature = signature;
      }
    };
    AbiEventSignatureEmptyTopicsError = class extends BaseError {
      constructor({ docsPath: docsPath4 }) {
        super("Cannot extract event signature from empty topics.", {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureEmptyTopicsError"
        });
      }
    };
    AbiEventSignatureNotFoundError = class extends BaseError {
      constructor(signature, { docsPath: docsPath4 }) {
        super([
          `Encoded event signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureNotFoundError"
        });
      }
    };
    AbiEventNotFoundError = class extends BaseError {
      constructor(eventName, { docsPath: docsPath4 } = {}) {
        super([
          `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventNotFoundError"
        });
      }
    };
    AbiFunctionNotFoundError = class extends BaseError {
      constructor(functionName, { docsPath: docsPath4 } = {}) {
        super([
          `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionNotFoundError"
        });
      }
    };
    AbiFunctionOutputsNotFoundError = class extends BaseError {
      constructor(functionName, { docsPath: docsPath4 }) {
        super([
          `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
          "Cannot decode function result without knowing what the parameter types are.",
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath: docsPath4
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionOutputsNotFoundError"
        });
      }
    };
    BytesSizeMismatchError = class extends BaseError {
      constructor({ expectedSize, givenSize }) {
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BytesSizeMismatchError"
        });
      }
    };
    DecodeLogDataMismatch = class extends BaseError {
      constructor({ abiItem, data, params, size: size3 }) {
        super([
          `Data size of ${size3} bytes is too small for non-indexed event parameters.`
        ].join("\n"), {
          metaMessages: [
            `Params: (${formatAbiParams(params, { includeName: true })})`,
            `Data:   ${data} (${size3} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogDataMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
        this.data = data;
        this.params = params;
        this.size = size3;
      }
    };
    DecodeLogTopicsMismatch = class extends BaseError {
      constructor({ abiItem, param }) {
        super([
          `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem(abiItem, { includeName: true })}".`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogTopicsMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
      }
    };
    InvalidAbiEncodingTypeError = class extends BaseError {
      constructor(type, { docsPath: docsPath4 }) {
        super([
          `Type "${type}" is not a valid encoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath: docsPath4 });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiEncodingType"
        });
      }
    };
    InvalidAbiDecodingTypeError = class extends BaseError {
      constructor(type, { docsPath: docsPath4 }) {
        super([
          `Type "${type}" is not a valid decoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath: docsPath4 });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiDecodingType"
        });
      }
    };
    InvalidArrayError = class extends BaseError {
      constructor(value) {
        super([`Value "${value}" is not a valid array.`].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidArrayError"
        });
      }
    };
    InvalidDefinitionTypeError = class extends BaseError {
      constructor(type) {
        super([
          `"${type}" is not a valid definition type.`,
          'Valid types: "function", "event", "error"'
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidDefinitionTypeError"
        });
      }
    };
  }
});

// ../node_modules/viem/_esm/errors/data.js
var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError;
var init_data = __esm({
  "../node_modules/viem/_esm/errors/data.js"() {
    init_base();
    SliceOffsetOutOfBoundsError = class extends BaseError {
      constructor({ offset, position, size: size3 }) {
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size3}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SliceOffsetOutOfBoundsError"
        });
      }
    };
    SizeExceedsPaddingSizeError = class extends BaseError {
      constructor({ size: size3, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size3}) exceeds padding size (${targetSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeExceedsPaddingSizeError"
        });
      }
    };
  }
});

// ../node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size3 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size3 });
  return padBytes(hexOrBytes, { dir, size: size3 });
}
function padHex(hex_, { dir, size: size3 = 32 } = {}) {
  if (size3 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size3 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size3,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size3 * 2, "0")}`;
}
function padBytes(bytes4, { dir, size: size3 = 32 } = {}) {
  if (size3 === null)
    return bytes4;
  if (bytes4.length > size3)
    throw new SizeExceedsPaddingSizeError({
      size: bytes4.length,
      targetSize: size3,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size3);
  for (let i = 0; i < size3; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size3 - i - 1] = bytes4[padEnd ? i : bytes4.length - i - 1];
  }
  return paddedBytes;
}
var init_pad = __esm({
  "../node_modules/viem/_esm/utils/data/pad.js"() {
    init_data();
  }
});

// ../node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError, InvalidHexBooleanError, SizeOverflowError;
var init_encoding = __esm({
  "../node_modules/viem/_esm/errors/encoding.js"() {
    init_base();
    IntegerOutOfRangeError = class extends BaseError {
      constructor({ max: max2, min: min2, signed, size: size3, value }) {
        super(`Number "${value}" is not in safe ${size3 ? `${size3 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max2 ? `(${min2} to ${max2})` : `(above ${min2})`}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntegerOutOfRangeError"
        });
      }
    };
    InvalidHexBooleanError = class extends BaseError {
      constructor(hex) {
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidHexBooleanError"
        });
      }
    };
    SizeOverflowError = class extends BaseError {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeOverflowError"
        });
      }
    };
  }
});

// ../node_modules/viem/_esm/utils/data/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}
var init_trim = __esm({
  "../node_modules/viem/_esm/utils/data/trim.js"() {
  }
});

// ../node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size3 }) {
  if (size(hexOrBytes) > size3)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size3
    });
}
function fromHex2(hex, toOrOpts) {
  const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
  const to = opts.to;
  if (to === "number")
    return hexToNumber2(hex, opts);
  if (to === "bigint")
    return hexToBigInt(hex, opts);
  if (to === "string")
    return hexToString(hex, opts);
  if (to === "boolean")
    return hexToBool(hex, opts);
  return hexToBytes2(hex, opts);
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size3 = (hex.length - 2) / 2;
  const max2 = (1n << BigInt(size3) * 8n - 1n) - 1n;
  if (value <= max2)
    return value;
  return value - BigInt(`0x${"f".padStart(size3 * 2, "f")}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = trim(hex);
  }
  if (trim(hex) === "0x00")
    return false;
  if (trim(hex) === "0x01")
    return true;
  throw new InvalidHexBooleanError(hex);
}
function hexToNumber2(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
function hexToString(hex, opts = {}) {
  let bytes4 = hexToBytes2(hex);
  if (opts.size) {
    assertSize(bytes4, { size: opts.size });
    bytes4 = trim(bytes4, { dir: "right" });
  }
  return new TextDecoder().decode(bytes4);
}
var init_fromHex = __esm({
  "../node_modules/viem/_esm/utils/encoding/fromHex.js"() {
    init_encoding();
    init_size();
    init_trim();
    init_toBytes();
  }
});

// ../node_modules/viem/_esm/utils/encoding/toHex.js
function toHex2(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex2(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex2(value, opts = {}) {
  let string = "";
  for (let i = 0; i < value.length; i++) {
    string += hexes3[value[i]];
  }
  const hex = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size3 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size3) {
    if (signed)
      maxValue = (1n << BigInt(size3) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size3) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size3,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size3 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size3)
    return pad(hex, { size: size3 });
  return hex;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex2(value, opts);
}
var hexes3, encoder;
var init_toHex = __esm({
  "../node_modules/viem/_esm/utils/encoding/toHex.js"() {
    init_encoding();
    init_pad();
    init_fromHex();
    hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
    encoder = /* @__PURE__ */ new TextEncoder();
  }
});

// ../node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes2(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex2(value))
    return hexToBytes2(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes4 = new Uint8Array(1);
  bytes4[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes4, { size: opts.size });
    return pad(bytes4, { size: opts.size });
  }
  return bytes4;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  else if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  else if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes2(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes4 = new Uint8Array(length);
  for (let index2 = 0, j = 0; index2 < length; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes4[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes4;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes2(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes4 = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes4, { size: opts.size });
    return pad(bytes4, { dir: "right", size: opts.size });
  }
  return bytes4;
}
var encoder2, charCodeMap;
var init_toBytes = __esm({
  "../node_modules/viem/_esm/utils/encoding/toBytes.js"() {
    init_base();
    init_isHex();
    init_pad();
    init_fromHex();
    init_toHex();
    encoder2 = /* @__PURE__ */ new TextEncoder();
    charCodeMap = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
  }
});

// ../node_modules/viem/_esm/utils/contract/extractFunctionParts.js
function extractFunctionParts(def) {
  const parts = def.match(paramsRegex);
  const type = parts?.[2] || void 0;
  const name = parts?.[3];
  const params = parts?.[5] || void 0;
  return { type, name, params };
}
function extractFunctionName(def) {
  return extractFunctionParts(def).name;
}
function extractFunctionParams(def) {
  const params = extractFunctionParts(def).params;
  const splitParams = params?.split(",").map((x) => x.trim().split(" "));
  return splitParams?.map((param) => ({
    type: param[0],
    name: param[1] === "indexed" ? param[2] : param[1],
    ...param[1] === "indexed" ? { indexed: true } : {}
  }));
}
var paramsRegex;
var init_extractFunctionParts = __esm({
  "../node_modules/viem/_esm/utils/contract/extractFunctionParts.js"() {
    paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
  }
});

// ../node_modules/viem/_esm/utils/hash/getFunctionSignature.js
var getFunctionSignature;
var init_getFunctionSignature = __esm({
  "../node_modules/viem/_esm/utils/hash/getFunctionSignature.js"() {
    init_formatAbiItem();
    init_extractFunctionParts();
    getFunctionSignature = (fn) => {
      if (typeof fn === "string") {
        const name = extractFunctionName(fn);
        const params = extractFunctionParams(fn) || [];
        return `${name}(${params.map(({ type }) => type).join(",")})`;
      }
      return formatAbiItem(fn);
    };
  }
});

// ../node_modules/viem/_esm/utils/hash/getEventSignature.js
var getEventSignature;
var init_getEventSignature = __esm({
  "../node_modules/viem/_esm/utils/hash/getEventSignature.js"() {
    init_getFunctionSignature();
    getEventSignature = (fn) => {
      return getFunctionSignature(fn);
    };
  }
});

// ../node_modules/viem/node_modules/@noble/hashes/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes3(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes3(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
var init_assert2 = __esm({
  "../node_modules/viem/node_modules/@noble/hashes/esm/_assert.js"() {
  }
});

// ../node_modules/viem/node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var U32_MASK64, _32n, rotlSH, rotlSL, rotlBH, rotlBL;
var init_u64 = __esm({
  "../node_modules/viem/node_modules/@noble/hashes/esm/_u64.js"() {
    U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    _32n = /* @__PURE__ */ BigInt(32);
    rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  }
});

// ../node_modules/viem/node_modules/@noble/hashes/esm/utils.js
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  if (!u8a2(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
var u8a2, u32, isLE2, Hash2, toStr;
var init_utils6 = __esm({
  "../node_modules/viem/node_modules/@noble/hashes/esm/utils.js"() {
    u8a2 = (a) => a instanceof Uint8Array;
    u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!isLE2)
      throw new Error("Non little-endian hardware is not supported");
    Hash2 = class {
      clone() {
        return this._cloneInto();
      }
    };
    toStr = {}.toString;
  }
});

// ../node_modules/viem/node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n6, _1n6, _2n5, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
var init_sha3 = __esm({
  "../node_modules/viem/node_modules/@noble/hashes/esm/sha3.js"() {
    init_assert2();
    init_u64();
    init_utils6();
    [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    _0n6 = /* @__PURE__ */ BigInt(0);
    _1n6 = /* @__PURE__ */ BigInt(1);
    _2n5 = /* @__PURE__ */ BigInt(2);
    _7n = /* @__PURE__ */ BigInt(7);
    _256n = /* @__PURE__ */ BigInt(256);
    _0x71n = /* @__PURE__ */ BigInt(113);
    for (let round = 0, R = _1n6, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n6;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n6 ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n5)
          t ^= _1n6 << (_1n6 << /* @__PURE__ */ BigInt(j)) - _1n6;
      }
      _SHA3_IOTA.push(t);
    }
    [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
    rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
    rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
    Keccak = class extends Hash2 {
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        number2(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        exists2(this);
        const { blockLen, state } = this;
        data = toBytes3(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        exists2(this, false);
        bytes3(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes4) {
        number2(bytes4);
        return this.xofInto(new Uint8Array(bytes4));
      }
      digestInto(out) {
        output2(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    gen = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak(blockLen, suffix, outputLen));
    sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
    sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
    sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
    sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
    keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
    keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
    keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
    keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
    genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
    shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);
  }
});

// ../node_modules/viem/_esm/utils/hash/keccak256.js
function keccak2565(value, to_) {
  const to = to_ || "hex";
  const bytes4 = keccak_256(isHex2(value, { strict: false }) ? toBytes2(value) : value);
  if (to === "bytes")
    return bytes4;
  return toHex2(bytes4);
}
var init_keccak256 = __esm({
  "../node_modules/viem/_esm/utils/hash/keccak256.js"() {
    init_sha3();
    init_isHex();
    init_toBytes();
    init_toHex();
  }
});

// ../node_modules/viem/_esm/utils/hash/getEventSelector.js
var hash2, getEventSelector;
var init_getEventSelector = __esm({
  "../node_modules/viem/_esm/utils/hash/getEventSelector.js"() {
    init_toBytes();
    init_getEventSignature();
    init_keccak256();
    hash2 = (value) => keccak2565(toBytes2(value));
    getEventSelector = (fn) => hash2(getEventSignature(fn));
  }
});

// ../node_modules/viem/_esm/errors/address.js
var InvalidAddressError;
var init_address2 = __esm({
  "../node_modules/viem/_esm/errors/address.js"() {
    init_base();
    InvalidAddressError = class extends BaseError {
      constructor({ address }) {
        super(`Address "${address}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAddressError"
        });
      }
    };
  }
});

// ../node_modules/viem/_esm/utils/address/isAddress.js
function isAddress(address) {
  return addressRegex.test(address);
}
var addressRegex;
var init_isAddress = __esm({
  "../node_modules/viem/_esm/utils/address/isAddress.js"() {
    addressRegex = /^0x[a-fA-F0-9]{40}$/;
  }
});

// ../node_modules/viem/_esm/utils/data/concat.js
function concat8(values) {
  if (typeof values[0] === "string")
    return concatHex(values);
  return concatBytes3(values);
}
function concatBytes3(values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  let offset = 0;
  for (const arr of values) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}
function concatHex(values) {
  return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
}
var init_concat = __esm({
  "../node_modules/viem/_esm/utils/data/concat.js"() {
  }
});

// ../node_modules/viem/_esm/utils/data/slice.js
function slice(value, start, end, { strict } = {}) {
  if (isHex2(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertStartOffset(value, start) {
  if (typeof start === "number" && start > 0 && start > size(value) - 1)
    throw new SliceOffsetOutOfBoundsError({
      offset: start,
      position: "start",
      size: size(value)
    });
}
function assertEndOffset(value, start, end) {
  if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  assertStartOffset(value_, start);
  const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
var init_slice = __esm({
  "../node_modules/viem/_esm/utils/data/slice.js"() {
    init_data();
    init_isHex();
    init_size();
  }
});

// ../node_modules/viem/_esm/utils/abi/encodeAbiParameters.js
function encodeAbiParameters(params, values) {
  if (params.length !== values.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: params.length,
      givenLength: values.length
    });
  const preparedParams = prepareParams({
    params,
    values
  });
  const data = encodeParams(preparedParams);
  if (data.length === 0)
    return "0x";
  return data;
}
function prepareParams({ params, values }) {
  const preparedParams = [];
  for (let i = 0; i < params.length; i++) {
    preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
  }
  return preparedParams;
}
function prepareParam({ param, value }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return encodeArray(value, { length, param: { ...param, type } });
  }
  if (param.type === "tuple") {
    return encodeTuple(value, {
      param
    });
  }
  if (param.type === "address") {
    return encodeAddress(value);
  }
  if (param.type === "bool") {
    return encodeBool(value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    const signed = param.type.startsWith("int");
    return encodeNumber(value, { signed });
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(value, { param });
  }
  if (param.type === "string") {
    return encodeString(value);
  }
  throw new InvalidAbiEncodingTypeError(param.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function encodeParams(preparedParams) {
  let staticSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size(encoded);
  }
  const staticParams = [];
  const dynamicParams = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParams.length; i++) {
    const { dynamic, encoded } = preparedParams[i];
    if (dynamic) {
      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
      dynamicParams.push(encoded);
      dynamicSize += size(encoded);
    } else {
      staticParams.push(encoded);
    }
  }
  return concat8([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
  if (!isAddress(value))
    throw new InvalidAddressError({ address: value });
  return { dynamic: false, encoded: padHex(value.toLowerCase()) };
}
function encodeArray(value, { length, param }) {
  const dynamic = length === null;
  if (!Array.isArray(value))
    throw new InvalidArrayError(value);
  if (!dynamic && value.length !== length)
    throw new AbiEncodingArrayLengthMismatchError({
      expectedLength: length,
      givenLength: value.length,
      type: `${param.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParams = [];
  for (let i = 0; i < value.length; i++) {
    const preparedParam = prepareParam({ param, value: value[i] });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParams.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encodeParams(preparedParams);
    if (dynamic) {
      const length2 = numberToHex(preparedParams.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParams.length > 0 ? concat8([length2, data]) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat8(preparedParams.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value, { param }) {
  const [, paramSize] = param.type.split("bytes");
  const bytesSize = size(value);
  if (!paramSize) {
    let value_ = value;
    if (bytesSize % 32 !== 0)
      value_ = padHex(value_, {
        dir: "right",
        size: Math.ceil((value.length - 2) / 2 / 32) * 32
      });
    return {
      dynamic: true,
      encoded: concat8([padHex(numberToHex(bytesSize, { size: 32 })), value_])
    };
  }
  if (bytesSize !== parseInt(paramSize))
    throw new AbiEncodingBytesSizeMismatchError({
      expectedSize: parseInt(paramSize),
      value
    });
  return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
}
function encodeBool(value) {
  return { dynamic: false, encoded: padHex(boolToHex(value)) };
}
function encodeNumber(value, { signed }) {
  return {
    dynamic: false,
    encoded: numberToHex(value, {
      size: 32,
      signed
    })
  };
}
function encodeString(value) {
  const hexValue2 = stringToHex(value);
  const partsLength = Math.ceil(size(hexValue2) / 32);
  const parts = [];
  for (let i = 0; i < partsLength; i++) {
    parts.push(padHex(slice(hexValue2, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  }
  return {
    dynamic: true,
    encoded: concat8([
      padHex(numberToHex(size(hexValue2), { size: 32 })),
      ...parts
    ])
  };
}
function encodeTuple(value, { param }) {
  let dynamic = false;
  const preparedParams = [];
  for (let i = 0; i < param.components.length; i++) {
    const param_ = param.components[i];
    const index2 = Array.isArray(value) ? i : param_.name;
    const preparedParam = prepareParam({
      param: param_,
      value: value[index2]
    });
    preparedParams.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encodeParams(preparedParams) : concat8(preparedParams.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type) {
  const matches = type.match(/^(.*)\[(\d+)?\]$/);
  return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : void 0;
}
var init_encodeAbiParameters = __esm({
  "../node_modules/viem/_esm/utils/abi/encodeAbiParameters.js"() {
    init_abi();
    init_address2();
    init_isAddress();
    init_concat();
    init_pad();
    init_size();
    init_slice();
    init_toHex();
  }
});

// ../node_modules/viem/_esm/utils/hash/getFunctionSelector.js
var hash3, getFunctionSelector;
var init_getFunctionSelector = __esm({
  "../node_modules/viem/_esm/utils/hash/getFunctionSelector.js"() {
    init_slice();
    init_toBytes();
    init_getFunctionSignature();
    init_keccak256();
    hash3 = (value) => keccak2565(toBytes2(value));
    getFunctionSelector = (fn) => slice(hash3(getFunctionSignature(fn)), 0, 4);
  }
});

// ../node_modules/viem/_esm/utils/abi/getAbiItem.js
function getAbiItem({ abi, args = [], name }) {
  const isSelector = isHex2(name, { strict: false });
  const abiItems = abi.filter((abiItem) => {
    if (isSelector) {
      if (abiItem.type === "function")
        return getFunctionSelector(abiItem) === name;
      if (abiItem.type === "event")
        return getEventSelector(abiItem) === name;
      return false;
    }
    return "name" in abiItem && abiItem.name === name;
  });
  if (abiItems.length === 0)
    return void 0;
  if (abiItems.length === 1)
    return abiItems[0];
  for (const abiItem of abiItems) {
    if (!("inputs" in abiItem))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem.inputs || abiItem.inputs.length === 0)
        return abiItem;
      continue;
    }
    if (!abiItem.inputs)
      continue;
    if (abiItem.inputs.length === 0)
      continue;
    if (abiItem.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index2) => {
      const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched)
      return abiItem;
  }
  return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return isAddress(arg);
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index2) => {
          return isArgOfType(Object.values(arg)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
          ...abiParameter,
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
var init_getAbiItem = __esm({
  "../node_modules/viem/_esm/utils/abi/getAbiItem.js"() {
    init_isHex();
    init_getEventSelector();
    init_getFunctionSelector();
    init_isAddress();
  }
});

// ../node_modules/viem/_esm/accounts/utils/parseAccount.js
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}
var init_parseAccount = __esm({
  "../node_modules/viem/_esm/accounts/utils/parseAccount.js"() {
  }
});

// ../node_modules/viem/_esm/utils/abi/encodeFunctionData.js
function encodeFunctionData({ abi, args, functionName }) {
  let abiItem = abi[0];
  if (functionName) {
    abiItem = getAbiItem({
      abi,
      args,
      name: functionName
    });
    if (!abiItem)
      throw new AbiFunctionNotFoundError(functionName, {
        docsPath: "/docs/contract/encodeFunctionData"
      });
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeFunctionData"
    });
  const definition = formatAbiItem(abiItem);
  const signature = getFunctionSelector(definition);
  const data = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
  return concatHex([signature, data ?? "0x"]);
}
var init_encodeFunctionData = __esm({
  "../node_modules/viem/_esm/utils/abi/encodeFunctionData.js"() {
    init_abi();
    init_concat();
    init_getFunctionSelector();
    init_encodeAbiParameters();
    init_formatAbiItem();
    init_getAbiItem();
  }
});

// ../node_modules/viem/_esm/constants/solidity.js
var panicReasons, solidityError, solidityPanic;
var init_solidity = __esm({
  "../node_modules/viem/_esm/constants/solidity.js"() {
    panicReasons = {
      1: "An `assert` condition failed.",
      17: "Arithmic operation resulted in underflow or overflow.",
      18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
      33: "Attempted to convert to an invalid type.",
      34: "Attempted to access a storage byte array that is incorrectly encoded.",
      49: "Performed `.pop()` on an empty array",
      50: "Array index is out of bounds.",
      65: "Allocated too much memory or created an array which is too large.",
      81: "Attempted to call a zero-initialized variable of internal function type."
    };
    solidityError = {
      inputs: [
        {
          name: "message",
          type: "string"
        }
      ],
      name: "Error",
      type: "error"
    };
    solidityPanic = {
      inputs: [
        {
          name: "reason",
          type: "uint256"
        }
      ],
      name: "Panic",
      type: "error"
    };
  }
});

// ../node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
  const hash4 = keccak2565(stringToBytes(hexAddress), "bytes");
  const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash4[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash4[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  return `0x${address.join("")}`;
}
var init_getAddress = __esm({
  "../node_modules/viem/_esm/utils/address/getAddress.js"() {
    init_toBytes();
    init_keccak256();
  }
});

// ../node_modules/viem/_esm/utils/abi/decodeAbiParameters.js
function decodeAbiParameters(params, data) {
  if (data === "0x" && params.length > 0)
    throw new AbiDecodingZeroDataError();
  if (size(data) && size(data) < 32)
    throw new AbiDecodingDataSizeTooSmallError({
      data,
      params,
      size: size(data)
    });
  return decodeParams({
    data,
    params
  });
}
function decodeParams({ data, params }) {
  const decodedValues = [];
  let position = 0;
  for (let i = 0; i < params.length; i++) {
    if (position >= size(data))
      throw new AbiDecodingDataSizeTooSmallError({
        data,
        params,
        size: size(data)
      });
    const param = params[i];
    const { consumed, value } = decodeParam({ data, param, position });
    decodedValues.push(value);
    position += consumed;
  }
  return decodedValues;
}
function decodeParam({ data, param, position }) {
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type] = arrayComponents;
    return decodeArray(data, {
      length,
      param: { ...param, type },
      position
    });
  }
  if (param.type === "tuple") {
    return decodeTuple(data, { param, position });
  }
  if (param.type === "string") {
    return decodeString(data, { position });
  }
  if (param.type.startsWith("bytes")) {
    return decodeBytes(data, { param, position });
  }
  const value = slice(data, position, position + 32, { strict: true });
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return decodeNumber(value, { param });
  }
  if (param.type === "address") {
    return decodeAddress(value);
  }
  if (param.type === "bool") {
    return decodeBool(value);
  }
  throw new InvalidAbiDecodingTypeError(param.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
function decodeAddress(value) {
  return { consumed: 32, value: checksumAddress(slice(value, -20)) };
}
function decodeArray(data, { param, length, position }) {
  if (!length) {
    const offset = hexToNumber2(slice(data, position, position + 32, { strict: true }));
    const length2 = hexToNumber2(slice(data, offset, offset + 32, { strict: true }));
    let consumed2 = 0;
    const value2 = [];
    for (let i = 0; i < length2; ++i) {
      const decodedChild = decodeParam({
        data: slice(data, offset + 32),
        param,
        position: consumed2
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: 32 };
  }
  if (hasDynamicChild(param)) {
    const arrayComponents = getArrayComponents(param.type);
    const dynamicChild = !arrayComponents?.[0];
    let consumed2 = 0;
    const value2 = [];
    for (let i = 0; i < length; ++i) {
      const offset = hexToNumber2(slice(data, position, position + 32, { strict: true }));
      const decodedChild = decodeParam({
        data: slice(data, offset),
        param,
        position: dynamicChild ? consumed2 : i * 32
      });
      consumed2 += decodedChild.consumed;
      value2.push(decodedChild.value);
    }
    return { value: value2, consumed: 32 };
  }
  let consumed = 0;
  const value = [];
  for (let i = 0; i < length; ++i) {
    const decodedChild = decodeParam({
      data,
      param,
      position: position + consumed
    });
    consumed += decodedChild.consumed;
    value.push(decodedChild.value);
  }
  return { value, consumed };
}
function decodeBool(value) {
  return { consumed: 32, value: hexToBool(value) };
}
function decodeBytes(data, { param, position }) {
  const [_, size3] = param.type.split("bytes");
  if (!size3) {
    const offset = hexToNumber2(slice(data, position, position + 32, { strict: true }));
    const length = hexToNumber2(slice(data, offset, offset + 32, { strict: true }));
    if (length === 0)
      return { consumed: 32, value: "0x" };
    const value2 = slice(data, offset + 32, offset + 32 + length, {
      strict: true
    });
    return { consumed: 32, value: value2 };
  }
  const value = slice(data, position, position + parseInt(size3), {
    strict: true
  });
  return { consumed: 32, value };
}
function decodeNumber(value, { param }) {
  const signed = param.type.startsWith("int");
  const size3 = parseInt(param.type.split("int")[1] || "256");
  return {
    consumed: 32,
    value: size3 > 48 ? hexToBigInt(value, { signed }) : hexToNumber2(value, { signed })
  };
}
function decodeString(data, { position }) {
  const offset = hexToNumber2(slice(data, position, position + 32, { strict: true }));
  const length = hexToNumber2(slice(data, offset, offset + 32, { strict: true }));
  if (length === 0)
    return { consumed: 32, value: "" };
  const value = hexToString(trim(slice(data, offset + 32, offset + 32 + length, { strict: true })));
  return { consumed: 32, value };
}
function decodeTuple(data, { param, position }) {
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
  const value = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = hexToNumber2(slice(data, position, position + 32, { strict: true }));
    for (let i = 0; i < param.components.length; ++i) {
      const component = param.components[i];
      const decodedChild = decodeParam({
        data: slice(data, offset),
        param: component,
        position: consumed
      });
      consumed += decodedChild.consumed;
      value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
    }
    return { consumed: 32, value };
  }
  for (let i = 0; i < param.components.length; ++i) {
    const component = param.components[i];
    const decodedChild = decodeParam({
      data,
      param: component,
      position: position + consumed
    });
    consumed += decodedChild.consumed;
    value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
  }
  return { consumed, value };
}
function hasDynamicChild(param) {
  const { type } = param;
  if (type === "string")
    return true;
  if (type === "bytes")
    return true;
  if (type.endsWith("[]"))
    return true;
  if (type === "tuple")
    return param.components?.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
    return true;
  return false;
}
var init_decodeAbiParameters = __esm({
  "../node_modules/viem/_esm/utils/abi/decodeAbiParameters.js"() {
    init_abi();
    init_getAddress();
    init_size();
    init_slice();
    init_trim();
    init_fromHex();
    init_encodeAbiParameters();
  }
});

// ../node_modules/viem/_esm/utils/abi/decodeErrorResult.js
function decodeErrorResult({ abi, data }) {
  const signature = slice(data, 0, 4);
  if (signature === "0x")
    throw new AbiDecodingZeroDataError();
  const abi_ = [...abi || [], solidityError, solidityPanic];
  const abiItem = abi_.find((x) => x.type === "error" && signature === getFunctionSelector(formatAbiItem(x)));
  if (!abiItem)
    throw new AbiErrorSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem,
    args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : void 0,
    errorName: abiItem.name
  };
}
var init_decodeErrorResult = __esm({
  "../node_modules/viem/_esm/utils/abi/decodeErrorResult.js"() {
    init_solidity();
    init_abi();
    init_slice();
    init_getFunctionSelector();
    init_decodeAbiParameters();
    init_formatAbiItem();
  }
});

// ../node_modules/viem/_esm/utils/stringify.js
var stringify2;
var init_stringify = __esm({
  "../node_modules/viem/_esm/utils/stringify.js"() {
    stringify2 = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
      const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
      return typeof replacer === "function" ? replacer(key, value2) : value2;
    }, space);
  }
});

// ../node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
  if (!("name" in abiItem))
    return;
  if (!("inputs" in abiItem))
    return;
  if (!abiItem.inputs)
    return;
  return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? stringify2(args[i]) : args[i]}`).join(", ")})`;
}
var init_formatAbiItemWithArgs = __esm({
  "../node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js"() {
    init_stringify();
  }
});

// ../node_modules/viem/_esm/constants/unit.js
var etherUnits, gweiUnits;
var init_unit = __esm({
  "../node_modules/viem/_esm/constants/unit.js"() {
    etherUnits = {
      gwei: 9,
      wei: 18
    };
    gweiUnits = {
      ether: -9,
      wei: 9
    };
  }
});

// ../node_modules/viem/_esm/utils/unit/formatUnits.js
function formatUnits2(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
var init_formatUnits = __esm({
  "../node_modules/viem/_esm/utils/unit/formatUnits.js"() {
  }
});

// ../node_modules/viem/_esm/utils/unit/formatEther.js
function formatEther2(wei, unit = "wei") {
  return formatUnits2(wei, etherUnits[unit]);
}
var init_formatEther = __esm({
  "../node_modules/viem/_esm/utils/unit/formatEther.js"() {
    init_unit();
    init_formatUnits();
  }
});

// ../node_modules/viem/_esm/utils/unit/formatGwei.js
function formatGwei(wei, unit = "wei") {
  return formatUnits2(wei, gweiUnits[unit]);
}
var init_formatGwei = __esm({
  "../node_modules/viem/_esm/utils/unit/formatGwei.js"() {
    init_unit();
    init_formatUnits();
  }
});

// ../node_modules/viem/_esm/errors/transaction.js
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
var FeeConflictError, InvalidSerializableTransactionError, TransactionExecutionError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError;
var init_transaction = __esm({
  "../node_modules/viem/_esm/errors/transaction.js"() {
    init_formatEther();
    init_formatGwei();
    init_base();
    FeeConflictError = class extends BaseError {
      constructor() {
        super([
          "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
          "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeConflictError"
        });
      }
    };
    InvalidSerializableTransactionError = class extends BaseError {
      constructor({ transaction }) {
        super("Cannot infer a transaction type from provided transaction.", {
          metaMessages: [
            "Provided Transaction:",
            "{",
            prettyPrint(transaction),
            "}",
            "",
            "To infer the type, either provide:",
            "- a `type` to the Transaction, or",
            "- an EIP-1559 Transaction with `maxFeePerGas`, or",
            "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
            "- a Legacy Transaction with `gasPrice`"
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializableTransactionError"
        });
      }
    };
    TransactionExecutionError = class extends BaseError {
      constructor(cause, { account, docsPath: docsPath4, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = prettyPrint({
          chain: chain && `${chain?.name} (id: ${chain?.id})`,
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${formatEther2(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath: docsPath4,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Request Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionExecutionError"
        });
        this.cause = cause;
      }
    };
    TransactionNotFoundError = class extends BaseError {
      constructor({ blockHash, blockNumber, blockTag, hash: hash4, index: index2 }) {
        let identifier = "Transaction";
        if (blockTag && index2 !== void 0)
          identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
        if (blockHash && index2 !== void 0)
          identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
        if (blockNumber && index2 !== void 0)
          identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
        if (hash4)
          identifier = `Transaction with hash "${hash4}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionNotFoundError"
        });
      }
    };
    TransactionReceiptNotFoundError = class extends BaseError {
      constructor({ hash: hash4 }) {
        super(`Transaction receipt with hash "${hash4}" could not be found. The Transaction may not be processed on a block yet.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionReceiptNotFoundError"
        });
      }
    };
    WaitForTransactionReceiptTimeoutError = class extends BaseError {
      constructor({ hash: hash4 }) {
        super(`Timed out while waiting for transaction with hash "${hash4}" to be confirmed.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WaitForTransactionReceiptTimeoutError"
        });
      }
    };
  }
});

// ../node_modules/viem/_esm/errors/contract.js
var CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, RawContractError;
var init_contract = __esm({
  "../node_modules/viem/_esm/errors/contract.js"() {
    init_parseAccount();
    init_solidity();
    init_decodeErrorResult();
    init_formatAbiItem();
    init_formatAbiItemWithArgs();
    init_getAbiItem();
    init_formatEther();
    init_formatGwei();
    init_abi();
    init_base();
    init_transaction();
    init_utils5();
    CallExecutionError = class extends BaseError {
      constructor(cause, { account: account_, docsPath: docsPath4, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const account = account_ ? parseAccount(account_) : void 0;
        const prettyArgs = prettyPrint({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${formatEther2(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath: docsPath4,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Raw Call Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CallExecutionError"
        });
        this.cause = cause;
      }
    };
    ContractFunctionExecutionError = class extends BaseError {
      constructor(cause, { abi, args, contractAddress, docsPath: docsPath4, functionName, sender }) {
        const abiItem = getAbiItem({ abi, args, name: functionName });
        const formattedArgs = abiItem ? formatAbiItemWithArgs({
          abiItem,
          args,
          includeFunctionName: false,
          includeName: false
        }) : void 0;
        const functionWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
        const prettyArgs = prettyPrint({
          address: contractAddress && getContractAddress2(contractAddress),
          function: functionWithParams,
          args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
          sender
        });
        super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
          cause,
          docsPath: docsPath4,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Contract Call:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "abi", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "args", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "contractAddress", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "formattedArgs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "functionName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "sender", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionExecutionError"
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
      }
    };
    ContractFunctionRevertedError = class extends BaseError {
      constructor({ abi, data, functionName, message }) {
        let cause;
        let decodedData = void 0;
        let metaMessages;
        let reason;
        if (data && data !== "0x") {
          try {
            decodedData = decodeErrorResult({ abi, data });
            const { abiItem, errorName, args: errorArgs } = decodedData;
            if (errorName === "Error") {
              reason = errorArgs[0];
            } else if (errorName === "Panic") {
              const [firstArg] = errorArgs;
              reason = panicReasons[firstArg];
            } else {
              const errorWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
              const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
                abiItem,
                args: errorArgs,
                includeFunctionName: false,
                includeName: false
              }) : void 0;
              metaMessages = [
                errorWithParams ? `Error: ${errorWithParams}` : "",
                formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
              ];
            }
          } catch (err) {
            cause = err;
          }
        } else if (message)
          reason = message;
        let signature;
        if (cause instanceof AbiErrorSignatureNotFoundError) {
          signature = cause.signature;
          metaMessages = [
            `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it.",
            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
          ];
        }
        super(reason && reason !== "execution reverted" || signature ? [
          `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
          reason || signature
        ].join("\n") : `The contract function "${functionName}" reverted.`, {
          cause,
          metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionRevertedError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "reason", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = decodedData;
        this.reason = reason;
        this.signature = signature;
      }
    };
    ContractFunctionZeroDataError = class extends BaseError {
      constructor({ functionName }) {
        super(`The contract function "${functionName}" returned no data ("0x").`, {
          metaMessages: [
            "This could be due to any of the following:",
            `  - The contract does not have the function "${functionName}",`,
            "  - The parameters passed to the contract function may be invalid, or",
            "  - The address is not a contract."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionZeroDataError"
        });
      }
    };
    RawContractError = class extends BaseError {
      constructor({ data, message }) {
        super(message || "");
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 3
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RawContractError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
      }
    };
  }
});

// ../node_modules/viem/_esm/errors/request.js
var HttpRequestError, RpcRequestError;
var init_request = __esm({
  "../node_modules/viem/_esm/errors/request.js"() {
    init_stringify();
    init_base();
    init_utils5();
    HttpRequestError = class extends BaseError {
      constructor({ body, details, headers, status, url }) {
        super("HTTP request failed.", {
          details,
          metaMessages: [
            status && `Status: ${status}`,
            `URL: ${getUrl(url)}`,
            body && `Request body: ${stringify2(body)}`
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "HttpRequestError"
        });
        Object.defineProperty(this, "body", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "status", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "url", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
      }
    };
    RpcRequestError = class extends BaseError {
      constructor({ body, error, url }) {
        super("RPC Request failed.", {
          cause: error,
          details: error.message,
          metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify2(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcRequestError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.code = error.code;
      }
    };
  }
});

// ../node_modules/viem/_esm/errors/rpc.js
var unknownErrorCode, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError;
var init_rpc = __esm({
  "../node_modules/viem/_esm/errors/rpc.js"() {
    init_base();
    init_request();
    unknownErrorCode = -1;
    RpcError = class extends BaseError {
      constructor(cause, { code, docsPath: docsPath4, metaMessages, shortMessage }) {
        super(shortMessage, {
          cause,
          docsPath: docsPath4,
          metaMessages: metaMessages || cause?.metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = cause.name;
        this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;
      }
    };
    ProviderRpcError = class extends RpcError {
      constructor(cause, options) {
        super(cause, options);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderRpcError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = options.data;
      }
    };
    ParseRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: ParseRpcError.code,
          shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ParseRpcError"
        });
      }
    };
    Object.defineProperty(ParseRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    InvalidRequestRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: InvalidRequestRpcError.code,
          shortMessage: "JSON is not a valid request object."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidRequestRpcError"
        });
      }
    };
    Object.defineProperty(InvalidRequestRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    MethodNotFoundRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: MethodNotFoundRpcError.code,
          shortMessage: "The method does not exist / is not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotFoundRpcError"
        });
      }
    };
    Object.defineProperty(MethodNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    InvalidParamsRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: InvalidParamsRpcError.code,
          shortMessage: [
            "Invalid parameters were provided to the RPC method.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParamsRpcError"
        });
      }
    };
    Object.defineProperty(InvalidParamsRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    InternalRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: InternalRpcError.code,
          shortMessage: "An internal error was received."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InternalRpcError"
        });
      }
    };
    Object.defineProperty(InternalRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    InvalidInputRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: InvalidInputRpcError.code,
          shortMessage: [
            "Missing or invalid parameters.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidInputRpcError"
        });
      }
    };
    Object.defineProperty(InvalidInputRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    ResourceNotFoundRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: ResourceNotFoundRpcError.code,
          shortMessage: "Requested resource not found."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceNotFoundRpcError"
        });
      }
    };
    Object.defineProperty(ResourceNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    ResourceUnavailableRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: ResourceUnavailableRpcError.code,
          shortMessage: "Requested resource not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceUnavailableRpcError"
        });
      }
    };
    Object.defineProperty(ResourceUnavailableRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    TransactionRejectedRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: TransactionRejectedRpcError.code,
          shortMessage: "Transaction creation failed."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionRejectedRpcError"
        });
      }
    };
    Object.defineProperty(TransactionRejectedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    MethodNotSupportedRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: MethodNotSupportedRpcError.code,
          shortMessage: "Method is not implemented."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotSupportedRpcError"
        });
      }
    };
    Object.defineProperty(MethodNotSupportedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    LimitExceededRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: LimitExceededRpcError.code,
          shortMessage: "Request exceeds defined limit."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "LimitExceededRpcError"
        });
      }
    };
    Object.defineProperty(LimitExceededRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    JsonRpcVersionUnsupportedError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: JsonRpcVersionUnsupportedError.code,
          shortMessage: "Version of JSON-RPC protocol is not supported."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "JsonRpcVersionUnsupportedError"
        });
      }
    };
    Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    UserRejectedRequestError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: UserRejectedRequestError.code,
          shortMessage: "User rejected the request."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UserRejectedRequestError"
        });
      }
    };
    Object.defineProperty(UserRejectedRequestError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    UnauthorizedProviderError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: UnauthorizedProviderError.code,
          shortMessage: "The requested method and/or account has not been authorized by the user."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnauthorizedProviderError"
        });
      }
    };
    Object.defineProperty(UnauthorizedProviderError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    UnsupportedProviderMethodError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: UnsupportedProviderMethodError.code,
          shortMessage: "The Provider does not support the requested method."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnsupportedProviderMethodError"
        });
      }
    };
    Object.defineProperty(UnsupportedProviderMethodError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    ProviderDisconnectedError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: ProviderDisconnectedError.code,
          shortMessage: "The Provider is disconnected from all chains."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderDisconnectedError"
        });
      }
    };
    Object.defineProperty(ProviderDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    ChainDisconnectedError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: ChainDisconnectedError.code,
          shortMessage: "The Provider is not connected to the requested chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDisconnectedError"
        });
      }
    };
    Object.defineProperty(ChainDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    SwitchChainError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: SwitchChainError.code,
          shortMessage: "An error occurred when attempting to switch chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SwitchChainError"
        });
      }
    };
    Object.defineProperty(SwitchChainError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
  }
});

// ../node_modules/viem/_esm/errors/node.js
var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
var init_node = __esm({
  "../node_modules/viem/_esm/errors/node.js"() {
    init_formatGwei();
    init_base();
    ExecutionRevertedError = class extends BaseError {
      constructor({ cause, message } = {}) {
        const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ExecutionRevertedError"
        });
      }
    };
    Object.defineProperty(ExecutionRevertedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /execution reverted/
    });
    FeeCapTooHighError = class extends BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooHigh"
        });
      }
    };
    Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    FeeCapTooLowError = class extends BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooLow"
        });
      }
    };
    Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    NonceTooHighError = class extends BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooHighError"
        });
      }
    };
    Object.defineProperty(NonceTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too high/
    });
    NonceTooLowError = class extends BaseError {
      constructor({ cause, nonce } = {}) {
        super([
          `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
          "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
        ].join("\n"), { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooLowError"
        });
      }
    };
    Object.defineProperty(NonceTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too low|transaction already imported|already known/
    });
    NonceMaxValueError = class extends BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceMaxValueError"
        });
      }
    };
    Object.defineProperty(NonceMaxValueError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce has max value/
    });
    InsufficientFundsError = class extends BaseError {
      constructor({ cause } = {}) {
        super([
          "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
        ].join("\n"), {
          cause,
          metaMessages: [
            "This error could arise when the account does not have enough funds to:",
            " - pay for the total gas fee,",
            " - pay for the value to send.",
            " ",
            "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
            " - `gas` is the amount of gas needed for transaction to execute,",
            " - `gas fee` is the gas fee,",
            " - `value` is the amount of ether to send to the recipient."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InsufficientFundsError"
        });
      }
    };
    Object.defineProperty(InsufficientFundsError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /insufficient funds/
    });
    IntrinsicGasTooHighError = class extends BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooHighError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too high|gas limit reached/
    });
    IntrinsicGasTooLowError = class extends BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooLowError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too low/
    });
    TransactionTypeNotSupportedError = class extends BaseError {
      constructor({ cause }) {
        super("The transaction type is not supported for this chain.", {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionTypeNotSupportedError"
        });
      }
    };
    Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /transaction type not valid/
    });
    TipAboveFeeCapError = class extends BaseError {
      constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
        super([
          `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
        ].join("\n"), {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TipAboveFeeCapError"
        });
      }
    };
    Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
    UnknownNodeError = class extends BaseError {
      constructor({ cause }) {
        super(`An error occurred while executing: ${cause?.shortMessage}`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownNodeError"
        });
      }
    };
  }
});

// ../node_modules/viem/_esm/utils/errors/getNodeError.js
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err.walk((e) => e.code === ExecutionRevertedError.code);
  if (executionRevertedError instanceof BaseError) {
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  } else if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  else if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  else if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  else if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args?.nonce });
  else if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args?.nonce });
  else if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
  else if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  else if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
  else if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
  else if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  else if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
var init_getNodeError = __esm({
  "../node_modules/viem/_esm/utils/errors/getNodeError.js"() {
    init_base();
    init_node();
  }
});

// ../node_modules/viem/_esm/utils/formatters/extract.js
function extract(value, { format }) {
  if (!format)
    return {};
  const keys = Object.keys(format({}));
  return keys.reduce((data, key) => {
    if (value?.hasOwnProperty(key)) {
      data[key] = value[key];
    }
    return data;
  }, {});
}
var init_extract = __esm({
  "../node_modules/viem/_esm/utils/formatters/extract.js"() {
  }
});

// ../node_modules/viem/_esm/utils/formatters/transactionRequest.js
function formatTransactionRequest(transactionRequest) {
  return {
    ...transactionRequest,
    gas: typeof transactionRequest.gas !== "undefined" ? numberToHex(transactionRequest.gas) : void 0,
    gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? numberToHex(transactionRequest.gasPrice) : void 0,
    maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxPriorityFeePerGas) : void 0,
    nonce: typeof transactionRequest.nonce !== "undefined" ? numberToHex(transactionRequest.nonce) : void 0,
    type: typeof transactionRequest.type !== "undefined" ? rpcTransactionType[transactionRequest.type] : void 0,
    value: typeof transactionRequest.value !== "undefined" ? numberToHex(transactionRequest.value) : void 0
  };
}
var rpcTransactionType;
var init_transactionRequest = __esm({
  "../node_modules/viem/_esm/utils/formatters/transactionRequest.js"() {
    init_toHex();
    rpcTransactionType = {
      legacy: "0x0",
      eip2930: "0x1",
      eip1559: "0x2"
    };
  }
});

// ../node_modules/viem/_esm/utils/transaction/assertRequest.js
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError();
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
var init_assertRequest = __esm({
  "../node_modules/viem/_esm/utils/transaction/assertRequest.js"() {
    init_parseAccount();
    init_address2();
    init_node();
    init_transaction();
    init_isAddress();
  }
});

// ../node_modules/viem/_esm/utils/abi/decodeFunctionResult.js
function decodeFunctionResult({ abi, args, functionName, data }) {
  let abiItem = abi[0];
  if (functionName) {
    abiItem = getAbiItem({
      abi,
      args,
      name: functionName
    });
    if (!abiItem)
      throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath2 });
  }
  if (abiItem.type !== "function")
    throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath2 });
  if (!abiItem.outputs)
    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath2 });
  const values = decodeAbiParameters(abiItem.outputs, data);
  if (values && values.length > 1)
    return values;
  if (values && values.length === 1)
    return values[0];
  return void 0;
}
var docsPath2;
var init_decodeFunctionResult = __esm({
  "../node_modules/viem/_esm/utils/abi/decodeFunctionResult.js"() {
    init_abi();
    init_decodeAbiParameters();
    init_getAbiItem();
    docsPath2 = "/docs/contract/decodeFunctionResult";
  }
});

// ../node_modules/viem/_esm/constants/abis.js
var multicall3Abi, universalResolverErrors, universalResolverResolveAbi, universalResolverReverseAbi, textResolverAbi, addressResolverAbi, universalSignatureValidatorAbi;
var init_abis = __esm({
  "../node_modules/viem/_esm/constants/abis.js"() {
    multicall3Abi = [
      {
        inputs: [
          {
            components: [
              {
                name: "target",
                type: "address"
              },
              {
                name: "allowFailure",
                type: "bool"
              },
              {
                name: "callData",
                type: "bytes"
              }
            ],
            name: "calls",
            type: "tuple[]"
          }
        ],
        name: "aggregate3",
        outputs: [
          {
            components: [
              {
                name: "success",
                type: "bool"
              },
              {
                name: "returnData",
                type: "bytes"
              }
            ],
            name: "returnData",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    universalResolverErrors = [
      {
        inputs: [],
        name: "ResolverNotFound",
        type: "error"
      },
      {
        inputs: [],
        name: "ResolverWildcardNotSupported",
        type: "error"
      }
    ];
    universalResolverResolveAbi = [
      ...universalResolverErrors,
      {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes" },
          { name: "data", type: "bytes" }
        ],
        outputs: [
          { name: "", type: "bytes" },
          { name: "address", type: "address" }
        ]
      }
    ];
    universalResolverReverseAbi = [
      ...universalResolverErrors,
      {
        name: "reverse",
        type: "function",
        stateMutability: "view",
        inputs: [{ type: "bytes", name: "reverseName" }],
        outputs: [
          { type: "string", name: "resolvedName" },
          { type: "address", name: "resolvedAddress" },
          { type: "address", name: "reverseResolver" },
          { type: "address", name: "resolver" }
        ]
      }
    ];
    textResolverAbi = [
      {
        name: "text",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes32" },
          { name: "key", type: "string" }
        ],
        outputs: [{ name: "", type: "string" }]
      }
    ];
    addressResolverAbi = [
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [{ name: "name", type: "bytes32" }],
        outputs: [{ name: "", type: "address" }]
      },
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes32" },
          { name: "coinType", type: "uint256" }
        ],
        outputs: [{ name: "", type: "bytes" }]
      }
    ];
    universalSignatureValidatorAbi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_signer",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_hash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      }
    ];
  }
});

// ../node_modules/viem/_esm/constants/contract.js
var aggregate3Signature;
var init_contract2 = __esm({
  "../node_modules/viem/_esm/constants/contract.js"() {
    aggregate3Signature = "0x82ad56cb";
  }
});

// ../node_modules/viem/_esm/errors/chain.js
var ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError;
var init_chain = __esm({
  "../node_modules/viem/_esm/errors/chain.js"() {
    init_base();
    ChainDoesNotSupportContract = class extends BaseError {
      constructor({ blockNumber, chain, contract }) {
        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
          metaMessages: [
            "This could be due to any of the following:",
            ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
              `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
            ] : [
              `- The chain does not have the contract "${contract.name}" configured.`
            ]
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDoesNotSupportContract"
        });
      }
    };
    ChainMismatchError = class extends BaseError {
      constructor({ chain, currentChainId }) {
        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
          metaMessages: [
            `Current Chain ID:  ${currentChainId}`,
            `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainMismatchError"
        });
      }
    };
    ChainNotFoundError = class extends BaseError {
      constructor() {
        super([
          "No chain was provided to the request.",
          "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainNotFoundError"
        });
      }
    };
    ClientChainNotConfiguredError = class extends BaseError {
      constructor() {
        super("No chain was provided to the Client.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ClientChainNotConfiguredError"
        });
      }
    };
  }
});

// ../node_modules/viem/_esm/utils/chain.js
function assertCurrentChain({ chain, currentChainId }) {
  if (!chain)
    throw new ChainNotFoundError();
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId });
}
function getChainContractAddress({ blockNumber, chain, contract: name }) {
  const contract = chain?.contracts?.[name];
  if (!contract)
    throw new ChainDoesNotSupportContract({
      chain,
      contract: { name }
    });
  if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
    throw new ChainDoesNotSupportContract({
      blockNumber,
      chain,
      contract: {
        name,
        blockCreated: contract.blockCreated
      }
    });
  return contract.address;
}
var init_chain2 = __esm({
  "../node_modules/viem/_esm/utils/chain.js"() {
    init_chain();
  }
});

// ../node_modules/viem/_esm/utils/errors/getCallError.js
function getCallError(err, { docsPath: docsPath4, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath: docsPath4,
    ...args
  });
}
var init_getCallError = __esm({
  "../node_modules/viem/_esm/utils/errors/getCallError.js"() {
    init_contract();
    init_node();
    init_getNodeError();
  }
});

// ../node_modules/viem/_esm/utils/promise/createBatchScheduler.js
function createBatchScheduler({ fn, id: id4, shouldSplitBatch, wait: wait2 = 0 }) {
  const exec = async () => {
    const scheduler = getScheduler();
    flush();
    const args = scheduler.map(({ args: args2 }) => args2);
    if (args.length === 0)
      return;
    fn(args).then((data) => {
      scheduler.forEach(({ pendingPromise }, i) => pendingPromise.resolve?.([data[i], data]));
    }).catch((err) => {
      scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err));
    });
  };
  const flush = () => schedulerCache.delete(id4);
  const getBatchedArgs = () => getScheduler().map(({ args }) => args);
  const getScheduler = () => schedulerCache.get(id4) || [];
  const setScheduler = (item) => schedulerCache.set(id4, [...getScheduler(), item]);
  return {
    flush,
    async schedule(args) {
      const pendingPromise = {};
      const promise = new Promise((resolve, reject) => {
        pendingPromise.resolve = resolve;
        pendingPromise.reject = reject;
      });
      const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
      if (split2)
        exec();
      const hasActiveScheduler = getScheduler().length > 0;
      if (hasActiveScheduler) {
        setScheduler({ args, pendingPromise });
        return promise;
      }
      setScheduler({ args, pendingPromise });
      setTimeout(exec, wait2);
      return promise;
    }
  };
}
var schedulerCache;
var init_createBatchScheduler = __esm({
  "../node_modules/viem/_esm/utils/promise/createBatchScheduler.js"() {
    schedulerCache = /* @__PURE__ */ new Map();
  }
});

// ../node_modules/viem/_esm/errors/ccip.js
var OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;
var init_ccip = __esm({
  "../node_modules/viem/_esm/errors/ccip.js"() {
    init_stringify();
    init_base();
    init_utils5();
    OffchainLookupError = class extends BaseError {
      constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
        super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
          cause,
          metaMessages: [
            ...cause.metaMessages || [],
            cause.metaMessages?.length ? "" : [],
            "Offchain Gateway Call:",
            urls && [
              "  Gateway URL(s):",
              ...urls.map((url) => `    ${getUrl(url)}`)
            ],
            `  Sender: ${sender}`,
            `  Data: ${data}`,
            `  Callback selector: ${callbackSelector}`,
            `  Extra data: ${extraData}`
          ].flat()
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupError"
        });
      }
    };
    OffchainLookupResponseMalformedError = class extends BaseError {
      constructor({ result, url }) {
        super("Offchain gateway response is malformed. Response data must be a hex value.", {
          metaMessages: [
            `Gateway URL: ${getUrl(url)}`,
            `Response: ${stringify2(result)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupResponseMalformedError"
        });
      }
    };
    OffchainLookupSenderMismatchError = class extends BaseError {
      constructor({ sender, to }) {
        super("Reverted sender address does not match target contract address (`to`).", {
          metaMessages: [
            `Contract address: ${to}`,
            `OffchainLookup sender address: ${sender}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupSenderMismatchError"
        });
      }
    };
  }
});

// ../node_modules/viem/_esm/utils/address/isAddressEqual.js
function isAddressEqual(a, b) {
  if (!isAddress(a))
    throw new InvalidAddressError({ address: a });
  if (!isAddress(b))
    throw new InvalidAddressError({ address: b });
  return a.toLowerCase() === b.toLowerCase();
}
var init_isAddressEqual = __esm({
  "../node_modules/viem/_esm/utils/address/isAddressEqual.js"() {
    init_address2();
    init_isAddress();
  }
});

// ../node_modules/viem/_esm/utils/ccip.js
var ccip_exports = {};
__export(ccip_exports, {
  ccipFetch: () => ccipFetch,
  offchainLookup: () => offchainLookup,
  offchainLookupAbiItem: () => offchainLookupAbiItem,
  offchainLookupSignature: () => offchainLookupSignature
});
async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
  const { args } = decodeErrorResult({
    data,
    abi: [offchainLookupAbiItem]
  });
  const [sender, urls, callData, callbackSelector, extraData] = args;
  try {
    if (!isAddressEqual(to, sender))
      throw new OffchainLookupSenderMismatchError({ sender, to });
    const result = await ccipFetch({ data: callData, sender, urls });
    const { data: data_ } = await call(client, {
      blockNumber,
      blockTag,
      data: concat8([
        callbackSelector,
        encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
      ]),
      to
    });
    return data_;
  } catch (err) {
    throw new OffchainLookupError({
      callbackSelector,
      cause: err,
      data,
      extraData,
      sender,
      urls
    });
  }
}
async function ccipFetch({ data, sender, urls }) {
  let error = new Error("An unknown error occurred.");
  for (let i = 0; i < urls.length; i++) {
    const url = urls[i];
    const method = url.includes("{sender}") || url.includes("{data}") ? "GET" : "POST";
    const body = method === "POST" ? { data, sender } : void 0;
    try {
      const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
        body: JSON.stringify(body),
        method
      });
      let result;
      if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        result = (await response.json()).data;
      } else {
        result = await response.text();
      }
      if (!response.ok) {
        error = new HttpRequestError({
          body,
          details: stringify2(result.error) || response.statusText,
          headers: response.headers,
          status: response.status,
          url
        });
        continue;
      }
      if (!isHex2(result)) {
        error = new OffchainLookupResponseMalformedError({
          result,
          url
        });
        continue;
      }
      return result;
    } catch (err) {
      error = new HttpRequestError({
        body,
        details: err.message,
        url
      });
    }
  }
  throw error;
}
var offchainLookupSignature, offchainLookupAbiItem;
var init_ccip2 = __esm({
  "../node_modules/viem/_esm/utils/ccip.js"() {
    init_call();
    init_ccip();
    init_request();
    init_decodeErrorResult();
    init_encodeAbiParameters();
    init_isAddressEqual();
    init_concat();
    init_isHex();
    init_stringify();
    offchainLookupSignature = "0x556f1830";
    offchainLookupAbiItem = {
      name: "OffchainLookup",
      type: "error",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "urls",
          type: "string[]"
        },
        {
          name: "callData",
          type: "bytes"
        },
        {
          name: "callbackFunction",
          type: "bytes4"
        },
        {
          name: "extraData",
          type: "bytes"
        }
      ]
    };
  }
});

// ../node_modules/viem/_esm/actions/public/call.js
async function call(client, args) {
  const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  try {
    assertRequest(args);
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const format = client.chain?.formatters?.transactionRequest?.format || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format }),
      from: account?.address,
      accessList,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    if (batch && shouldPerformMulticall({ request })) {
      try {
        return await scheduleMulticall(client, {
          ...request,
          blockNumber,
          blockTag
        });
      } catch (err) {
        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
          throw err;
      }
    }
    const response = await client.request({
      method: "eth_call",
      params: block ? [request, block] : [request]
    });
    if (response === "0x")
      return { data: void 0 };
    return { data: response };
  } catch (err) {
    const data2 = getRevertErrorData(err);
    const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), ccip_exports));
    if (data2?.slice(0, 10) === offchainLookupSignature2 && to) {
      return { data: await offchainLookup2(client, { data: data2, to }) };
    }
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}
function shouldPerformMulticall({ request }) {
  const { data, to, ...request_ } = request;
  if (!data)
    return false;
  if (data.startsWith(aggregate3Signature))
    return false;
  if (!to)
    return false;
  if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
    return false;
  return true;
}
async function scheduleMulticall(client, args) {
  const { batchSize = 1024, wait: wait2 = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
  const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new ClientChainNotConfiguredError();
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const block = blockNumberHex || blockTag;
  const { schedule } = createBatchScheduler({
    id: `${client.uid}.${block}`,
    wait: wait2,
    shouldSplitBatch(args2) {
      const size3 = args2.reduce((size4, { data: data2 }) => size4 + (data2.length - 2), 0);
      return size3 > batchSize * 2;
    },
    fn: async (requests) => {
      const calls = requests.map((request) => ({
        allowFailure: true,
        callData: request.data,
        target: request.to
      }));
      const calldata = encodeFunctionData({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3"
      });
      const data2 = await client.request({
        method: "eth_call",
        params: [
          {
            data: calldata,
            to: multicallAddress
          },
          block
        ]
      });
      return decodeFunctionResult({
        abi: multicall3Abi,
        args: [calls],
        functionName: "aggregate3",
        data: data2 || "0x"
      });
    }
  });
  const [{ returnData, success }] = await schedule({ data, to });
  if (!success)
    throw new RawContractError({ data: returnData });
  if (returnData === "0x")
    return { data: void 0 };
  return { data: returnData };
}
function getRevertErrorData(err) {
  if (!(err instanceof BaseError))
    return void 0;
  const error = err.walk();
  return typeof error.data === "object" ? error.data.data : error.data;
}
var init_call = __esm({
  "../node_modules/viem/_esm/actions/public/call.js"() {
    init_parseAccount();
    init_abis();
    init_contract2();
    init_base();
    init_chain();
    init_contract();
    init_decodeFunctionResult();
    init_encodeFunctionData();
    init_chain2();
    init_toHex();
    init_getCallError();
    init_extract();
    init_transactionRequest();
    init_createBatchScheduler();
    init_assertRequest();
  }
});

// ../node_modules/viem/node_modules/@noble/curves/esm/abstract/utils.js
function equalBytes2(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
var _0n7, _1n7, _2n6;
var init_utils7 = __esm({
  "../node_modules/viem/node_modules/@noble/curves/esm/abstract/utils.js"() {
    _0n7 = BigInt(0);
    _1n7 = BigInt(1);
    _2n6 = BigInt(2);
  }
});

// src/api/abis.ts
var aggregatorV2V3InterfaceABI = [
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "current", internalType: "int256", type: "int256", indexed: true },
      { name: "roundId", internalType: "uint256", type: "uint256", indexed: true },
      { name: "updatedAt", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "AnswerUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "roundId", internalType: "uint256", type: "uint256", indexed: true },
      { name: "startedBy", internalType: "address", type: "address", indexed: true },
      { name: "startedAt", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "NewRound"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "aggregator",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", internalType: "uint8", type: "uint8" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "description",
    outputs: [{ name: "", internalType: "string", type: "string" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "_roundId", internalType: "uint256", type: "uint256" }],
    name: "getAnswer",
    outputs: [{ name: "", internalType: "int256", type: "int256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "_roundId", internalType: "uint80", type: "uint80" }],
    name: "getRoundData",
    outputs: [
      { name: "roundId", internalType: "uint80", type: "uint80" },
      { name: "answer", internalType: "int256", type: "int256" },
      { name: "startedAt", internalType: "uint256", type: "uint256" },
      { name: "updatedAt", internalType: "uint256", type: "uint256" },
      { name: "answeredInRound", internalType: "uint80", type: "uint80" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "_roundId", internalType: "uint256", type: "uint256" }],
    name: "getTimestamp",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "latestAnswer",
    outputs: [{ name: "", internalType: "int256", type: "int256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "latestRound",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "latestRoundData",
    outputs: [
      { name: "roundId", internalType: "uint80", type: "uint80" },
      { name: "answer", internalType: "int256", type: "int256" },
      { name: "startedAt", internalType: "uint256", type: "uint256" },
      { name: "updatedAt", internalType: "uint256", type: "uint256" },
      { name: "answeredInRound", internalType: "uint80", type: "uint80" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "latestTimestamp",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "version",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  }
];
var chainlinkAggregatorV2V3MockABI = [
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "current", internalType: "int256", type: "int256", indexed: true },
      { name: "roundId", internalType: "uint256", type: "uint256", indexed: true },
      { name: "updatedAt", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "AnswerUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "roundId", internalType: "uint256", type: "uint256", indexed: true },
      { name: "startedBy", internalType: "address", type: "address", indexed: true },
      { name: "startedAt", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "NewRound"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "aggregator",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", internalType: "uint8", type: "uint8" }]
  },
  {
    stateMutability: "pure",
    type: "function",
    inputs: [],
    name: "description",
    outputs: [{ name: "", internalType: "string", type: "string" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    name: "getAnswer",
    outputs: [{ name: "", internalType: "int256", type: "int256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "roundId", internalType: "uint80", type: "uint80" }],
    name: "getRoundData",
    outputs: [
      { name: "roundId_", internalType: "uint80", type: "uint80" },
      { name: "answer", internalType: "int256", type: "int256" },
      { name: "startedAt", internalType: "uint256", type: "uint256" },
      { name: "updatedAt", internalType: "uint256", type: "uint256" },
      { name: "answeredInRound", internalType: "uint80", type: "uint80" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    name: "getTimestamp",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "latestAnswer",
    outputs: [{ name: "", internalType: "int256", type: "int256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "latestRound",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "latestRoundData",
    outputs: [
      { name: "roundId", internalType: "uint80", type: "uint80" },
      { name: "answer", internalType: "int256", type: "int256" },
      { name: "startedAt", internalType: "uint256", type: "uint256" },
      { name: "updatedAt", internalType: "uint256", type: "uint256" },
      { name: "answeredInRound", internalType: "uint80", type: "uint80" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "latestTimestamp",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  { stateMutability: "view", type: "function", inputs: [], name: "price", outputs: [{ name: "", internalType: "int256", type: "int256" }] },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "_price", internalType: "int256", type: "int256" }],
    name: "set",
    outputs: [{ name: "", internalType: "contract ChainlinkAggregatorV2V3Mock", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "_decimals", internalType: "uint8", type: "uint8" }],
    name: "setDecimals",
    outputs: [{ name: "", internalType: "contract ChainlinkAggregatorV2V3Mock", type: "address" }]
  },
  {
    stateMutability: "pure",
    type: "function",
    inputs: [],
    name: "version",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  }
];
var contangoABI = [
  {
    stateMutability: "nonpayable",
    type: "constructor",
    inputs: [
      { name: "nft", internalType: "contract PositionNFT", type: "address" },
      { name: "v", internalType: "contract IVault", type: "address" },
      { name: "pf", internalType: "contract IUnderlyingPositionFactory", type: "address" },
      { name: "fm", internalType: "contract IFeeManager", type: "address" },
      { name: "spot", internalType: "contract SpotExecutor", type: "address" }
    ]
  },
  { type: "error", inputs: [], name: "CashflowCcyRequired" },
  { type: "error", inputs: [], name: "ClosingOnly" },
  {
    type: "error",
    inputs: [
      { name: "limit", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "ExcessiveInputQuote"
  },
  { type: "error", inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16" }], name: "InstrumentAlreadyExists" },
  {
    type: "error",
    inputs: [
      { name: "expected", internalType: "int256", type: "int256" },
      { name: "actual", internalType: "int256", type: "int256" }
    ],
    name: "InsufficientBaseCashflow"
  },
  {
    type: "error",
    inputs: [
      { name: "expected", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "int256", type: "int256" }
    ],
    name: "InsufficientBaseOnOpen"
  },
  { type: "error", inputs: [], name: "InvalidCashflowCcy" },
  { type: "error", inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16" }], name: "InvalidInstrument" },
  { type: "error", inputs: [{ name: "msgSender", internalType: "address", type: "address" }], name: "NotFlashBorrowProvider" },
  { type: "error", inputs: [], name: "OnlyFullClosureAllowedAfterExpiry" },
  {
    type: "error",
    inputs: [
      { name: "limit", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "PriceAboveLimit"
  },
  {
    type: "error",
    inputs: [
      { name: "limit", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "PriceBelowLimit"
  },
  { type: "error", inputs: [{ name: "msgSender", internalType: "address", type: "address" }], name: "Unauthorised" },
  { type: "error", inputs: [], name: "UnexpectedCallback" },
  { type: "error", inputs: [], name: "UnexpectedTrade" },
  { type: "error", inputs: [], name: "ZeroDestination" },
  { type: "error", inputs: [], name: "ZeroPayer" },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "previousAdmin", internalType: "address", type: "address", indexed: false },
      { name: "newAdmin", internalType: "address", type: "address", indexed: false }
    ],
    name: "AdminChanged"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "beacon", internalType: "address", type: "address", indexed: true }],
    name: "BeaconUpgraded"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16", indexed: true },
      { name: "closingOnly", internalType: "bool", type: "bool", indexed: false }
    ],
    name: "ClosingOnlySet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "version", internalType: "uint8", type: "uint8", indexed: false }],
    name: "Initialized"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16", indexed: true },
      { name: "base", internalType: "contract IERC20Metadata", type: "address", indexed: false },
      { name: "quote", internalType: "contract IERC20Metadata", type: "address", indexed: false }
    ],
    name: "InstrumentCreated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "id", internalType: "MoneyMarketId", type: "uint8", indexed: true },
      { name: "moneyMarket", internalType: "contract IMoneyMarket", type: "address", indexed: false }
    ],
    name: "MoneyMarketRegistered"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "account", internalType: "address", type: "address", indexed: false }],
    name: "Paused"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32", indexed: true },
      { name: "owner", internalType: "address", type: "address", indexed: true },
      { name: "tradedBy", internalType: "address", type: "address", indexed: true },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8", indexed: false },
      { name: "cashflow", internalType: "int256", type: "int256", indexed: false },
      { name: "quantityDelta", internalType: "int256", type: "int256", indexed: false },
      { name: "price", internalType: "uint256", type: "uint256", indexed: false },
      { name: "fee", internalType: "uint256", type: "uint256", indexed: false },
      { name: "feeCcy", internalType: "enum Currency", type: "uint8", indexed: false }
    ],
    name: "PositionUpserted"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32", indexed: true },
      { name: "to", internalType: "address", type: "address", indexed: true }
    ],
    name: "RewardsClaimed"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "previousAdminRole", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "newAdminRole", internalType: "bytes32", type: "bytes32", indexed: true }
    ],
    name: "RoleAdminChanged"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "sender", internalType: "address", type: "address", indexed: true }
    ],
    name: "RoleGranted"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "sender", internalType: "address", type: "address", indexed: true }
    ],
    name: "RoleRevoked"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "account", internalType: "address", type: "address", indexed: false }],
    name: "Unpaused"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "implementation", internalType: "address", type: "address", indexed: true }],
    name: "Upgraded"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "token", internalType: "contract IERC20Metadata", type: "address" }],
    name: "approveFeeManager",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "claimRewards",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "repayTo", internalType: "address", type: "address" },
      { name: "asset", internalType: "address", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" },
      { name: "fee", internalType: "uint256", type: "uint256" },
      { name: "params", internalType: "bytes", type: "bytes" }
    ],
    name: "completeClose",
    outputs: [{ name: "result", internalType: "bytes", type: "bytes" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "asset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "amountOwed", internalType: "uint256", type: "uint256" },
      { name: "params", internalType: "bytes", type: "bytes" }
    ],
    name: "completeOpenFromFlashBorrow",
    outputs: [{ name: "result", internalType: "bytes", type: "bytes" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "repayTo", internalType: "address", type: "address" },
      { name: "asset", internalType: "address", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" },
      { name: "fee", internalType: "uint256", type: "uint256" },
      { name: "params", internalType: "bytes", type: "bytes" }
    ],
    name: "completeOpenFromFlashLoan",
    outputs: [{ name: "result", internalType: "bytes", type: "bytes" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16" },
      { name: "base", internalType: "contract IERC20Metadata", type: "address" },
      { name: "quote", internalType: "contract IERC20Metadata", type: "address" }
    ],
    name: "createInstrument",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "feeManager",
    outputs: [{ name: "", internalType: "contract IFeeManager", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "role", internalType: "bytes32", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "grantRole",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "timelock", internalType: "Timelock", type: "address" }],
    name: "initialize",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16" }],
    name: "instrument",
    outputs: [
      {
        name: "instrument_",
        internalType: "struct Instrument",
        type: "tuple",
        components: [
          { name: "base", internalType: "contract IERC20Metadata", type: "address" },
          { name: "baseUnit", internalType: "uint256", type: "uint256" },
          { name: "quote", internalType: "contract IERC20Metadata", type: "address" },
          { name: "quoteUnit", internalType: "uint256", type: "uint256" },
          { name: "closingOnly", internalType: "bool", type: "bool" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "data", internalType: "bytes[]", type: "bytes[]" }],
    name: "multicall",
    outputs: [{ name: "results", internalType: "bytes[]", type: "bytes[]" }]
  },
  { stateMutability: "nonpayable", type: "function", inputs: [], name: "pause", outputs: [] },
  { stateMutability: "view", type: "function", inputs: [], name: "paused", outputs: [{ name: "", internalType: "bool", type: "bool" }] },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "positionFactory",
    outputs: [{ name: "", internalType: "contract IUnderlyingPositionFactory", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "positionNFT",
    outputs: [{ name: "", internalType: "contract PositionNFT", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "renounceRole",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "revokeRole",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16" },
      { name: "closingOnly", internalType: "bool", type: "bool" }
    ],
    name: "setClosingOnly",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "spotExecutor",
    outputs: [{ name: "", internalType: "contract SpotExecutor", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "interfaceId", internalType: "bytes4", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      }
    ],
    name: "trade",
    outputs: [
      { name: "", internalType: "PositionId", type: "bytes32" },
      {
        name: "",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      { name: "onBehalfOf", internalType: "address", type: "address" }
    ],
    name: "tradeOnBehalfOf",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  { stateMutability: "nonpayable", type: "function", inputs: [], name: "unpause", outputs: [] },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newImplementation", internalType: "address", type: "address" }],
    name: "upgradeTo",
    outputs: []
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      { name: "newImplementation", internalType: "address", type: "address" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "vault",
    outputs: [{ name: "", internalType: "contract IVault", type: "address" }]
  }
];
var exactlyReverseLookupABI = [
  {
    stateMutability: "nonpayable",
    type: "constructor",
    inputs: [
      { name: "timelock", internalType: "Timelock", type: "address" },
      { name: "_auditor", internalType: "contract IAuditor", type: "address" }
    ]
  },
  { type: "error", inputs: [{ name: "asset", internalType: "contract IERC20Metadata", type: "address" }], name: "MarketNotFound" },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "asset", internalType: "contract IERC20Metadata", type: "address", indexed: true },
      { name: "market", internalType: "contract IExactlyMarket", type: "address", indexed: true }
    ],
    name: "MarketSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "previousAdminRole", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "newAdminRole", internalType: "bytes32", type: "bytes32", indexed: true }
    ],
    name: "RoleAdminChanged"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "sender", internalType: "address", type: "address", indexed: true }
    ],
    name: "RoleGranted"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "sender", internalType: "address", type: "address", indexed: true }
    ],
    name: "RoleRevoked"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "auditor",
    outputs: [{ name: "", internalType: "contract IAuditor", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "role", internalType: "bytes32", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "grantRole",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "asset", internalType: "contract IERC20Metadata", type: "address" }],
    name: "market",
    outputs: [{ name: "_market", internalType: "contract IExactlyMarket", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "renounceRole",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "revokeRole",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "asset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "_market", internalType: "contract IExactlyMarket", type: "address" }
    ],
    name: "setMarket",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "interfaceId", internalType: "bytes4", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  { stateMutability: "nonpayable", type: "function", inputs: [], name: "update", outputs: [] }
];
var exactlyReverseLookupEventsABI = [
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "asset", internalType: "contract IERC20Metadata", type: "address", indexed: true },
      { name: "market", internalType: "contract IExactlyMarket", type: "address", indexed: true }
    ],
    name: "MarketSet"
  }
];
var fixedFeeModelABI = [
  { stateMutability: "nonpayable", type: "constructor", inputs: [{ name: "timelock", internalType: "Timelock", type: "address" }] },
  { type: "error", inputs: [{ name: "fee", internalType: "uint256", type: "uint256" }], name: "AboveMaxFee" },
  { type: "error", inputs: [{ name: "fee", internalType: "uint256", type: "uint256" }], name: "BelowMinFee" },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "fee", internalType: "uint256", type: "uint256", indexed: false }],
    name: "DefaultFeeSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16", indexed: true }],
    name: "FeeRemoved"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16", indexed: true },
      { name: "fee", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "FeeSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "previousAdminRole", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "newAdminRole", internalType: "bytes32", type: "bytes32", indexed: true }
    ],
    name: "RoleAdminChanged"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "sender", internalType: "address", type: "address", indexed: true }
    ],
    name: "RoleGranted"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "sender", internalType: "address", type: "address", indexed: true }
    ],
    name: "RoleRevoked"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "uint256", type: "uint256" }
    ],
    name: "calculateFee",
    outputs: [{ name: "calculatedFee", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "defaultFee",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "role", internalType: "bytes32", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "grantRole",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16" }],
    name: "removeFee",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "renounceRole",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "revokeRole",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "fee", internalType: "uint256", type: "uint256" }],
    name: "setDefaultFee",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16" },
      { name: "fee", internalType: "uint256", type: "uint256" }
    ],
    name: "setFee",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "interfaceId", internalType: "bytes4", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16" }],
    name: "symbolFee",
    outputs: [{ name: "fee", internalType: "uint256", type: "uint256" }]
  }
];
var iAaveOracleABI = [
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "asset", internalType: "address", type: "address", indexed: true },
      { name: "source", internalType: "address", type: "address", indexed: true }
    ],
    name: "AssetSourceUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "baseCurrency", internalType: "address", type: "address", indexed: true },
      { name: "baseCurrencyUnit", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "BaseCurrencySet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "fallbackOracle", internalType: "address", type: "address", indexed: true }],
    name: "FallbackOracleUpdated"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "ADDRESSES_PROVIDER",
    outputs: [{ name: "", internalType: "contract IPoolAddressesProvider", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "BASE_CURRENCY",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "BASE_CURRENCY_UNIT",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "asset", internalType: "address", type: "address" }],
    name: "getAssetPrice",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "assets", internalType: "address[]", type: "address[]" }],
    name: "getAssetsPrices",
    outputs: [{ name: "", internalType: "uint256[]", type: "uint256[]" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getFallbackOracle",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "asset", internalType: "address", type: "address" }],
    name: "getSourceOfAsset",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "assets", internalType: "address[]", type: "address[]" },
      { name: "sources", internalType: "address[]", type: "address[]" }
    ],
    name: "setAssetSources",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "fallbackOracle", internalType: "address", type: "address" }],
    name: "setFallbackOracle",
    outputs: []
  }
];
var ierc20MetadataABI = [
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "owner", internalType: "address", type: "address", indexed: true },
      { name: "spender", internalType: "address", type: "address", indexed: true },
      { name: "value", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Approval"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "from", internalType: "address", type: "address", indexed: true },
      { name: "to", internalType: "address", type: "address", indexed: true },
      { name: "value", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Transfer"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "owner", internalType: "address", type: "address" },
      { name: "spender", internalType: "address", type: "address" }
    ],
    name: "allowance",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "spender", internalType: "address", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", internalType: "uint8", type: "uint8" }]
  },
  { stateMutability: "view", type: "function", inputs: [], name: "name", outputs: [{ name: "", internalType: "string", type: "string" }] },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "symbol",
    outputs: [{ name: "", internalType: "string", type: "string" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "to", internalType: "address", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "from", internalType: "address", type: "address" },
      { name: "to", internalType: "address", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  }
];
var ierc20PermitABI = [
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "owner", internalType: "address", type: "address" }],
    name: "nonces",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "owner", internalType: "address", type: "address" },
      { name: "spender", internalType: "address", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" },
      { name: "deadline", internalType: "uint256", type: "uint256" },
      { name: "v", internalType: "uint8", type: "uint8" },
      { name: "r", internalType: "bytes32", type: "bytes32" },
      { name: "s", internalType: "bytes32", type: "bytes32" }
    ],
    name: "permit",
    outputs: []
  }
];
var ierc7399ABI = [
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "loanReceiver", internalType: "address", type: "address" },
      { name: "asset", internalType: "address", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" },
      { name: "data", internalType: "bytes", type: "bytes" },
      {
        name: "callback",
        internalType: "function (address,address,address,uint256,uint256,bytes) external returns (bytes)",
        type: "function"
      }
    ],
    name: "flash",
    outputs: [{ name: "", internalType: "bytes", type: "bytes" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "asset", internalType: "address", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ],
    name: "flashFee",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "asset", internalType: "address", type: "address" }],
    name: "maxFlashLoan",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  }
];
var iExactlyMarketABI = [
  { type: "error", inputs: [], name: "Disagreement" },
  { type: "error", inputs: [], name: "InsufficientProtocolLiquidity" },
  { type: "error", inputs: [], name: "MaturityOverflow" },
  { type: "error", inputs: [], name: "NotAuditor" },
  { type: "error", inputs: [], name: "SelfLiquidation" },
  {
    type: "error",
    inputs: [
      { name: "", internalType: "uint8", type: "uint8" },
      { name: "", internalType: "uint8", type: "uint8" }
    ],
    name: "UnmatchedPoolState"
  },
  {
    type: "error",
    inputs: [
      { name: "", internalType: "uint8", type: "uint8" },
      { name: "", internalType: "uint8", type: "uint8" },
      { name: "", internalType: "uint8", type: "uint8" }
    ],
    name: "UnmatchedPoolStates"
  },
  { type: "error", inputs: [], name: "ZeroBorrow" },
  { type: "error", inputs: [], name: "ZeroDeposit" },
  { type: "error", inputs: [], name: "ZeroRepay" },
  { type: "error", inputs: [], name: "ZeroWithdraw" },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "timestamp", internalType: "uint256", type: "uint256", indexed: false }],
    name: "AccumulatorAccrual"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "owner", internalType: "address", type: "address", indexed: true },
      { name: "spender", internalType: "address", type: "address", indexed: true },
      { name: "amount", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Approval"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "backupFeeRate", internalType: "uint256", type: "uint256", indexed: false }],
    name: "BackupFeeRateSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "caller", internalType: "address", type: "address", indexed: true },
      { name: "receiver", internalType: "address", type: "address", indexed: true },
      { name: "borrower", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "shares", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Borrow"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "maturity", internalType: "uint256", type: "uint256", indexed: true },
      { name: "caller", internalType: "address", type: "address", indexed: false },
      { name: "receiver", internalType: "address", type: "address", indexed: true },
      { name: "borrower", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "fee", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "BorrowAtMaturity"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "dampSpeedUp", internalType: "uint256", type: "uint256", indexed: false },
      { name: "dampSpeedDown", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "DampSpeedSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "caller", internalType: "address", type: "address", indexed: true },
      { name: "owner", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "shares", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Deposit"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "maturity", internalType: "uint256", type: "uint256", indexed: true },
      { name: "caller", internalType: "address", type: "address", indexed: true },
      { name: "owner", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "fee", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "DepositAtMaturity"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "earningsAccumulatorSmoothFactor", internalType: "uint256", type: "uint256", indexed: false }],
    name: "EarningsAccumulatorSmoothFactorSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "timestamp", internalType: "uint256", type: "uint256", indexed: false },
      { name: "maturity", internalType: "uint256", type: "uint256", indexed: true },
      { name: "unassignedEarnings", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "FixedEarningsUpdate"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "timestamp", internalType: "uint256", type: "uint256", indexed: false },
      { name: "utilization", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "FloatingDebtUpdate"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "version", internalType: "uint8", type: "uint8", indexed: false }],
    name: "Initialized"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "interestRateModel", internalType: "address", type: "address", indexed: true }],
    name: "InterestRateModelSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "receiver", internalType: "address", type: "address", indexed: true },
      { name: "borrower", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "lendersAssets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "seizeMarket", internalType: "address", type: "address", indexed: true },
      { name: "seizedAssets", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Liquidate"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "timestamp", internalType: "uint256", type: "uint256", indexed: false },
      { name: "floatingDepositShares", internalType: "uint256", type: "uint256", indexed: false },
      { name: "floatingAssets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "floatingBorrowShares", internalType: "uint256", type: "uint256", indexed: false },
      { name: "floatingDebt", internalType: "uint256", type: "uint256", indexed: false },
      { name: "earningsAccumulator", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "MarketUpdate"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "maxFuturePools", internalType: "uint256", type: "uint256", indexed: false }],
    name: "MaxFuturePoolsSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "account", internalType: "address", type: "address", indexed: false }],
    name: "Paused"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "penaltyRate", internalType: "uint256", type: "uint256", indexed: false }],
    name: "PenaltyRateSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "caller", internalType: "address", type: "address", indexed: true },
      { name: "borrower", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "shares", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Repay"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "maturity", internalType: "uint256", type: "uint256", indexed: true },
      { name: "caller", internalType: "address", type: "address", indexed: true },
      { name: "borrower", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "positionAssets", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "RepayAtMaturity"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "reserveFactor", internalType: "uint256", type: "uint256", indexed: false }],
    name: "ReserveFactorSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "rewardsController", internalType: "address", type: "address", indexed: true }],
    name: "RewardsControllerSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "previousAdminRole", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "newAdminRole", internalType: "bytes32", type: "bytes32", indexed: true }
    ],
    name: "RoleAdminChanged"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "sender", internalType: "address", type: "address", indexed: true }
    ],
    name: "RoleGranted"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "sender", internalType: "address", type: "address", indexed: true }
    ],
    name: "RoleRevoked"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "liquidator", internalType: "address", type: "address", indexed: true },
      { name: "borrower", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Seize"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "borrower", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "SpreadBadDebt"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "from", internalType: "address", type: "address", indexed: true },
      { name: "to", internalType: "address", type: "address", indexed: true },
      { name: "amount", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Transfer"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "treasury", internalType: "address", type: "address", indexed: true },
      { name: "treasuryFeeRate", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "TreasurySet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "account", internalType: "address", type: "address", indexed: false }],
    name: "Unpaused"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "caller", internalType: "address", type: "address", indexed: true },
      { name: "receiver", internalType: "address", type: "address", indexed: true },
      { name: "owner", internalType: "address", type: "address", indexed: true },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "shares", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "Withdraw"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "maturity", internalType: "uint256", type: "uint256", indexed: true },
      { name: "caller", internalType: "address", type: "address", indexed: false },
      { name: "receiver", internalType: "address", type: "address", indexed: true },
      { name: "owner", internalType: "address", type: "address", indexed: true },
      { name: "positionAssets", internalType: "uint256", type: "uint256", indexed: false },
      { name: "assets", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "WithdrawAtMaturity"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "PAUSER_ROLE",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "accountSnapshot",
    outputs: [
      { name: "", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "address", type: "address" }],
    name: "accounts",
    outputs: [
      { name: "fixedDeposits", internalType: "uint256", type: "uint256" },
      { name: "fixedBorrows", internalType: "uint256", type: "uint256" },
      { name: "floatingBorrowShares", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "address", type: "address" }
    ],
    name: "allowance",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "spender", internalType: "address", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "asset",
    outputs: [{ name: "", internalType: "contract IERC20Metadata", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "auditor",
    outputs: [{ name: "", internalType: "contract IAuditor", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "backupFeeRate",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "address", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "assets", internalType: "uint256", type: "uint256" },
      { name: "receiver", internalType: "address", type: "address" },
      { name: "borrower", internalType: "address", type: "address" }
    ],
    name: "borrow",
    outputs: [{ name: "borrowShares", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "maturity", internalType: "uint256", type: "uint256" },
      { name: "assets", internalType: "uint256", type: "uint256" },
      { name: "maxAssets", internalType: "uint256", type: "uint256" },
      { name: "receiver", internalType: "address", type: "address" },
      { name: "borrower", internalType: "address", type: "address" }
    ],
    name: "borrowAtMaturity",
    outputs: [{ name: "assetsOwed", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "borrower", internalType: "address", type: "address" }],
    name: "clearBadDebt",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "shares", internalType: "uint256", type: "uint256" }],
    name: "convertToAssets",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "assets", internalType: "uint256", type: "uint256" }],
    name: "convertToShares",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "dampSpeedDown",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "dampSpeedUp",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", internalType: "uint8", type: "uint8" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "assets", internalType: "uint256", type: "uint256" },
      { name: "receiver", internalType: "address", type: "address" }
    ],
    name: "deposit",
    outputs: [{ name: "shares", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "maturity", internalType: "uint256", type: "uint256" },
      { name: "assets", internalType: "uint256", type: "uint256" },
      { name: "minAssetsRequired", internalType: "uint256", type: "uint256" },
      { name: "receiver", internalType: "address", type: "address" }
    ],
    name: "depositAtMaturity",
    outputs: [{ name: "positionAssets", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "earningsAccumulator",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "earningsAccumulatorSmoothFactor",
    outputs: [{ name: "", internalType: "uint128", type: "uint128" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "address", type: "address" }
    ],
    name: "fixedBorrowPositions",
    outputs: [
      { name: "principal", internalType: "uint256", type: "uint256" },
      { name: "fee", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "address", type: "address" }
    ],
    name: "fixedDepositPositions",
    outputs: [
      { name: "principal", internalType: "uint256", type: "uint256" },
      { name: "fee", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "maturity", internalType: "uint256", type: "uint256" }],
    name: "fixedPoolBalance",
    outputs: [
      { name: "", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "maturity", internalType: "uint256", type: "uint256" }],
    name: "fixedPoolBorrowed",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    name: "fixedPools",
    outputs: [
      { name: "borrowed", internalType: "uint256", type: "uint256" },
      { name: "supplied", internalType: "uint256", type: "uint256" },
      { name: "unassignedEarnings", internalType: "uint256", type: "uint256" },
      { name: "lastAccrual", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "floatingAssets",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "floatingAssetsAverage",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "floatingBackupBorrowed",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "floatingDebt",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "role", internalType: "bytes32", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "grantRole",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "maxFuturePools_", internalType: "uint8", type: "uint8" },
      { name: "earningsAccumulatorSmoothFactor_", internalType: "uint128", type: "uint128" },
      { name: "interestRateModel_", internalType: "address", type: "address" },
      { name: "penaltyRate_", internalType: "uint256", type: "uint256" },
      { name: "backupFeeRate_", internalType: "uint256", type: "uint256" },
      { name: "reserveFactor_", internalType: "uint128", type: "uint128" },
      { name: "dampSpeedUp_", internalType: "uint256", type: "uint256" },
      { name: "dampSpeedDown_", internalType: "uint256", type: "uint256" }
    ],
    name: "initialize",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "interestRateModel",
    outputs: [{ name: "", internalType: "contract IInterestRateModel", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "lastAccumulatorAccrual",
    outputs: [{ name: "", internalType: "uint32", type: "uint32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "lastAverageUpdate",
    outputs: [{ name: "", internalType: "uint32", type: "uint32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "lastFloatingDebtUpdate",
    outputs: [{ name: "", internalType: "uint32", type: "uint32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "borrower", internalType: "address", type: "address" },
      { name: "maxAssets", internalType: "uint256", type: "uint256" },
      { name: "seizeMarket", internalType: "address", type: "address" }
    ],
    name: "liquidate",
    outputs: [{ name: "repaidAssets", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "address", type: "address" }],
    name: "maxDeposit",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "maxFuturePools",
    outputs: [{ name: "", internalType: "uint8", type: "uint8" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "address", type: "address" }],
    name: "maxMint",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "owner", internalType: "address", type: "address" }],
    name: "maxRedeem",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "owner", internalType: "address", type: "address" }],
    name: "maxWithdraw",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "shares", internalType: "uint256", type: "uint256" },
      { name: "receiver", internalType: "address", type: "address" }
    ],
    name: "mint",
    outputs: [{ name: "assets", internalType: "uint256", type: "uint256" }]
  },
  { stateMutability: "view", type: "function", inputs: [], name: "name", outputs: [{ name: "", internalType: "string", type: "string" }] },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "address", type: "address" }],
    name: "nonces",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  { stateMutability: "nonpayable", type: "function", inputs: [], name: "pause", outputs: [] },
  { stateMutability: "view", type: "function", inputs: [], name: "paused", outputs: [{ name: "", internalType: "bool", type: "bool" }] },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "penaltyRate",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "owner", internalType: "address", type: "address" },
      { name: "spender", internalType: "address", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" },
      { name: "deadline", internalType: "uint256", type: "uint256" },
      { name: "v", internalType: "uint8", type: "uint8" },
      { name: "r", internalType: "bytes32", type: "bytes32" },
      { name: "s", internalType: "bytes32", type: "bytes32" }
    ],
    name: "permit",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "assets", internalType: "uint256", type: "uint256" }],
    name: "previewBorrow",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "borrower", internalType: "address", type: "address" }],
    name: "previewDebt",
    outputs: [{ name: "debt", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "assets", internalType: "uint256", type: "uint256" }],
    name: "previewDeposit",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "previewFloatingAssetsAverage",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "shares", internalType: "uint256", type: "uint256" }],
    name: "previewMint",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "shares", internalType: "uint256", type: "uint256" }],
    name: "previewRedeem",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "shares", internalType: "uint256", type: "uint256" }],
    name: "previewRefund",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "assets", internalType: "uint256", type: "uint256" }],
    name: "previewRepay",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "assets", internalType: "uint256", type: "uint256" }],
    name: "previewWithdraw",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "shares", internalType: "uint256", type: "uint256" },
      { name: "receiver", internalType: "address", type: "address" },
      { name: "owner", internalType: "address", type: "address" }
    ],
    name: "redeem",
    outputs: [{ name: "assets", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "borrowShares", internalType: "uint256", type: "uint256" },
      { name: "borrower", internalType: "address", type: "address" }
    ],
    name: "refund",
    outputs: [
      { name: "assets", internalType: "uint256", type: "uint256" },
      { name: "actualShares", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "renounceRole",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "assets", internalType: "uint256", type: "uint256" },
      { name: "borrower", internalType: "address", type: "address" }
    ],
    name: "repay",
    outputs: [
      { name: "actualRepay", internalType: "uint256", type: "uint256" },
      { name: "borrowShares", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "maturity", internalType: "uint256", type: "uint256" },
      { name: "positionAssets", internalType: "uint256", type: "uint256" },
      { name: "maxAssets", internalType: "uint256", type: "uint256" },
      { name: "borrower", internalType: "address", type: "address" }
    ],
    name: "repayAtMaturity",
    outputs: [{ name: "actualRepayAssets", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "reserveFactor",
    outputs: [{ name: "", internalType: "uint128", type: "uint128" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "role", internalType: "bytes32", type: "bytes32" },
      { name: "account", internalType: "address", type: "address" }
    ],
    name: "revokeRole",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "rewardsController",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "liquidator", internalType: "address", type: "address" },
      { name: "borrower", internalType: "address", type: "address" },
      { name: "assets", internalType: "uint256", type: "uint256" }
    ],
    name: "seize",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "backupFeeRate_", internalType: "uint256", type: "uint256" }],
    name: "setBackupFeeRate",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "up", internalType: "uint256", type: "uint256" },
      { name: "down", internalType: "uint256", type: "uint256" }
    ],
    name: "setDampSpeed",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "earningsAccumulatorSmoothFactor_", internalType: "uint128", type: "uint128" }],
    name: "setEarningsAccumulatorSmoothFactor",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "interestRateModel_", internalType: "address", type: "address" }],
    name: "setInterestRateModel",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "futurePools", internalType: "uint8", type: "uint8" }],
    name: "setMaxFuturePools",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "penaltyRate_", internalType: "uint256", type: "uint256" }],
    name: "setPenaltyRate",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "reserveFactor_", internalType: "uint128", type: "uint128" }],
    name: "setReserveFactor",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "rewardsController_", internalType: "address", type: "address" }],
    name: "setRewardsController",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "treasury_", internalType: "address", type: "address" },
      { name: "treasuryFeeRate_", internalType: "uint256", type: "uint256" }
    ],
    name: "setTreasury",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "interfaceId", internalType: "bytes4", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "symbol",
    outputs: [{ name: "", internalType: "string", type: "string" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "totalAssets",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "totalFloatingBorrowAssets",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "totalFloatingBorrowShares",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "to", internalType: "address", type: "address" },
      { name: "shares", internalType: "uint256", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "from", internalType: "address", type: "address" },
      { name: "to", internalType: "address", type: "address" },
      { name: "shares", internalType: "uint256", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "treasury",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "treasuryFeeRate",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  { stateMutability: "nonpayable", type: "function", inputs: [], name: "unpause", outputs: [] },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "assets", internalType: "uint256", type: "uint256" },
      { name: "receiver", internalType: "address", type: "address" },
      { name: "owner", internalType: "address", type: "address" }
    ],
    name: "withdraw",
    outputs: [{ name: "shares", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "maturity", internalType: "uint256", type: "uint256" },
      { name: "positionAssets", internalType: "uint256", type: "uint256" },
      { name: "minAssetsRequired", internalType: "uint256", type: "uint256" },
      { name: "receiver", internalType: "address", type: "address" },
      { name: "owner", internalType: "address", type: "address" }
    ],
    name: "withdrawAtMaturity",
    outputs: [{ name: "assetsDiscounted", internalType: "uint256", type: "uint256" }]
  }
];
var iExactlyPreviewerABI = [
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "auditor",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "basePriceFeed",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "account", internalType: "address", type: "address" }],
    name: "exactly",
    outputs: [
      {
        name: "data",
        internalType: "struct IExactlyPreviewer.MarketAccount[]",
        type: "tuple[]",
        components: [
          { name: "market", internalType: "address", type: "address" },
          { name: "symbol", internalType: "string", type: "string" },
          { name: "decimals", internalType: "uint8", type: "uint8" },
          { name: "asset", internalType: "address", type: "address" },
          { name: "assetName", internalType: "string", type: "string" },
          { name: "assetSymbol", internalType: "string", type: "string" },
          {
            name: "interestRateModel",
            internalType: "struct IExactlyPreviewer.InterestRateModel",
            type: "tuple",
            components: [
              { name: "id", internalType: "address", type: "address" },
              { name: "fixedCurveA", internalType: "uint256", type: "uint256" },
              { name: "fixedCurveB", internalType: "int256", type: "int256" },
              { name: "fixedMaxUtilization", internalType: "uint256", type: "uint256" },
              { name: "floatingCurveA", internalType: "uint256", type: "uint256" },
              { name: "floatingCurveB", internalType: "int256", type: "int256" },
              { name: "floatingMaxUtilization", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "usdPrice", internalType: "uint256", type: "uint256" },
          { name: "penaltyRate", internalType: "uint256", type: "uint256" },
          { name: "adjustFactor", internalType: "uint256", type: "uint256" },
          { name: "maxFuturePools", internalType: "uint8", type: "uint8" },
          {
            name: "fixedPools",
            internalType: "struct IExactlyPreviewer.FixedPool[]",
            type: "tuple[]",
            components: [
              { name: "maturity", internalType: "uint256", type: "uint256" },
              { name: "borrowed", internalType: "uint256", type: "uint256" },
              { name: "supplied", internalType: "uint256", type: "uint256" },
              { name: "available", internalType: "uint256", type: "uint256" },
              { name: "utilization", internalType: "uint256", type: "uint256" },
              { name: "depositRate", internalType: "uint256", type: "uint256" },
              { name: "minBorrowRate", internalType: "uint256", type: "uint256" },
              { name: "optimalDeposit", internalType: "uint256", type: "uint256" }
            ]
          },
          {
            name: "rewardRates",
            internalType: "struct IExactlyPreviewer.RewardRate[]",
            type: "tuple[]",
            components: [
              { name: "asset", internalType: "address", type: "address" },
              { name: "assetName", internalType: "string", type: "string" },
              { name: "assetSymbol", internalType: "string", type: "string" },
              { name: "usdPrice", internalType: "uint256", type: "uint256" },
              { name: "borrow", internalType: "uint256", type: "uint256" },
              { name: "floatingDeposit", internalType: "uint256", type: "uint256" },
              { name: "maturities", internalType: "uint256[]", type: "uint256[]" }
            ]
          },
          { name: "floatingBorrowRate", internalType: "uint256", type: "uint256" },
          { name: "floatingUtilization", internalType: "uint256", type: "uint256" },
          { name: "floatingBackupBorrowed", internalType: "uint256", type: "uint256" },
          { name: "floatingAvailableAssets", internalType: "uint256", type: "uint256" },
          { name: "totalFloatingBorrowAssets", internalType: "uint256", type: "uint256" },
          { name: "totalFloatingDepositAssets", internalType: "uint256", type: "uint256" },
          { name: "totalFloatingBorrowShares", internalType: "uint256", type: "uint256" },
          { name: "totalFloatingDepositShares", internalType: "uint256", type: "uint256" },
          { name: "isCollateral", internalType: "bool", type: "bool" },
          { name: "maxBorrowAssets", internalType: "uint256", type: "uint256" },
          { name: "floatingBorrowShares", internalType: "uint256", type: "uint256" },
          { name: "floatingBorrowAssets", internalType: "uint256", type: "uint256" },
          { name: "floatingDepositShares", internalType: "uint256", type: "uint256" },
          { name: "floatingDepositAssets", internalType: "uint256", type: "uint256" },
          {
            name: "fixedDepositPositions",
            internalType: "struct IExactlyPreviewer.FixedPosition[]",
            type: "tuple[]",
            components: [
              { name: "maturity", internalType: "uint256", type: "uint256" },
              { name: "previewValue", internalType: "uint256", type: "uint256" },
              {
                name: "position",
                internalType: "struct IExactlyPreviewer.Position",
                type: "tuple",
                components: [
                  { name: "principal", internalType: "uint256", type: "uint256" },
                  { name: "fee", internalType: "uint256", type: "uint256" }
                ]
              }
            ]
          },
          {
            name: "fixedBorrowPositions",
            internalType: "struct IExactlyPreviewer.FixedPosition[]",
            type: "tuple[]",
            components: [
              { name: "maturity", internalType: "uint256", type: "uint256" },
              { name: "previewValue", internalType: "uint256", type: "uint256" },
              {
                name: "position",
                internalType: "struct IExactlyPreviewer.Position",
                type: "tuple",
                components: [
                  { name: "principal", internalType: "uint256", type: "uint256" },
                  { name: "fee", internalType: "uint256", type: "uint256" }
                ]
              }
            ]
          },
          {
            name: "claimableRewards",
            internalType: "struct IExactlyPreviewer.ClaimableReward[]",
            type: "tuple[]",
            components: [
              { name: "asset", internalType: "address", type: "address" },
              { name: "assetName", internalType: "string", type: "string" },
              { name: "assetSymbol", internalType: "string", type: "string" },
              { name: "amount", internalType: "uint256", type: "uint256" }
            ]
          }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "market", internalType: "address", type: "address" },
      { name: "assets", internalType: "uint256", type: "uint256" }
    ],
    name: "previewBorrowAtAllMaturities",
    outputs: [
      {
        name: "previews",
        internalType: "struct IExactlyPreviewer.FixedPreview[]",
        type: "tuple[]",
        components: [
          { name: "maturity", internalType: "uint256", type: "uint256" },
          { name: "assets", internalType: "uint256", type: "uint256" },
          { name: "utilization", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "market", internalType: "address", type: "address" },
      { name: "maturity", internalType: "uint256", type: "uint256" },
      { name: "assets", internalType: "uint256", type: "uint256" }
    ],
    name: "previewBorrowAtMaturity",
    outputs: [
      {
        name: "",
        internalType: "struct IExactlyPreviewer.FixedPreview",
        type: "tuple",
        components: [
          { name: "maturity", internalType: "uint256", type: "uint256" },
          { name: "assets", internalType: "uint256", type: "uint256" },
          { name: "utilization", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "market", internalType: "address", type: "address" },
      { name: "assets", internalType: "uint256", type: "uint256" }
    ],
    name: "previewDepositAtAllMaturities",
    outputs: [
      {
        name: "previews",
        internalType: "struct IExactlyPreviewer.FixedPreview[]",
        type: "tuple[]",
        components: [
          { name: "maturity", internalType: "uint256", type: "uint256" },
          { name: "assets", internalType: "uint256", type: "uint256" },
          { name: "utilization", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "market", internalType: "address", type: "address" },
      { name: "maturity", internalType: "uint256", type: "uint256" },
      { name: "assets", internalType: "uint256", type: "uint256" }
    ],
    name: "previewDepositAtMaturity",
    outputs: [
      {
        name: "",
        internalType: "struct IExactlyPreviewer.FixedPreview",
        type: "tuple",
        components: [
          { name: "maturity", internalType: "uint256", type: "uint256" },
          { name: "assets", internalType: "uint256", type: "uint256" },
          { name: "utilization", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "market", internalType: "address", type: "address" },
      { name: "maturity", internalType: "uint256", type: "uint256" },
      { name: "positionAssets", internalType: "uint256", type: "uint256" },
      { name: "borrower", internalType: "address", type: "address" }
    ],
    name: "previewRepayAtMaturity",
    outputs: [
      {
        name: "",
        internalType: "struct IExactlyPreviewer.FixedPreview",
        type: "tuple",
        components: [
          { name: "maturity", internalType: "uint256", type: "uint256" },
          { name: "assets", internalType: "uint256", type: "uint256" },
          { name: "utilization", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "market", internalType: "address", type: "address" },
      { name: "maturity", internalType: "uint256", type: "uint256" },
      { name: "positionAssets", internalType: "uint256", type: "uint256" },
      { name: "owner", internalType: "address", type: "address" }
    ],
    name: "previewWithdrawAtMaturity",
    outputs: [
      {
        name: "",
        internalType: "struct IExactlyPreviewer.FixedPreview",
        type: "tuple",
        components: [
          { name: "maturity", internalType: "uint256", type: "uint256" },
          { name: "assets", internalType: "uint256", type: "uint256" },
          { name: "utilization", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  }
];
var iFlashBorrowProviderABI = [
  { type: "error", inputs: [], name: "InvalidSenderOrInitiator" },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "asset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" },
      { name: "params", internalType: "bytes", type: "bytes" },
      { name: "callback", internalType: "function (contract IERC20Metadata,uint256,bytes) external returns (bytes)", type: "function" }
    ],
    name: "flashBorrow",
    outputs: [{ name: "result", internalType: "bytes", type: "bytes" }]
  }
];
var iMoneyMarketABI = [
  { type: "error", inputs: [], name: "InvalidMoneyMarketId" },
  { type: "error", inputs: [], name: "RewardsNotImplemented" },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "NEEDS_ACCOUNT",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "asset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "borrow",
    outputs: [{ name: "actualAmount", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "collateralAsset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "debtAsset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "claimRewards",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "asset", internalType: "contract IERC20Metadata", type: "address" }
    ],
    name: "collateralBalance",
    outputs: [{ name: "balance", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "collateralAsset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "debtAsset", internalType: "contract IERC20Metadata", type: "address" }
    ],
    name: "initialise",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "asset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ],
    name: "lend",
    outputs: [{ name: "actualAmount", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "moneyMarketId",
    outputs: [{ name: "", internalType: "MoneyMarketId", type: "uint8" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "asset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ],
    name: "repay",
    outputs: [{ name: "actualAmount", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "interfaceId", internalType: "bytes4", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "asset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "withdraw",
    outputs: [{ name: "actualAmount", internalType: "uint256", type: "uint256" }]
  }
];
var iMoneyMarketViewABI = [
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "collateralAsset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "debtAsset", internalType: "contract IERC20Metadata", type: "address" }
    ],
    name: "balances",
    outputs: [
      {
        name: "balances_",
        internalType: "struct Balances",
        type: "tuple",
        components: [
          { name: "collateral", internalType: "uint256", type: "uint256" },
          { name: "debt", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "collateralAsset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "debtAsset", internalType: "contract IERC20Metadata", type: "address" }
    ],
    name: "liquidity",
    outputs: [
      { name: "borrowing", internalType: "uint256", type: "uint256" },
      { name: "lending", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "moneyMarketId",
    outputs: [{ name: "", internalType: "MoneyMarketId", type: "uint8" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "collateralAsset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "debtAsset", internalType: "contract IERC20Metadata", type: "address" }
    ],
    name: "prices",
    outputs: [
      {
        name: "prices_",
        internalType: "struct Prices",
        type: "tuple",
        components: [
          { name: "collateral", internalType: "uint256", type: "uint256" },
          { name: "debt", internalType: "uint256", type: "uint256" },
          { name: "unit", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "collateralAsset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "debtAsset", internalType: "contract IERC20Metadata", type: "address" }
    ],
    name: "rates",
    outputs: [
      { name: "borrowing", internalType: "uint256", type: "uint256" },
      { name: "lending", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "collateralAsset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "debtAsset", internalType: "contract IERC20Metadata", type: "address" }
    ],
    name: "rewards",
    outputs: [
      {
        name: "borrowing",
        internalType: "struct Reward[]",
        type: "tuple[]",
        components: [
          {
            name: "token",
            internalType: "struct TokenData",
            type: "tuple",
            components: [
              { name: "token", internalType: "contract IERC20Metadata", type: "address" },
              { name: "name", internalType: "string", type: "string" },
              { name: "symbol", internalType: "string", type: "string" },
              { name: "decimals", internalType: "uint8", type: "uint8" },
              { name: "unit", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "rate", internalType: "uint256", type: "uint256" },
          { name: "claimable", internalType: "uint256", type: "uint256" },
          { name: "usdPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      {
        name: "lending",
        internalType: "struct Reward[]",
        type: "tuple[]",
        components: [
          {
            name: "token",
            internalType: "struct TokenData",
            type: "tuple",
            components: [
              { name: "token", internalType: "contract IERC20Metadata", type: "address" },
              { name: "name", internalType: "string", type: "string" },
              { name: "symbol", internalType: "string", type: "string" },
              { name: "decimals", internalType: "uint8", type: "uint8" },
              { name: "unit", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "rate", internalType: "uint256", type: "uint256" },
          { name: "claimable", internalType: "uint256", type: "uint256" },
          { name: "usdPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "collateralAsset", internalType: "contract IERC20Metadata", type: "address" },
      { name: "debtAsset", internalType: "contract IERC20Metadata", type: "address" }
    ],
    name: "thresholds",
    outputs: [
      { name: "ltv", internalType: "uint256", type: "uint256" },
      { name: "liquidationThreshold", internalType: "uint256", type: "uint256" }
    ]
  }
];
var iOrderManagerABI = [
  { type: "error", inputs: [{ name: "gasMultiplier", internalType: "uint64", type: "uint64" }], name: "AboveMaxGasMultiplier" },
  { type: "error", inputs: [{ name: "gasMultiplier", internalType: "uint64", type: "uint64" }], name: "BelowMinGasMultiplier" },
  { type: "error", inputs: [], name: "CashflowCcyRequired" },
  { type: "error", inputs: [], name: "ClosingOnly" },
  {
    type: "error",
    inputs: [
      { name: "limit", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "ExcessiveInputQuote"
  },
  { type: "error", inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16" }], name: "InstrumentAlreadyExists" },
  {
    type: "error",
    inputs: [
      { name: "expected", internalType: "int256", type: "int256" },
      { name: "actual", internalType: "int256", type: "int256" }
    ],
    name: "InsufficientBaseCashflow"
  },
  {
    type: "error",
    inputs: [
      { name: "expected", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "int256", type: "int256" }
    ],
    name: "InsufficientBaseOnOpen"
  },
  { type: "error", inputs: [], name: "InvalidCashflowCcy" },
  {
    type: "error",
    inputs: [
      { name: "deadline", internalType: "uint256", type: "uint256" },
      { name: "blockTimestamp", internalType: "uint256", type: "uint256" }
    ],
    name: "InvalidDeadline"
  },
  { type: "error", inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16" }], name: "InvalidInstrument" },
  { type: "error", inputs: [{ name: "orderType", internalType: "enum OrderType", type: "uint8" }], name: "InvalidOrderType" },
  {
    type: "error",
    inputs: [
      { name: "forwardPrice", internalType: "uint256", type: "uint256" },
      { name: "limitPrice", internalType: "uint256", type: "uint256" }
    ],
    name: "InvalidPrice"
  },
  { type: "error", inputs: [], name: "InvalidQuantity" },
  { type: "error", inputs: [{ name: "tolerance", internalType: "uint256", type: "uint256" }], name: "InvalidTolerance" },
  { type: "error", inputs: [{ name: "msgSender", internalType: "address", type: "address" }], name: "NotFlashBorrowProvider" },
  { type: "error", inputs: [], name: "OnlyFullClosureAllowedAfterExpiry" },
  { type: "error", inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }], name: "OrderAlreadyExists" },
  { type: "error", inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }], name: "OrderDoesNotExist" },
  {
    type: "error",
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32" },
      { name: "deadline", internalType: "uint256", type: "uint256" },
      { name: "blockTimestamp", internalType: "uint256", type: "uint256" }
    ],
    name: "OrderExpired"
  },
  { type: "error", inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }], name: "OrderInvalidated" },
  { type: "error", inputs: [{ name: "positionId", internalType: "PositionId", type: "bytes32" }], name: "PositionDoesNotExist" },
  {
    type: "error",
    inputs: [
      { name: "limit", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "PriceAboveLimit"
  },
  {
    type: "error",
    inputs: [
      { name: "limit", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "PriceBelowLimit"
  },
  { type: "error", inputs: [], name: "UnexpectedCallback" },
  { type: "error", inputs: [], name: "UnexpectedTrade" },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "gasMultiplier", internalType: "uint256", type: "uint256", indexed: false }],
    name: "GasMultiplierSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "gasTip", internalType: "uint256", type: "uint256", indexed: false }],
    name: "GasTipSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32", indexed: true }],
    name: "OrderCancelled"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32", indexed: true },
      { name: "positionId", internalType: "PositionId", type: "bytes32", indexed: true },
      { name: "keeperReward", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "OrderExecuted"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32", indexed: true },
      { name: "positionId", internalType: "PositionId", type: "bytes32", indexed: true },
      { name: "owner", internalType: "address", type: "address", indexed: true },
      { name: "quantity", internalType: "int256", type: "int256", indexed: false },
      { name: "limitPrice", internalType: "uint256", type: "uint256", indexed: false },
      { name: "tolerance", internalType: "uint256", type: "uint256", indexed: false },
      { name: "cashflow", internalType: "int256", type: "int256", indexed: false },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8", indexed: false },
      { name: "deadline", internalType: "uint256", type: "uint256", indexed: false },
      { name: "orderType", internalType: "enum OrderType", type: "uint8", indexed: false },
      { name: "placedBy", internalType: "address", type: "address", indexed: false }
    ],
    name: "OrderPlaced"
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }],
    name: "cancel",
    outputs: []
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32" },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      }
    ],
    name: "execute",
    outputs: [
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "keeperReward_", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }],
    name: "hasOrder",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "nativeToken",
    outputs: [{ name: "", internalType: "contract IWETH9", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }],
    name: "orders",
    outputs: [
      {
        name: "order",
        internalType: "struct Order",
        type: "tuple",
        components: [
          { name: "owner", internalType: "address", type: "address" },
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "tolerance", internalType: "uint256", type: "uint256" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct OrderParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int128", type: "int128" },
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint256", type: "uint256" },
          { name: "cashflow", internalType: "int128", type: "int128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "place",
    outputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct OrderParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int128", type: "int128" },
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint256", type: "uint256" },
          { name: "cashflow", internalType: "int128", type: "int128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      },
      { name: "onBehalfOf", internalType: "address", type: "address" }
    ],
    name: "placeOnBehalfOf",
    outputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "positionNFT",
    outputs: [{ name: "", internalType: "contract PositionNFT", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "gasMultiplier", internalType: "uint64", type: "uint64" }],
    name: "setGasMultiplier",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "gasTip", internalType: "uint64", type: "uint64" }],
    name: "setGasTip",
    outputs: []
  }
];
var iOrderManagerErrorsABI = [
  { type: "error", inputs: [{ name: "gasMultiplier", internalType: "uint64", type: "uint64" }], name: "AboveMaxGasMultiplier" },
  { type: "error", inputs: [{ name: "gasMultiplier", internalType: "uint64", type: "uint64" }], name: "BelowMinGasMultiplier" },
  {
    type: "error",
    inputs: [
      { name: "deadline", internalType: "uint256", type: "uint256" },
      { name: "blockTimestamp", internalType: "uint256", type: "uint256" }
    ],
    name: "InvalidDeadline"
  },
  { type: "error", inputs: [{ name: "orderType", internalType: "enum OrderType", type: "uint8" }], name: "InvalidOrderType" },
  {
    type: "error",
    inputs: [
      { name: "forwardPrice", internalType: "uint256", type: "uint256" },
      { name: "limitPrice", internalType: "uint256", type: "uint256" }
    ],
    name: "InvalidPrice"
  },
  { type: "error", inputs: [], name: "InvalidQuantity" },
  { type: "error", inputs: [{ name: "tolerance", internalType: "uint256", type: "uint256" }], name: "InvalidTolerance" },
  { type: "error", inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }], name: "OrderAlreadyExists" },
  { type: "error", inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }], name: "OrderDoesNotExist" },
  {
    type: "error",
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32" },
      { name: "deadline", internalType: "uint256", type: "uint256" },
      { name: "blockTimestamp", internalType: "uint256", type: "uint256" }
    ],
    name: "OrderExpired"
  },
  { type: "error", inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }], name: "OrderInvalidated" },
  { type: "error", inputs: [{ name: "positionId", internalType: "PositionId", type: "bytes32" }], name: "PositionDoesNotExist" }
];
var iOrderManagerEventsABI = [
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "gasMultiplier", internalType: "uint256", type: "uint256", indexed: false }],
    name: "GasMultiplierSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "gasTip", internalType: "uint256", type: "uint256", indexed: false }],
    name: "GasTipSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32", indexed: true }],
    name: "OrderCancelled"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32", indexed: true },
      { name: "positionId", internalType: "PositionId", type: "bytes32", indexed: true },
      { name: "keeperReward", internalType: "uint256", type: "uint256", indexed: false }
    ],
    name: "OrderExecuted"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32", indexed: true },
      { name: "positionId", internalType: "PositionId", type: "bytes32", indexed: true },
      { name: "owner", internalType: "address", type: "address", indexed: true },
      { name: "quantity", internalType: "int256", type: "int256", indexed: false },
      { name: "limitPrice", internalType: "uint256", type: "uint256", indexed: false },
      { name: "tolerance", internalType: "uint256", type: "uint256", indexed: false },
      { name: "cashflow", internalType: "int256", type: "int256", indexed: false },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8", indexed: false },
      { name: "deadline", internalType: "uint256", type: "uint256", indexed: false },
      { name: "orderType", internalType: "enum OrderType", type: "uint8", indexed: false },
      { name: "placedBy", internalType: "address", type: "address", indexed: false }
    ],
    name: "OrderPlaced"
  }
];
var iPoolAddressesProviderABI = [
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "oldAddress", internalType: "address", type: "address", indexed: true },
      { name: "newAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "ACLAdminUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "oldAddress", internalType: "address", type: "address", indexed: true },
      { name: "newAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "ACLManagerUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "id", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "oldAddress", internalType: "address", type: "address", indexed: true },
      { name: "newAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "AddressSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "id", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "proxyAddress", internalType: "address", type: "address", indexed: true },
      { name: "oldImplementationAddress", internalType: "address", type: "address", indexed: false },
      { name: "newImplementationAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "AddressSetAsProxy"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "oldMarketId", internalType: "string", type: "string", indexed: true },
      { name: "newMarketId", internalType: "string", type: "string", indexed: true }
    ],
    name: "MarketIdSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "oldAddress", internalType: "address", type: "address", indexed: true },
      { name: "newAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "PoolConfiguratorUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "oldAddress", internalType: "address", type: "address", indexed: true },
      { name: "newAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "PoolDataProviderUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "oldAddress", internalType: "address", type: "address", indexed: true },
      { name: "newAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "PoolUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "oldAddress", internalType: "address", type: "address", indexed: true },
      { name: "newAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "PriceOracleSentinelUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "oldAddress", internalType: "address", type: "address", indexed: true },
      { name: "newAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "PriceOracleUpdated"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "id", internalType: "bytes32", type: "bytes32", indexed: true },
      { name: "proxyAddress", internalType: "address", type: "address", indexed: true },
      { name: "implementationAddress", internalType: "address", type: "address", indexed: true }
    ],
    name: "ProxyCreated"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getACLAdmin",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getACLManager",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "id", internalType: "bytes32", type: "bytes32" }],
    name: "getAddress",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getMarketId",
    outputs: [{ name: "", internalType: "string", type: "string" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getPool",
    outputs: [{ name: "", internalType: "contract IPool", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getPoolConfigurator",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getPoolDataProvider",
    outputs: [{ name: "", internalType: "contract IPoolDataProvider", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getPriceOracle",
    outputs: [{ name: "", internalType: "contract IAaveOracle", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getPriceOracleSentinel",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newAclAdmin", internalType: "address", type: "address" }],
    name: "setACLAdmin",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newAclManager", internalType: "address", type: "address" }],
    name: "setACLManager",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "id", internalType: "bytes32", type: "bytes32" },
      { name: "newAddress", internalType: "address", type: "address" }
    ],
    name: "setAddress",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "id", internalType: "bytes32", type: "bytes32" },
      { name: "newImplementationAddress", internalType: "address", type: "address" }
    ],
    name: "setAddressAsProxy",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newMarketId", internalType: "string", type: "string" }],
    name: "setMarketId",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newPoolConfiguratorImpl", internalType: "address", type: "address" }],
    name: "setPoolConfiguratorImpl",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newDataProvider", internalType: "address", type: "address" }],
    name: "setPoolDataProvider",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newPoolImpl", internalType: "address", type: "address" }],
    name: "setPoolImpl",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newPriceOracle", internalType: "address", type: "address" }],
    name: "setPriceOracle",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newPriceOracleSentinel", internalType: "address", type: "address" }],
    name: "setPriceOracleSentinel",
    outputs: []
  }
];
var iUnderlyingPositionFactoryABI = [
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "mm", internalType: "MoneyMarketId", type: "uint8", indexed: true },
      { name: "moneyMarket", internalType: "contract IMoneyMarket", type: "address", indexed: true }
    ],
    name: "MoneyMarketRegistered"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "positionId", internalType: "PositionId", type: "bytes32", indexed: true }
    ],
    name: "UnderlyingPositionCreated"
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "", internalType: "PositionId", type: "bytes32" }],
    name: "createUnderlyingPosition",
    outputs: [{ name: "", internalType: "contract IMoneyMarket", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "PositionId", type: "bytes32" }],
    name: "moneyMarket",
    outputs: [{ name: "", internalType: "contract IMoneyMarket", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "MoneyMarketId", type: "uint8" }],
    name: "moneyMarket",
    outputs: [{ name: "", internalType: "contract IMoneyMarket", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "imm", internalType: "contract IMoneyMarket", type: "address" }],
    name: "registerMoneyMarket",
    outputs: []
  }
];
var iUnderlyingPositionFactoryEventsABI = [
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "mm", internalType: "MoneyMarketId", type: "uint8", indexed: true },
      { name: "moneyMarket", internalType: "contract IMoneyMarket", type: "address", indexed: true }
    ],
    name: "MoneyMarketRegistered"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "account", internalType: "address", type: "address", indexed: true },
      { name: "positionId", internalType: "PositionId", type: "bytes32", indexed: true }
    ],
    name: "UnderlyingPositionCreated"
  }
];
var maestroABI = [
  {
    stateMutability: "nonpayable",
    type: "constructor",
    inputs: [
      { name: "_timelock", internalType: "Timelock", type: "address" },
      { name: "_contango", internalType: "contract IContango", type: "address" },
      { name: "_orderManager", internalType: "contract IOrderManager", type: "address" },
      { name: "_vault", internalType: "contract IVault", type: "address" },
      { name: "_permit2", internalType: "contract IPermit2", type: "address" },
      { name: "_spotExecutor", internalType: "contract SimpleSpotExecutor", type: "address" }
    ]
  },
  { type: "error", inputs: [{ name: "gasMultiplier", internalType: "uint64", type: "uint64" }], name: "AboveMaxGasMultiplier" },
  { type: "error", inputs: [{ name: "gasMultiplier", internalType: "uint64", type: "uint64" }], name: "BelowMinGasMultiplier" },
  { type: "error", inputs: [], name: "CashflowCcyRequired" },
  { type: "error", inputs: [], name: "ClosingOnly" },
  {
    type: "error",
    inputs: [
      { name: "limit", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "ExcessiveInputQuote"
  },
  { type: "error", inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16" }], name: "InstrumentAlreadyExists" },
  {
    type: "error",
    inputs: [
      { name: "expected", internalType: "int256", type: "int256" },
      { name: "actual", internalType: "int256", type: "int256" }
    ],
    name: "InsufficientBaseCashflow"
  },
  {
    type: "error",
    inputs: [
      { name: "expected", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "int256", type: "int256" }
    ],
    name: "InsufficientBaseOnOpen"
  },
  {
    type: "error",
    inputs: [
      { name: "required", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "InsufficientPermitAmount"
  },
  { type: "error", inputs: [], name: "InvalidCashflow" },
  { type: "error", inputs: [], name: "InvalidCashflowCcy" },
  {
    type: "error",
    inputs: [
      { name: "deadline", internalType: "uint256", type: "uint256" },
      { name: "blockTimestamp", internalType: "uint256", type: "uint256" }
    ],
    name: "InvalidDeadline"
  },
  { type: "error", inputs: [{ name: "symbol", internalType: "Symbol", type: "bytes16" }], name: "InvalidInstrument" },
  { type: "error", inputs: [{ name: "orderType", internalType: "enum OrderType", type: "uint8" }], name: "InvalidOrderType" },
  {
    type: "error",
    inputs: [
      { name: "forwardPrice", internalType: "uint256", type: "uint256" },
      { name: "limitPrice", internalType: "uint256", type: "uint256" }
    ],
    name: "InvalidPrice"
  },
  { type: "error", inputs: [], name: "InvalidQuantity" },
  { type: "error", inputs: [{ name: "tolerance", internalType: "uint256", type: "uint256" }], name: "InvalidTolerance" },
  {
    type: "error",
    inputs: [
      { name: "orderId1", internalType: "OrderId", type: "bytes32" },
      { name: "orderId2", internalType: "OrderId", type: "bytes32" }
    ],
    name: "MismatchingPositionId"
  },
  {
    type: "error",
    inputs: [
      { name: "token", internalType: "contract IERC20Metadata", type: "address" },
      { name: "balance", internalType: "uint256", type: "uint256" },
      { name: "requested", internalType: "uint256", type: "uint256" }
    ],
    name: "NotEnoughBalance"
  },
  { type: "error", inputs: [{ name: "msgSender", internalType: "address", type: "address" }], name: "NotFlashBorrowProvider" },
  { type: "error", inputs: [{ name: "token", internalType: "contract IERC20Metadata", type: "address" }], name: "NotNativeToken" },
  { type: "error", inputs: [], name: "OnlyFullClosureAllowedAfterExpiry" },
  { type: "error", inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }], name: "OrderAlreadyExists" },
  { type: "error", inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }], name: "OrderDoesNotExist" },
  {
    type: "error",
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32" },
      { name: "deadline", internalType: "uint256", type: "uint256" },
      { name: "blockTimestamp", internalType: "uint256", type: "uint256" }
    ],
    name: "OrderExpired"
  },
  { type: "error", inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }], name: "OrderInvalidated" },
  { type: "error", inputs: [{ name: "positionId", internalType: "PositionId", type: "bytes32" }], name: "PositionDoesNotExist" },
  {
    type: "error",
    inputs: [
      { name: "limit", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "PriceAboveLimit"
  },
  {
    type: "error",
    inputs: [
      { name: "limit", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" }
    ],
    name: "PriceBelowLimit"
  },
  {
    type: "error",
    inputs: [
      { name: "msgSender", internalType: "address", type: "address" },
      { name: "nativeToken", internalType: "address", type: "address" }
    ],
    name: "SenderIsNotNativeToken"
  },
  { type: "error", inputs: [{ name: "msgSender", internalType: "address", type: "address" }], name: "Unauthorised" },
  { type: "error", inputs: [], name: "UnexpectedCallback" },
  { type: "error", inputs: [], name: "UnexpectedTrade" },
  { type: "error", inputs: [{ name: "token", internalType: "contract IERC20Metadata", type: "address" }], name: "UnsupportedToken" },
  { type: "error", inputs: [], name: "ZeroAmount" },
  { type: "error", inputs: [], name: "ZeroDestination" },
  { type: "error", inputs: [], name: "ZeroPayer" },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "previousAdmin", internalType: "address", type: "address", indexed: false },
      { name: "newAdmin", internalType: "address", type: "address", indexed: false }
    ],
    name: "AdminChanged"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "beacon", internalType: "address", type: "address", indexed: true }],
    name: "BeaconUpgraded"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "version", internalType: "uint8", type: "uint8", indexed: false }],
    name: "Initialized"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "implementation", internalType: "address", type: "address", indexed: true }],
    name: "Upgraded"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "UPPER_BIT_MASK",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      { name: "to", internalType: "address", type: "address" },
      { name: "native", internalType: "bool", type: "bool" }
    ],
    name: "_tradeAndWithdraw",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "token", internalType: "contract IERC20Permit", type: "address" },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      },
      { name: "spender", internalType: "address", type: "address" }
    ],
    name: "applyPermit",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }],
    name: "cancel",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "orderId1", internalType: "OrderId", type: "bytes32" },
      { name: "orderId2", internalType: "OrderId", type: "bytes32" }
    ],
    name: "cancel",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32" },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "cancelAndWithdraw",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "orderId", internalType: "OrderId", type: "bytes32" },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "cancelAndWithdrawNative",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "cancelOrderId", internalType: "OrderId", type: "bytes32" },
      {
        name: "newLinkedOrderParams",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "cancelReplaceLinkedOrder",
    outputs: [{ name: "newLinkedOrderId", internalType: "OrderId", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "cancelOrderId1", internalType: "OrderId", type: "bytes32" },
      { name: "cancelOrderId2", internalType: "OrderId", type: "bytes32" },
      {
        name: "newLinkedOrderParams1",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      },
      {
        name: "newLinkedOrderParams2",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "cancelReplaceLinkedOrders",
    outputs: [
      { name: "newLinkedOrderId1", internalType: "OrderId", type: "bytes32" },
      { name: "newLinkedOrderId2", internalType: "OrderId", type: "bytes32" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "contango",
    outputs: [{ name: "", internalType: "contract IContango", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "token", internalType: "contract IERC20Metadata", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ],
    name: "deposit",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct OrderParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int128", type: "int128" },
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint256", type: "uint256" },
          { name: "cashflow", internalType: "int128", type: "int128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "depositAndPlace",
    outputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct OrderParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int128", type: "int128" },
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint256", type: "uint256" },
          { name: "cashflow", internalType: "int128", type: "int128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      }
    ],
    name: "depositAndPlaceWithPermit",
    outputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      }
    ],
    name: "depositAndTrade",
    outputs: [
      { name: "", internalType: "PositionId", type: "bytes32" },
      {
        name: "",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      }
    ],
    name: "depositAndTradeWithPermit",
    outputs: [
      { name: "", internalType: "PositionId", type: "bytes32" },
      {
        name: "",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [],
    name: "depositNative",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      {
        name: "linkedOrderParams",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "depositTradeAndLinkedOrder",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "linkedOrderId", internalType: "OrderId", type: "bytes32" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      {
        name: "linkedOrderParams",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      }
    ],
    name: "depositTradeAndLinkedOrderWithPermit",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "linkedOrderId", internalType: "OrderId", type: "bytes32" }
    ]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      {
        name: "linkedOrderParams1",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      },
      {
        name: "linkedOrderParams2",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "depositTradeAndLinkedOrders",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "linkedOrderId1", internalType: "OrderId", type: "bytes32" },
      { name: "linkedOrderId2", internalType: "OrderId", type: "bytes32" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      {
        name: "linkedOrderParams1",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      },
      {
        name: "linkedOrderParams2",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      }
    ],
    name: "depositTradeAndLinkedOrdersWithPermit",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "linkedOrderId1", internalType: "OrderId", type: "bytes32" },
      { name: "linkedOrderId2", internalType: "OrderId", type: "bytes32" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "token", internalType: "contract IERC20Permit", type: "address" },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      }
    ],
    name: "depositWithPermit",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "token", internalType: "contract IERC20Metadata", type: "address" },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      }
    ],
    name: "depositWithPermit2",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "data", internalType: "bytes[]", type: "bytes[]" }],
    name: "multicall",
    outputs: [{ name: "results", internalType: "bytes[]", type: "bytes[]" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "nativeToken",
    outputs: [{ name: "", internalType: "contract IWETH9", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "orderManager",
    outputs: [{ name: "", internalType: "contract IOrderManager", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "permit2",
    outputs: [{ name: "", internalType: "contract IPermit2", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct OrderParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int128", type: "int128" },
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint256", type: "uint256" },
          { name: "cashflow", internalType: "int128", type: "int128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "place",
    outputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "params",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "placeLinkedOrder",
    outputs: [{ name: "orderId", internalType: "OrderId", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "linkedOrderParams1",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      },
      {
        name: "linkedOrderParams2",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "placeLinkedOrders",
    outputs: [
      { name: "linkedOrderId1", internalType: "OrderId", type: "bytes32" },
      { name: "linkedOrderId2", internalType: "OrderId", type: "bytes32" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "positionNFT",
    outputs: [{ name: "", internalType: "contract PositionNFT", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "spotExecutor",
    outputs: [{ name: "", internalType: "contract SimpleSpotExecutor", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "tokenToSell", internalType: "contract IERC20Metadata", type: "address" },
      { name: "tokenToDeposit", internalType: "contract IERC20Metadata", type: "address" },
      {
        name: "swapData",
        internalType: "struct SwapData",
        type: "tuple",
        components: [
          { name: "router", internalType: "address", type: "address" },
          { name: "spender", internalType: "address", type: "address" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "minAmountOut", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" }
        ]
      }
    ],
    name: "swapAndDeposit",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      { name: "tokenToDeposit", internalType: "contract IERC20Metadata", type: "address" },
      {
        name: "swapData",
        internalType: "struct SwapData",
        type: "tuple",
        components: [
          { name: "router", internalType: "address", type: "address" },
          { name: "spender", internalType: "address", type: "address" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "minAmountOut", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" }
        ]
      }
    ],
    name: "swapAndDepositNative",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "tokenToSell", internalType: "contract IERC20Metadata", type: "address" },
      { name: "tokenToDeposit", internalType: "contract IERC20Metadata", type: "address" },
      {
        name: "swapData",
        internalType: "struct SwapData",
        type: "tuple",
        components: [
          { name: "router", internalType: "address", type: "address" },
          { name: "spender", internalType: "address", type: "address" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "minAmountOut", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" }
        ]
      },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      }
    ],
    name: "swapAndDepositWithPermit",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "tokenToSell", internalType: "contract IERC20Metadata", type: "address" },
      { name: "tokenToDeposit", internalType: "contract IERC20Metadata", type: "address" },
      {
        name: "swapData",
        internalType: "struct SwapData",
        type: "tuple",
        components: [
          { name: "router", internalType: "address", type: "address" },
          { name: "spender", internalType: "address", type: "address" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "minAmountOut", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" }
        ]
      },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      }
    ],
    name: "swapAndDepositWithPermit2",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "tokenToSell", internalType: "contract IERC20Metadata", type: "address" },
      { name: "tokenToReceive", internalType: "contract IERC20Metadata", type: "address" },
      {
        name: "swapData",
        internalType: "struct SwapData",
        type: "tuple",
        components: [
          { name: "router", internalType: "address", type: "address" },
          { name: "spender", internalType: "address", type: "address" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "minAmountOut", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" }
        ]
      },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "swapAndWithdraw",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "tokenToSell", internalType: "contract IERC20Metadata", type: "address" },
      {
        name: "swapData",
        internalType: "struct SwapData",
        type: "tuple",
        components: [
          { name: "router", internalType: "address", type: "address" },
          { name: "spender", internalType: "address", type: "address" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "minAmountOut", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" }
        ]
      },
      { name: "to", internalType: "address payable", type: "address" }
    ],
    name: "swapAndWithdrawNative",
    outputs: [{ name: "output", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "timelock",
    outputs: [{ name: "", internalType: "Timelock", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      }
    ],
    name: "trade",
    outputs: [
      { name: "", internalType: "PositionId", type: "bytes32" },
      {
        name: "",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      {
        name: "linkedOrderParams",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "tradeAndLinkedOrder",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "linkedOrderId", internalType: "OrderId", type: "bytes32" }
    ]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      {
        name: "linkedOrderParams1",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      },
      {
        name: "linkedOrderParams2",
        internalType: "struct LinkedOrderParams",
        type: "tuple",
        components: [
          { name: "limitPrice", internalType: "uint128", type: "uint128" },
          { name: "tolerance", internalType: "uint128", type: "uint128" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "deadline", internalType: "uint32", type: "uint32" },
          { name: "orderType", internalType: "enum OrderType", type: "uint8" }
        ]
      }
    ],
    name: "tradeAndLinkedOrders",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "linkedOrderId1", internalType: "OrderId", type: "bytes32" },
      { name: "linkedOrderId2", internalType: "OrderId", type: "bytes32" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "tradeAndWithdraw",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "tradeParams",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "execParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "tradeAndWithdrawNative",
    outputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade_",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "amount", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "newImplementation", internalType: "address", type: "address" }],
    name: "upgradeTo",
    outputs: []
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      { name: "newImplementation", internalType: "address", type: "address" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "token", internalType: "contract IERC20Metadata", type: "address" },
      {
        name: "permit",
        internalType: "struct EIP2098Permit",
        type: "tuple",
        components: [
          { name: "amount", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "r", internalType: "bytes32", type: "bytes32" },
          { name: "vs", internalType: "bytes32", type: "bytes32" }
        ]
      },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "usePermit2",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "vault",
    outputs: [{ name: "", internalType: "contract IVault", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "token", internalType: "contract IERC20Metadata", type: "address" },
      { name: "amount", internalType: "uint256", type: "uint256" },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "withdraw",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "amount", internalType: "uint256", type: "uint256" },
      { name: "to", internalType: "address", type: "address" }
    ],
    name: "withdrawNative",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  { stateMutability: "payable", type: "receive" }
];
var positionActionsABI = [
  {
    stateMutability: "nonpayable",
    type: "constructor",
    inputs: [
      { name: "_env", internalType: "contract Env", type: "address" },
      { name: "_trader", internalType: "address", type: "address" },
      { name: "_traderPk", internalType: "uint256", type: "uint256" }
    ]
  },
  { stateMutability: "view", type: "function", inputs: [], name: "IS_TEST", outputs: [{ name: "", internalType: "bool", type: "bool" }] },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "closePosition",
    outputs: [
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "uint256", type: "uint256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "closePosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "uint256", type: "uint256" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "closePosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "closePosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct TradeParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "limitPrice", internalType: "uint256", type: "uint256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" }
        ]
      },
      {
        name: "executionParams",
        internalType: "struct ExecutionParams",
        type: "tuple",
        components: [
          { name: "spender", internalType: "address", type: "address" },
          { name: "router", internalType: "address", type: "address" },
          { name: "swapAmount", internalType: "uint256", type: "uint256" },
          { name: "swapBytes", internalType: "bytes", type: "bytes" },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
        ]
      },
      { name: "_cashflowToken", internalType: "contract IERC20Metadata", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" }
    ],
    name: "executeTrade",
    outputs: [
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "modifyPosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16" },
      { name: "mm", internalType: "MoneyMarketId", type: "uint8" },
      { name: "quantity", internalType: "uint256", type: "uint256" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "openPosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16" },
      { name: "mm", internalType: "MoneyMarketId", type: "uint8" },
      { name: "quantity", internalType: "uint256", type: "uint256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "openPosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "uint256", type: "uint256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "openPosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "uint256", type: "uint256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "openPosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "openPosition",
    outputs: [
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "uint256", type: "uint256" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "openPosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16" },
      { name: "mm", internalType: "MoneyMarketId", type: "uint8" },
      { name: "quantity", internalType: "uint256", type: "uint256" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
      { name: "_slippageTolerance", internalType: "uint256", type: "uint256" }
    ],
    name: "openPosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "openPosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "symbol", internalType: "Symbol", type: "bytes16" },
      { name: "mm", internalType: "MoneyMarketId", type: "uint8" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "openPosition",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "positionId_", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
      { name: "cashflowUsed", internalType: "int256", type: "int256" }
    ],
    name: "prepareCashflow",
    outputs: [
      { name: "_cashflowToken", internalType: "contract IERC20Metadata", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "quoteFullyClose",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "quoteModify",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "int256", type: "int256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "quoteTrade",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "int256", type: "int256" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "quoteWithCashflow",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "int256", type: "int256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "quoteWithLeverage",
    outputs: [
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "_expiry", internalType: "uint32", type: "uint32" }],
    name: "setExpiry",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "_nativeTokenWrapper", internalType: "contract IERC20Metadata", type: "address" }],
    name: "setNativeTokenWrapper",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "_slippageTolerance", internalType: "uint256", type: "uint256" }],
    name: "setSlippageTolerance",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "_usePermit", internalType: "bool", type: "bool" }],
    name: "setUsePermit",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "slippageTolerance",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "quote",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" }
    ],
    name: "submitTrade",
    outputs: [
      { name: "_positionId", internalType: "PositionId", type: "bytes32" },
      {
        name: "trade",
        internalType: "struct Trade",
        type: "tuple",
        components: [
          { name: "quantity", internalType: "int256", type: "int256" },
          {
            name: "swap",
            internalType: "struct SwapInfo",
            type: "tuple",
            components: [
              { name: "inputCcy", internalType: "enum Currency", type: "uint8" },
              { name: "input", internalType: "int256", type: "int256" },
              { name: "output", internalType: "int256", type: "int256" },
              { name: "price", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "feeCcy", internalType: "enum Currency", type: "uint8" },
          { name: "forwardPrice", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  }
];
var tsQuoterABI = [
  {
    stateMutability: "nonpayable",
    type: "constructor",
    inputs: [{ name: "_contango", internalType: "contract Contango", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct TSQuoter.TSQuoteParams",
        type: "tuple",
        components: [
          { name: "positionId", internalType: "PositionId", type: "bytes32" },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "leverage", internalType: "uint256", type: "uint256" },
          { name: "cashflow", internalType: "int256", type: "int256" },
          { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
          { name: "slippageTolerance", internalType: "uint256", type: "uint256" },
          {
            name: "meta",
            internalType: "struct TSQuoter.TSMetaParams",
            type: "tuple",
            components: [
              {
                name: "instrument",
                internalType: "struct TSQuoter.TSInstrument",
                type: "tuple",
                components: [
                  { name: "closingOnly", internalType: "bool", type: "bool" },
                  {
                    name: "base",
                    internalType: "struct TSQuoter.Token",
                    type: "tuple",
                    components: [
                      { name: "addr", internalType: "address", type: "address" },
                      { name: "symbol", internalType: "string", type: "string" },
                      { name: "name", internalType: "string", type: "string" },
                      { name: "decimals", internalType: "uint256", type: "uint256" },
                      { name: "unit", internalType: "uint256", type: "uint256" }
                    ]
                  },
                  {
                    name: "quote",
                    internalType: "struct TSQuoter.Token",
                    type: "tuple",
                    components: [
                      { name: "addr", internalType: "address", type: "address" },
                      { name: "symbol", internalType: "string", type: "string" },
                      { name: "name", internalType: "string", type: "string" },
                      { name: "decimals", internalType: "uint256", type: "uint256" },
                      { name: "unit", internalType: "uint256", type: "uint256" }
                    ]
                  }
                ]
              },
              {
                name: "prices",
                internalType: "struct Prices",
                type: "tuple",
                components: [
                  { name: "collateral", internalType: "uint256", type: "uint256" },
                  { name: "debt", internalType: "uint256", type: "uint256" },
                  { name: "unit", internalType: "uint256", type: "uint256" }
                ]
              },
              {
                name: "balances",
                internalType: "struct Balances",
                type: "tuple",
                components: [
                  { name: "collateral", internalType: "uint256", type: "uint256" },
                  { name: "debt", internalType: "uint256", type: "uint256" }
                ]
              },
              {
                name: "normalisedBalances",
                internalType: "struct TSQuoter.NormalisedBalances",
                type: "tuple",
                components: [
                  { name: "collateral", internalType: "uint256", type: "uint256" },
                  { name: "debt", internalType: "uint256", type: "uint256" },
                  { name: "unit", internalType: "uint256", type: "uint256" }
                ]
              },
              {
                name: "liquidity",
                internalType: "struct TSQuoter.Liquidity",
                type: "tuple",
                components: [
                  { name: "borrowingLiquidity", internalType: "uint256", type: "uint256" },
                  { name: "lendingLiquidity", internalType: "uint256", type: "uint256" }
                ]
              },
              {
                name: "ltv",
                internalType: "struct TSQuoter.Ltv",
                type: "tuple",
                components: [
                  { name: "ltv", internalType: "uint256", type: "uint256" },
                  { name: "liquidationThreshold", internalType: "uint256", type: "uint256" }
                ]
              },
              { name: "fee", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" },
          { name: "flashFee", internalType: "uint256", type: "uint256" },
          { name: "spotExecutor", internalType: "address", type: "address" },
          {
            name: "liquidityBuffer",
            internalType: "struct TSQuoter.LiquidityBuffer",
            type: "tuple",
            components: [
              { name: "lending", internalType: "uint256", type: "uint256" },
              { name: "borrowing", internalType: "uint256", type: "uint256" }
            ]
          }
        ]
      }
    ],
    name: "____tsQuote",
    outputs: [
      {
        name: "",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "_provider", internalType: "contract IERC7399", type: "address" }],
    name: "addFlashLoanProvider",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "uint256", type: "uint256" }],
    name: "flashLoanProviders",
    outputs: [{ name: "", internalType: "contract IERC7399", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "liquidityBuffer",
    outputs: [
      { name: "lending", internalType: "uint256", type: "uint256" },
      { name: "borrowing", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "", internalType: "MoneyMarketId", type: "uint8" }],
    name: "moneyMarkets",
    outputs: [{ name: "", internalType: "contract IMoneyMarketView", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "int256", type: "int256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
      { name: "slippageTolerance", internalType: "uint256", type: "uint256" }
    ],
    name: "quote",
    outputs: [
      {
        name: "result",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "positionId", internalType: "PositionId", type: "bytes32" },
      { name: "quantity", internalType: "int256", type: "int256" },
      { name: "leverage", internalType: "uint256", type: "uint256" },
      { name: "cashflow", internalType: "int256", type: "int256" },
      { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
      { name: "slippageTolerance", internalType: "uint256", type: "uint256" },
      { name: "dex", internalType: "string", type: "string" }
    ],
    name: "quoteRealDex",
    outputs: [
      {
        name: "result",
        internalType: "struct TSQuote",
        type: "tuple",
        components: [
          {
            name: "tradeParams",
            internalType: "struct TradeParams",
            type: "tuple",
            components: [
              { name: "positionId", internalType: "PositionId", type: "bytes32" },
              { name: "quantity", internalType: "int256", type: "int256" },
              { name: "limitPrice", internalType: "uint256", type: "uint256" },
              { name: "cashflowCcy", internalType: "enum Currency", type: "uint8" },
              { name: "cashflow", internalType: "int256", type: "int256" }
            ]
          },
          {
            name: "execParams",
            internalType: "struct ExecutionParams",
            type: "tuple",
            components: [
              { name: "spender", internalType: "address", type: "address" },
              { name: "router", internalType: "address", type: "address" },
              { name: "swapAmount", internalType: "uint256", type: "uint256" },
              { name: "swapBytes", internalType: "bytes", type: "bytes" },
              { name: "flashLoanProvider", internalType: "contract IERC7399", type: "address" }
            ]
          },
          { name: "quantity", internalType: "int256", type: "int256" },
          { name: "cashflowUsed", internalType: "int256", type: "int256" },
          { name: "price", internalType: "uint256", type: "uint256" },
          { name: "fullyClosing", internalType: "bool", type: "bool" },
          { name: "fee", internalType: "uint256", type: "uint256" },
          { name: "transactionFees", internalType: "uint256", type: "uint256" }
        ]
      }
    ]
  },
  { stateMutability: "nonpayable", type: "function", inputs: [], name: "removeAllFlashLoanProviders", outputs: [] },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "_liquidityBuffer",
        internalType: "struct TSQuoter.LiquidityBuffer",
        type: "tuple",
        components: [
          { name: "lending", internalType: "uint256", type: "uint256" },
          { name: "borrowing", internalType: "uint256", type: "uint256" }
        ]
      }
    ],
    name: "setLiquidityBuffer",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "moneyMarketView", internalType: "contract IMoneyMarketView", type: "address" }],
    name: "setMoneyMarket",
    outputs: []
  }
];
var iPermit2ABI = [
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "permit",
        internalType: "struct IPermit2.PermitTransferFrom",
        type: "tuple",
        components: [
          {
            name: "permitted",
            internalType: "struct IPermit2.TokenPermissions",
            type: "tuple",
            components: [
              { name: "token", internalType: "address", type: "address" },
              { name: "amount", internalType: "uint256", type: "uint256" }
            ]
          },
          { name: "nonce", internalType: "uint256", type: "uint256" },
          { name: "deadline", internalType: "uint256", type: "uint256" }
        ]
      },
      {
        name: "transferDetails",
        internalType: "struct IPermit2.SignatureTransferDetails",
        type: "tuple",
        components: [
          { name: "to", internalType: "address", type: "address" },
          { name: "requestedAmount", internalType: "uint256", type: "uint256" }
        ]
      },
      { name: "owner", internalType: "address", type: "address" },
      { name: "signature", internalType: "bytes", type: "bytes" }
    ],
    name: "permitTransferFrom",
    outputs: []
  }
];
var iSwapRouterABI = [
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct ISwapRouter.ExactInputParams",
        type: "tuple",
        components: [
          { name: "path", internalType: "bytes", type: "bytes" },
          { name: "recipient", internalType: "address", type: "address" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "amountOutMinimum", internalType: "uint256", type: "uint256" }
        ]
      }
    ],
    name: "exactInput",
    outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct ISwapRouter.ExactInputSingleParams",
        type: "tuple",
        components: [
          { name: "tokenIn", internalType: "address", type: "address" },
          { name: "tokenOut", internalType: "address", type: "address" },
          { name: "fee", internalType: "uint24", type: "uint24" },
          { name: "recipient", internalType: "address", type: "address" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "amountOutMinimum", internalType: "uint256", type: "uint256" },
          { name: "sqrtPriceLimitX96", internalType: "uint160", type: "uint160" }
        ]
      }
    ],
    name: "exactInputSingle",
    outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct ISwapRouter.ExactOutputParams",
        type: "tuple",
        components: [
          { name: "path", internalType: "bytes", type: "bytes" },
          { name: "recipient", internalType: "address", type: "address" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "amountOut", internalType: "uint256", type: "uint256" },
          { name: "amountInMaximum", internalType: "uint256", type: "uint256" }
        ]
      }
    ],
    name: "exactOutput",
    outputs: [{ name: "amountIn", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct ISwapRouter.ExactOutputSingleParams",
        type: "tuple",
        components: [
          { name: "tokenIn", internalType: "address", type: "address" },
          { name: "tokenOut", internalType: "address", type: "address" },
          { name: "fee", internalType: "uint24", type: "uint24" },
          { name: "recipient", internalType: "address", type: "address" },
          { name: "deadline", internalType: "uint256", type: "uint256" },
          { name: "amountOut", internalType: "uint256", type: "uint256" },
          { name: "amountInMaximum", internalType: "uint256", type: "uint256" },
          { name: "sqrtPriceLimitX96", internalType: "uint160", type: "uint160" }
        ]
      }
    ],
    name: "exactOutputSingle",
    outputs: [{ name: "amountIn", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "amount0Delta", internalType: "int256", type: "int256" },
      { name: "amount1Delta", internalType: "int256", type: "int256" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "uniswapV3SwapCallback",
    outputs: []
  }
];
var iUniswapQuoterABI = [
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "path", internalType: "bytes", type: "bytes" },
      { name: "amountIn", internalType: "uint256", type: "uint256" }
    ],
    name: "quoteExactInput",
    outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "tokenIn", internalType: "address", type: "address" },
      { name: "tokenOut", internalType: "address", type: "address" },
      { name: "fee", internalType: "uint24", type: "uint24" },
      { name: "amountIn", internalType: "uint256", type: "uint256" },
      { name: "sqrtPriceLimitX96", internalType: "uint160", type: "uint160" }
    ],
    name: "quoteExactInputSingle",
    outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "path", internalType: "bytes", type: "bytes" },
      { name: "amountOut", internalType: "uint256", type: "uint256" }
    ],
    name: "quoteExactOutput",
    outputs: [{ name: "amountIn", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "tokenIn", internalType: "address", type: "address" },
      { name: "tokenOut", internalType: "address", type: "address" },
      { name: "fee", internalType: "uint24", type: "uint24" },
      { name: "amountOut", internalType: "uint256", type: "uint256" },
      { name: "sqrtPriceLimitX96", internalType: "uint160", type: "uint160" }
    ],
    name: "quoteExactOutputSingle",
    outputs: [{ name: "amountIn", internalType: "uint256", type: "uint256" }]
  }
];
var iUniswapV3SwapCallbackABI = [
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "amount0Delta", internalType: "int256", type: "int256" },
      { name: "amount1Delta", internalType: "int256", type: "int256" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "uniswapV3SwapCallback",
    outputs: []
  }
];
var swapRouter02ABI = [
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct SwapRouter02.ExactInputParams",
        type: "tuple",
        components: [
          { name: "path", internalType: "bytes", type: "bytes" },
          { name: "recipient", internalType: "address", type: "address" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "amountOutMinimum", internalType: "uint256", type: "uint256" }
        ]
      }
    ],
    name: "exactInput",
    outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct SwapRouter02.ExactInputSingleParams",
        type: "tuple",
        components: [
          { name: "tokenIn", internalType: "address", type: "address" },
          { name: "tokenOut", internalType: "address", type: "address" },
          { name: "fee", internalType: "uint24", type: "uint24" },
          { name: "recipient", internalType: "address", type: "address" },
          { name: "amountIn", internalType: "uint256", type: "uint256" },
          { name: "amountOutMinimum", internalType: "uint256", type: "uint256" },
          { name: "sqrtPriceLimitX96", internalType: "uint160", type: "uint160" }
        ]
      }
    ],
    name: "exactInputSingle",
    outputs: [{ name: "amountOut", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct SwapRouter02.ExactOutputParams",
        type: "tuple",
        components: [
          { name: "path", internalType: "bytes", type: "bytes" },
          { name: "recipient", internalType: "address", type: "address" },
          { name: "amountOut", internalType: "uint256", type: "uint256" },
          { name: "amountInMaximum", internalType: "uint256", type: "uint256" }
        ]
      }
    ],
    name: "exactOutput",
    outputs: [{ name: "amountIn", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "params",
        internalType: "struct SwapRouter02.ExactOutputSingleParams",
        type: "tuple",
        components: [
          { name: "tokenIn", internalType: "address", type: "address" },
          { name: "tokenOut", internalType: "address", type: "address" },
          { name: "fee", internalType: "uint24", type: "uint24" },
          { name: "recipient", internalType: "address", type: "address" },
          { name: "amountOut", internalType: "uint256", type: "uint256" },
          { name: "amountInMaximum", internalType: "uint256", type: "uint256" },
          { name: "sqrtPriceLimitX96", internalType: "uint160", type: "uint160" }
        ]
      }
    ],
    name: "exactOutputSingle",
    outputs: [{ name: "amountIn", internalType: "uint256", type: "uint256" }]
  }
];
var uniswapV3FactoryABI = [
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "uint24", type: "uint24" }
    ],
    name: "getPool",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  }
];
var uniswapV3PoolABI = [
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "token0",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "token1",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  }
];
var uniswapPoolStubABI = [
  {
    stateMutability: "nonpayable",
    type: "constructor",
    inputs: [
      { name: "_token0", internalType: "contract IERC20Metadata", type: "address" },
      { name: "_token1", internalType: "contract IERC20Metadata", type: "address" },
      { name: "_token0Oracle", internalType: "contract AggregatorV2V3Interface", type: "address" },
      { name: "_token1Oracle", internalType: "contract AggregatorV2V3Interface", type: "address" },
      { name: "_token0Quoted", internalType: "bool", type: "bool" }
    ]
  },
  {
    type: "error",
    inputs: [
      { name: "expected", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" },
      { name: "diff", internalType: "uint256", type: "uint256" }
    ],
    name: "TooLittleRepaid"
  },
  {
    type: "error",
    inputs: [
      { name: "expected", internalType: "uint256", type: "uint256" },
      { name: "actual", internalType: "uint256", type: "uint256" },
      { name: "diff", internalType: "uint256", type: "uint256" }
    ],
    name: "TooMuchRepaid"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [{ name: "spread", internalType: "int256", type: "int256", indexed: false }],
    name: "SpreadSet"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "recipient", internalType: "address", type: "address", indexed: false },
      { name: "zeroForOne", internalType: "bool", type: "bool", indexed: false },
      { name: "amount0", internalType: "int256", type: "int256", indexed: false },
      { name: "amount1", internalType: "int256", type: "int256", indexed: false },
      { name: "oraclePrice", internalType: "int256", type: "int256", indexed: false },
      { name: "price", internalType: "int256", type: "int256", indexed: false }
    ],
    name: "Swap"
  },
  {
    type: "event",
    anonymous: false,
    inputs: [
      { name: "token0", internalType: "contract IERC20Metadata", type: "address", indexed: false },
      { name: "token1", internalType: "contract IERC20Metadata", type: "address", indexed: false },
      { name: "token0Oracle", internalType: "contract AggregatorV2V3Interface", type: "address", indexed: false },
      { name: "token1Oracle", internalType: "contract AggregatorV2V3Interface", type: "address", indexed: false },
      { name: "token0Quoted", internalType: "bool", type: "bool", indexed: false }
    ],
    name: "UniswapPoolStubCreated"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "absoluteSpread",
    outputs: [{ name: "", internalType: "int256", type: "int256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [{ name: "value", internalType: "int256", type: "int256" }],
    name: "setAbsoluteSpread",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "recipient", internalType: "address", type: "address" },
      { name: "zeroForOne", internalType: "bool", type: "bool" },
      { name: "amountSpecified", internalType: "int256", type: "int256" },
      { name: "", internalType: "uint160", type: "uint160" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "swap",
    outputs: [
      { name: "amount0", internalType: "int256", type: "int256" },
      { name: "amount1", internalType: "int256", type: "int256" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "token0",
    outputs: [{ name: "", internalType: "contract IERC20Metadata", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "token0Oracle",
    outputs: [{ name: "", internalType: "contract AggregatorV2V3Interface", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "token0Quoted",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "token1",
    outputs: [{ name: "", internalType: "contract IERC20Metadata", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "token1Oracle",
    outputs: [{ name: "", internalType: "contract AggregatorV2V3Interface", type: "address" }]
  }
];

// ../networks.json
var networks_default = {
  "arbitrum-one": {
    multisig: {
      address: "0xE865379A78d65D4cc58472BC16514e39bDEB2759"
    },
    treasury: {
      address: "0x643178CF8AEc063962654CAc256FD1f7fe06ac28"
    },
    Timelock: {
      address: "0xc0939a4Ed0129bc5162F6f693935B3F72a46a90D"
    },
    ContangoProxy: {
      address: "0x6Cae28b3D09D8f8Fc74ccD496AC986FC84C0C24E",
      startBlock: 137136154
    },
    Contango: {
      address: "0x384231BCC5652295f77b4A59B352234Db860A0d5"
    },
    PositionNFT: {
      address: "0xC2462f03920D47fC5B9e2C5F0ba5D2ded058fD78",
      startBlock: 137136154
    },
    Liquidations: {
      startBlock: 137136154
    },
    AavePoolAddressesProvider: {
      address: "0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb"
    },
    UnderlyingPositionFactory: {
      address: "0xDaBA83815404f5e1bc33f5885db7D96F51e127F5",
      startBlock: 137136154
    },
    AaveMoneyMarket: {
      address: "0x76c48d0927dCceEE555053acACe51d102c6ABfCa"
    },
    AaveRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    },
    BalancerFlashLoanProvider: {
      address: "0x3d4DF8596e5750A4F721c8764d585dcc8623d009"
    },
    AaveFlashLoanProvider: {
      address: "0x02C7632b84B3447845531541d0285D67E656e50c"
    },
    UniswapFlashLoanProvider: {
      address: "0x23de8e0bB91A105bEFf9d40d8d75C1A9fE40f523"
    },
    FixedFeeModel: {
      address: "0xA3c4Ccb9eBDa3BA16e524C6173898bf334dde693"
    },
    NativeToken: {
      address: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"
    },
    OrderManagerProxy: {
      address: "0xA64f0dbB10c473978C2EFe069da207991e8e3Cb3",
      startBlock: 137136154
    },
    OrderManager: {
      address: "0x1231F1d0173bFa60F49b34a8128ecB0CD861f441"
    },
    ReferralManager: {
      address: "0x45886dcC87B28Cc5943dE087B4E11Ad6C70cd37d",
      startBlock: 137136154
    },
    VaultProxy: {
      address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b"
    },
    Vault: {
      address: "0x4869E478d8efa441C60b919a74EbAF4aDB0b4f87"
    },
    MaestroProxy: {
      address: "0xa6a147946FACAc9E0B99824870B36088764f969F",
      startBlock: 137136154
    },
    Maestro: {
      address: "0x23d03Dd88234eaE6b163Ef50F0E078e53D3fE90a"
    },
    FeeManagerProxy: {
      address: "0xA362611E47eb1888e0f6fD4b5a65A42d7C3eA3A4",
      startBlock: 137136154
    },
    FeeManager: {
      address: "0xab80F3EC64Fd4985eaCe359323d24d7c9d0De269"
    },
    "InitialProxyImpl-ContangoProxy": {
      address: "0xb9021d7e1d7d800f813107d878FDF8F36eD14B77"
    },
    "InitialProxyImpl-VaultProxy": {
      address: "0xac72e62714E656A69009eC992272C624BdAaE0c2"
    },
    "InitialProxyImpl-OrderManagerProxy": {
      address: "0x037A5eA2F7fd0160871F09796713C99dD55ac198"
    },
    "InitialProxyImpl-MaestroProxy": {
      address: "0x35E6C82B43B03c15C80A321202E966AAF665b246"
    },
    "InitialProxyImpl-FeeManagerProxy": {
      address: "0x6919d5bb68295559EaFea6ABD17F4C506c269ec9"
    },
    AaveOracle: {
      address: "0x87a1C2099d6cd02a1c9183BED8401ACB4Dc8929c"
    },
    "UpgradeableBeacon-Aave": {
      address: "0x465704c99BA869069f48d88D1F0dC7D7ebd270Cd"
    },
    AaveImmutableProxy: {
      address: "0xa71cAB37c5A2FD2543f21acab3ccAe4BeB127458"
    },
    AaveMoneyMarketView: {
      address: "0xBA8F0cc53D08227E7313530c302ce5365dA7a40B"
    },
    IPermit2: {
      address: "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    },
    SpotExecutor: {
      address: "0x332b65c67C371d72477a3f5F8da836a3cA998CFc"
    },
    Balancer: {
      address: "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
    },
    RadiantMoneyMarket: {
      address: "0x5d865897E26d6604eF14C5bc5afB5347d41bEc91"
    },
    "UpgradeableBeacon-Radiant": {
      address: "0xF4A485813F41eBd96a19e6710eB5aDBb1531B618"
    },
    RadiantImmutableProxy: {
      address: "0x10b71c764A9D7614302E08C893b28043DAE1bcAa"
    },
    RadiantMoneyMarketView: {
      address: "0xf1a0324BB12c53119410D51B17FcCb0940FF8754"
    },
    RadiantPoolAddressesProvider: {
      address: "0x091d52CacE1edc5527C99cDCFA6937C1635330E4"
    },
    RadiantPoolDataProvider: {
      address: "0x596B0cc4c5094507C50b579a662FE7e7b094A2cC"
    }
  },
  optimism: {
    multisig: {
      address: "0xCA7fE1a4CF1640d2bA6d399fbB103C605b27EA7F"
    },
    treasury: {
      address: "0xB6F5574Ccd09B49ABC7883A346e7ACE726b80E35"
    },
    Timelock: {
      address: "0xc0939a4Ed0129bc5162F6f693935B3F72a46a90D"
    },
    ContangoProxy: {
      address: "0x6Cae28b3D09D8f8Fc74ccD496AC986FC84C0C24E",
      startBlock: 110323085
    },
    Contango: {
      address: "0x90896236b00A88959E427e5D47b73Fd51bd82F1b"
    },
    PositionNFT: {
      address: "0xC2462f03920D47fC5B9e2C5F0ba5D2ded058fD78",
      startBlock: 110323085
    },
    Liquidations: {
      startBlock: 110323085
    },
    AavePoolAddressesProvider: {
      address: "0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb"
    },
    UnderlyingPositionFactory: {
      address: "0xDaBA83815404f5e1bc33f5885db7D96F51e127F5",
      startBlock: 110323085
    },
    AaveMoneyMarket: {
      address: "0x9FeE839df29059D80BC78A5E3618a055a8076055"
    },
    AaveRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    },
    BalancerFlashLoanProvider: {
      address: "0x3d4DF8596e5750A4F721c8764d585dcc8623d009"
    },
    AaveFlashLoanProvider: {
      address: "0x02C7632b84B3447845531541d0285D67E656e50c"
    },
    UniswapFlashLoanProvider: {
      address: "0x23de8e0bB91A105bEFf9d40d8d75C1A9fE40f523"
    },
    FixedFeeModel: {
      address: "0x88d2676A4C43A36c029dFD0E35A94A7DEC145DC4"
    },
    NativeToken: {
      address: "0x4200000000000000000000000000000000000006"
    },
    OrderManagerProxy: {
      address: "0xA64f0dbB10c473978C2EFe069da207991e8e3Cb3",
      startBlock: 110323085
    },
    OrderManager: {
      address: "0xa73b1Ea466C18D166b718dE5AF269ae177128CeE"
    },
    ReferralManager: {
      address: "0xea8cD16b9cEdC799a2e3aCD7f122975fB2cDa98E",
      startBlock: 110323085
    },
    VaultProxy: {
      address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b"
    },
    Vault: {
      address: "0x984665CCF39467eee3e0e73fa7f3911fBEcade38"
    },
    MaestroProxy: {
      address: "0xa6a147946FACAc9E0B99824870B36088764f969F",
      startBlock: 110323085
    },
    Maestro: {
      address: "0x165DB7D1AAea0F03C25d63D0302c524B1CDC4Fd2"
    },
    FeeManagerProxy: {
      address: "0xA362611E47eb1888e0f6fD4b5a65A42d7C3eA3A4",
      startBlock: 110323085
    },
    FeeManager: {
      address: "0xF9E68e8Ec59257DEf066e5a21601e4127C2D9cFE"
    },
    "InitialProxyImpl-ContangoProxy": {
      address: "0xb9021d7e1d7d800f813107d878FDF8F36eD14B77"
    },
    "InitialProxyImpl-VaultProxy": {
      address: "0xac72e62714E656A69009eC992272C624BdAaE0c2"
    },
    "InitialProxyImpl-OrderManagerProxy": {
      address: "0x037A5eA2F7fd0160871F09796713C99dD55ac198"
    },
    "InitialProxyImpl-MaestroProxy": {
      address: "0x35E6C82B43B03c15C80A321202E966AAF665b246"
    },
    "InitialProxyImpl-FeeManagerProxy": {
      address: "0x6919d5bb68295559EaFea6ABD17F4C506c269ec9"
    },
    AaveOracle: {
      address: "0xcF678E428fBd6d9173fb780e971e4A123b68877a"
    },
    "UpgradeableBeacon-Aave": {
      address: "0x527c69581f190Ca648f734584Fe83540f3De23e1"
    },
    AaveImmutableProxy: {
      address: "0x2C8ec598Db4C78779179CB518399a260cdD57A9D"
    },
    AaveMoneyMarketView: {
      address: "0xecFa570eC16c3F3D53ba5D34E304419d50960c12"
    },
    IPermit2: {
      address: "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    },
    SpotExecutor: {
      address: "0x370755b2846D7bA8fa237765F68c1783d76879E3"
    },
    Balancer: {
      address: "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
    },
    ExactlyAccountDeployer: {
      address: "0x3974cFDe63eF55f5813e74dB2f915CC77fAbD4f6"
    },
    ExactlyMoneyMarket: {
      address: "0x45FA7b0d7c7d1EF17D83287c5952AB465112bBeb"
    },
    ExactlyReverseLookup: {
      address: "0x6407Ee6E27292ABC96c117a6e224c0fd73CEC14F"
    },
    ExactlyAuditor: {
      address: "0xaEb62e6F27BC103702E7BC879AE98bceA56f027E"
    },
    ExactlyRewardsController: {
      address: "0xBd1ba78A3976cAB420A9203E6ef14D18C2B2E031"
    },
    "UpgradeableBeacon-Exactly": {
      address: "0x3E2c04DCCF6205b259537E1A10d416D65c00aDAE"
    },
    ExactlyImmutableProxy: {
      address: "0xd52c40931Ec0a50ab4Bb60723f8b596B72A0a768"
    },
    ExactlyMoneyMarketView: {
      address: "0xa14d9244504cB771457FFa45AF56C1685c25086A"
    },
    ExactlyPreviewer: {
      address: "0xb8b1f590272b541b263A49b28bF52f8774b0E6c9"
    }
  },
  mainnet: {
    multisig: {
      address: "0xe16cfA41902FDA3B0C86f1634F4A2C11af0C7Ece"
    },
    treasury: {
      address: "0x3bfbc7016ad9780F3509752119E09549353A3843"
    },
    Timelock: {
      address: "0xc0939a4Ed0129bc5162F6f693935B3F72a46a90D"
    },
    ContangoProxy: {
      address: "0x6Cae28b3D09D8f8Fc74ccD496AC986FC84C0C24E",
      startBlock: 18269652
    },
    Contango: {
      address: "0x69414978558F2fC850190848E91a3B4C72e2Ae4a",
      startBlock: 18269652
    },
    PositionNFT: {
      address: "0xC2462f03920D47fC5B9e2C5F0ba5D2ded058fD78",
      startBlock: 18269652
    },
    Liquidations: {
      startBlock: 18269652
    },
    BalancerFlashLoanProvider: {
      address: "0x3d4DF8596e5750A4F721c8764d585dcc8623d009"
    },
    AaveFlashLoanProvider: {
      address: "0x9A10fC91cCc6e8C3a8616C58B96667a591Aaf683"
    },
    UniswapFlashLoanProvider: {
      address: "0x23de8e0bB91A105bEFf9d40d8d75C1A9fE40f523"
    },
    FixedFeeModel: {
      address: "0xE6e7447B98c488DDd7971335B2F53B16426493dc"
    },
    NativeToken: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
    },
    OrderManagerProxy: {
      address: "0xA64f0dbB10c473978C2EFe069da207991e8e3Cb3",
      startBlock: 18269652
    },
    OrderManager: {
      address: "0xF5Dc4601e11D47F475608Df77ced9b4371B60D34",
      startBlock: 18412539
    },
    ReferralManager: {
      address: "0xfF7b4D89617D8ac9698632B14127aac55895d21e",
      startBlock: 18269652
    },
    VaultProxy: {
      address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b",
      startBlock: 18269652
    },
    Vault: {
      address: "0xDEb33DfD88169D53857231c8d07a6af87d33F7ae",
      startBlock: 18271420
    },
    MaestroProxy: {
      address: "0xa6a147946FACAc9E0B99824870B36088764f969F",
      startBlock: 18269652
    },
    Maestro: {
      address: "0xC24E2B3ef8c762b87BBb161931F67fA4982Fb92D",
      startBlock: 18412539
    },
    FeeManagerProxy: {
      address: "0xA362611E47eb1888e0f6fD4b5a65A42d7C3eA3A4",
      startBlock: 18269652
    },
    FeeManager: {
      address: "0xD3C41A41E5430239772a4BcaCAe89be89dc73e2B",
      startBlock: 18485362
    },
    "InitialProxyImpl-ContangoProxy": {
      address: "0xb9021d7e1d7d800f813107d878FDF8F36eD14B77"
    },
    "InitialProxyImpl-VaultProxy": {
      address: "0xac72e62714E656A69009eC992272C624BdAaE0c2"
    },
    "InitialProxyImpl-OrderManagerProxy": {
      address: "0x037A5eA2F7fd0160871F09796713C99dD55ac198"
    },
    "InitialProxyImpl-MaestroProxy": {
      address: "0x35E6C82B43B03c15C80A321202E966AAF665b246"
    },
    "InitialProxyImpl-FeeManagerProxy": {
      address: "0x6919d5bb68295559EaFea6ABD17F4C506c269ec9"
    },
    UnderlyingPositionFactory: {
      address: "0xDaBA83815404f5e1bc33f5885db7D96F51e127F5",
      startBlock: 18269652
    },
    AaveOracle: {
      address: "0x8D82f03d20ac0708c2BE2D606dd86B2bFE21D5F7"
    },
    AaveMoneyMarketView: {
      address: "0x55eAD03A084e565d6244175A78b2c8eE040B9526"
    },
    IPermit2: {
      address: "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    },
    SpotExecutor: {
      address: "0x90896236b00A88959E427e5D47b73Fd51bd82F1b"
    },
    AaveMoneyMarket: {
      address: "0x49282A453e94C3c8d33a3ad4e5F4fC6b6C8A97fE"
    },
    AavePoolAddressesProvider: {
      address: "0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e"
    },
    AaveImmutableProxy: {
      address: "0xDED92397301EBeAa8D0666b51Dd54e696B60b385"
    },
    "UpgradeableBeacon-Aave": {
      address: "0x52302105F718BB9145aE1cCD7Ce48FD41A35008D"
    },
    AaveRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    },
    SparkMoneyMarket: {
      address: "0xC8D01bEd5CBb48184f23AbCD552195B1F9aC87AE"
    },
    SparkPoolAddressesProvider: {
      address: "0x02C3eA4e34C0cBd694D2adFa2c690EECbC1793eE"
    },
    SparkImmutableProxy: {
      address: "0xCDA64DE5c1ABc1dc0cAf22E8FDdf348423f8803d"
    },
    "UpgradeableBeacon-Spark": {
      address: "0x56e01dD7c6543C42eD53DF79eE26cEB37Dc92482"
    },
    SparkRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    },
    SparkMoneyMarketView: {
      address: "0xc52Bd19Bf425Dec8a1308Aa4132158A3e1233E98"
    },
    AaveV2MoneyMarket: {
      address: "0xF52D2184A943b521e7846d70a1bEbA7818C0728a"
    },
    "UpgradeableBeacon-AaveV2": {
      address: "0xF4DCC1E69403D56CC17E84Ad3dc6817bF4F5aD4b"
    },
    AaveV2ImmutableProxy: {
      address: "0x82181f0e251B89AAB7Fd2CFeac0bC88c39003781"
    },
    AaveV2MoneyMarketView: {
      address: "0x5d6D3cB5146475141269c789627a0dE9215E8f99"
    },
    AaveV2PoolAddressesProvider: {
      address: "0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5"
    },
    AaveV2PoolDataProvider: {
      address: "0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d"
    }
  },
  matic: {
    multisig: {
      address: "0x21c5267d613F316D11583F4A82D97c06Bc6f5E11"
    },
    treasury: {
      address: "0x42353e33A6e381Fc982F34092f80803FD5AcEADe"
    },
    Timelock: {
      address: "0xc0939a4Ed0129bc5162F6f693935B3F72a46a90D"
    },
    ContangoProxy: {
      address: "0x6Cae28b3D09D8f8Fc74ccD496AC986FC84C0C24E",
      startBlock: 48665181
    },
    Contango: {
      address: "0x210F4e1942bEEc4038743A8f885B870E0c27b414"
    },
    PositionNFT: {
      address: "0xC2462f03920D47fC5B9e2C5F0ba5D2ded058fD78",
      startBlock: 48665181
    },
    Liquidations: {
      startBlock: 48665181
    },
    AavePoolAddressesProvider: {
      address: "0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb"
    },
    UnderlyingPositionFactory: {
      address: "0xDaBA83815404f5e1bc33f5885db7D96F51e127F5",
      startBlock: 48665181
    },
    AaveMoneyMarket: {
      address: "0x16D727F22605c7E520296900AcaC3f9526e37CBd"
    },
    AaveRewardsController: {
      address: "0x929EC64c34a17401F460460D4B9390518E5B473e"
    },
    BalancerFlashLoanProvider: {
      address: "0x3d4DF8596e5750A4F721c8764d585dcc8623d009"
    },
    AaveV3FlashLoanProvider: {
      address: "0x02C7632b84B3447845531541d0285D67E656e50c"
    },
    AaveV2FlashLoanProvider: {
      address: "0x93412A8772b809b0EB2C390f72AFf1eD5B303F67"
    },
    UniswapFlashLoanProvider: {
      address: "0x23de8e0bB91A105bEFf9d40d8d75C1A9fE40f523"
    },
    FixedFeeModel: {
      address: "0x790f475832695C4E523cd52d2C4Ac393cA43037A"
    },
    NativeToken: {
      address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"
    },
    OrderManagerProxy: {
      address: "0xA64f0dbB10c473978C2EFe069da207991e8e3Cb3",
      startBlock: 48665181
    },
    OrderManager: {
      address: "0x88d2676A4C43A36c029dFD0E35A94A7DEC145DC4"
    },
    ReferralManager: {
      address: "0x945EF92aEB96F2ADFcc501379D3F887D0fCBD685",
      startBlock: 48665181
    },
    VaultProxy: {
      address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b"
    },
    Vault: {
      address: "0xB586D3B232A167bb319944120eAF0629af512311"
    },
    MaestroProxy: {
      address: "0xa6a147946FACAc9E0B99824870B36088764f969F",
      startBlock: 48665181
    },
    Maestro: {
      address: "0x7c77456DbB932eAF2E85dDC650F16fAfd1061089"
    },
    FeeManagerProxy: {
      address: "0xA362611E47eb1888e0f6fD4b5a65A42d7C3eA3A4",
      startBlock: 48665181
    },
    FeeManager: {
      address: "0x90896236b00A88959E427e5D47b73Fd51bd82F1b",
      startBlock: 49620638
    },
    "InitialProxyImpl-ContangoProxy": {
      address: "0xb9021d7e1d7d800f813107d878FDF8F36eD14B77"
    },
    "InitialProxyImpl-VaultProxy": {
      address: "0xac72e62714E656A69009eC992272C624BdAaE0c2"
    },
    "InitialProxyImpl-OrderManagerProxy": {
      address: "0x037A5eA2F7fd0160871F09796713C99dD55ac198"
    },
    "InitialProxyImpl-MaestroProxy": {
      address: "0x35E6C82B43B03c15C80A321202E966AAF665b246"
    },
    "InitialProxyImpl-FeeManagerProxy": {
      address: "0x6919d5bb68295559EaFea6ABD17F4C506c269ec9"
    },
    AaveOracle: {
      address: "0x2F201B7B1176ECABA3D9E6C3e720B1f6A923229E"
    },
    "UpgradeableBeacon-Aave": {
      address: "0xAdF19c598CA986F6a01b578a3BFeC2EcB4b03fad"
    },
    AaveImmutableProxy: {
      address: "0xF72bf33a860E64a6F897d1fD24d754655F3E524c"
    },
    AaveMoneyMarketView: {
      address: "0x9FeE839df29059D80BC78A5E3618a055a8076055"
    },
    IPermit2: {
      address: "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    },
    SpotExecutor: {
      address: "0x96bF9aB0E421a3da31D4506c967A825312455767"
    },
    Balancer: {
      address: "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
    },
    AaveV2MoneyMarket: {
      address: "0x02ef55AD73Ce24fa3d0b33DaBcd4f27e0604e63b"
    },
    "UpgradeableBeacon-AaveV2": {
      address: "0x0ebb5715C8136C0A11bd7cC288e6EEef556D0091"
    },
    AaveV2ImmutableProxy: {
      address: "0xb76c0582a3D918F304C556BebF4f9D1a97f5F050"
    },
    AaveV2MoneyMarketView: {
      address: "0x34B7fA94d07d709fb20c023858f553f8466A6574"
    },
    AaveV2PoolAddressesProvider: {
      address: "0xd05e3E715d945B59290df0ae8eF85c1BdB684744"
    },
    AaveV2PoolDataProvider: {
      address: "0x7551b5D2763519d4e37e8B81929D336De671d46d"
    }
  },
  gnosis: {
    multisig: {
      address: "0xBB3dD3114Cde2bba4510B98FC8D6383dDA7f0305"
    },
    treasury: {
      address: "0x137A1953712Fe5dD4a8423eA0Ca4A086b23d92Db"
    },
    Timelock: {
      address: "0xc0939a4Ed0129bc5162F6f693935B3F72a46a90D"
    },
    ContangoProxy: {
      address: "0x6Cae28b3D09D8f8Fc74ccD496AC986FC84C0C24E",
      startBlock: 30822347
    },
    Contango: {
      address: "0x807073F955439fa0eF808a9B50007696b5dCE971"
    },
    PositionNFT: {
      address: "0xC2462f03920D47fC5B9e2C5F0ba5D2ded058fD78",
      startBlock: 30822347
    },
    Liquidations: {
      startBlock: 30774573
    },
    UnderlyingPositionFactory: {
      address: "0xDaBA83815404f5e1bc33f5885db7D96F51e127F5",
      startBlock: 30822347
    },
    BalancerFlashLoanProvider: {
      address: "0x3d4DF8596e5750A4F721c8764d585dcc8623d009"
    },
    SparkFlashLoanProvider: {
      address: "0x0d822565FC37ceFfBc2CEa8a28d7159D9F12Fe31"
    },
    AgaveFlashLoanProvider: {
      address: "0x013d0d4c4D4D9d07e519AAC84b31dBAe8068cc59"
    },
    FixedFeeModel: {
      address: "0x8cAad37f67FAb806383F59048723A92B5Dc4581D"
    },
    NativeToken: {
      address: "0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d"
    },
    OrderManagerProxy: {
      address: "0xA64f0dbB10c473978C2EFe069da207991e8e3Cb3",
      startBlock: 30822347
    },
    OrderManager: {
      address: "0x4c05E3A558d91840b14c893c41B807e9AfAD23Ff"
    },
    ReferralManager: {
      address: "0x945EF92aEB96F2ADFcc501379D3F887D0fCBD685",
      startBlock: 30822347
    },
    VaultProxy: {
      address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b"
    },
    Vault: {
      address: "0xB586D3B232A167bb319944120eAF0629af512311"
    },
    MaestroProxy: {
      address: "0xa6a147946FACAc9E0B99824870B36088764f969F",
      startBlock: 30822347
    },
    Maestro: {
      address: "0x62bF66Fc3e14a008c34E7A6BCAcD99945C02deAb"
    },
    FeeManagerProxy: {
      address: "0xA362611E47eb1888e0f6fD4b5a65A42d7C3eA3A4",
      startBlock: 30822347
    },
    FeeManager: {
      address: "0xB132C10acabCB8966Fa38e5AE9745039b7c8008b"
    },
    "InitialProxyImpl-ContangoProxy": {
      address: "0xb9021d7e1d7d800f813107d878FDF8F36eD14B77"
    },
    "InitialProxyImpl-VaultProxy": {
      address: "0xac72e62714E656A69009eC992272C624BdAaE0c2"
    },
    "InitialProxyImpl-OrderManagerProxy": {
      address: "0x037A5eA2F7fd0160871F09796713C99dD55ac198"
    },
    "InitialProxyImpl-MaestroProxy": {
      address: "0x35E6C82B43B03c15C80A321202E966AAF665b246"
    },
    "InitialProxyImpl-FeeManagerProxy": {
      address: "0x6919d5bb68295559EaFea6ABD17F4C506c269ec9"
    },
    IPermit2: {
      address: "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    },
    SpotExecutor: {
      address: "0x96bF9aB0E421a3da31D4506c967A825312455767"
    },
    SimpleSpotExecutor: {
      address: "0x370755b2846D7bA8fa237765F68c1783d76879E3"
    },
    AaveOracle: {
      address: "0x2F201B7B1176ECABA3D9E6C3e720B1f6A923229E"
    },
    Balancer: {
      address: "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
    },
    SparkMoneyMarket: {
      address: "0xF3e2ec7dB013f4F75c0905698796dEeca15B58Cf"
    },
    "UpgradeableBeacon-Spark": {
      address: "0x60059bC8bCBe97D44170151060c7F0FAC17fAF58"
    },
    SparkImmutableProxy: {
      address: "0x3e00c0471B5C40255aC1bBf3AD3AD6Cc94f33bBc"
    },
    SparkMoneyMarketView: {
      address: "0x1891B54a4889aC5EB428d1E56B1BfF4FA65b7f59"
    },
    SparkPoolAddressesProvider: {
      address: "0xA98DaCB3fC964A6A0d2ce3B77294241585EAbA6d",
      startBlock: 30774573
    },
    SparkRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    },
    AgaveMoneyMarket: {
      address: "0xB32C63420F8c9C5F6091B5e1160bcd4A41433643"
    },
    "UpgradeableBeacon-Agave": {
      address: "0x918df484B10e8ED60Ed1Dec290Eb0e3Bc08371D9"
    },
    AgaveImmutableProxy: {
      address: "0x6174E498a13fE848510fB739B76653b6B4CDcd3E"
    },
    AgaveMoneyMarketView: {
      address: "0xD4A36f40657899e566F48B81339b49fA6eF50142"
    },
    AgavePoolAddressesProvider: {
      address: "0x3673C22153E363B1da69732c4E0aA71872Bbb87F"
    },
    AgavePoolDataProvider: {
      address: "0xE6729389DEa76D47b5BcB0bA5c080821c3B51329"
    },
    AgaveIncentivesController: {
      address: "0xfa255f5104f129B78f477e9a6D050a02f31A5D86"
    },
    AaveMoneyMarket: {
      address: "0xE7e12F53e85C9c91BfD4587049E28bC7bdDC6519"
    },
    "UpgradeableBeacon-Aave": {
      address: "0x363047035C17FCbD595235b4e701Fe93108Fd58E"
    },
    AaveImmutableProxy: {
      address: "0x97f4Ce94aB5d92CA171Dc52c46aaCC78Fecc9391"
    },
    AaveMoneyMarketView: {
      address: "0x8e9aD87AA0770b30a02Fe3fF49D0162f050aC84B"
    },
    AavePoolAddressesProvider: {
      address: "0x36616cf17557639614c1cdDb356b1B83fc0B2132",
      startBlock: 30774573
    },
    AaveRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    }
  },
  base: {
    multisig: {
      address: "0xBA59f902e3EE431E97C4Aca203fD5E6e3d4f8bE9"
    },
    treasury: {
      address: "0xF549b59134644a0810Cd3cD776A0C624c00606c6"
    },
    Timelock: {
      address: "0xc0939a4Ed0129bc5162F6f693935B3F72a46a90D"
    },
    ContangoProxy: {
      address: "0x6Cae28b3D09D8f8Fc74ccD496AC986FC84C0C24E",
      startBlock: 6373860
    },
    Contango: {
      address: "0x210F4e1942bEEc4038743A8f885B870E0c27b414"
    },
    PositionNFT: {
      address: "0xC2462f03920D47fC5B9e2C5F0ba5D2ded058fD78",
      startBlock: 6373860
    },
    Liquidations: {
      startBlock: 6373389
    },
    UnderlyingPositionFactory: {
      address: "0xDaBA83815404f5e1bc33f5885db7D96F51e127F5",
      startBlock: 6373860
    },
    BalancerFlashLoanProvider: {
      address: "0x3d4DF8596e5750A4F721c8764d585dcc8623d009"
    },
    AaveFlashLoanProvider: {
      address: "0xD6c3982eE6Aa45dB6C98eAB9fA7e990Dc02cF898"
    },
    UniswapFlashLoanProvider: {
      address: "0x23de8e0bB91A105bEFf9d40d8d75C1A9fE40f523"
    },
    FixedFeeModel: {
      address: "0x8cAad37f67FAb806383F59048723A92B5Dc4581D"
    },
    NativeToken: {
      address: "0x4200000000000000000000000000000000000006"
    },
    OrderManagerProxy: {
      address: "0xA64f0dbB10c473978C2EFe069da207991e8e3Cb3",
      startBlock: 6373860
    },
    OrderManager: {
      address: "0xa73b1Ea466C18D166b718dE5AF269ae177128CeE"
    },
    ReferralManager: {
      address: "0x945EF92aEB96F2ADFcc501379D3F887D0fCBD685",
      startBlock: 6373860
    },
    VaultProxy: {
      address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b"
    },
    Vault: {
      address: "0xB586D3B232A167bb319944120eAF0629af512311"
    },
    MaestroProxy: {
      address: "0xa6a147946FACAc9E0B99824870B36088764f969F",
      startBlock: 6373860
    },
    Maestro: {
      address: "0x62bF66Fc3e14a008c34E7A6BCAcD99945C02deAb"
    },
    FeeManagerProxy: {
      address: "0xA362611E47eb1888e0f6fD4b5a65A42d7C3eA3A4",
      startBlock: 6373860
    },
    FeeManager: {
      address: "0xB132C10acabCB8966Fa38e5AE9745039b7c8008b"
    },
    "InitialProxyImpl-ContangoProxy": {
      address: "0xb9021d7e1d7d800f813107d878FDF8F36eD14B77"
    },
    "InitialProxyImpl-VaultProxy": {
      address: "0xac72e62714E656A69009eC992272C624BdAaE0c2"
    },
    "InitialProxyImpl-OrderManagerProxy": {
      address: "0x037A5eA2F7fd0160871F09796713C99dD55ac198"
    },
    "InitialProxyImpl-MaestroProxy": {
      address: "0x35E6C82B43B03c15C80A321202E966AAF665b246"
    },
    "InitialProxyImpl-FeeManagerProxy": {
      address: "0x6919d5bb68295559EaFea6ABD17F4C506c269ec9"
    },
    AaveOracle: {
      address: "0x2F201B7B1176ECABA3D9E6C3e720B1f6A923229E"
    },
    IPermit2: {
      address: "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    },
    SpotExecutor: {
      address: "0x96bF9aB0E421a3da31D4506c967A825312455767"
    },
    SimpleSpotExecutor: {
      address: "0x370755b2846D7bA8fa237765F68c1783d76879E3"
    },
    Balancer: {
      address: "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
    },
    AaveMoneyMarket: {
      address: "0xF3e2ec7dB013f4F75c0905698796dEeca15B58Cf"
    },
    "UpgradeableBeacon-Aave": {
      address: "0xD1e452d6a78182135FE3455005A60BCC6a119905"
    },
    AaveImmutableProxy: {
      address: "0x0e7BC0e96bC7068866E46fAE9474a9366957228C"
    },
    AaveMoneyMarketView: {
      address: "0x718814062E4143a1fF3b3B7cD36e1d6C9603b85F"
    },
    AavePoolAddressesProvider: {
      address: "0xe20fCBdBfFC4Dd138cE8b2E6FBb6CB49777ad64D",
      startBlock: 6373389
    },
    AaveRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    }
  },
  "localhost-arbitrum": {
    multisig: {
      address: "0xE865379A78d65D4cc58472BC16514e39bDEB2759"
    },
    treasury: {
      address: "0x643178CF8AEc063962654CAc256FD1f7fe06ac28"
    },
    Timelock: {
      address: "0xc0939a4Ed0129bc5162F6f693935B3F72a46a90D"
    },
    ContangoProxy: {
      address: "0x6Cae28b3D09D8f8Fc74ccD496AC986FC84C0C24E",
      startBlock: 98674995
    },
    Contango: {
      address: "0xEBD8fE128EABaFAD42e7E4fE9566160884f06E9a",
      startBlock: 98674995
    },
    PositionNFT: {
      address: "0xC2462f03920D47fC5B9e2C5F0ba5D2ded058fD78",
      startBlock: 98674995
    },
    Liquidations: {
      startBlock: 98674995
    },
    AavePoolAddressesProvider: {
      address: "0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb"
    },
    AaveMoneyMarket: {
      address: "0xd81969C39BA010F857d2977D4F7a9c9f41fC2b8A"
    },
    BalancerFlashLoanProvider: {
      address: "0x87a1C2099d6cd02a1c9183BED8401ACB4Dc8929c"
    },
    AaveFlashLoanProvider: {
      address: "0xc3e92f4476E3Aae38FC9275B293032Ea54870B8F"
    },
    FixedFeeModel: {
      address: "0x20425C742a452A60c8e271A6C23320fa9D2484E6"
    },
    DAI: {
      address: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1"
    },
    USDC: {
      address: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8"
    },
    WETH: {
      address: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"
    },
    NativeToken: {
      address: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"
    },
    OrderManagerProxy: {
      address: "0xA64f0dbB10c473978C2EFe069da207991e8e3Cb3",
      startBlock: 98674995
    },
    OrderManager: {
      address: "0x763a7EA9e634B63EeF2b9c479f322C7191335662",
      startBlock: 98674995
    },
    ReferralManager: {
      address: "0x96E9198c47c645632FC0B60319A718fB71Db71B4",
      startBlock: 98674995
    },
    VaultProxy: {
      address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b",
      startBlock: 98674995
    },
    Vault: {
      address: "0x7546CF2F4655388aa42bFC3329B5eA910b606CE8",
      startBlock: 98674995
    },
    MaestroProxy: {
      address: "0xa6a147946FACAc9E0B99824870B36088764f969F",
      startBlock: 98674995
    },
    Maestro: {
      address: "0x9F91E9AdDd383f2368D034C8Ee04f22b51f36132",
      startBlock: 98674995
    },
    FeeManagerProxy: {
      address: "0xA362611E47eb1888e0f6fD4b5a65A42d7C3eA3A4",
      startBlock: 98674995
    },
    FeeManager: {
      address: "0x6bB27fd7F2F586018b602e25DD77bb9186095b79",
      startBlock: 98674995
    },
    "InitialProxyImpl-ContangoProxy": {
      address: "0xb9021d7e1d7d800f813107d878FDF8F36eD14B77"
    },
    "InitialProxyImpl-VaultProxy": {
      address: "0xac72e62714E656A69009eC992272C624BdAaE0c2"
    },
    "InitialProxyImpl-OrderManagerProxy": {
      address: "0x037A5eA2F7fd0160871F09796713C99dD55ac198"
    },
    "InitialProxyImpl-MaestroProxy": {
      address: "0x35E6C82B43B03c15C80A321202E966AAF665b246"
    },
    "InitialProxyImpl-FeeManagerProxy": {
      address: "0x6919d5bb68295559EaFea6ABD17F4C506c269ec9"
    },
    "Chainlink-DAI": {
      address: "0xc5C8E77B397E531B8EC06BFb0048328B30E9eCfB"
    },
    "Chainlink-USDC": {
      address: "0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3"
    },
    "Chainlink-WETH": {
      address: "0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612"
    },
    UnderlyingPositionFactory: {
      address: "0xDaBA83815404f5e1bc33f5885db7D96F51e127F5",
      startBlock: 98674995
    },
    "UpgradeableBeacon-Aave": {
      address: "0xB17fa258e46be6F2875256f268b49c8b57499C4e"
    },
    "UpgradeableBeacon-Exactly": {
      address: "0x0e24146Eb46B990be93EC7bc6048cFdA6C9c675a"
    },
    AaveImmutableProxy: {
      address: "0x7719e1E40051392E6Cb6a5CB40A8eDfa323C01a2"
    },
    ExactlyImmutableProxy: {
      address: "0x0e24146Eb46B990be93EC7bc6048cFdA6C9c675a"
    },
    AaveRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    },
    AaveOracle: {
      address: "0x1Dd77def2575CfC474BCb0ce73970F553b074af9"
    },
    AaveMoneyMarketView: {
      address: "0x0f1B90870D8AC8918517F7a6F5078A2FE190E91C"
    },
    IPermit2: {
      address: "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    },
    SpotExecutor: {
      address: "0x253cFc795f2Ca9BD56B217E7b377F98f15F07311"
    },
    SimpleSpotExecutor: {
      address: "0xC4851248f4EDaF9c4699dF6F7438FCf246Fa5E0E"
    },
    Balancer: {
      address: "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
    },
    SwapRouter02: {
      address: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"
    },
    UniswapFactory: {
      address: "0x1F98431c8aD98523631AE4a59f267346ea31F984"
    },
    RadiantMoneyMarket: {
      address: "0x33DfD5626991ED1e32275075BA0fc11fAB985434"
    },
    "UpgradeableBeacon-Radiant": {
      address: "0x8c28c9ed4FC9776d6e5Dca4f92ED9116eDC6f5b6"
    },
    RadiantImmutableProxy: {
      address: "0x2090bc8840885A9f4572eC701f8621dd2817B3E4"
    },
    RadiantMoneyMarketView: {
      address: "0x43470c12e441c06F01bFa7cef978bcc4B512D74f"
    },
    RadiantPoolAddressesProvider: {
      address: "0x091d52CacE1edc5527C99cDCFA6937C1635330E4"
    },
    RadiantPoolDataProvider: {
      address: "0x596B0cc4c5094507C50b579a662FE7e7b094A2cC"
    }
  },
  "localhost-optimism": {
    multisig: {
      address: "0xE865379A78d65D4cc58472BC16514e39bDEB2759"
    },
    treasury: {
      address: "0x643178CF8AEc063962654CAc256FD1f7fe06ac28"
    },
    Timelock: {
      address: "0xc0939a4Ed0129bc5162F6f693935B3F72a46a90D"
    },
    ContangoProxy: {
      address: "0x6Cae28b3D09D8f8Fc74ccD496AC986FC84C0C24E",
      startBlock: 98674995
    },
    Contango: {
      address: "0x4D65F4d5fCcD8fd0c85e0F8a93175cA9FDdfa835",
      startBlock: 98675337
    },
    PositionNFT: {
      address: "0xC2462f03920D47fC5B9e2C5F0ba5D2ded058fD78",
      startBlock: 98674995
    },
    Liquidations: {
      startBlock: 98674995
    },
    AavePoolAddressesProvider: {
      address: "0xa97684ead0e402dC232d5A977953DF7ECBaB3CDb"
    },
    AaveMoneyMarket: {
      address: "0x1531F8d2d0667d81ABdb17f4abf4ff32cB18a4E2"
    },
    BalancerFlashLoanProvider: {
      address: "0x00b98a7fA3eAF0E35B9fD353Fe58306B61D2BdD4"
    },
    AaveFlashLoanProvider: {
      address: "0x47E6b83cAC4e297D04c3F8548c806CF2B2e8FE77"
    },
    FixedFeeModel: {
      address: "0x6F58e7C2cBa734db4b12ddc9573484c18907968B"
    },
    DAI: {
      address: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1"
    },
    USDC: {
      address: "0x7F5c764cBc14f9669B88837ca1490cCa17c31607"
    },
    WETH: {
      address: "0x4200000000000000000000000000000000000006"
    },
    NativeToken: {
      address: "0x4200000000000000000000000000000000000006"
    },
    OrderManagerProxy: {
      address: "0xA64f0dbB10c473978C2EFe069da207991e8e3Cb3",
      startBlock: 98674995
    },
    OrderManager: {
      address: "0xea8cD16b9cEdC799a2e3aCD7f122975fB2cDa98E",
      startBlock: 98674995
    },
    ReferralManager: {
      address: "0x8cAad37f67FAb806383F59048723A92B5Dc4581D",
      startBlock: 98674995
    },
    VaultProxy: {
      address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b",
      startBlock: 98674995
    },
    Vault: {
      address: "0x361F0201e82c9d701bcA9913191086476A8df53a",
      startBlock: 98674995
    },
    MaestroProxy: {
      address: "0xa6a147946FACAc9E0B99824870B36088764f969F",
      startBlock: 98674995
    },
    Maestro: {
      address: "0x370755b2846D7bA8fa237765F68c1783d76879E3",
      startBlock: 98674995
    },
    FeeManagerProxy: {
      address: "0xA362611E47eb1888e0f6fD4b5a65A42d7C3eA3A4",
      startBlock: 98674995
    },
    FeeManager: {
      address: "0x945EF92aEB96F2ADFcc501379D3F887D0fCBD685",
      startBlock: 98674995
    },
    "InitialProxyImpl-ContangoProxy": {
      address: "0xb9021d7e1d7d800f813107d878FDF8F36eD14B77"
    },
    "InitialProxyImpl-VaultProxy": {
      address: "0xac72e62714E656A69009eC992272C624BdAaE0c2"
    },
    "InitialProxyImpl-OrderManagerProxy": {
      address: "0x037A5eA2F7fd0160871F09796713C99dD55ac198"
    },
    "InitialProxyImpl-MaestroProxy": {
      address: "0x35E6C82B43B03c15C80A321202E966AAF665b246"
    },
    "InitialProxyImpl-FeeManagerProxy": {
      address: "0x6919d5bb68295559EaFea6ABD17F4C506c269ec9"
    },
    ExactlyAccountDeployer: {
      address: "0x3974cFDe63eF55f5813e74dB2f915CC77fAbD4f6"
    },
    ExactlyMoneyMarket: {
      address: "0xA9A04F40101F62397A24B3cEebbdC9660898e172"
    },
    ExactlyReverseLookup: {
      address: "0x94C8C29C9C7EE1b0d38557B1EeC44f608a4DEDe6"
    },
    ExactlyAuditor: {
      address: "0xaEb62e6F27BC103702E7BC879AE98bceA56f027E"
    },
    ExactlyRewardsController: {
      address: "0xBd1ba78A3976cAB420A9203E6ef14D18C2B2E031"
    },
    ExactlyPreviewer: {
      address: "0xb8b1f590272b541b263A49b28bF52f8774b0E6c9"
    },
    "Chainlink-DAI": {
      address: "0x8dBa75e83DA73cc766A7e5a0ee71F656BAb470d6"
    },
    "Chainlink-USDC": {
      address: "0x16a9FA2FDa030272Ce99B29CF780dFA30361E0f3"
    },
    "Chainlink-WETH": {
      address: "0x13e3Ee699D1909E989722E753853AE30b17e08c5"
    },
    UnderlyingPositionFactory: {
      address: "0xDaBA83815404f5e1bc33f5885db7D96F51e127F5",
      startBlock: 98674995
    },
    "UpgradeableBeacon-Aave": {
      address: "0x1edeB9355AC74B6C81A905500df9F9c0794C231c"
    },
    "UpgradeableBeacon-Exactly": {
      address: "0xEc9986003984fC98b86add3818e5e6dd5b652fA6"
    },
    AaveImmutableProxy: {
      address: "0x4821b8EBb2eE2f856a334E775049Ee01df359ff6"
    },
    ExactlyImmutableProxy: {
      address: "0x52E270490e7Ee15CbA2f65c5A43A24Db185E6e77"
    },
    AaveRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    },
    AaveOracle: {
      address: "0x53A35a547549875Cd8ddC498c3f2bd866c392900"
    },
    AaveMoneyMarketView: {
      address: "0xcF678E428fBd6d9173fb780e971e4A123b68877a"
    },
    ExactlyMoneyMarketView: {
      address: "0xF7242fb5b73A6f7E8808bAAE6a81BB899c86A5dc"
    },
    IPermit2: {
      address: "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    },
    SpotExecutor: {
      address: "0xEc5B0cCcae497389a2aCbDba2Def7eC53BDC7Fd1"
    },
    SimpleSpotExecutor: {
      address: "0x954f7cF4a0473CCde2AD4c85Da65A84Df03F3B30"
    },
    Balancer: {
      address: "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
    },
    SwapRouter02: {
      address: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"
    },
    UniswapFactory: {
      address: "0x1F98431c8aD98523631AE4a59f267346ea31F984"
    }
  },
  "localhost-mainnet": {
    multisig: {
      address: "0xE865379A78d65D4cc58472BC16514e39bDEB2759"
    },
    treasury: {
      address: "0x643178CF8AEc063962654CAc256FD1f7fe06ac28"
    },
    Timelock: {
      address: "0xc0939a4Ed0129bc5162F6f693935B3F72a46a90D"
    },
    ContangoProxy: {
      address: "0x6Cae28b3D09D8f8Fc74ccD496AC986FC84C0C24E",
      startBlock: 18175557
    },
    Contango: {
      address: "0x95Bb968af09ac6975Adae3c96d3721A47E17D6C8",
      startBlock: 18175557
    },
    PositionNFT: {
      address: "0xC2462f03920D47fC5B9e2C5F0ba5D2ded058fD78",
      startBlock: 18175557
    },
    Liquidations: {
      startBlock: 18175557
    },
    AavePoolAddressesProvider: {
      address: "0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e"
    },
    AaveMoneyMarket: {
      address: "0x3c17C35ffCb41bC01Eb9fF7f92126D5777c213F1"
    },
    SparkPoolAddressesProvider: {
      address: "0x02C3eA4e34C0cBd694D2adFa2c690EECbC1793eE"
    },
    SparkMoneyMarket: {
      address: "0x39a4C4aCD154e14D7d84562a93e2214A3aCAF687"
    },
    BalancerFlashLoanProvider: {
      address: "0xb159F089F6689968f43749D79ed28a19BDcA6d70"
    },
    AaveFlashLoanProvider: {
      address: "0xDEb33DfD88169D53857231c8d07a6af87d33F7ae"
    },
    FixedFeeModel: {
      address: "0x9FeE839df29059D80BC78A5E3618a055a8076055"
    },
    DAI: {
      address: "0x6b175474e89094c44da98b954eedeac495271d0f"
    },
    USDC: {
      address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
    },
    WETH: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
    },
    NativeToken: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"
    },
    OrderManagerProxy: {
      address: "0xA64f0dbB10c473978C2EFe069da207991e8e3Cb3",
      startBlock: 18175557
    },
    OrderManager: {
      address: "0x8D82f03d20ac0708c2BE2D606dd86B2bFE21D5F7",
      startBlock: 18175557
    },
    ReferralManager: {
      address: "0x16D727F22605c7E520296900AcaC3f9526e37CBd",
      startBlock: 18175557
    },
    VaultProxy: {
      address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b",
      startBlock: 18175557
    },
    Vault: {
      address: "0xaC7c880dAC687640Ec4965f8854BA48842fcB6cF",
      startBlock: 18175557
    },
    MaestroProxy: {
      address: "0xa6a147946FACAc9E0B99824870B36088764f969F",
      startBlock: 18175557
    },
    Maestro: {
      address: "0x703F8334f10e166E9f00F49443f2E8c226DcA123",
      startBlock: 18175557
    },
    FeeManagerProxy: {
      address: "0xA362611E47eb1888e0f6fD4b5a65A42d7C3eA3A4",
      startBlock: 18175557
    },
    FeeManager: {
      address: "0x34B7fA94d07d709fb20c023858f553f8466A6574",
      startBlock: 18175557
    },
    "InitialProxyImpl-ContangoProxy": {
      address: "0xb9021d7e1d7d800f813107d878FDF8F36eD14B77"
    },
    "InitialProxyImpl-VaultProxy": {
      address: "0xac72e62714E656A69009eC992272C624BdAaE0c2"
    },
    "InitialProxyImpl-OrderManagerProxy": {
      address: "0x037A5eA2F7fd0160871F09796713C99dD55ac198"
    },
    "InitialProxyImpl-MaestroProxy": {
      address: "0x35E6C82B43B03c15C80A321202E966AAF665b246"
    },
    "InitialProxyImpl-FeeManagerProxy": {
      address: "0x6919d5bb68295559EaFea6ABD17F4C506c269ec9"
    },
    "Chainlink-DAI": {
      address: "0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9"
    },
    "Chainlink-USDC": {
      address: "0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6"
    },
    "Chainlink-WETH": {
      address: "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419"
    },
    UnderlyingPositionFactory: {
      address: "0xDaBA83815404f5e1bc33f5885db7D96F51e127F5",
      startBlock: 18175557
    },
    "UpgradeableBeacon-Aave": {
      address: "0x22e73D4c5f3bbf1FfE2F54929158f6587D9c5458"
    },
    "UpgradeableBeacon-Spark": {
      address: "0x5D768d36d6Edb131cde8dFC6ea39da23282eB12B"
    },
    AaveImmutableProxy: {
      address: "0x0cBBC5db66112C89d092742a8Ef35e6542B7F1C4"
    },
    AaveRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    },
    AaveOracle: {
      address: "0xecFa570eC16c3F3D53ba5D34E304419d50960c12"
    },
    AaveMoneyMarketView: {
      address: "0x5a0a527c371DC5f9a8975BF3942db69f2eaD69B7"
    },
    SparkImmutableProxy: {
      address: "0xE6BF55F449555Bf89c6B1d54787413fB63690f89"
    },
    SparkRewardsController: {
      address: "0x0000000000000000000000000000000000000000"
    },
    SparkMoneyMarketView: {
      address: "0xFb5717685db9c1FE7076eABDa559a3D93919Bec2"
    },
    IPermit2: {
      address: "0x000000000022D473030F116dDEE9F6B43aC78BA3"
    },
    SpotExecutor: {
      address: "0xfF7b4D89617D8ac9698632B14127aac55895d21e"
    },
    SimpleSpotExecutor: {
      address: "0xf3cA711a64CaEbD9085cc933b45a26F7ae96E086"
    },
    Balancer: {
      address: "0xBA12222222228d8Ba445958a75a0704d566BF2C8"
    },
    SwapRouter02: {
      address: "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45"
    },
    UniswapFactory: {
      address: "0x1F98431c8aD98523631AE4a59f267346ea31F984"
    },
    AaveV2MoneyMarket: {
      address: "0x9071fE8197e59a345B7CFD884134796B6829F5b7"
    },
    "UpgradeableBeacon-AaveV2": {
      address: "0x5F2e5b383540eE26f5d69e3BB53d8fFF2bff8803"
    },
    AaveV2ImmutableProxy: {
      address: "0xA1A3A91E91B2C123689e8c54D2E9442BDc59b4AF"
    },
    AaveV2MoneyMarketView: {
      address: "0x72A6Bf49d4B3230Af06c1C5054Fb9AAB3d50f172"
    },
    AaveV2PoolAddressesProvider: {
      address: "0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5"
    },
    AaveV2PoolDataProvider: {
      address: "0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d"
    }
  }
};

// src/types.ts
var CashflowCurrency = /* @__PURE__ */ ((CashflowCurrency2) => {
  CashflowCurrency2[CashflowCurrency2["None"] = 0] = "None";
  CashflowCurrency2[CashflowCurrency2["Base"] = 1] = "Base";
  CashflowCurrency2[CashflowCurrency2["Quote"] = 2] = "Quote";
  return CashflowCurrency2;
})(CashflowCurrency || {});
var Side = {
  Long: "Long",
  Short: "Short"
};
var MoneyMarket = /* @__PURE__ */ ((MoneyMarket3) => {
  MoneyMarket3[MoneyMarket3["Aave"] = 1] = "Aave";
  MoneyMarket3[MoneyMarket3["Compound"] = 2] = "Compound";
  MoneyMarket3[MoneyMarket3["Yield"] = 3] = "Yield";
  MoneyMarket3[MoneyMarket3["Exactly"] = 4] = "Exactly";
  MoneyMarket3[MoneyMarket3["Sonne"] = 5] = "Sonne";
  MoneyMarket3[MoneyMarket3["Maker"] = 6] = "Maker";
  MoneyMarket3[MoneyMarket3["Spark"] = 7] = "Spark";
  MoneyMarket3[MoneyMarket3["MorphoBlue"] = 8] = "MorphoBlue";
  MoneyMarket3[MoneyMarket3["Agave"] = 9] = "Agave";
  MoneyMarket3[MoneyMarket3["AaveV2"] = 10] = "AaveV2";
  MoneyMarket3[MoneyMarket3["Radiant"] = 11] = "Radiant";
  return MoneyMarket3;
})(MoneyMarket || {});
function getMoneyMarketName(market) {
  return MoneyMarket[market];
}
function getDisplayMoneyMarketName(market) {
  const name = getMoneyMarketName(market);
  return name === "Aave" ? "AaveV3" : name;
}

// src/api/addressMappers.ts
var chainIdToChainName = {
  31337: "localhost-arbitrum",
  31338: "localhost-optimism",
  31339: "localhost-mainnet",
  42161: "arbitrum-one",
  8453: "base",
  137: "matic",
  100: "gnosis",
  10: "optimism",
  1: "mainnet"
};
var getContangoProxy = (chainId) => {
  const chainName = chainIdToChainName[chainId];
  return networks_default[chainName].ContangoProxy.address;
};
var getMaestroProxy = (chainId) => {
  const chainName = chainIdToChainName[chainId];
  return networks_default[chainName].MaestroProxy.address;
};
var getOrderManager = (chainId) => {
  const chainName = chainIdToChainName[chainId];
  return networks_default[chainName].OrderManagerProxy.address;
};
var chainAndHardcodedAddressMapper = (_chainId, mm) => {
  if (!Object.keys(chainIdToChainName).includes(_chainId.toString())) {
    throw "unsupported chain id";
  }
  const chainId = _chainId;
  const chainName = chainIdToChainName[chainId];
  const chain = networks_default[chainName];
  const contangoProxy = chain.ContangoProxy.address;
  const spotExecutor = chain.SpotExecutor.address;
  const vaultProxy = chain.VaultProxy.address;
  const maestroProxy = chain.MaestroProxy.address;
  let moneyMarket;
  let moneyMarketView;
  const feeModel = chain.FixedFeeModel.address;
  const permit2 = chain.IPermit2.address;
  const flashloanProviders = Object.entries(chain).filter(([key]) => key.includes("FlashLoanProvider")).map(([, value]) => value.address);
  moneyMarket = loadAddress(chainId, `${getMoneyMarketName(mm)}MoneyMarket`);
  moneyMarketView = loadAddress(chainId, `${getMoneyMarketName(mm)}MoneyMarketView`);
  return { moneyMarket, permit2, moneyMarketView, maestroProxy, spotExecutor, feeModel, contangoProxy, vaultProxy, flashloanProviders };
};
var loadAddress = (chainId, name) => {
  const chainName = chainIdToChainName[chainId];
  const chain = networks_default[chainName];
  if (!chain)
    throw `Chain not found for ${chainId}`;
  const element = chain[name];
  if (!element || !element.address)
    throw `Address not found for ${name} on ${chainName}`;
  return element.address;
};

// ../node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// src/api/listeners.ts
var positionUpsert$ = (owner, next, client) => {
  const chainId = client.chain?.id;
  const address = getContangoProxy(chainId);
  return client.watchContractEvent({
    address,
    abi: contangoABI,
    eventName: "PositionUpserted",
    args: { owner },
    strict: true,
    onLogs: (logs) => {
      logs.filter(({ eventName, args }) => eventName === "PositionUpserted" && args.owner.toLowerCase() === owner.toLowerCase()).forEach(({ args, transactionHash, blockNumber }) => {
        next({ ...args, chainId, txHash: transactionHash, blockNumber });
      });
    }
  });
};
var rewardsClaimed$ = (owner, client) => {
  const chainId = client.chain?.id;
  const address = getContangoProxy(chainId);
  return new Observable((observer) => {
    const next = observer.next.bind(observer);
    return client.watchContractEvent({
      address,
      abi: contangoABI,
      eventName: "RewardsClaimed",
      args: { to: owner },
      strict: true,
      onLogs: (logs) => {
        next(logs.reduce((acc, curr) => acc.add(curr.args.positionId.toLowerCase()), /* @__PURE__ */ new Set()));
      }
    });
  });
};
var ordersAdded$ = (trader, next, client) => {
  const chainId = client.chain?.id;
  const address = getOrderManager(chainId);
  return client.watchContractEvent({
    address,
    abi: iOrderManagerABI,
    eventName: "OrderPlaced",
    args: { owner: trader },
    strict: true,
    onLogs: (logs) => {
      logs.filter(({ eventName }) => eventName === "OrderPlaced").forEach(({ args }) => {
        next({ chainId, blockNumber: logs[0].blockNumber, ...args });
      });
    }
  });
};
var ordersRemoved$ = (next, client) => {
  const chainId = client.chain?.id;
  const address = getOrderManager(chainId);
  const canceled = client.watchContractEvent({
    address,
    abi: iOrderManagerABI,
    eventName: "OrderCancelled",
    strict: true,
    onLogs: (logs) => {
      logs.filter(({ eventName }) => eventName === "OrderCancelled").forEach(({ args: { orderId } }) => {
        next({ chainId, blockNumber: logs[0].blockNumber, orderId });
      });
    }
  });
  const executed = client.watchContractEvent({
    pollingInterval: 3e4,
    address,
    abi: iOrderManagerABI,
    eventName: "OrderExecuted",
    strict: true,
    onLogs: (logs) => {
      logs.filter(({ eventName }) => eventName === "OrderExecuted").forEach(({ args: { orderId } }) => {
        next({ chainId, blockNumber: logs[0].blockNumber, orderId });
      });
    }
  });
  return () => {
    canceled();
    executed();
  };
};

// src/api/mean-sdk.ts
var import_sdk2 = __toESM(require_dist3());

// src/api/viem-gas-price-source.ts
var import_sdk = __toESM(require_dist3());
var ViemGasPriceSource = class {
  constructor(publicClient) {
    this.publicClient = publicClient;
  }
  supportedSpeeds() {
    const support = { standard: "present" };
    return Object.fromEntries(Object.keys(chainIdToChainName).map((chainId) => [Number(chainId), support]));
  }
  async getGasPrice({
    config: config2
  }) {
    const { maxFeePerGas, maxPriorityFeePerGas } = await (0, import_sdk.timeoutPromise)(this.publicClient.estimateFeesPerGas(), config2?.timeout);
    const gasPrice = !!maxFeePerGas && !!maxPriorityFeePerGas ? { standard: { maxFeePerGas: Number(maxFeePerGas).toString(), maxPriorityFeePerGas: Number(maxPriorityFeePerGas).toString() } } : { standard: { gasPrice: Number(await this.publicClient.getGasPrice()).toString() } };
    return gasPrice;
  }
};

// src/api/mean-sdk.ts
var supportedClients = Object.fromEntries(Object.keys(chainIdToChainName).map((chainId) => [chainId, { viem: true, ethers: false }]));
var supportedProperties = Object.fromEntries(
  Object.keys(chainIdToChainName).map((chainId) => [chainId, { symbol: "present", decimals: "present", name: "present" }])
);
var getAllQuotes = async (chainId, sellToken, buyToken, sellAmount, takerAddress, slippageTolerance, publicClient, dex) => {
  const customConfig = publicClient ? {
    provider: {
      source: {
        type: "custom",
        instance: {
          supportedClients: () => supportedClients,
          getViemTransport: () => publicClient.transport,
          getEthersProvider: () => ({})
        }
      }
    }
  } : {};
  const customGasProviderConf = chainId === 100 || chainId === 8453 ? {
    gas: {
      source: {
        type: "custom",
        instance: new ViemGasPriceSource(publicClient)
      }
    }
  } : {};
  const customFetch = typeof window !== "undefined" ? {} : { fetch: { fetch } };
  const spotSdk = (0, import_sdk2.buildSDK)({
    ...customConfig,
    ...customGasProviderConf,
    ...customFetch,
    metadata: {
      source: {
        type: "custom",
        instance: {
          supportedProperties: () => supportedProperties,
          getMetadata: async () => {
            return {
              [chainId]: {
                [sellToken.address]: sellToken,
                [buyToken.address]: buyToken
              }
            };
          }
        }
      }
    },
    quotes: {
      defaultConfig: {
        global: {
          referrer: {
            address: "0x3F37C7d8e61C000085AAc0515775b06A3412F36b",
            name: "Contango"
          }
        }
      }
    }
  });
  const slippagePercentage = Number(slippageTolerance) / Number(1e16);
  const excludeSources = [];
  const res = await spotSdk.quoteService.getAllQuotes({
    request: {
      chainId,
      sellToken: sellToken.address,
      buyToken: buyToken.address,
      order: {
        type: "sell",
        sellAmount
      },
      takerAddress,
      slippagePercentage,
      ...dex ? { filters: { includeSources: [dex] } } : { filters: { excludeSources } }
    },
    config: {
      ignoredFailed: false,
      timeout: "5 s"
    }
  });
  const validQuotes = res.filter((quote) => !quote["failed"]);
  if (validQuotes.length === 0) {
    console.error("All quotes failed", res);
    throw new Error("No quotes found");
  }
  return validQuotes;
};

// ../node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_abi();

// ../node_modules/viem/_esm/errors/log.js
init_base();
var FilterTypeNotSupportedError = class extends BaseError {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "FilterTypeNotSupportedError"
    });
  }
};

// ../node_modules/viem/_esm/utils/abi/encodeEventTopics.js
init_toBytes();
init_getEventSelector();
init_keccak256();
init_encodeAbiParameters();
init_formatAbiItem();
init_getAbiItem();
function encodeEventTopics({ abi, eventName, args }) {
  let abiItem = abi[0];
  if (eventName) {
    abiItem = getAbiItem({
      abi,
      args,
      name: eventName
    });
    if (!abiItem)
      throw new AbiEventNotFoundError(eventName, {
        docsPath: "/docs/contract/encodeEventTopics"
      });
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeEventTopics"
    });
  const definition = formatAbiItem(abiItem);
  const signature = getEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null) ?? [];
    }
  }
  return [signature, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak2565(toBytes2(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}

// ../node_modules/viem/_esm/actions/public/createContractEventFilter.js
init_toHex();

// ../node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method }) {
  const requestMap = {};
  if (client.transport.type === "fallback")
    client.transport.onResponse?.(({ method: method_, response: id4, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id4] = transport.request;
    });
  return (id4) => requestMap[id4] || client.request;
}

// ../node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, strict, toBlock }) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi,
    args,
    eventName
  }) : void 0;
  const id4 = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi,
    args,
    eventName,
    id: id4,
    request: getRequest(id4),
    strict,
    type: "event"
  };
}

// ../node_modules/viem/_esm/actions/public/estimateContractGas.js
init_parseAccount();
init_encodeFunctionData();

// ../node_modules/viem/_esm/utils/errors/getContractError.js
init_abi();
init_base();
init_contract();
init_rpc();
var EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath: docsPath4, functionName, sender }) {
  const { code, data, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath4,
    functionName,
    sender
  });
}

// ../node_modules/viem/_esm/actions/public/estimateGas.js
init_parseAccount();

// ../node_modules/viem/_esm/errors/account.js
init_base();
var AccountNotFoundError = class extends BaseError {
  constructor({ docsPath: docsPath4 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join("\n"), {
      docsPath: docsPath4,
      docsSlug: "account"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccountNotFoundError"
    });
  }
};

// ../node_modules/viem/_esm/actions/public/estimateGas.js
init_toHex();

// ../node_modules/viem/_esm/errors/estimateGas.js
init_formatEther();
init_formatGwei();
init_base();
init_transaction();
var EstimateGasExecutionError = class extends BaseError {
  constructor(cause, { account, docsPath: docsPath4, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther2(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath4,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean)
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EstimateGasExecutionError"
    });
    this.cause = cause;
  }
};

// ../node_modules/viem/_esm/utils/errors/getEstimateGasError.js
init_node();
init_getNodeError();
function getEstimateGasError(err, { docsPath: docsPath4, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath4,
    ...args
  });
}

// ../node_modules/viem/_esm/actions/public/estimateGas.js
init_extract();
init_transactionRequest();
init_assertRequest();

// ../node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
init_parseAccount();

// ../node_modules/viem/_esm/errors/fee.js
init_formatGwei();
init_base();
var BaseFeeScalarError = class extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseFeeScalarError"
    });
  }
};
var Eip1559FeesNotSupportedError = class extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Eip1559FeesNotSupportedError"
    });
  }
};
var MaxFeePerGasTooLowError = class extends BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "MaxFeePerGasTooLowError"
    });
  }
};

// ../node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
init_fromHex();

// ../node_modules/viem/_esm/errors/block.js
init_base();
var BlockNotFoundError = class extends BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BlockNotFoundError"
    });
  }
};

// ../node_modules/viem/_esm/actions/public/getBlock.js
init_toHex();

// ../node_modules/viem/_esm/utils/formatters/transaction.js
init_fromHex();
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber2(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber2(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  return transaction_;
}

// ../node_modules/viem/_esm/utils/formatters/block.js
function formatBlock2(block) {
  const transactions = block.transactions?.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}

// ../node_modules/viem/_esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format = client.chain?.formatters?.block?.format || formatBlock2;
  return format(block);
}

// ../node_modules/viem/_esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// ../node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function estimateMaxPriorityFeePerGas(client, args) {
  return internal_estimateMaxPriorityFeePerGas(client, args);
}
async function internal_estimateMaxPriorityFeePerGas(client, args) {
  const { block: block_, chain = client.chain, request } = args || {};
  if (typeof chain?.fees?.defaultPriorityFee === "function") {
    const block = block_ || await getBlock(client);
    return chain.fees.defaultPriorityFee({
      block,
      client,
      request
    });
  } else if (typeof chain?.fees?.defaultPriorityFee !== "undefined")
    return chain?.fees?.defaultPriorityFee;
  try {
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getBlock(client),
      getGasPrice(client)
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// ../node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function estimateFeesPerGas(client, args) {
  return internal_estimateFeesPerGas(client, args);
}
async function internal_estimateFeesPerGas(client, args) {
  const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client,
        request
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError();
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getBlock(client);
  if (typeof chain?.fees?.estimateFeesPerGas === "function")
    return chain.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request,
      type
    });
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = request?.maxPriorityFeePerGas ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request?.gasPrice ?? multiply(await getGasPrice(client));
  return {
    gasPrice
  };
}

// ../node_modules/viem/_esm/actions/public/getTransactionCount.js
init_fromHex();
init_toHex();
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  });
  return hexToNumber2(count);
}

// ../node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
init_assertRequest();

// ../node_modules/viem/_esm/utils/transaction/getTransactionType.js
init_transaction();
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined")
    return "eip1559";
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// ../node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
async function prepareTransactionRequest(client, args) {
  const { account: account_ = client.account, chain, gas, nonce, type } = args;
  if (!account_)
    throw new AccountNotFoundError();
  const account = parseAccount(account_);
  const block = await getBlock(client, { blockTag: "latest" });
  const request = { ...args, from: account.address };
  if (typeof nonce === "undefined")
    request.nonce = await getTransactionCount(client, {
      address: account.address,
      blockTag: "pending"
    });
  if (typeof type === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      request.type = typeof block.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (request.type === "eip1559") {
    const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
      block,
      chain,
      request
    });
    if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
      throw new MaxFeePerGasTooLowError({
        maxPriorityFeePerGas
      });
    request.maxPriorityFeePerGas = maxPriorityFeePerGas;
    request.maxFeePerGas = maxFeePerGas;
  } else {
    if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
      throw new Eip1559FeesNotSupportedError();
    const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
      block,
      chain,
      request,
      type: "legacy"
    });
    request.gasPrice = gasPrice_;
  }
  if (typeof gas === "undefined")
    request.gas = await estimateGas(client, {
      ...request,
      account: { address: account.address, type: "json-rpc" }
    });
  assertRequest(request);
  return request;
}

// ../node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas(client, args) {
  const account_ = args.account ?? client.account;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/public/estimateGas"
    });
  const account = parseAccount(account_);
  try {
    const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await prepareTransactionRequest(client, args) : args;
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    assertRequest(args);
    const format = client.chain?.formatters?.transactionRequest?.format || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format }),
      from: account.address,
      accessList,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const balance = await client.request({
      method: "eth_estimateGas",
      params: block ? [request, block] : [request]
    });
    return BigInt(balance);
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// ../node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await estimateGas(client, {
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (err) {
    const account = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(err, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account?.address
    });
  }
}

// ../node_modules/viem/_esm/actions/public/getContractEvents.js
init_getAbiItem();

// ../node_modules/viem/_esm/actions/public/getLogs.js
init_abi();

// ../node_modules/viem/_esm/utils/abi/decodeEventLog.js
init_abi();
init_getEventSelector();
init_decodeAbiParameters();
init_formatAbiItem();
var docsPath = "/docs/contract/decodeEventLog";
function decodeEventLog({ abi, data, strict: strict_, topics }) {
  const strict = strict_ ?? true;
  const [signature, ...argTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({
      docsPath
    });
  const abiItem = abi.find((x) => x.type === "event" && signature === getEventSelector(formatAbiItem(x)));
  if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, {
      docsPath
    });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
  for (let i = 0; i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[param.name || i] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0; i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data: err.data,
              params: err.params,
              size: err.size
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}

// ../node_modules/viem/_esm/actions/public/getLogs.js
init_toHex();

// ../node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// ../node_modules/viem/_esm/actions/public/getLogs.js
async function getLogs2(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events) {
    topics = [
      events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  return logs.map((log) => {
    try {
      const { eventName, args: args2 } = events ? decodeEventLog({
        abi: events,
        data: log.data,
        topics: log.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog(log, { args: args2, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
      }
      return formatLog(log, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}

// ../node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict }) {
  const event = eventName ? getAbiItem({ abi, name: eventName }) : void 0;
  const events = !event ? abi.filter((x) => x.type === "event") : void 0;
  return getLogs2(client, {
    address,
    args,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict
  });
}

// ../node_modules/viem/_esm/actions/public/readContract.js
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await call(client, {
      data: calldata,
      to: address,
      ...callRequest
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (err) {
    throw getContractError(err, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// ../node_modules/viem/_esm/actions/public/simulateContract.js
init_parseAccount();
init_decodeFunctionResult();
init_encodeFunctionData();
init_call();
async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
  const account = callRequest.account ? parseAccount(callRequest.account) : void 0;
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await call(client, {
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest
    });
    const result = decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
    return {
      result,
      request: {
        abi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest
      }
    };
  } catch (err) {
    throw getContractError(err, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account?.address
    });
  }
}

// ../node_modules/viem/_esm/utils/observe.js
var listenersCache = /* @__PURE__ */ new Map();
var cleanupCache = /* @__PURE__ */ new Map();
var callbackCount = 0;
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = (...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      listeners2.forEach((listener) => listener.fns[key]?.(...args));
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}

// ../node_modules/viem/_esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// ../node_modules/viem/_esm/utils/poll.js
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data = void 0;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}

// ../node_modules/viem/_esm/actions/public/watchContractEvent.js
init_stringify();
init_abi();
init_rpc();

// ../node_modules/viem/_esm/utils/promise/withCache.js
var promiseCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache) => ({
    clear: () => cache.delete(cacheKey3),
    get: () => cache.get(cacheKey3),
    set: (data) => cache.set(cacheKey3, data)
  });
  const promise = buildCache(cacheKey2, promiseCache);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Infinity }) {
  const cache = getCache(cacheKey2);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = new Date().getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: new Date(), data });
    return data;
  } finally {
    cache.promise.clear();
  }
}

// ../node_modules/viem/_esm/actions/public/getBlockNumber.js
var cacheKey = (id4) => `blockNumber.${id4}`;
async function getBlockNumber(client, { cacheTime = client.cacheTime, maxAge } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime: maxAge ?? cacheTime });
  return BigInt(blockNumberHex);
}

// ../node_modules/viem/_esm/actions/public/getFilterChanges.js
init_abi();
async function getFilterChanges(_client, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  return logs.map((log) => {
    if (typeof log === "string")
      return log;
    try {
      const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
        abi: filter.abi,
        data: log.data,
        topics: log.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog(log, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter && filter.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
      }
      return formatLog(log, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}

// ../node_modules/viem/_esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}

// ../node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollContractEvent = () => {
    const observerId = stringify2([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval
    ]);
    const strict = strict_ ?? false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await createContractEventFilter(client, {
              abi,
              address,
              args,
              eventName,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getFilterChanges(client, { filter });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getContractEvents(client, {
                abi,
                address,
                args,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await uninstallFilter(client, { filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const topics = eventName ? encodeEventTopics({
          abi,
          eventName,
          args
        }) : [];
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName: eventName2, args: args2 } = decodeEventLog({
                abi,
                data: log.data,
                topics: log.topics,
                strict: strict_
              });
              const formatted = formatLog(log, {
                args: args2,
                eventName: eventName2
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName2;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName2 = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName: eventName2
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}

// ../node_modules/viem/_esm/actions/wallet/writeContract.js
init_encodeFunctionData();

// ../node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_parseAccount();
init_chain2();

// ../node_modules/viem/_esm/utils/errors/getTransactionError.js
init_node();
init_transaction();
init_getNodeError();
function getTransactionError(err, { docsPath: docsPath4, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath4,
    ...args
  });
}

// ../node_modules/viem/_esm/actions/wallet/sendTransaction.js
init_extract();
init_transactionRequest();
init_assertRequest();

// ../node_modules/viem/_esm/actions/public/getChainId.js
init_fromHex();
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  });
  return hexToNumber2(chainIdHex);
}

// ../node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  });
}

// ../node_modules/viem/_esm/actions/wallet/sendTransaction.js
async function sendTransaction(client, args) {
  const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = parseAccount(account_);
  try {
    assertRequest(args);
    let chainId;
    if (chain !== null) {
      chainId = await getChainId(client);
      assertCurrentChain({
        currentChainId: chainId,
        chain
      });
    }
    if (account.type === "local") {
      const request2 = await prepareTransactionRequest(client, {
        account,
        accessList,
        chain,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...rest
      });
      if (!chainId)
        chainId = await getChainId(client);
      const serializer = chain?.serializers?.transaction;
      const serializedTransaction = await account.signTransaction({
        ...request2,
        chainId
      }, { serializer });
      return await sendRawTransaction(client, {
        serializedTransaction
      });
    }
    const format = chain?.formatters?.transactionRequest?.format || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format }),
      accessList,
      data,
      from: account.address,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    return await client.request({
      method: "eth_sendTransaction",
      params: [request]
    });
  } catch (err) {
    throw getTransactionError(err, {
      ...args,
      account,
      chain: args.chain || void 0
    });
  }
}

// ../node_modules/viem/_esm/actions/wallet/writeContract.js
async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  const hash4 = await sendTransaction(client, {
    data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
    to: address,
    ...request
  });
  return hash4;
}

// ../node_modules/viem/_esm/actions/getContract.js
function getContract({ abi, address, publicClient, walletClient }) {
  const hasPublicClient = publicClient !== void 0 && publicClient !== null;
  const hasWalletClient = walletClient !== void 0 && walletClient !== null;
  const contract = {};
  let hasReadFunction = false;
  let hasWriteFunction = false;
  let hasEvent = false;
  for (const item of abi) {
    if (item.type === "function")
      if (item.stateMutability === "view" || item.stateMutability === "pure")
        hasReadFunction = true;
      else
        hasWriteFunction = true;
    else if (item.type === "event")
      hasEvent = true;
    if (hasReadFunction && hasWriteFunction && hasEvent)
      break;
  }
  if (hasPublicClient) {
    if (hasReadFunction)
      contract.read = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return readContract(publicClient, {
              abi,
              address,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasWriteFunction)
      contract.simulate = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return simulateContract(publicClient, {
              abi,
              address,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasEvent) {
      contract.createEventFilter = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return createContractEventFilter(publicClient, {
              abi,
              address,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract.getEvents = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getContractEvents(publicClient, {
              abi,
              address,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract.watchEvent = new Proxy({}, {
        get(_, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return watchContractEvent(publicClient, {
              abi,
              address,
              eventName,
              args,
              ...options
            });
          };
        }
      });
    }
  }
  if (hasWalletClient) {
    if (hasWriteFunction)
      contract.write = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return writeContract(walletClient, {
              abi,
              address,
              functionName,
              args,
              ...options
            });
          };
        }
      });
  }
  if (hasPublicClient || hasWalletClient) {
    if (hasWriteFunction)
      contract.estimateGas = new Proxy({}, {
        get(_, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            const client = publicClient ?? walletClient;
            return estimateContractGas(client, {
              abi,
              address,
              functionName,
              args,
              ...options,
              account: options.account ?? walletClient.account
            });
          };
        }
      });
  }
  contract.address = address;
  contract.abi = abi;
  return contract;
}
function getFunctionParameters(values) {
  const hasArgs = values.length && Array.isArray(values[0]);
  const args = hasArgs ? values[0] : [];
  const options = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options };
}
function getEventParameters(values, abiEvent) {
  let hasArgs = false;
  if (Array.isArray(values[0]))
    hasArgs = true;
  else if (values.length === 1) {
    hasArgs = abiEvent.inputs.some((x) => x.indexed);
  } else if (values.length === 2) {
    hasArgs = true;
  }
  const args = hasArgs ? values[0] : void 0;
  const options = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options };
}

// ../node_modules/viem/_esm/utils/accounts.js
init_parseAccount();

// ../node_modules/viem/_esm/utils/uid.js
var size2 = 256;
var index = size2;
var buffer;
function uid(length = 11) {
  if (!buffer || index + length > size2 * 2) {
    buffer = "";
    index = 0;
    for (let i = 0; i < size2; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// ../node_modules/viem/_esm/clients/createClient.js
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4e3, key = "base", name = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
  const chain = parameters.chain;
  const account = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config: config2, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config2, ...value };
  const client = {
    account,
    batch,
    cacheTime,
    chain,
    key,
    name,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid()
  };
  function extend(base) {
    return (extendFn) => {
      const extended = extendFn(base);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client, { extend: extend(client) });
}

// ../node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay2 = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay2)
          await wait(delay2);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await fn();
        resolve(data);
      } catch (err) {
        if (count < retryCount && await shouldRetry({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}

// ../node_modules/viem/_esm/actions/ens/getEnsAddress.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_chain2();
init_trim();
init_toHex();

// ../node_modules/viem/_esm/utils/ens/errors.js
init_solidity();
init_base();
init_contract();
function isNullUniversalResolverError(err, callType) {
  if (!(err instanceof BaseError))
    return false;
  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}

// ../node_modules/viem/_esm/utils/ens/namehash.js
init_concat();
init_toBytes();
init_toHex();
init_keccak256();

// ../node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
init_isHex();
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash4 = `0x${label.slice(1, 65)}`;
  if (!isHex2(hash4))
    return null;
  return hash4;
}

// ../node_modules/viem/_esm/utils/ens/namehash.js
function namehash2(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex2(result);
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes2(hashFromEncodedLabel) : keccak2565(stringToBytes(labels[i]), "bytes");
    result = keccak2565(concat8([result, hashed]), "bytes");
  }
  return bytesToHex2(result);
}

// ../node_modules/viem/_esm/utils/ens/packetToBytes.js
init_toBytes();

// ../node_modules/viem/_esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash4) {
  return `[${hash4.slice(2)}]`;
}

// ../node_modules/viem/_esm/utils/ens/labelhash.js
init_toBytes();
init_toHex();
init_keccak256();
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex2(result);
  return encodedLabelToLabelhash(label) || keccak2565(stringToBytes(label));
}

// ../node_modules/viem/_esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes4 = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i = 0; i < list.length; i++) {
    let encoded = stringToBytes(list[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
    bytes4[offset] = encoded.length;
    bytes4.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes4.byteLength !== offset + 1)
    return bytes4.slice(0, offset + 1);
  return bytes4;
}

// ../node_modules/viem/_esm/actions/ens/getEnsAddress.js
async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash2(name), BigInt(coinType)] } : { args: [namehash2(name)] }
    });
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex2(packetToBytes(name)), functionData],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash2(name), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err) {
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// ../node_modules/viem/_esm/errors/ens.js
init_base();
var EnsAvatarInvalidMetadataError = class extends BaseError {
  constructor({ data }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data)}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
};
var EnsAvatarInvalidNftUriError = class extends BaseError {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
};
var EnsAvatarUriResolutionError = class extends BaseError {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUriResolutionError"
    });
  }
};
var EnsAvatarUnsupportedNamespaceError = class extends BaseError {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
};

// ../node_modules/viem/_esm/utils/ens/avatar/utils.js
var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom, defaultGateway) {
  if (!custom)
    return defaultGateway;
  if (custom.endsWith("/"))
    return custom.slice(0, -1);
  return custom;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  } else if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}

// ../node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
async function parseAvatarRecord(client, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}

// ../node_modules/viem/_esm/actions/ens/getEnsText.js
init_abis();
init_decodeFunctionResult();
init_encodeFunctionData();
init_chain2();
init_toHex();
async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex2(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash2(name), key]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}

// ../node_modules/viem/_esm/actions/ens/getEnsAvatar.js
async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
  const record = await getEnsText(client, {
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client, { record, gatewayUrls });
  } catch {
    return null;
  }
}

// ../node_modules/viem/_esm/actions/ens/getEnsName.js
init_abis();
init_chain2();
init_toHex();
async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex2(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    });
    return res[0];
  } catch (err) {
    if (isNullUniversalResolverError(err, "reverse"))
      return null;
    throw err;
  }
}

// ../node_modules/viem/_esm/actions/ens/getEnsResolver.js
init_chain2();
init_toHex();
async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await readContract(client, {
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex2(packetToBytes(name))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}

// ../node_modules/viem/_esm/clients/decorators/public.js
init_call();

// ../node_modules/viem/_esm/actions/public/createBlockFilter.js
async function createBlockFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newBlockFilter"
  });
  const id4 = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id: id4, request: getRequest(id4), type: "block" };
}

// ../node_modules/viem/_esm/actions/public/createEventFilter.js
init_toHex();
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events = events_ ?? (event ? [event] : void 0);
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events) {
    topics = [
      events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  const id4 = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events,
    args,
    eventName: event ? event.name : void 0,
    fromBlock,
    id: id4,
    request: getRequest(id4),
    strict,
    toBlock,
    type: "event"
  };
}

// ../node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
async function createPendingTransactionFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newPendingTransactionFilter"
  });
  const id4 = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: id4, request: getRequest(id4), type: "transaction" };
}

// ../node_modules/viem/_esm/actions/public/getBalance.js
init_toHex();
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// ../node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
init_fromHex();
init_toHex();
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count;
  if (blockHash) {
    count = await client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  } else {
    count = await client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    });
  }
  return hexToNumber2(count);
}

// ../node_modules/viem/_esm/actions/public/getBytecode.js
init_toHex();
async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  });
  if (hex === "0x")
    return void 0;
  return hex;
}

// ../node_modules/viem/_esm/actions/public/getFeeHistory.js
init_toHex();

// ../node_modules/viem/_esm/utils/formatters/feeHistory.js
function formatFeeHistory(feeHistory) {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
  };
}

// ../node_modules/viem/_esm/actions/public/getFeeHistory.js
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const feeHistory = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  });
  return formatFeeHistory(feeHistory);
}

// ../node_modules/viem/_esm/actions/public/getFilterLogs.js
init_abi();
async function getFilterLogs(_client, { filter }) {
  const strict = filter.strict ?? false;
  const logs = await filter.request({
    method: "eth_getFilterLogs",
    params: [filter.id]
  });
  return logs.map((log) => {
    try {
      const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
        abi: filter.abi,
        data: log.data,
        topics: log.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog(log, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter && filter.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
      }
      return formatLog(log, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}

// ../node_modules/viem/_esm/actions/public/getProof.js
init_toHex();

// ../node_modules/viem/_esm/utils/regex.js
var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

// ../node_modules/viem/_esm/utils/typedData.js
init_abi();
init_address2();
init_isAddress();
init_size();
init_toHex();

// ../node_modules/viem/_esm/utils/signature/hashTypedData.js
init_encodeAbiParameters();
init_concat();
init_toHex();
init_keccak256();
function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
  const domain = typeof domain_ === "undefined" ? {} : domain_;
  const types = {
    EIP712Domain: getTypesForEIP712Domain({ domain }),
    ...types_
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types
    }));
  if (primaryType !== "EIP712Domain") {
    parts.push(hashStruct({
      data: message,
      primaryType,
      types
    }));
  }
  return keccak2565(concat8(parts));
}
function hashDomain({ domain, types }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types
  });
}
function hashStruct({ data, primaryType, types }) {
  const encoded = encodeData({
    data,
    primaryType,
    types
  });
  return keccak2565(encoded);
}
function encodeData({ data, primaryType, types }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types })];
  for (const field of types[primaryType]) {
    const [type, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types }) {
  const encodedHashType = toHex2(encodeType({ primaryType, types }));
  return keccak2565(encodedHashType);
}
function encodeType({ primaryType, types }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match?.[0];
  if (results.has(primaryType) || types[primaryType] === void 0) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types }, results);
  }
  return results;
}
function encodeField({ types, name, type, value }) {
  if (types[type] !== void 0) {
    return [
      { type: "bytes32" },
      keccak2565(encodeData({ data: value, primaryType: type, types }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak2565(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak2565(toHex2(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak2565(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
    ];
  }
  return [{ type }, value];
}

// ../node_modules/viem/_esm/utils/typedData.js
function validateTypedData({ domain, message, primaryType, types: types_ }) {
  const types = types_;
  const validateData = (struct, value_) => {
    for (const param of struct) {
      const { name, type: type_ } = param;
      const type = type_;
      const value = value_[name];
      const integerMatch = type.match(integerRegex);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base, size_] = integerMatch;
        numberToHex(value, {
          signed: base === "int",
          size: parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value) !== parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: parseInt(size_),
            givenSize: size(value)
          });
      }
      const struct2 = types[type];
      if (struct2)
        validateData(struct2, value);
    }
  };
  if (types.EIP712Domain && domain)
    validateData(types.EIP712Domain, domain);
  if (primaryType !== "EIP712Domain") {
    const type = types[primaryType];
    validateData(type, message);
  }
}
function getTypesForEIP712Domain({ domain }) {
  return [
    typeof domain?.name === "string" && { name: "name", type: "string" },
    domain?.version && { name: "version", type: "string" },
    typeof domain?.chainId === "number" && {
      name: "chainId",
      type: "uint256"
    },
    domain?.verifyingContract && {
      name: "verifyingContract",
      type: "address"
    },
    domain?.salt && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}

// ../node_modules/viem/_esm/utils/abi/encodeDeployData.js
init_abi();
init_concat();
init_encodeAbiParameters();
var docsPath3 = "/docs/contract/encodeDeployData";
function encodeDeployData({ abi, args, bytecode }) {
  if (!args || args.length === 0)
    return bytecode;
  const description = abi.find((x) => "type" in x && x.type === "constructor");
  if (!description)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath3 });
  if (!("inputs" in description))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
  if (!description.inputs || description.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
  const data = encodeAbiParameters(description.inputs, args);
  return concatHex([bytecode, data]);
}

// ../node_modules/viem/_esm/utils/index.js
init_isHex();

// ../node_modules/viem/_esm/utils/formatters/transactionReceipt.js
init_fromHex();
var statuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  return {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber2(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
}

// ../node_modules/viem/_esm/utils/index.js
init_toHex();
init_fromHex();

// ../node_modules/viem/_esm/utils/signature/hashMessage.js
init_concat();
init_toBytes();
init_keccak256();
function hashMessage3(message, to_) {
  const messageBytes = (() => {
    if (typeof message === "string")
      return stringToBytes(message);
    if (message.raw instanceof Uint8Array)
      return message.raw;
    return toBytes2(message.raw);
  })();
  const prefixBytes = stringToBytes(`Ethereum Signed Message:
${messageBytes.length}`);
  return keccak2565(concat8([prefixBytes, messageBytes]), to_);
}

// ../node_modules/viem/_esm/utils/formatters/proof.js
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : void 0,
    nonce: proof.nonce ? hexToNumber2(proof.nonce) : void 0,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
  };
}

// ../node_modules/viem/_esm/actions/public/getProof.js
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const proof = await client.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}

// ../node_modules/viem/_esm/actions/public/getStorageAt.js
init_toHex();
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data = await client.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}

// ../node_modules/viem/_esm/actions/public/getTransaction.js
init_transaction();
init_toHex();
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash4, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction = null;
  if (hash4) {
    transaction = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash4]
    });
  } else if (blockHash) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    });
  } else if (blockNumberHex || blockTag) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash4,
      index: index2
    });
  const format = client.chain?.formatters?.transaction?.format || formatTransaction;
  return format(transaction);
}

// ../node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
async function getTransactionConfirmations(client, { hash: hash4, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getBlockNumber(client),
    hash4 ? getTransaction(client, { hash: hash4 }) : void 0
  ]);
  const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}

// ../node_modules/viem/_esm/actions/public/getTransactionReceipt.js
init_transaction();
async function getTransactionReceipt(client, { hash: hash4 }) {
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash4]
  });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash4 });
  const format = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
  return format(receipt);
}

// ../node_modules/viem/_esm/actions/public/multicall.js
init_abis();
init_abi();
init_base();
init_contract();
init_decodeFunctionResult();
init_encodeFunctionData();
init_chain2();
async function multicall(client, args) {
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts, multicallAddress: multicallAddress_ } = args;
  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0; i < contracts.length; i++) {
    const { abi, address, args: args2, functionName } = contracts[i];
    try {
      const callData = encodeFunctionData({
        abi,
        args: args2,
        functionName
      });
      currentChunkSize += (callData.length - 2) / 2;
      if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi,
        address,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => readContract(client, {
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3"
  })));
  const results = [];
  for (let i = 0; i < aggregate3Results.length; i++) {
    const result = aggregate3Results[i];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j = 0; j < chunkedCalls[i].length; j++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j = 0; j < aggregate3Result.length; j++) {
      const { returnData, success } = aggregate3Result[j];
      const { callData } = chunkedCalls[i][j];
      const { abi, address, functionName, args: args2 } = contracts[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi,
          args: args2,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err) {
        const error = getContractError(err, {
          abi,
          address,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        results.push({ error, result: void 0, status: "failure" });
      }
    }
  }
  if (results.length !== contracts.length)
    throw new BaseError("multicall results mismatch");
  return results;
}

// ../node_modules/viem/_esm/actions/public/verifyHash.js
init_abis();

// ../node_modules/viem/_esm/constants/contracts.js
var universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

// ../node_modules/viem/_esm/actions/public/verifyHash.js
init_contract();

// ../node_modules/viem/_esm/utils/data/isBytesEqual.js
init_utils7();
init_toBytes();
init_isHex();
function isBytesEqual(a_, b_) {
  const a = isHex2(a_) ? toBytes2(a_) : a_;
  const b = isHex2(b_) ? toBytes2(b_) : b_;
  return equalBytes2(a, b);
}

// ../node_modules/viem/_esm/actions/public/verifyHash.js
init_call();
async function verifyHash(client, { address, hash: hash4, signature, ...callRequest }) {
  const signatureHex = isHex2(signature) ? signature : toHex2(signature);
  try {
    const { data } = await call(client, {
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash4, signatureHex],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...callRequest
    });
    return isBytesEqual(data ?? "0x0", "0x1");
  } catch (error) {
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}

// ../node_modules/viem/_esm/actions/public/verifyMessage.js
async function verifyMessage(client, { address, message, signature, ...callRequest }) {
  const hash4 = hashMessage3(message);
  return verifyHash(client, {
    address,
    hash: hash4,
    signature,
    ...callRequest
  });
}

// ../node_modules/viem/_esm/actions/public/verifyTypedData.js
async function verifyTypedData(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
  const hash4 = hashTypedData({ message, primaryType, types, domain });
  return verifyHash(client, {
    address,
    hash: hash4,
    signature,
    ...callRequest
  });
}

// ../node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
init_transaction();
init_stringify();

// ../node_modules/viem/_esm/actions/public/watchBlockNumber.js
init_fromHex();
init_stringify();
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify2([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      try {
        const blockNumber = await getBlockNumber(client, { cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
              emit.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newHeads"],
          onData(data) {
            if (!active)
              return;
            const blockNumber = hexToBigInt(data.result?.number);
            onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

// ../node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
async function waitForTransactionReceipt(client, { confirmations = 1, hash: hash4, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
  const observerId = stringify2(["waitForTransactionReceipt", client.uid, hash4]);
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve, reject) => {
    if (timeout)
      setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash4 })), timeout);
    const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
      const _unwatch = watchBlockNumber(client, {
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          if (retrying)
            return;
          let blockNumber = blockNumber_;
          const done = (fn) => {
            _unwatch();
            fn();
            _unobserve();
          };
          try {
            if (receipt) {
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              done(() => emit.resolve(receipt));
              return;
            }
            if (!transaction) {
              retrying = true;
              await withRetry(async () => {
                transaction = await getTransaction(client, { hash: hash4 });
                if (transaction.blockNumber)
                  blockNumber = transaction.blockNumber;
              }, {
                delay: ({ count }) => ~~(1 << count) * 200,
                retryCount: 6
              });
              retrying = false;
            }
            receipt = await getTransactionReceipt(client, { hash: hash4 });
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done(() => emit.resolve(receipt));
          } catch (err) {
            if (transaction && (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError)) {
              try {
                replacedTransaction = transaction;
                const block = await getBlock(client, {
                  blockNumber,
                  includeTransactions: true
                });
                const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getTransactionReceipt(client, {
                  hash: replacementTransaction.hash
                });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit.resolve(receipt);
                });
              } catch (err_) {
                done(() => emit.reject(err_));
              }
            } else {
              done(() => emit.reject(err));
            }
          }
        }
      });
    });
  });
}

// ../node_modules/viem/_esm/actions/public/watchBlocks.js
init_stringify();
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify2([
      "watchBlocks",
      client.uid,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
      try {
        const block = await getBlock(client, {
          blockTag,
          includeTransactions
        });
        if (block.number && prevBlock?.number) {
          if (block.number === prevBlock.number)
            return;
          if (block.number - prevBlock.number > 1 && emitMissed) {
            for (let i = prevBlock?.number + 1n; i < block.number; i++) {
              const block2 = await getBlock(client, {
                blockNumber: i,
                includeTransactions
              });
              emit.onBlock(block2, prevBlock);
              prevBlock = block2;
            }
          }
        }
        if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
          emit.onBlock(block, prevBlock);
          prevBlock = block;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newHeads"],
          onData(data) {
            if (!active)
              return;
            const format = client.chain?.formatters?.block?.format || formatBlock2;
            const block = format(data.result);
            onBlock(block, prevBlock);
            prevBlock = block;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}

// ../node_modules/viem/_esm/actions/public/watchEvent.js
init_stringify();
init_abi();
init_rpc();
function watchEvent(client, { address, args, batch = true, event, events, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify2([
      "watchEvent",
      address,
      args,
      batch,
      client.uid,
      event,
      pollingInterval
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await createEventFilter(client, {
              address,
              args,
              event,
              events,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getFilterChanges(client, { filter });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getLogs2(client, {
                address,
                args,
                event,
                events,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await uninstallFilter(client, { filter });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const events_ = events ?? (event ? [event] : void 0);
        let topics = [];
        if (events_) {
          topics = [
            events_.flatMap((event2) => encodeEventTopics({
              abi: [event2],
              eventName: event2.name,
              args
            }))
          ];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_,
                data: log.data,
                topics: log.topics,
                strict
              });
              const formatted = formatLog(log, {
                args: args2,
                eventName
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}

// ../node_modules/viem/_esm/actions/public/watchPendingTransactions.js
init_stringify();
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify2([
      "watchPendingTransactions",
      client.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit) => {
      let filter;
      const unwatch = poll(async () => {
        try {
          if (!filter) {
            try {
              filter = await createPendingTransactionFilter(client);
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getFilterChanges(client, { filter });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            hashes.forEach((hash4) => emit.onTransactions([hash4]));
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await uninstallFilter(client, { filter });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active)
              return;
            const transaction = data.result;
            onTransactions([transaction]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

// ../node_modules/viem/_esm/clients/decorators/public.js
function publicActions(client) {
  return {
    call: (args) => call(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) => createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args),
    estimateGas: (args) => estimateGas(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getBytecode(client, args),
    getChainId: () => getChainId(client),
    getContractEvents: (args) => getContractEvents(client, args),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs2(client, args),
    getProof: (args) => getProof(client, args),
    estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),
    readContract: (args) => readContract(client, args),
    sendRawTransaction: (args) => sendRawTransaction(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage(client, args),
    verifyTypedData: (args) => verifyTypedData(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args)
  };
}

// ../node_modules/viem/_esm/clients/createPublicClient.js
function createPublicClient(parameters) {
  const { key = "public", name = "Public Client" } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    type: "publicClient"
  });
  return client.extend(publicActions);
}

// ../node_modules/viem/_esm/constants/address.js
var zeroAddress = "0x0000000000000000000000000000000000000000";

// ../node_modules/viem/_esm/index.js
init_encodeFunctionData();
init_formatUnits();
init_fromHex();

// src/pure/constants.ts
var WAD = BigInt(1e18);
var E8 = BigInt(1e8);
var MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MAX_INT256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// src/pure/helpers.ts
var absolute = (value) => value > 0 ? value : value * -1n;
var mulDiv = (a, b, unit) => {
  const numerator = a * b;
  return numerator && unit && numerator / unit;
};
var min = (a, b) => a < b ? a : b;
var max = (a, b) => a > b ? a : b;
var calculateLeverage = ({ collateral, debt, unit }) => mulDiv(collateral, unit, collateral - debt) * E8 / unit;
var calculateMarginLeverage = (normalisedBalances2, liquidationLtv, isShort) => {
  const { collateral, debt, unit } = normalisedBalances2;
  return {
    margin: mulDiv(collateral - debt, unit, collateral) * E8 / unit,
    minMargin: isShort ? mulDiv(WAD, E8, liquidationLtv) - E8 : mulDiv(WAD - liquidationLtv, E8, WAD),
    leverage: calculateLeverage(normalisedBalances2) - (isShort ? E8 : 0n)
  };
};
var defaultLeverage = (ltv) => {
  const a = 1 / (1 - Number(ltv) / 1e18);
  const b = (a + 1) / 2;
  const c = Math.floor(b * 20) / 20;
  return BigInt(c * 1e8);
};
var calculateMarkPrice = ({ prices, instrument }, short) => {
  if (short)
    return mulDiv(prices.debt, instrument.base.unit, prices.collateral);
  return mulDiv(prices.collateral, instrument.quote.unit, prices.debt);
};
var applySlippage = (price, slippageTolerance, slippageDirection) => {
  return mulDiv(price, WAD + slippageTolerance * slippageDirection, WAD);
};
var calculateLiquidationPrice = (collateral, debt, { prices, instrument, ltv: { liquidationThreshold } }, short) => {
  if (collateral === 0n)
    return 0n;
  const quantity = mulDiv(collateral, prices.unit, prices.collateral);
  const debtTimesRatio = mulDiv(debt, WAD, liquidationThreshold);
  const price = mulDiv(debtTimesRatio, prices.unit, prices.debt);
  return short ? mulDiv(quantity, instrument.base.unit, price) : mulDiv(price, instrument.quote.unit, quantity);
};
var calculateAPR = (collateral, debt, rates) => {
  return collateral && rates.lendingRate - mulDiv(rates.borrowingRate, debt, collateral);
};
var calculateFee = (quantity, fee) => {
  return absolute(mulDiv(quantity, fee, WAD));
};
var calculateEquity = (collateral, debt, prices, instrument, short) => {
  if (short)
    return mulDiv(collateral - debt, instrument.base.unit, prices.collateral);
  return mulDiv(collateral - debt, instrument.quote.unit, prices.debt);
};
var calculateMinEquity = (collateral, minMarginRatio, { prices, instrument }, short) => {
  const minCollateral = mulDiv(collateral, minMarginRatio, E8);
  if (short)
    return mulDiv(minCollateral, instrument.base.unit, prices.collateral);
  return mulDiv(minCollateral, instrument.quote.unit, prices.debt);
};
var calculateClosingFee = (collateral, fee, prices, instrument, short) => {
  const normalisedFee = mulDiv(collateral, fee, WAD);
  return short ? mulDiv(normalisedFee, instrument.base.unit, prices.collateral) : mulDiv(normalisedFee, instrument.quote.unit, prices.debt);
};
var calculateValue = (collateral, { prices, normalisedBalances: normalisedBalances2, instrument }, short) => {
  const [a, b] = short ? [prices.collateral, instrument.base.unit] : [prices.debt, instrument.quote.unit];
  const temp = mulDiv(collateral, prices.unit, a);
  return mulDiv(temp, b, normalisedBalances2.unit);
};
var asHex = (str) => {
  if (str.startsWith("0x"))
    return str;
  return `0x${str}`;
};
var positionIdMapper = (positionId) => {
  const symbolHex = asHex(positionId.substring(0, 34));
  const symbol = fromHex2(symbolHex, { size: 32, to: "string" });
  const mm = Number(`0x${positionId.substring(34, 36)}`);
  const maturity = Number(`0x${positionId.substring(36, 44)}`);
  const number3 = Number(`0x${positionId.substring(54)}`);
  return {
    symbol,
    mm,
    number: number3,
    positionId: asHex(positionId),
    maturity,
    isPerp: isPerp(maturity),
    symbolHex
  };
};
var isPerp = (timestamp) => timestamp === 4294967295;
var mapArgs = (args, meta) => {
  const argsCopy = { ...args, params: { ...args.params } };
  const {
    normalisedBalances: normalisedBalances2,
    prices,
    instrument: { base, quote }
  } = meta;
  if (argsCopy.type === "1") {
    if (argsCopy.params.side === Side.Short) {
      const { quantity } = argsCopy.params;
      const { debt, collateral } = normalisedBalances2;
      argsCopy.params.leverage += E8;
      let normalisedQty = mulDiv(quantity, prices.debt, quote.unit);
      normalisedQty = mulDiv(normalisedQty, argsCopy.params.leverage, argsCopy.params.leverage - E8);
      const collateralDeltaForExistingDebt = mulDiv(debt, argsCopy.params.leverage, argsCopy.params.leverage - E8) - collateral;
      normalisedQty += collateralDeltaForExistingDebt;
      const quantityInBase = mulDiv(normalisedQty, meta.prices.unit, meta.prices.collateral);
      argsCopy.params.quantity = mulDiv(quantityInBase, base.unit, prices.unit);
      const cccy = argsCopy.params.cashflowCcy;
      if (cccy === 1 /* Base */) {
        argsCopy.params.cashflowCcy = 2 /* Quote */;
      }
      if (cccy === 2 /* Quote */) {
        argsCopy.params.cashflowCcy = 1 /* Base */;
      }
    }
  }
  return argsCopy;
};
var chainToWrappedNativeToken = {
  31337: "WETH",
  31338: "WETH",
  31339: "WETH",
  42161: "WETH",
  8453: "WETH",
  137: "WMATIC",
  100: "WXDAI",
  10: "WETH",
  1: "WETH"
};
var isWrappedNative = (symbol, chainId) => chainToWrappedNativeToken[chainId] === symbol;

// src/pure/positionStatus.ts
var positionStatusPure = (args, side) => {
  const isShort = side === Side.Short;
  const { normalisedBalances: normalisedBalances2, ltv, prices, instrument, fee, balances, rates, rewards } = args;
  const { collateral, debt } = normalisedBalances2;
  const marginLeverageValues = calculateMarginLeverage(normalisedBalances2, ltv.liquidationThreshold, isShort);
  const { minMargin } = marginLeverageValues;
  return {
    ...marginLeverageValues,
    markPrice: calculateMarkPrice(args, isShort),
    liquidationPrice: calculateLiquidationPrice(collateral, debt, args, isShort),
    equity: calculateEquity(collateral, debt, prices, instrument, isShort),
    minEquity: calculateMinEquity(collateral, minMargin, args, isShort),
    closingFee: calculateClosingFee(collateral, fee, prices, instrument, isShort),
    value: calculateValue(collateral, { prices, normalisedBalances: normalisedBalances2, instrument }, isShort),
    apr: calculateAPR(collateral, debt, rates),
    positionSize: balances.collateral,
    balances,
    normalisedBalances: normalisedBalances2,
    rates,
    rewards
  };
};

// src/pure/deriveQuoteValues.ts
function createLiquidityBuffer(lending = BigInt(5e14), borrowing = BigInt(5e14)) {
  return { lending, borrowing };
}
var isBase = (ccy) => ccy === 1 /* Base */;
var qtyCappedToLendingLiquidity = (quantity, lendingLiquidity, currentPositionSize, buffer2) => max(min(quantity, mulDiv(lendingLiquidity, WAD - buffer2, WAD)), -currentPositionSize);
var calculateMaxDebt = (newCollateral, ltv, nBorrowingLiquidity, nCurrentDebt, buffer2) => {
  const theoretical = mulDiv(mulDiv(newCollateral, ltv, WAD), WAD - buffer2, WAD);
  const currentPlusLiquidity = nCurrentDebt + nBorrowingLiquidity;
  return min(theoretical, currentPlusLiquidity);
};
var calculateDebtDeltaByLeverage = (newCollateral, maxDebt, desiredLeverage, meta) => {
  const { normalisedBalances: normalisedBalances2 } = meta;
  let targetDebt = newCollateral - mulDiv(newCollateral, E8, max(desiredLeverage, E8));
  targetDebt = min(targetDebt, maxDebt);
  return targetDebt - normalisedBalances2.debt;
};
var capDebtDelta = (targetDebtDelta, maxDebt, meta) => {
  const { normalisedBalances: normalisedBalances2 } = meta;
  const maxDebtDelta = maxDebt - normalisedBalances2.debt;
  let debtDelta = targetDebtDelta;
  debtDelta = min(debtDelta, maxDebtDelta);
  debtDelta = max(debtDelta, -normalisedBalances2.debt);
  return debtDelta;
};
var deriveNewCollateral = (quantity, { normalisedBalances: normalisedBalances2, prices, instrument }) => {
  return normalisedBalances2.collateral + mulDiv(quantity, prices.collateral, instrument.base.unit);
};
var calculateTradingFee = (tradeQuantity, _fee) => {
  if (_fee === 0n)
    return 0n;
  const fee = _fee + BigInt(1e13);
  if (tradeQuantity > 0n) {
    return calculateFee(tradeQuantity, mulDiv(WAD, WAD, WAD - fee) - WAD);
  } else
    return calculateFee(tradeQuantity, fee);
};
var calculateCollateralValues = (quantity, meta, liquidityBuffer) => {
  const {
    normalisedBalances: normalisedBalances2,
    fee: tradingFee,
    liquidity: { lendingLiquidity, borrowingLiquidity },
    ltv: { ltv },
    balances,
    prices,
    instrument
  } = meta;
  const tradeQuantity = qtyCappedToLendingLiquidity(quantity, lendingLiquidity, balances.collateral, liquidityBuffer.lending);
  const fullyClosing = tradeQuantity === -balances.collateral;
  const fee = calculateTradingFee(tradeQuantity, tradingFee);
  const newCollateral = deriveNewCollateral(tradeQuantity, meta);
  const collateralDelta = newCollateral - normalisedBalances2.collateral;
  const normalisedFee = calculateTradingFee(collateralDelta, tradingFee);
  const normalisedBorrowingLiquidity = mulDiv(borrowingLiquidity, prices.debt, instrument.quote.unit);
  const maxDebt = calculateMaxDebt(newCollateral, ltv, normalisedBorrowingLiquidity, normalisedBalances2.debt, liquidityBuffer.borrowing);
  return { tradeQuantity, fullyClosing, fee, newCollateral, collateralDelta, normalisedFee, maxDebt };
};
var calculateCollateralAndDebtValuesByLeverage = (quantity, leverage, meta, liquidityBuffer = createLiquidityBuffer()) => {
  const collateralValues = calculateCollateralValues(quantity, meta, liquidityBuffer);
  const { newCollateral, maxDebt } = collateralValues;
  const debtDelta = calculateDebtDeltaByLeverage(newCollateral, maxDebt, leverage, meta);
  const newDebt = meta.normalisedBalances.debt + debtDelta;
  return { ...collateralValues, debtDelta, newDebt };
};
var calculateCollateralAndDebtValuesByCashflow = (quantity, cashflow, cashflowCcy, meta, liquidityBuffer = createLiquidityBuffer()) => {
  const collateralValues = calculateCollateralValues(quantity, meta, liquidityBuffer);
  const { maxDebt, collateralDelta, normalisedFee } = collateralValues;
  const [price, unit] = cashflowCcy === 1 /* Base */ ? [meta.prices.collateral, meta.instrument.base.unit] : [meta.prices.debt, meta.instrument.quote.unit];
  const normalisedCashflow = mulDiv(cashflow, price, unit);
  const debtDelta = capDebtDelta(collateralDelta + normalisedFee - normalisedCashflow, maxDebt, meta);
  const newDebt = meta.normalisedBalances.debt + debtDelta;
  return { ...collateralValues, debtDelta, newDebt };
};
var calculateCollateralAndDebtValuesByDebtDelta = (quantity, desiredDebtDelta, meta, liquidityBuffer = createLiquidityBuffer()) => {
  const collateralValues = calculateCollateralValues(quantity, meta, liquidityBuffer);
  const normalisedDDD = mulDiv(desiredDebtDelta, meta.prices.debt, meta.instrument.quote.unit);
  const debtDelta = capDebtDelta(normalisedDDD, collateralValues.maxDebt, meta);
  const newDebt = meta.normalisedBalances.debt + debtDelta;
  return { ...collateralValues, debtDelta, newDebt };
};
var convertToQuote = (num, { instrument, prices }) => mulDiv(num, instrument.quote.unit, prices.debt);
var convertToBase = (num, { instrument, prices }) => mulDiv(num, instrument.base.unit, prices.collateral);
var toBaseOrQuote = (num, meta, ccy) => ccy === 1 /* Base */ ? convertToBase(num, meta) : convertToQuote(num, meta);
var deriveSwap = (cashflowCcy, debtDelta, collateralDelta, normalisedFee) => {
  let swapCcy = 0 /* None */;
  let nFlashloanAmount = collateralDelta > 0n ? max(debtDelta, 0n) : 0n;
  let nSwapAmount = 0n;
  let slippageDirection = 1n;
  if (cashflowCcy === 2 /* Quote */) {
    if (collateralDelta > 0n) {
      swapCcy = 2 /* Quote */;
      nSwapAmount = collateralDelta + normalisedFee;
    } else if (collateralDelta < 0n) {
      swapCcy = 1 /* Base */;
      nFlashloanAmount = nSwapAmount = absolute(collateralDelta + normalisedFee);
      slippageDirection = -1n;
    }
  } else {
    if (debtDelta > 0n) {
      swapCcy = 2 /* Quote */;
      nSwapAmount = debtDelta;
      if (collateralDelta < 0n) {
        slippageDirection = -1n;
      }
    } else if (debtDelta < 0n) {
      swapCcy = 1 /* Base */;
      nSwapAmount = absolute(debtDelta);
      if (collateralDelta <= 0n) {
        slippageDirection = -1n;
        if (collateralDelta < 0n) {
          nFlashloanAmount = nSwapAmount;
        }
      }
    }
  }
  return { swapCcy, nFlashloanAmount, nSwapAmount, slippageDirection };
};
var calculateSwapAmount = ({
  swapCcy,
  nFlashloanAmount,
  flashFee,
  nSwapAmount,
  slippageTolerance,
  fullyClosing,
  cashflowCcy,
  meta,
  quantity,
  normalisedFee
}) => {
  let nFlashloanFee;
  if (fullyClosing) {
    nSwapAmount = isBase(cashflowCcy) ? mulDiv(nSwapAmount, WAD + slippageTolerance * 2n, WAD) : mulDiv(nSwapAmount, WAD, WAD + flashFee) - 1n;
    nFlashloanFee = nSwapAmount && flashFee && calculateFee(nSwapAmount, flashFee);
    if (isBase(cashflowCcy)) {
      nSwapAmount = min(nSwapAmount, meta.normalisedBalances.collateral - nFlashloanFee - normalisedFee);
    }
  } else {
    nFlashloanFee = nFlashloanAmount && flashFee && calculateFee(nFlashloanAmount, flashFee);
    if (quantity < 0n)
      nFlashloanFee -= calculateFee(nFlashloanFee, WAD - BigInt(1e36) / (WAD + flashFee));
    nSwapAmount -= isBase(swapCcy) ? nFlashloanFee : 0n;
  }
  return {
    swapAmount: toBaseOrQuote(nSwapAmount, meta, swapCcy),
    flashloanFee: toBaseOrQuote(nFlashloanFee, meta, swapCcy),
    nFlashloanFee
  };
};
var deriveQuoteValuesQtyCashflowPure = ({
  quantity,
  cashflow,
  cashflowCcy,
  slippageTolerance,
  meta,
  flashFee = 0n,
  liquidityBuffer
}) => {
  const debtAndCollateralData = calculateCollateralAndDebtValuesByCashflow(quantity, cashflow, cashflowCcy, meta, liquidityBuffer);
  const { collateralDelta, newCollateral, newDebt, debtDelta, normalisedFee, fee, tradeQuantity, fullyClosing } = debtAndCollateralData;
  const swapData = deriveSwap(cashflowCcy, debtDelta, collateralDelta, normalisedFee);
  const { swapCcy, slippageDirection } = swapData;
  const {
    swapAmount,
    nFlashloanFee,
    flashloanFee: transactionFees
  } = calculateSwapAmount({
    ...swapData,
    ...debtAndCollateralData,
    meta,
    slippageTolerance,
    cashflowCcy,
    flashFee,
    quantity
  });
  const cashflowUsed = toBaseOrQuote(collateralDelta - debtDelta + normalisedFee, meta, cashflowCcy);
  const markPrice = mulDiv(meta.prices.collateral, meta.instrument.quote.unit, meta.prices.debt);
  const price = applySlippage(markPrice, slippageTolerance, slippageDirection);
  return {
    cashflowUsed,
    fee,
    transactionFees,
    collateral: newCollateral,
    debt: newDebt + nFlashloanFee,
    fullyClosing,
    swapAmount,
    price,
    swapCcy,
    quantity: fullyClosing ? -MAX_INT256 : tradeQuantity
  };
};
var deriveQuoteValuesQtyLeveragePure = ({
  quantity,
  leverage,
  cashflowCcy,
  slippageTolerance,
  meta,
  flashFee = 0n,
  liquidityBuffer
}) => {
  const debtAndCollateralData = calculateCollateralAndDebtValuesByLeverage(quantity, leverage, meta, liquidityBuffer);
  const { collateralDelta, fee, newCollateral, newDebt, debtDelta, normalisedFee, fullyClosing, tradeQuantity } = debtAndCollateralData;
  const swapData = deriveSwap(cashflowCcy, debtDelta, collateralDelta, normalisedFee);
  const { swapCcy, slippageDirection } = swapData;
  const {
    swapAmount,
    nFlashloanFee,
    flashloanFee: transactionFees
  } = calculateSwapAmount({
    ...swapData,
    ...debtAndCollateralData,
    meta,
    slippageTolerance,
    cashflowCcy,
    flashFee,
    quantity
  });
  let cashflowUsed = toBaseOrQuote(collateralDelta - debtDelta + normalisedFee + nFlashloanFee, meta, cashflowCcy);
  if (tradeQuantity > 0n) {
    if (cashflowCcy === 1 /* Base */ && debtDelta > 0n) {
      if (cashflowUsed > tradeQuantity) {
        cashflowUsed = tradeQuantity - convertToBase(debtDelta, meta);
      }
      if (swapAmount === 0n && convertToQuote(debtDelta, meta) === 0n) {
        cashflowUsed = tradeQuantity;
      }
    }
  } else if (tradeQuantity < 0n) {
    if (cashflowCcy === 2 /* Quote */ && cashflowUsed < 0n && debtAndCollateralData.newDebt == debtAndCollateralData.maxDebt) {
      cashflowUsed = mulDiv(cashflowUsed, WAD - slippageTolerance, WAD);
    }
    if (cashflowCcy == 1 /* Base */ && cashflowUsed < 0n && debtDelta > 0n) {
      cashflowUsed -= convertToBase(normalisedFee + nFlashloanFee, meta);
    }
  }
  const markPrice = mulDiv(meta.prices.collateral, meta.instrument.quote.unit, meta.prices.debt);
  const price = applySlippage(markPrice, slippageTolerance, slippageDirection);
  return {
    cashflowUsed,
    fee,
    transactionFees,
    collateral: newCollateral,
    debt: newDebt,
    fullyClosing,
    swapAmount,
    price,
    swapCcy,
    quantity: fullyClosing ? -MAX_INT256 : tradeQuantity
  };
};

// src/api/exactly/queryRates.ts
var WAD2 = 1000000000000000000n;
var FIXED_INTERVAL = 86400 * 7 * 4;
var floatingRate = (interestRateModel, utilization) => {
  const curveA = BigInt(interestRateModel.floatingCurveA);
  const curveB = BigInt(interestRateModel.floatingCurveB);
  const maxUtilization = BigInt(interestRateModel.floatingMaxUtilization);
  return curveA * WAD2 / (maxUtilization - utilization) + curveB;
};
var totalFloatingBorrowAssets = (timestamp, { floatingAssets, floatingDebt }, { timestamp: debtUpdate } = { timestamp: 0 }, interestRateModel) => {
  const utilization = BigInt(floatingAssets) > 0n ? BigInt(floatingDebt) * WAD2 / BigInt(floatingAssets) : 0n;
  const borrowRate = floatingRate(interestRateModel, utilization);
  return BigInt(floatingDebt) + BigInt(floatingDebt) * (borrowRate * BigInt(timestamp - debtUpdate) / 31536000n) / WAD2;
};
var totalAssets = (timestamp, marketState, floatingDebtState, interestRateModel, accumulatorAccrual, smoothFactor, treasuryFeeRate, fixedPools) => {
  const { floatingAssets, floatingDebt, earningsAccumulator } = marketState;
  const maxFuturePools = fixedPools.length - 1;
  const elapsed = BigInt(timestamp - accumulatorAccrual);
  return BigInt(floatingAssets) + fixedPools.filter(Boolean).reduce(
    (smartPoolEarnings, { timestamp: lastAccrual, maturity, unassignedEarnings }) => smartPoolEarnings + (maturity > lastAccrual ? timestamp < maturity ? BigInt(unassignedEarnings) * BigInt(timestamp - lastAccrual) / BigInt(maturity - lastAccrual) : BigInt(unassignedEarnings) : 0n),
    0n
  ) + (elapsed && BigInt(earningsAccumulator) * elapsed / (elapsed + BigInt(smoothFactor) * BigInt(maxFuturePools * FIXED_INTERVAL) / WAD2)) + (totalFloatingBorrowAssets(timestamp, marketState, floatingDebtState, interestRateModel) - BigInt(floatingDebt)) * (WAD2 - BigInt(treasuryFeeRate)) / WAD2;
};
var queryRates = async (subgraph, market, type, {
  maxFuturePools,
  roundTicks = false,
  interval = 900,
  offset = 0,
  count = 1
}) => {
  const request = async (subgraph2, query) => await fetch(subgraph2, {
    headers: {
      accept: "application/json",
      "content-type": "application/json"
    },
    body: JSON.stringify({ query }),
    method: "POST"
  }).then((res) => res.json()).then((res) => res.data);
  const now = Math.floor(Date.now() / 1e3) - offset * interval;
  const lastTimestamp = roundTicks ? now - now % interval : now;
  const response = await request(
    subgraph,
    `{${[...Array(count + 1)].map((_, i) => {
      const timestamp = lastTimestamp - interval * i;
      const key = `k_${market}_${timestamp}`;
      return `
      ${key}_marketState: marketUpdates(
        first: 1
        orderBy: timestamp
        orderDirection: desc
        where: { market: "${market}", timestamp_lte: ${timestamp} }
      ) {
        timestamp
        floatingDepositShares
        floatingAssets
        floatingBorrowShares
        floatingDebt
        earningsAccumulator
      }
      ${key}_floatingDebtState: floatingDebtUpdates(
        first: 1
        orderBy: timestamp
        orderDirection: desc
        where: { market: "${market}", timestamp_lte: ${timestamp} }
      ) {
        timestamp
      }
      ${key}_interestRateModel: interestRateModelSets(
        first: 1
        orderBy: timestamp
        orderDirection: desc
        where: { market: "${market}", timestamp_lte: ${timestamp} }
      ) {
        floatingCurveA
        floatingCurveB
        floatingMaxUtilization
      }
      ${type === "deposit" ? `
        ${key}_accumulatorAccrual: accumulatorAccruals(
          first: 1
          orderBy: timestamp
          orderDirection: desc
          where: { market: "${market}", timestamp_lte: ${timestamp} }
        ) {
          accumulatorAccrual: timestamp
        }
        ${key}_smoothFactor: earningsAccumulatorSmoothFactorSets(
          first: 1
          orderBy: timestamp
          orderDirection: desc
          where: { market: "${market}", timestamp_lte: ${timestamp} }
        ) {
          smoothFactor: earningsAccumulatorSmoothFactor
        }
        ${key}_treasuryFeeRate: treasurySets(
          first: 1
          orderBy: timestamp
          orderDirection: desc
          where: { market: "${market}", timestamp_lte: ${timestamp} }
        ) {
          treasuryFeeRate
        }
        ${[...new Array(maxFuturePools + 1)].map((__, j) => timestamp - timestamp % FIXED_INTERVAL + j * FIXED_INTERVAL).map(
        (maturity) => `
          ${key}_pool_${maturity}: fixedEarningsUpdates(
            first: 1
            orderBy: timestamp
            orderDirection: desc
            where: { market: "${market}", timestamp_lte: ${timestamp}, maturity: ${maturity} }
          ) {
            timestamp
            maturity
            unassignedEarnings
          }
        `
      ).join("")}
      ` : ""}
    `;
    }).join("")}}`.replace(/\s+/g, " ")
  );
  const states = [...Array(count + 1)].map((_, i) => {
    const timestamp = lastTimestamp - (count - i) * interval;
    const key = `k_${market}_${timestamp}`;
    const marketState = response[`${key}_marketState`][0];
    const floatingDebtState = response[`${key}_floatingDebtState`][0];
    const interestRateModel = response[`${key}_interestRateModel`][0];
    const accumulatorAccrual = response[`${key}_accumulatorAccrual`]?.[0]?.accumulatorAccrual;
    const smoothFactor = response[`${key}_smoothFactor`]?.[0]?.smoothFactor;
    const treasuryFeeRate = response[`${key}_treasuryFeeRate`]?.[0]?.treasuryFeeRate ?? "0";
    const fixedPools = [...new Array(type === "deposit" ? maxFuturePools + 1 : 0)].map((__, j) => timestamp - timestamp % FIXED_INTERVAL + j * FIXED_INTERVAL).map((maturity) => response[`${key}_pool_${maturity}`]?.[0]);
    return {
      timestamp,
      ...marketState ? {
        utilization: BigInt(marketState.floatingAssets) && BigInt(marketState.floatingDebt) * WAD2 / BigInt(marketState.floatingAssets),
        shares: BigInt(
          {
            deposit: marketState.floatingDepositShares,
            borrow: marketState.floatingBorrowShares
          }[type]
        ),
        assets: {
          deposit: totalAssets,
          borrow: totalFloatingBorrowAssets
        }[type](
          timestamp,
          marketState,
          floatingDebtState,
          interestRateModel,
          accumulatorAccrual,
          smoothFactor,
          treasuryFeeRate,
          fixedPools
        )
      } : { utilization: 0n, shares: 0n, assets: 0n }
    };
  });
  return states.slice(1).map(({ timestamp, utilization, shares, assets }, i) => {
    const prevShareValue = states[i].shares ? states[i].assets * WAD2 / states[i].shares : WAD2;
    const shareValue = shares ? assets * WAD2 / shares : WAD2;
    const proportion = shareValue * WAD2 / prevShareValue;
    return {
      date: new Date(timestamp * 1e3),
      apr: (Number(formatUnits2(proportion, 18)) - 1) * (31536e3 / interval),
      apy: Number(formatUnits2(proportion, 18)) ** (31536e3 / interval) - 1,
      utilization: Number(formatUnits2(utilization, 18))
    };
  });
};

// src/api/exactly/exactlyRewards.ts
var subgraphUrl = "https://api.thegraph.com/subgraphs/name/exactly/optimism";
var exactlyLendingAPR = async (asset, chainId, publicClient) => {
  const market = await getContract({
    address: loadAddress(chainId, "ExactlyReverseLookup"),
    abi: exactlyReverseLookupABI,
    publicClient
  }).read.market([asset]);
  const maxFuturePools = await getContract({ address: market, abi: iExactlyMarketABI, publicClient }).read.maxFuturePools();
  const [{ apr }] = await queryRates(subgraphUrl, market, "deposit", { maxFuturePools });
  return BigInt(Math.trunc(apr) * 1e18);
};

// src/api/chain.ts
var normalisedBalances = ({ collateral: collateralPrice, debt: debtPrice, unit }, { collateral: collateralBalance, debt: debtBalance }, collateralUnit, debtUnit) => ({
  collateral: mulDiv(collateralBalance, collateralPrice, collateralUnit),
  debt: mulDiv(debtBalance, debtPrice, debtUnit),
  unit
});
var token = async (token2, publicClient) => {
  if (publicClient.chain?.id === 1 && token2.toLowerCase() === "0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2")
    return Promise.resolve({
      address: token2,
      name: "Maker",
      symbol: "MKR",
      decimals: 18,
      unit: BigInt(1e18)
    });
  const erc20 = getContract({
    abi: ierc20MetadataABI,
    address: token2,
    publicClient
  }).read;
  const [name, symbol, decimals] = await Promise.all([erc20.name(), erc20.symbol(), erc20.decimals()]);
  return {
    address: token2,
    name,
    symbol,
    decimals,
    unit: BigInt(10) ** BigInt(decimals)
  };
};
var getMetaData = async (positionId, publicClient) => {
  const { symbol, symbolHex, mm } = positionIdMapper(positionId);
  const chainId = publicClient.chain?.id;
  const addresses = chainAndHardcodedAddressMapper(chainId, mm);
  const { moneyMarketView, contangoProxy } = addresses;
  const contango = getContract({ address: contangoProxy, abi: contangoABI, publicClient });
  const instrument = await contango.read.instrument([symbolHex]);
  const { base, quote } = instrument;
  const mMarket = getContract({ abi: iMoneyMarketViewABI, address: moneyMarketView, publicClient });
  try {
    const [prices, { result: balances }, [borrowingLiquidity, lendingLiquidity], [borrowingRate, lendingRate]] = await Promise.all([
      mMarket.read.prices([positionId, base, quote]),
      mMarket.simulate.balances([positionId, base, quote]),
      mMarket.read.liquidity([positionId, base, quote]),
      mMarket.read.rates([positionId, base, quote]).then(([borrowingRate2, lendingRate2]) => {
        if (mm === 4 /* Exactly */) {
          return exactlyLendingAPR(base, chainId, publicClient).then((lendingRate3) => [borrowingRate2, lendingRate3]);
        }
        return [borrowingRate2, lendingRate2];
      })
    ]);
    const [ltv, fee, baseToken, quoteToken, rewards] = await Promise.all([
      mMarket.read.thresholds([positionId, base, quote]).then(([ltv2, liquidationThreshold]) => ({
        ltv: ltv2,
        liquidationThreshold
      })),
      0n,
      token(instrument.base, publicClient),
      token(instrument.quote, publicClient),
      mMarket.read.rewards([positionId, base, quote]).catch(() => Promise.resolve([[], []])).then(([baseRewards, quoteRewards]) => ({ baseRewards, quoteRewards }))
    ]);
    return {
      symbol,
      instrument: { base: baseToken, quote: quoteToken, closingOnly: instrument.closingOnly },
      prices,
      balances,
      normalisedBalances: normalisedBalances(prices, balances, baseToken.unit, quoteToken.unit),
      liquidity: {
        borrowingLiquidity,
        lendingLiquidity
      },
      rates: {
        borrowingRate,
        lendingRate
      },
      ltv,
      fee,
      addresses,
      positionId,
      chainId,
      moneyMarketId: mm,
      rewards
    };
  } catch (e) {
    console.error("Error fetching metadata", { instrument, chainId });
    throw e;
  }
};
var getRewardsData = async (positionId, publicClient) => {
  const { symbolHex, mm } = positionIdMapper(positionId);
  const chainId = publicClient.chain?.id;
  const addresses = chainAndHardcodedAddressMapper(chainId, mm);
  const { moneyMarketView, contangoProxy } = addresses;
  const contango = getContract({ address: contangoProxy, abi: contangoABI, publicClient });
  const instrument = await contango.read.instrument([symbolHex]);
  const { base, quote } = instrument;
  const mMarket = getContract({ abi: iMoneyMarketViewABI, address: moneyMarketView, publicClient });
  return await mMarket.read.rewards([positionId, base, quote]).catch(() => Promise.resolve([[], []])).then(([baseRewards, quoteRewards]) => ({ baseRewards, quoteRewards }));
};
var getFlashloanFee = async (flashloanProviders, cashflowCcy, { debtDelta, collateralDelta, normalisedFee }, meta, publicClient) => {
  const swapData = deriveSwap(cashflowCcy, debtDelta, collateralDelta, normalisedFee);
  const { swapCcy, nFlashloanAmount } = swapData;
  const flashloanAmount = toBaseOrQuote(nFlashloanAmount, meta, swapCcy);
  const flashloanToken = swapCcy === 1 /* Base */ ? meta.instrument.base.address : meta.instrument.quote.address;
  let flashFee = 0n;
  let flProvidersUsed = [zeroAddress];
  if (flashloanAmount > 0n && flashloanProviders.length > 0) {
    const flashloanOptions = (await Promise.allSettled(
      flashloanProviders.map(async (address) => {
        const fee = await getContract({ abi: ierc7399ABI, address, publicClient }).read.flashFee([flashloanToken, flashloanAmount]);
        return [fee, address];
      })
    )).filter((x) => x.status === "fulfilled").map((x) => x.value).sort(([a], [b]) => Number(a) - Number(b));
    flashFee = flashloanOptions[0][0];
    flProvidersUsed = flashloanOptions.filter(([fee]) => fee === flashFee).map(([, provider]) => provider);
  }
  const unit = isBase(swapCcy) ? meta.instrument.base.unit : meta.instrument.quote.unit;
  flashFee = mulDiv(flashFee, unit, flashloanAmount);
  return { flashFee, flProvidersUsed, ...swapData };
};
var getDebtAndCollateralData = ({ type, params }, meta) => {
  switch (type) {
    case "1":
      return calculateCollateralAndDebtValuesByLeverage(params.quantity, params.leverage, meta);
    case "2":
      return calculateCollateralAndDebtValuesByCashflow(params.quantity, params.cashflow, params.cashflowCcy, meta);
    case "3":
      throw new Error("quote params type 3 is not supported yet :)");
    case "4":
      return calculateCollateralAndDebtValuesByLeverage(0n, params.leverage, meta);
    case "5":
      return calculateCollateralAndDebtValuesByCashflow(0n, params.cashflow, params.cashflowCcy, meta);
    case "6":
      return calculateCollateralAndDebtValuesByCashflow(params.quantity, 0n, params.cashflowCcy, meta);
    case "7":
      return calculateCollateralAndDebtValuesByDebtDelta(params.quantity, params.debtDelta, meta);
  }
};
var getQuote = async (args, meta, publicClient) => {
  const {
    params: { cashflowCcy, slippageTolerance, excludedFlashloanProviders }
  } = args;
  const {
    addresses: { flashloanProviders },
    moneyMarketId
  } = meta;
  const excluded = excludedFlashloanProviders || /* @__PURE__ */ new Set();
  const debtAndCollateralData = getDebtAndCollateralData(args, meta);
  const { collateralDelta, newDebt, debtDelta, normalisedFee, tradeQuantity } = debtAndCollateralData;
  const flashloanData = await getFlashloanFee(
    tradeQuantity > 0n && [1 /* Aave */, 10 /* AaveV2 */, 9 /* Agave */, 11 /* Radiant */, 7 /* Spark */].includes(moneyMarketId) ? [] : flashloanProviders.filter((x) => !excluded.has(x)),
    cashflowCcy,
    debtAndCollateralData,
    meta,
    publicClient
  );
  const { swapCcy, flProvidersUsed, flashFee, slippageDirection } = flashloanData;
  const { swapAmount } = calculateSwapAmount({
    ...flashloanData,
    ...debtAndCollateralData,
    meta,
    slippageTolerance,
    cashflowCcy,
    quantity: collateralDelta
  });
  const [price, flashFeeUnit] = isBase(swapCcy) ? [meta.prices.collateral, meta.instrument.base.unit] : [meta.prices.debt, meta.instrument.quote.unit];
  const nFlashloanFee = mulDiv(flashFee, price, flashFeeUnit);
  switch (args.type) {
    case "1":
    case "3":
    case "4":
    case "7": {
      const cashflowUsed = toBaseOrQuote(collateralDelta - debtDelta + normalisedFee + nFlashloanFee, meta, cashflowCcy);
      return {
        ...debtAndCollateralData,
        swapAmount,
        swapCcy,
        cashflowUsed,
        flProvidersUsed,
        cashflowCcy,
        slippageDirection
      };
    }
    case "2":
    case "5":
    case "6": {
      const cashflowUsed = toBaseOrQuote(collateralDelta - debtDelta + normalisedFee, meta, cashflowCcy);
      return {
        ...debtAndCollateralData,
        newDebt: newDebt + nFlashloanFee,
        debtDelta: debtDelta + nFlashloanFee,
        swapAmount,
        swapCcy,
        cashflowUsed,
        flProvidersUsed,
        cashflowCcy,
        slippageDirection
      };
    }
  }
};

// src/api/uniswap-stub.ts
var uniV3Router = "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";
var encodeRouter02Bytes = (tokenIn, tokenOut, amountIn, recipient) => {
  return encodeFunctionData({
    abi: swapRouter02ABI,
    functionName: "exactInputSingle",
    args: [
      {
        tokenIn,
        tokenOut,
        fee: 500,
        recipient,
        amountIn,
        amountOutMinimum: 0n,
        sqrtPriceLimitX96: 0n
      }
    ]
  });
};
var quoteUniswapSingle = async (sellToken, buyToken, sellAmount, publicClient) => {
  const quoter = getContract({ abi: quoterAbi, address: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6", publicClient });
  const { result } = await quoter.simulate.quoteExactInputSingle([sellToken, buyToken, 500, sellAmount, 0n]);
  return result;
};
var quoterAbi = [
  {
    inputs: [
      { internalType: "address", name: "_factory", type: "address" },
      { internalType: "address", name: "_WETH9", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "WETH9",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "factory",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes", name: "path", type: "bytes" },
      { internalType: "uint256", name: "amountIn", type: "uint256" }
    ],
    name: "quoteExactInput",
    outputs: [{ internalType: "uint256", name: "amountOut", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tokenIn", type: "address" },
      { internalType: "address", name: "tokenOut", type: "address" },
      { internalType: "uint24", name: "fee", type: "uint24" },
      { internalType: "uint256", name: "amountIn", type: "uint256" },
      { internalType: "uint160", name: "sqrtPriceLimitX96", type: "uint160" }
    ],
    name: "quoteExactInputSingle",
    outputs: [{ internalType: "uint256", name: "amountOut", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes", name: "path", type: "bytes" },
      { internalType: "uint256", name: "amountOut", type: "uint256" }
    ],
    name: "quoteExactOutput",
    outputs: [{ internalType: "uint256", name: "amountIn", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tokenIn", type: "address" },
      { internalType: "address", name: "tokenOut", type: "address" },
      { internalType: "uint24", name: "fee", type: "uint24" },
      { internalType: "uint256", name: "amountOut", type: "uint256" },
      { internalType: "uint160", name: "sqrtPriceLimitX96", type: "uint160" }
    ],
    name: "quoteExactOutputSingle",
    outputs: [{ internalType: "uint256", name: "amountIn", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "int256", name: "amount0Delta", type: "int256" },
      { internalType: "int256", name: "amount1Delta", type: "int256" },
      { internalType: "bytes", name: "path", type: "bytes" }
    ],
    name: "uniswapV3SwapCallback",
    outputs: [],
    stateMutability: "view",
    type: "function"
  }
];

// src/api/spot-quoter.ts
var calculatePrice = (swapCcy, swapAmount, amountOut, baseUnit) => {
  if (swapCcy === 2 /* Quote */)
    return mulDiv(swapAmount, baseUnit, amountOut);
  return mulDiv(amountOut, baseUnit, swapAmount);
};
var getTradeParams = ({ positionId, fullyClosing, tradeQuantity, cashflowUsed, cashflowCcy }, limitPrice) => ({
  positionId,
  quantity: fullyClosing ? -MAX_INT256 : tradeQuantity,
  cashflow: fullyClosing ? -1n : cashflowUsed,
  cashflowCcy,
  limitPrice
});
var quoteSwap = async (tradeQuote, slippageTolerance, publicClient, dex) => {
  const recipient = tradeQuote.meta.addresses.spotExecutor;
  const { base, quote } = tradeQuote.meta.instrument;
  const { swapAmount, swapCcy, cashflowUsed, cashflowCcy, slippageDirection, flProvidersUsed } = tradeQuote;
  let [sellToken, buyToken] = tradeQuote.swapCcy === 2 /* Quote */ ? [quote, base] : [base, quote];
  let sellAmount = swapAmount;
  if (swapAmount === 0n) {
    ;
    [sellToken, buyToken] = cashflowCcy === 2 /* Quote */ ? [quote, base] : [base, quote];
    sellAmount = cashflowUsed;
  }
  const chainId = publicClient.chain?.id || 0;
  if ([31337, 31338, 31339].includes(chainId) || dex === "uniswap-single-pool" || sellAmount < 0n) {
    const amountOut = sellAmount > 0n ? await quoteUniswapSingle(sellToken.address, buyToken.address, sellAmount, publicClient) : 0n;
    const price = calculatePrice(swapCcy, swapAmount, amountOut, base.unit);
    const limitPrice = applySlippage(price, slippageTolerance, slippageDirection);
    const swapBytes = price > 0n ? encodeRouter02Bytes(sellToken.address, buyToken.address, sellAmount, recipient) : "";
    const tradeParams = getTradeParams(tradeQuote, limitPrice);
    return flProvidersUsed.map((flashLoanProvider) => ({
      tradeParams,
      execParams: {
        swapBytes,
        swapAmount,
        flashLoanProvider,
        spender: uniV3Router,
        router: uniV3Router
      },
      price,
      source: { name: swapBytes ? "Uniswap" : "[no spot trade]", logoURI: "ipfs://QmNa3YBYAYS5qSCLuXataV5XCbtxP9ZB4rHUfomRxrpRhJ" }
    }));
  }
  try {
    const swaps = await getAllQuotes(chainId, sellToken, buyToken, sellAmount, recipient, slippageTolerance, publicClient, dex);
    const trades = swaps.map((swap) => {
      const amountOut = BigInt(swap.buyAmount.amount);
      const price = calculatePrice(swapCcy, swapAmount, amountOut, base.unit);
      const limitPrice = applySlippage(price, slippageTolerance, slippageDirection);
      const tradeParams = getTradeParams(tradeQuote, limitPrice);
      return flProvidersUsed.map((flashLoanProvider) => ({
        tradeParams,
        execParams: {
          swapBytes: swap.tx.data,
          swapAmount: tradeQuote.swapAmount,
          flashLoanProvider,
          spender: swap.source.allowanceTarget,
          router: swap.tx.to
        },
        price,
        source: swap.source
      }));
    });
    return trades.flat(1);
  } catch (e) {
    console.error(e);
    return quoteSwap(tradeQuote, slippageTolerance, publicClient, "uniswap-single-pool");
  }
};

// src/api/quoter.ts
var formatCashflowData = (cashflowCcy, quoteResult, meta) => {
  const {
    instrument: { quote, base },
    chainId
  } = meta;
  const { unit, address: tokenAddress, name, symbol } = cashflowCcy === 1 /* Base */ ? base : quote;
  const cashflow = {
    value: quoteResult.cashflowUsed,
    unit,
    tokenAddress,
    allowanceTarget: meta.addresses.vaultProxy,
    cashflowCcy,
    name,
    isNative: isWrappedNative(symbol, chainId)
  };
  const markPrice = mulDiv(meta.prices.collateral, meta.instrument.quote.unit, meta.prices.debt);
  const positionSize = meta.balances.collateral + quoteResult.tradeQuantity;
  return { cashflow, markPrice, positionSize };
};
var quoteTrade = async (positionIdOrSymbol, _args, client) => {
  const meta = await getMetaData(positionIdOrSymbol, client);
  const args = mapArgs(_args, meta);
  const quoteResult = await getQuote(args, meta, client);
  return {
    ...quoteResult,
    meta,
    positionId: meta.positionId,
    ...formatCashflowData(args.params.cashflowCcy, quoteResult, meta),
    params: _args
  };
};
var quoteWithTrade = async (_positionId, args, client, dex) => {
  const quote = await quoteTrade(_positionId, args, client);
  const trades = await quoteSwap(quote, args.params.slippageTolerance, client, dex);
  return {
    ...quote,
    trade: trades[0]
  };
};
var quoteWithTrades = async (_positionId, args, client, dex) => {
  const quote = await quoteTrade(_positionId, args, client);
  const trades = await quoteSwap(quote, args.params.slippageTolerance, client, dex);
  return {
    ...quote,
    trades
  };
};
var positionStatus = async (positionId, side, client) => {
  const meta = await getMetaData(positionId, client);
  return positionStatusPure(meta, side);
};
var ContangoSDK = (clientConfigs, prod = true) => {
  const clients = Object.fromEntries(
    clientConfigs.map((config2) => {
      const httpClient = createPublicClient({ ...config2, batch: { multicall: prod }, cacheTime: 5e3 });
      return [
        config2.chain?.id,
        {
          httpClient,
          wsClient: config2.wsTransport ? createPublicClient({ ...config2, transport: config2.wsTransport }) : httpClient
        }
      ];
    })
  );
  const getChain = (chainId, clientType = "httpClient") => {
    if (!clients[chainId]) {
      throw new Error(`received request for chainId: ${chainId}. Currently configured chainIds are: ${Object.keys(clients)}`);
    }
    return clients[chainId][clientType];
  };
  return {
    quoteTrade: (positionId, args, chainId) => quoteTrade(positionId, args, getChain(chainId)),
    quoteWithTrade: (positionId, args, chainId, dex) => quoteWithTrade(positionId, args, getChain(chainId), dex),
    quoteWithTrades: (positionId, args, chainId, dex) => quoteWithTrades(positionId, args, getChain(chainId), dex),
    quoteSwap: (quote, slippageTolerance, chainId, dex) => quoteSwap(quote, slippageTolerance, getChain(chainId), dex),
    positionStatus: (positionId, side, chainId) => positionStatus(positionId, side, getChain(chainId)),
    getMetaData: (positionId, chainId) => getMetaData(positionId, getChain(chainId)),
    getRewardsData: (positionId, chainId) => getRewardsData(positionId, getChain(chainId)),
    positionUpserts$: (owner, chainId, next) => positionUpsert$(owner, next, getChain(chainId, "wsClient")),
    ordersAdded$: (owner, chainId, next) => ordersAdded$(owner, next, getChain(chainId, "wsClient")),
    ordersRemoved$: (chainId, next) => ordersRemoved$(next, getChain(chainId, "wsClient")),
    rewardsClaimed$: (owner, chainId) => rewardsClaimed$(owner, getChain(chainId, "wsClient"))
  };
};

// src/price-tracker/feeds/CurrencyGraph.ts
var CurrencyGraph = class {
  constructor() {
    this.adjacencyList = {};
  }
  addPair(base, quote) {
    if (!this.adjacencyList[base]) {
      this.adjacencyList[base] = [];
    }
    if (!this.adjacencyList[quote]) {
      this.adjacencyList[quote] = [];
    }
    this.adjacencyList[base].push(quote);
    this.adjacencyList[quote].push(base);
  }
  findPath(start, end) {
    const queue = [[start]];
    const visited = /* @__PURE__ */ new Set();
    while (queue.length) {
      const path = queue.shift();
      const node = path[path.length - 1];
      if (node === end)
        return path;
      if (visited.has(node))
        continue;
      visited.add(node);
      for (const neighbor of this.adjacencyList[node] || []) {
        const newPath = [...path, neighbor];
        queue.push(newPath);
      }
    }
    return null;
  }
};

// src/price-tracker/feeds/arbitrum.ts
var chainlinkFeeds = [
  {
    pair: "PEPE / USD",
    base: "PEPE",
    quote: "USD",
    deviation: 50,
    heartbeat: 3600,
    dec: 18,
    address: "0x02DEd5a7EDDA750E3Eb240b54437a54d57b74dBE"
  },
  {
    pair: "LINK / USD",
    base: "LINK",
    quote: "USD",
    deviation: 20,
    heartbeat: 3600,
    dec: 8,
    address: "0x86E53CF1B870786351Da77A57575e79CB55812CB"
  },
  {
    pair: "FXS / USD",
    base: "FXS",
    quote: "USD",
    deviation: 50,
    heartbeat: 3600,
    dec: 8,
    address: "0x36a121448D74Fa81450c992A1a44B9b7377CD3a5"
  },
  {
    pair: "EURS / USD",
    base: "EURS",
    quote: "USD",
    deviation: 10,
    heartbeat: 3600,
    dec: 8,
    address: "0xA14d53bC1F1c0F31B4aA3BD109344E5009051a84"
  },
  {
    pair: "CRV / USD",
    base: "CRV",
    quote: "USD",
    deviation: 50,
    heartbeat: 3600,
    dec: 8,
    address: "0xaebDA2c976cfd1eE1977Eac079B4382acb849325"
  },
  {
    pair: "COMP / USD",
    base: "COMP",
    quote: "USD",
    deviation: 50,
    heartbeat: 3600,
    dec: 8,
    address: "0xe7C53FFd03Eb6ceF7d208bC4C13446c76d1E5884"
  },
  {
    pair: "BAL / USD",
    base: "BAL",
    quote: "USD",
    deviation: 50,
    heartbeat: 3600,
    dec: 8,
    address: "0xBE5eA816870D11239c543F84b71439511D70B94f"
  },
  {
    pair: "YFI / USD",
    base: "YFI",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x745Ab5b69E01E2BE1104Ca84937Bb71f96f5fB21"
  },
  {
    pair: "XRP / USD",
    base: "XRP",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xB4AD57B52aB9141de9926a3e0C8dc6264c2ef205"
  },
  {
    pair: "XAU / USD",
    base: "XAU",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x1F954Dc24a49708C26E0C1777f16750B5C6d5a2c"
  },
  {
    pair: "XAG / USD",
    base: "XAG",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xC56765f04B248394CF1619D20dB8082Edbfa75b1"
  },
  {
    pair: "WTI / USD",
    base: "WTI",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x594b919AD828e693B935705c3F816221729E7AE8"
  },
  {
    pair: "WOO / USD",
    base: "WOO",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x5e2b5C5C07cCA3437c4D724225Bb42c7E55d1597"
  },
  {
    pair: "WBTC / USD",
    base: "WBTC",
    quote: "USD",
    deviation: 5,
    heartbeat: 86400,
    dec: 8,
    address: "0xd0C7101eACbB49F3deCcCc166d238410D6D46d57"
  },
  {
    pair: "USDT / USD",
    base: "USDT",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0x3f3f5dF88dC9F13eac63DF89EC16ef6e7E25DdE7"
  },
  {
    pair: "USDD / USD",
    base: "USDD",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x4Ee1f9ec1048979930aC832a3C1d18a0b4955a02"
  },
  {
    pair: "USDC / USD",
    base: "USDC",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0x50834F3163758fcC1Df9973b6e91f0F0F0434aD3"
  },
  {
    pair: "UNI / USD",
    base: "UNI",
    quote: "USD",
    deviation: 15,
    heartbeat: 86400,
    dec: 8,
    address: "0x9C917083fDb403ab5ADbEC26Ee294f6EcAda2720"
  },
  {
    pair: "TUSD / USD",
    base: "TUSD",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x6fAbee62266Da6686EE2744C6f15bb8352d2f28D"
  },
  {
    pair: "TSLA / USD",
    base: "TSLA",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x3609baAa0a9b1f0FE4d6CC01884585d0e191C3E3"
  },
  {
    pair: "TRY / USD",
    base: "TRY",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xE8f8AfE4b56c6C421F691bfAc225cE61b2C7CD05"
  },
  {
    pair: "SUSHI / USD",
    base: "SUSHI",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xb2A8BA74cbca38508BA1632761b56C897060147C"
  },
  {
    pair: "STG / USD",
    base: "STG",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xe74d69E233faB0d8F48921f2D93aDfDe44cEb3B7"
  },
  {
    pair: "STETH / USD",
    base: "STETH",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x07C5b924399cc23c24a95c8743DE4006a32b7f2a"
  },
  {
    pair: "SPY / USD",
    base: "SPY",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x46306F3795342117721D8DEd50fbcF6DF2b3cc10"
  },
  {
    pair: "SPELL / USD",
    base: "SPELL",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x383b3624478124697BEF675F07cA37570b73992f"
  },
  {
    pair: "SOL / USD",
    base: "SOL",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0x24ceA4b8ce57cdA5058b924B9B9987992450590c"
  },
  {
    pair: "SNX / USD",
    base: "SNX",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x054296f0D036b95531B4E14aFB578B80CFb41252"
  },
  {
    pair: "SGD / USD",
    base: "SGD",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xF0d38324d1F86a176aC727A4b0c43c9F9d9c5EB1"
  },
  {
    pair: "SEK / USD",
    base: "SEK",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xdE89a55d04DEd40A410877ab87d4F567ee66a1f0"
  },
  {
    pair: "RPL / USD",
    base: "RPL",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xF0b7159BbFc341Cc41E7Cb182216F62c6d40533D"
  },
  {
    pair: "RDNT / USD",
    base: "RDNT",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x20d0Fcab0ECFD078B036b6CAf1FaC69A6453b352"
  },
  {
    pair: "PHP / USD",
    base: "PHP",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xfF82AAF635645fD0bcc7b619C3F28004cDb58574"
  },
  {
    pair: "PENDLE / USD",
    base: "PENDLE",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x66853E19d73c0F9301fe099c324A1E9726953433"
  },
  {
    pair: "PAXG / USD",
    base: "PAXG",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x2BA975D4D7922cD264267Af16F3bD177F206FE3c"
  },
  {
    pair: "OP / USD",
    base: "OP",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x205aaD468a11fd5D34fA7211bC6Bad5b3deB9b98"
  },
  {
    pair: "OHMV2 / USD",
    base: "OHMV2",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x761aaeBf021F19F198D325D7979965D0c7C9e53b"
  },
  {
    pair: "NEAR / USD",
    base: "NEAR",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xBF5C3fB2633e924598A46B9D07a174a9DBcF57C0"
  },
  {
    pair: "MSFT / USD",
    base: "MSFT",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xDde33fb9F21739602806580bdd73BAd831DcA867"
  },
  {
    pair: "MKR / USD",
    base: "MKR",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xdE9f0894670c4EFcacF370426F10C3AD2Cdf147e"
  },
  {
    pair: "MAI / USD",
    base: "MAI",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0x59644ec622243878d1464A9504F9e9a31294128a"
  },
  {
    pair: "MIM / USD",
    base: "MIM",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x87121F6c9A9F6E90E59591E4Cf4804873f54A95b"
  },
  {
    pair: "META / USD",
    base: "META",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xcd1bd86fDc33080DCF1b5715B6FCe04eC6F85845"
  },
  {
    pair: "MATIC / USD",
    base: "MATIC",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x52099D4523531f678Dfc568a7B1e5038aadcE1d6"
  },
  {
    pair: "MAGIC / USD",
    base: "MAGIC",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x47E55cCec6582838E173f252D08Afd8116c2202d"
  },
  {
    pair: "LUSD / USD",
    base: "LUSD",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x0411D28c94d85A36bC72Cb0f875dfA8371D8fFfF"
  },
  {
    pair: "LDO / USD",
    base: "LDO",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xA43A34030088E6510FecCFb77E88ee5e7ed0fE64"
  },
  {
    pair: "KRW / USD",
    base: "KRW",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x85bb02E0Ae286600d1c68Bb6Ce22Cc998d411916"
  },
  {
    pair: "KNC / USD",
    base: "KNC",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xbF539d4c2106dd4D9AB6D56aed3d9023529Db145"
  },
  {
    pair: "JPY / USD",
    base: "JPY",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x3dD6e51CB9caE717d5a8778CF79A04029f9cFDF8"
  },
  {
    pair: "JOE / USD",
    base: "JOE",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0x04180965a782E487d0632013ABa488A472243542"
  },
  {
    pair: "IOTX / USD",
    base: "IOTX",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x484A1b29ED1Ea038dBd75D7c7293714343363122"
  },
  {
    pair: "GOOGL / USD",
    base: "GOOGL",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x1D1a83331e9D255EB1Aaf75026B60dFD00A252ba"
  },
  {
    pair: "GNS / USD",
    base: "GNS",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xE89E98CE4E19071E59Ed4780E0598b541CE76486"
  },
  {
    pair: "GMX / USD",
    base: "GMX",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xDB98056FecFff59D032aB628337A4887110df3dB"
  },
  {
    pair: "GBP / USD",
    base: "GBP",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x9C4424Fd84C6661F97D8d6b3fc3C1aAc2BeDd137"
  },
  {
    pair: "FTM / USD",
    base: "FTM",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xFeaC1A3936514746e70170c0f539e70b23d36F19"
  },
  {
    pair: "FRAX / USD",
    base: "FRAX",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x0809E3d38d1B4214958faf06D8b1B1a2b73f2ab8"
  },
  {
    pair: "EUROC / USD",
    base: "EUROC",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x36713A3CF7f054a0A0D8893ae6e1b65980C90d25"
  },
  {
    pair: "WETH / USD",
    base: "WETH",
    quote: "USD",
    deviation: 5,
    heartbeat: 86400,
    dec: 8,
    address: "0x639Fe6ab55C921f74e7fac1ee960C0B6293ba612"
  },
  {
    pair: "DPX / USD",
    base: "DPX",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xc373B9DB0707fD451Bc56bA5E9b029ba26629DF0"
  },
  {
    pair: "DOT / USD",
    base: "DOT",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0xa6bC5bAF2000424e90434bA7104ee399dEe80DEc"
  },
  {
    pair: "DOGE / USD",
    base: "DOGE",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0x9A7FB1b3950837a8D9b40517626E11D4127C098C"
  },
  {
    pair: "DODO / USD",
    base: "DODO",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xA33a06c119EC08F92735F9ccA37e07Af08C4f281"
  },
  {
    pair: "DAI / USD",
    base: "DAI",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0xc5C8E77B397E531B8EC06BFb0048328B30E9eCfB"
  },
  {
    pair: "CVX / USD",
    base: "CVX",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x851175a919f36c8e30197c09a9A49dA932c2CC00"
  },
  {
    pair: "CNY / USD",
    base: "CNY",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xcC3370Bde6AFE51e1205a5038947b9836371eCCb"
  },
  {
    pair: "CHF / USD",
    base: "CHF",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xe32AccC8c4eC03F6E75bd3621BfC9Fbb234E1FC3"
  },
  {
    pair: "CAKE / USD",
    base: "CAKE",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x256654437f1ADA8057684b18d742eFD14034C400"
  },
  {
    pair: "CAD / USD",
    base: "CAD",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xf6DA27749484843c4F02f5Ad1378ceE723dD61d4"
  },
  {
    pair: "BUSD / USD",
    base: "BUSD",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x8FCb0F3715A82D83270777b3a5f3a7CF95Ce8Eec"
  },
  {
    pair: "BTC / USD",
    base: "BTC",
    quote: "USD",
    deviation: 5,
    heartbeat: 86400,
    dec: 8,
    address: "0x6ce185860a4963106506C203335A2910413708e9"
  },
  {
    pair: "BRL / USD",
    base: "BRL",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0x04b7384473A2aDF1903E3a98aCAc5D62ba8C2702"
  },
  {
    pair: "BNB / USD",
    base: "BNB",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0x6970460aabF80C5BE983C6b74e5D06dEDCA95D4A"
  },
  {
    pair: "AXS / USD",
    base: "AXS",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x5B58aA6E0651Ae311864876A55411F481aD86080"
  },
  {
    pair: "AVAX / USD",
    base: "AVAX",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0x8bf61728eeDCE2F32c456454d87B5d6eD6150208"
  },
  {
    pair: "AUD / USD",
    base: "AUD",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x9854e9a850e7C354c1de177eA953a6b1fba8Fc22"
  },
  {
    pair: "ATOM / USD",
    base: "ATOM",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xCDA67618e51762235eacA373894F0C79256768fa"
  },
  {
    pair: "ARB / USD",
    base: "ARB",
    quote: "USD",
    deviation: 5,
    heartbeat: 86400,
    dec: 8,
    address: "0xb2A824043730FE05F3DA2efaFa1CBbe83fa548D6"
  },
  {
    pair: "APE / USD",
    base: "APE",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x221912ce795669f628c51c69b7d0873eDA9C03bB"
  },
  {
    pair: "AMZN / USD",
    base: "AMZN",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xd6a77691f071E98Df7217BED98f38ae6d2313EBA"
  },
  {
    pair: "ADA / USD",
    base: "ADA",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xD9f615A9b820225edbA2d821c4A696a0924051c6"
  },
  {
    pair: "AAVE / USD",
    base: "AAVE",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xaD1d5344AaDE45F43E596773Bcc4c423EAbdD034"
  },
  {
    pair: "AAPL / USD",
    base: "AAPL",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x8d0CC5f38f9E802475f2CFf4F9fc7000C2E1557c"
  },
  {
    pair: "1INCH / USD",
    base: "1INCH",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x4bC735Ef24bf286983024CAd5D03f0738865Aaef"
  },
  {
    pair: "RETH / WETH",
    base: "RETH",
    quote: "WETH",
    deviation: 20,
    heartbeat: 86400,
    dec: 18,
    address: "0xF3272CAfe65b190e76caAF483db13424a3e23dD2"
  },
  {
    pair: "CBETH / WETH",
    base: "CBETH",
    quote: "WETH",
    deviation: 30,
    heartbeat: 86400,
    dec: 18,
    address: "0xa668682974E3f121185a3cD94f00322beC674275"
  },
  {
    pair: "WSTETH / WETH",
    base: "WSTETH",
    quote: "WETH",
    deviation: 50,
    heartbeat: 86400,
    dec: 18,
    address: "0xb523AE262D20A936BC152e6023996e46FDC2A95D"
  },
  {
    pair: "SFRXETH / FRXETH",
    base: "SFRXETH",
    quote: "FRXETH",
    deviation: 50,
    heartbeat: 86400,
    dec: 18,
    address: "0x98E5a52fB741347199C08a7a3fcF017364284431"
  }
];
var arbitrumGraph = new CurrencyGraph();
chainlinkFeeds.forEach(({ base, quote }) => arbitrumGraph.addPair(base, quote));
var arbitrumPairs = Object.fromEntries(Object.values(chainlinkFeeds).map((x) => [x.pair, x]));

// src/price-tracker/feeds/mainnet.ts
var chainlinkFeeds2 = [
  {
    pair: "YFI / USD",
    base: "YFI",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0xA027702dbb89fbd58938e4324ac03B58d812b0E1"
  },
  {
    pair: "USDP / USD",
    base: "USDP",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0x09023c0DA49Aaf8fc3fA3ADF34C6A7016D38D5e3"
  },
  {
    pair: "UNI / USD",
    base: "UNI",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0x553303d460EE0afB37EdFf9bE42922D8FF63220e"
  },
  {
    pair: "SUSHI / USD",
    base: "SUSHI",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0xCc70F09A6CC17553b2E31954cD36E4A2d89501f7"
  },
  {
    pair: "STETH / USD",
    base: "STETH",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0xCfE54B5cD566aB89272946F602D76Ea879CAb4a8"
  },
  {
    pair: "RAI / USD",
    base: "RAI",
    quote: "USD",
    deviation: 50,
    heartbeat: 3600,
    dec: 8,
    address: "0x483d36F6a1d063d580c7a24F9A42B346f3a69fbb"
  },
  {
    pair: "MKR / USD",
    base: "MKR",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0xec1D1B3b0443256cc3860e24a46F108e699484Aa"
  },
  {
    pair: "MATIC / USD",
    base: "MATIC",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0x7bAC85A8a13A4BcD8abb3eB7d6b4d632c5a57676"
  },
  {
    pair: "LUSD / USD",
    base: "LUSD",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0x3D7aE7E594f2f2091Ad8798313450130d0Aba3a0"
  },
  {
    pair: "LINK / USD",
    base: "LINK",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c"
  },
  {
    pair: "GUSD / USD",
    base: "GUSD",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0xa89f5d2365ce98B3cD68012b6f503ab1416245Fc"
  },
  {
    pair: "FRAX / USD",
    base: "FRAX",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0xB9E1E3A9feFf48998E45Fa90847ed4D467E8BcfD"
  },
  {
    pair: "WETH / USD",
    base: "WETH",
    quote: "USD",
    deviation: 50,
    heartbeat: 3600,
    dec: 8,
    address: "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419"
  },
  {
    pair: "DAI / USD",
    base: "DAI",
    quote: "USD",
    deviation: 25,
    heartbeat: 3600,
    dec: 8,
    address: "0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9"
  },
  {
    pair: "COMP / USD",
    base: "COMP",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5"
  },
  {
    pair: "BTC / USD",
    base: "BTC",
    quote: "USD",
    deviation: 50,
    heartbeat: 3600,
    dec: 8,
    address: "0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c"
  },
  {
    pair: "AAVE / USD",
    base: "AAVE",
    quote: "USD",
    deviation: 100,
    heartbeat: 3600,
    dec: 8,
    address: "0x547a514d5e3769680Ce22B2361c10Ea13619e8a9"
  },
  {
    pair: "GRT / WETH",
    base: "GRT",
    quote: "WETH",
    deviation: 200,
    heartbeat: 3600,
    dec: 18,
    address: "0x17D054eCac33D91F7340645341eFB5DE9009F1C1"
  },
  {
    pair: "SUSD / USD",
    base: "SUSD",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xad35Bd71b9aFE6e4bDc266B345c198eaDEf9Ad94"
  },
  {
    pair: "XCN / USD",
    base: "XCN",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xeb988B77b94C186053282BfcD8B7ED55142D3cAB"
  },
  {
    pair: "XAU / USD",
    base: "XAU",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x214eD9Da11D2fbe465a6fc601a91E62EbEc1a0D6"
  },
  {
    pair: "XAG / USD",
    base: "XAG",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x379589227b15F1a12195D3f2d90bBc9F31f95235"
  },
  {
    pair: "WING / USD",
    base: "WING",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x134fE0a225Fb8e6683617C13cEB6B3319fB4fb82"
  },
  {
    pair: "USDT / USD",
    base: "USDT",
    quote: "USD",
    deviation: 25,
    heartbeat: 86400,
    dec: 8,
    address: "0x3E7d1eAB13ad0104d2750B8863b489D65364e32D"
  },
  {
    pair: "USDD / USD",
    base: "USDD",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0x0ed39A19D2a68b722408d84e4d970827f61E6c0A"
  },
  {
    pair: "USDC / USD",
    base: "USDC",
    quote: "USD",
    deviation: 25,
    heartbeat: 86400,
    dec: 8,
    address: "0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6"
  },
  {
    pair: "TUSD / USD",
    base: "TUSD",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xec746eCF986E2927Abd291a2A1716c940100f8Ba"
  },
  {
    pair: "TRY / USD",
    base: "TRY",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xB09fC5fD3f11Cf9eb5E1C5Dba43114e3C9f477b5"
  },
  {
    pair: "SXP / USD",
    base: "SXP",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0xFb0CfD6c19e25DB4a08D8a204a387cEa48Cc138f"
  },
  {
    pair: "STG / USD",
    base: "STG",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x7A9f34a0Aa917D438e9b6E630067062B7F8f6f3d"
  },
  {
    pair: "SPELL / USD",
    base: "SPELL",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0x8c110B94C5f1d347fAcF5E1E938AB2db60E3c9a8"
  },
  {
    pair: "SOL / USD",
    base: "SOL",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x4ffC43a60e009B551865A93d232E33Fce9f01507"
  },
  {
    pair: "SNX / USD",
    base: "SNX",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699"
  },
  {
    pair: "SHV / USD",
    base: "SHV",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xc04611C43842220fd941515F86d1DDdB15F04e46"
  },
  {
    pair: "SGD / USD",
    base: "SGD",
    quote: "USD",
    deviation: 15,
    heartbeat: 86400,
    dec: 8,
    address: "0xe25277fF4bbF9081C75Ab0EB13B4A13a721f3E13"
  },
  {
    pair: "SAND / USD",
    base: "SAND",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x35E3f7E558C04cE7eEE1629258EcbbA03B36Ec56"
  },
  {
    pair: "RSR / USD",
    base: "RSR",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x759bBC1be8F90eE6457C44abc7d443842a976d02"
  },
  {
    pair: "RPL / USD",
    base: "RPL",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x4E155eD98aFE9034b7A5962f6C84c86d869daA9d"
  },
  {
    pair: "RDNT / USD",
    base: "RDNT",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x393CC05baD439c9B36489384F11487d9C8410471"
  },
  {
    pair: "PERP / USD",
    base: "PERP",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x01cE1210Fe8153500F60f7131d63239373D7E26C"
  },
  {
    pair: "NZD / USD",
    base: "NZD",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x3977CFc9e4f29C184D4675f4EB8e0013236e5f3e"
  },
  {
    pair: "MIM / USD",
    base: "MIM",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x7A364e8770418566e3eb2001A96116E6138Eb32F"
  },
  {
    pair: "LTC / USD",
    base: "LTC",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0x6AF09DF7563C363B5763b9102712EbeD3b9e859B"
  },
  {
    pair: "KRW / USD",
    base: "KRW",
    quote: "USD",
    deviation: 15,
    heartbeat: 86400,
    dec: 8,
    address: "0x01435677FB11763550905594A16B645847C1d0F3"
  },
  {
    pair: "KNC / USD",
    base: "KNC",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0xf8fF43E991A81e6eC886a3D281A2C6cC19aE70Fc"
  },
  {
    pair: "JPY / USD",
    base: "JPY",
    quote: "USD",
    deviation: 15,
    heartbeat: 86400,
    dec: 8,
    address: "0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3"
  },
  {
    pair: "IMX / USD",
    base: "IMX",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xBAEbEFc1D023c0feCcc047Bff42E75F15Ff213E6"
  },
  {
    pair: "IBTA / USD",
    base: "IBTA",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xd27e6D02b72eB6FCe04Ad5690C419196B4EF2885"
  },
  {
    pair: "IB01 / USD",
    base: "IB01",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x32d1463EB53b73C095625719Afa544D5426354cB"
  },
  {
    pair: "HBAR / USD",
    base: "HBAR",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x38C5ae3ee324ee027D88c5117ee58d07c9b4699b"
  },
  {
    pair: "GHO / USD",
    base: "GHO",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x3f12643D3f6f874d39C2a4c9f2Cd6f2DbAC877FC"
  },
  {
    pair: "GBP / USD",
    base: "GBP",
    quote: "USD",
    deviation: 15,
    heartbeat: 86400,
    dec: 8,
    address: "0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5"
  },
  {
    pair: "FXS / USD",
    base: "FXS",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x6Ebc52C8C1089be9eB3945C4350B68B8E4C2233f"
  },
  {
    pair: "FOR / USD",
    base: "FOR",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x456834f736094Fb0AAD40a9BBc9D4a0f37818A54"
  },
  {
    pair: "EURT / USD",
    base: "EURT",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x01D391A48f4F7339aC64CA2c83a07C22F95F587a"
  },
  {
    pair: "EURS / USD",
    base: "EURS",
    quote: "USD",
    deviation: 15,
    heartbeat: 86400,
    dec: 8,
    address: "0xb49f677943BC038e9857d61E7d053CaA2C1734C1"
  },
  {
    pair: "ENS / USD",
    base: "ENS",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x5C00128d4d1c2F4f652C267d7bcdD7aC99C16E16"
  },
  {
    pair: "DPI / USD",
    base: "DPI",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0xD2A593BF7594aCE1faD597adb697b5645d5edDB2"
  },
  {
    pair: "DOT / USD",
    base: "DOT",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734"
  },
  {
    pair: "DOGE / USD",
    base: "DOGE",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x2465CefD3b488BE410b941b1d4b2767088e2A028"
  },
  {
    pair: "CVX / USD",
    base: "CVX",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xd962fC30A72A84cE50161031391756Bf2876Af5D"
  },
  {
    pair: "CSPX / USD",
    base: "CSPX",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xF4E1B57FB228879D057ac5AE33973e8C53e4A0e0"
  },
  {
    pair: "CRVUSD / USD",
    base: "CRVUSD",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xEEf0C605546958c1f899b6fB336C20671f9cD49F"
  },
  {
    pair: "CRV / USD",
    base: "CRV",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f"
  },
  {
    pair: "CNY / USD",
    base: "CNY",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xeF8A4aF35cd47424672E3C590aBD37FBB7A7759a"
  },
  {
    pair: "CHF / USD",
    base: "CHF",
    quote: "USD",
    deviation: 15,
    heartbeat: 86400,
    dec: 8,
    address: "0x449d117117838fFA61263B61dA6301AA2a88B13A"
  },
  {
    pair: "CAKE / USD",
    base: "CAKE",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xEb0adf5C06861d6c07174288ce4D0a8128164003"
  },
  {
    pair: "CAD / USD",
    base: "CAD",
    quote: "USD",
    deviation: 15,
    heartbeat: 86400,
    dec: 8,
    address: "0xa34317DB73e77d453b1B8d04550c44D10e981C8e"
  },
  {
    pair: "BUSD / USD",
    base: "BUSD",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x833D8Eb16D306ed1FbB5D7A2E019e106B960965A"
  },
  {
    pair: "BNB / USD",
    base: "BNB",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0x14e613AC84a31f709eadbdF89C6CC390fDc9540A"
  },
  {
    pair: "BAL / USD",
    base: "BAL",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xdF2917806E30300537aEB49A7663062F4d1F2b5F"
  },
  {
    pair: "BADGER / USD",
    base: "BADGER",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x66a47b7206130e6FF64854EF0E1EDfa237E65339"
  },
  {
    pair: "AVAX / USD",
    base: "AVAX",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xFF3EEb22B5E3dE6e705b44749C2559d704923FD7"
  },
  {
    pair: "AUD / USD",
    base: "AUD",
    quote: "USD",
    deviation: 15,
    heartbeat: 86400,
    dec: 8,
    address: "0x77F9710E7d0A19669A13c055F62cd80d313dF022"
  },
  {
    pair: "APE / USD",
    base: "APE",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xD10aBbC76679a20055E167BB80A24ac851b37056"
  },
  {
    pair: "ANKR / USD",
    base: "ANKR",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0x7eed379bf00005CfeD29feD4009669dE9Bcc21ce"
  },
  {
    pair: "ADA / USD",
    base: "ADA",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55"
  },
  {
    pair: "1INCH / USD",
    base: "1INCH",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0xc929ad75B72593967DE83E7F7Cda0493458261D9"
  },
  {
    pair: "ZRX / WETH",
    base: "ZRX",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x2Da4983a622a8498bb1a21FaE9D8F6C664939962"
  },
  {
    pair: "WNXM / WETH",
    base: "WNXM",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0xe5Dc0A609Ab8bCF15d3f35cFaa1Ff40f521173Ea"
  },
  {
    pair: "TRIBE / WETH",
    base: "TRIBE",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x84a24deCA415Acc0c395872a9e6a63E27D6225c8"
  },
  {
    pair: "SHIB / WETH",
    base: "SHIB",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x8dD1CD88F43aF196ae478e91b9F5E4Ac69A97C61"
  },
  {
    pair: "RLC / WETH",
    base: "RLC",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x4cba1e1fdc738D0fe8DB3ee07728E2Bc4DA676c6"
  },
  {
    pair: "RETH / WETH",
    base: "RETH",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x536218f9E9Eb48863970252233c8F271f554C2d0"
  },
  {
    pair: "REN / WETH",
    base: "REN",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x3147D7203354Dc06D9fd350c7a2437bcA92387a4"
  },
  {
    pair: "PAXG / WETH",
    base: "PAXG",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x9B97304EA12EFed0FAd976FBeCAad46016bf269e"
  },
  {
    pair: "PAX / WETH",
    base: "PAX",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x3a08ebBaB125224b7b6474384Ee39fBb247D2200"
  },
  {
    pair: "OHMV2 / WETH",
    base: "OHMV2",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x9a72298ae3886221820B1c878d12D872087D3a23"
  },
  {
    pair: "NMR / WETH",
    base: "NMR",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x9cB2A01A7E64992d32A34db7cEea4c919C391f6A"
  },
  {
    pair: "MLN / WETH",
    base: "MLN",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0xDaeA8386611A157B08829ED4997A8A62B557014C"
  },
  {
    pair: "MANA / WETH",
    base: "MANA",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x82A44D92D6c329826dc557c5E1Be6ebeC5D5FeB9"
  },
  {
    pair: "LRC / WETH",
    base: "LRC",
    quote: "WETH",
    deviation: 100,
    heartbeat: 86400,
    dec: 18,
    address: "0x160AC928A16C93eD4895C2De6f81ECcE9a7eB7b4"
  },
  {
    pair: "LDO / WETH",
    base: "LDO",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x4e844125952D32AcdF339BE976c98E22F6F318dB"
  },
  {
    pair: "FTT / WETH",
    base: "FTT",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0xF0985f7E2CaBFf22CecC5a71282a89582c382EFE"
  },
  {
    pair: "FTM / WETH",
    base: "FTM",
    quote: "WETH",
    deviation: 300,
    heartbeat: 86400,
    dec: 18,
    address: "0x2DE7E4a9488488e0058B95854CC2f7955B35dC9b"
  },
  {
    pair: "FIL / WETH",
    base: "FIL",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x0606Be69451B1C9861Ac6b3626b99093b713E801"
  },
  {
    pair: "ENJ / WETH",
    base: "ENJ",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x24D9aB51950F3d62E9144fdC2f3135DAA6Ce8D1B"
  },
  {
    pair: "CBETH / WETH",
    base: "CBETH",
    quote: "WETH",
    deviation: 100,
    heartbeat: 86400,
    dec: 18,
    address: "0xF017fcB346A1885194689bA23Eff2fE6fA5C483b"
  },
  {
    pair: "BAT / WETH",
    base: "BAT",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x0d16d4528239e9ee52fa531af613AcdB23D88c94"
  },
  {
    pair: "AMPL / WETH",
    base: "AMPL",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x492575FDD11a0fCf2C6C719867890a7648d526eB"
  },
  {
    pair: "ALCX / WETH",
    base: "ALCX",
    quote: "WETH",
    deviation: 200,
    heartbeat: 86400,
    dec: 18,
    address: "0x194a9AaF2e0b67c35915cD01101585A33Fe25CAa"
  },
  {
    pair: "WBTC / BTC",
    base: "WBTC",
    quote: "BTC",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xfdFD9C85aD200c506Cf9e21F1FD8dd01932FBB23"
  }
];
var mainnetGraph = new CurrencyGraph();
chainlinkFeeds2.forEach(({ base, quote }) => mainnetGraph.addPair(base, quote));
var mainnetPairs = Object.fromEntries(Object.values(chainlinkFeeds2).map((x) => [x.pair, x]));

// src/price-tracker/feeds/polygon.ts
var chainlinkFeeds3 = [
  {
    pair: "ZRX / USD",
    base: "ZRX",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x6EA4d89474d9410939d429B786208c74853A5B47"
  },
  {
    pair: "ZEC / USD",
    base: "ZEC",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xBC08c639e579a391C4228F20d0C29d0690092DF0"
  },
  {
    pair: "YFI / USD",
    base: "YFI",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x9d3A43c111E7b2C6601705D9fcF7a70c95b1dc55"
  },
  {
    pair: "XTZ / USD",
    base: "XTZ",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x691e26AB58ff05800E028b0876A41B720b26FC65"
  },
  {
    pair: "XRP / USD",
    base: "XRP",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x785ba89291f676b5386652eB12b30cF361020694"
  },
  {
    pair: "XMR / USD",
    base: "XMR",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xBE6FB0AB6302B693368D0E9001fAF77ecc6571db"
  },
  {
    pair: "XLM / USD",
    base: "XLM",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x692AE5510cA9070095A496dbcFBCDA99D4024Cd9"
  },
  {
    pair: "XAU / USD",
    base: "XAU",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x0C466540B2ee1a31b441671eac0ca886e051E410"
  },
  {
    pair: "USDT / USD",
    base: "USDT",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x0A6513e40db6EB1b165753AD52E80663aeA50545"
  },
  {
    pair: "USDC / USD",
    base: "USDC",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xfE4A8cc5b5B2366C1B58Bea3858e81843581b2F7"
  },
  {
    pair: "UNI / USD",
    base: "UNI",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xdf0Fb4e4F928d2dCB76f438575fDD8682386e13C"
  },
  {
    pair: "UMA / USD",
    base: "UMA",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x33D9B1BAaDcF4b26ab6F8E83e9cb8a611B2B3956"
  },
  {
    pair: "TUSD / USD",
    base: "TUSD",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x7C5D415B64312D38c56B54358449d0a4058339d2"
  },
  {
    pair: "TRX / USD",
    base: "TRX",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x307cCF7cBD17b69A487b9C3dbe483931Cf3E1833"
  },
  {
    pair: "THETA / USD",
    base: "THETA",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x38611b09F8f2D520c14eA973765C225Bf57B9Eac"
  },
  {
    pair: "SOL / USD",
    base: "SOL",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x10C8264C0935b3B9870013e057f330Ff3e9C56dC"
  },
  {
    pair: "SNX / USD",
    base: "SNX",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xbF90A5D9B6EE9019028dbFc2a9E50056d5252894"
  },
  {
    pair: "PAXG / USD",
    base: "PAXG",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x0f6914d8e7e1214CDb3A4C6fbf729b75C69DF608"
  },
  {
    pair: "OMG / USD",
    base: "OMG",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x93FfEE768F74208a7b9f2a4426f0F6BCbb1D09de"
  },
  {
    pair: "OCEAN / USD",
    base: "OCEAN",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xdcda79097C44353Dee65684328793695bd34A629"
  },
  {
    pair: "NEXO / USD",
    base: "NEXO",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x666bb13b3ED3816504E8c30D0F9B9C16b371774b"
  },
  {
    pair: "MKR / USD",
    base: "MKR",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xa070427bF5bA5709f70e98b94Cb2F435a242C46C"
  },
  {
    pair: "WMATIC / USD",
    base: "WMATIC",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xAB594600376Ec9fD91F8e885dADF0CE036862dE0"
  },
  {
    pair: "MATICX / USD",
    base: "MATICX",
    quote: "USD",
    deviation: 50,
    heartbeat: 3600,
    dec: 8,
    address: "0x5d37E4b374E6907de8Fc7fb33EE3b0af403C7403"
  },
  {
    pair: "STMATIC / USD",
    base: "STMATIC",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x97371dF4492605486e23Da797fA68e55Fc38a13f"
  },
  {
    pair: "MANA / USD",
    base: "MANA",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xA1CbF3Fe43BC3501e3Fc4b573e822c70e76A7512"
  },
  {
    pair: "LTC / USD",
    base: "LTC",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xEB99F173cf7d9a6dC4D889C2Ad7103e8383b6Efa"
  },
  {
    pair: "LPT / USD",
    base: "LPT",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xBAaF11CeDA1d1Ca9Cf01748F8196653c9656a400"
  },
  {
    pair: "LINK / USD",
    base: "LINK",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xd9FFdb71EbE7496cC440152d43986Aae0AB76665"
  },
  {
    pair: "KNC / USD",
    base: "KNC",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x10e5f3DFc81B3e5Ef4e648C4454D04e79E1E41E2"
  },
  {
    pair: "ICP / USD",
    base: "ICP",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x84227A76a04289473057BEF706646199D7C58c34"
  },
  {
    pair: "HKD / USD",
    base: "HKD",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x82d43B72573f902F960126a19581BcBbA5b014F5"
  },
  {
    pair: "GRT / USD",
    base: "GRT",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x3FabBfb300B1e2D7c9B84512fe9D30aeDF24C410"
  },
  {
    pair: "GBP / USD",
    base: "GBP",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x099a2540848573e94fb1Ca0Fa420b00acbBc845a"
  },
  {
    pair: "EURS / USD",
    base: "EURS",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x73366Fe0AA0Ded304479862808e02506FE556a98"
  },
  {
    pair: "WETH / USD",
    base: "WETH",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xF9680D99D6C9589e2a93a78A04A279e509205945"
  },
  {
    pair: "ETC / USD",
    base: "ETC",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xDf3f72Be10d194b58B1BB56f2c4183e661cB2114"
  },
  {
    pair: "EOS / USD",
    base: "EOS",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xd6285F06203D938ab713Fa6A315e7d23247DDE95"
  },
  {
    pair: "ENJ / USD",
    base: "ENJ",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x440A341bbC9FA86aA60A195e2409a547e48d4C0C"
  },
  {
    pair: "DOT / USD",
    base: "DOT",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xacb51F1a83922632ca02B25a8164c10748001BdE"
  },
  {
    pair: "DOGE / USD",
    base: "DOGE",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xbaf9327b6564454F4a3364C33eFeEf032b4b4444"
  },
  {
    pair: "DASH / USD",
    base: "DASH",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xD94427eDee70E4991b4b8DdCc848f2B58ED01C0b"
  },
  {
    pair: "DAI / USD",
    base: "DAI",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x4746DeC9e833A82EC7C2C1356372CcF2cfcD2F3D"
  },
  {
    pair: "COMP / USD",
    base: "COMP",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x2A8758b7257102461BC958279054e372C2b1bDE6"
  },
  {
    pair: "CHZ / USD",
    base: "CHZ",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x2409987e514Ad8B0973C2b90ee1D95051DF0ECB9"
  },
  {
    pair: "CEL / USD",
    base: "CEL",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xc9ECF45956f576681bDc01F79602A79bC2667B0c"
  },
  {
    pair: "CAD / USD",
    base: "CAD",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xACA44ABb8B04D07D883202F99FA5E3c53ed57Fb5"
  },
  {
    pair: "BUSD / USD",
    base: "BUSD",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xE0dC07D5ED74741CeeDA61284eE56a2A0f7A4Cc9"
  },
  {
    pair: "BTC / USD",
    base: "BTC",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xc907E116054Ad103354f2D350FD2514433D57F6f"
  },
  {
    pair: "BNT / USD",
    base: "BNT",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0xF5724884b6E99257cC003375e6b844bC776183f9"
  },
  {
    pair: "BNB / USD",
    base: "BNB",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x82a6c4AF830caa6c97bb504425f6A66165C2c26e"
  },
  {
    pair: "BCH / USD",
    base: "BCH",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x327d9822e9932996f55b39F557AEC838313da8b7"
  },
  {
    pair: "BAT / USD",
    base: "BAT",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x2346Ce62bd732c62618944E51cbFa09D985d86D2"
  },
  {
    pair: "AUD / USD",
    base: "AUD",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x062Df9C4efd2030e243ffCc398b652e8b8F95C6f"
  },
  {
    pair: "ALGO / USD",
    base: "ALGO",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x03Bc6D9EFed65708D35fDaEfb25E87631a0a3437"
  },
  {
    pair: "AED / USD",
    base: "AED",
    quote: "USD",
    deviation: 300,
    heartbeat: 27,
    dec: 8,
    address: "0x3fd911749Fce21a38704B76FFaBcB6BeF2567F2E"
  },
  {
    pair: "ADA / USD",
    base: "ADA",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x882554df528115a743c4537828DA8D5B58e52544"
  },
  {
    pair: "AAVE / USD",
    base: "AAVE",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x72484B12719E23115761D5DA1646945632979bB6"
  },
  {
    pair: "1INCH / USD",
    base: "1INCH",
    quote: "USD",
    deviation: 0,
    heartbeat: 27,
    dec: 8,
    address: "0x443C5116CdF663Eb387e72C688D276e702135C87"
  },
  {
    pair: "TRY / USD",
    base: "TRY",
    quote: "USD",
    deviation: 30,
    heartbeat: 60,
    dec: 8,
    address: "0xd78325DcA0F90F0FFe53cCeA1B02Bb12E1bf8FdB"
  },
  {
    pair: "SGD / USD",
    base: "SGD",
    quote: "USD",
    deviation: 10,
    heartbeat: 60,
    dec: 8,
    address: "0x8CE3cAc0E6635ce04783709ca3CC4F5fc5304299"
  },
  {
    pair: "XAG / USD",
    base: "XAG",
    quote: "USD",
    deviation: 30,
    heartbeat: 120,
    dec: 8,
    address: "0x461c7B8D370a240DdB46B402748381C3210136b3"
  },
  {
    pair: "GNS / USD",
    base: "GNS",
    quote: "USD",
    deviation: 50,
    heartbeat: 120,
    dec: 8,
    address: "0x9cb43aa3D036Cb035a694Ba0AAa91f8875B16cE1"
  },
  {
    pair: "WBTC / USD",
    base: "WBTC",
    quote: "USD",
    deviation: 10,
    heartbeat: 300,
    dec: 8,
    address: "0xDE31F8bFBD8c84b5360CFACCa3539B938dd78ae6"
  },
  {
    pair: "SLP / USD",
    base: "SLP",
    quote: "USD",
    deviation: 50,
    heartbeat: 300,
    dec: 8,
    address: "0xBB3eF70953fC3766bec4Ab7A9BF05B6E4caf89c6"
  },
  {
    pair: "OHMV2 / USD",
    base: "OHMV2",
    quote: "USD",
    deviation: 50,
    heartbeat: 300,
    dec: 8,
    address: "0x4cE90F28C6357A7d3F47D680723d18AF3684cD00"
  },
  {
    pair: "FIL / USD",
    base: "FIL",
    quote: "USD",
    deviation: 50,
    heartbeat: 300,
    dec: 8,
    address: "0xa07703E5C2eD1516107c7c72A494493Dcb99C676"
  },
  {
    pair: "DODO / USD",
    base: "DODO",
    quote: "USD",
    deviation: 50,
    heartbeat: 300,
    dec: 8,
    address: "0x59161117086a4C7A9beDA16C66e40Bdaa1C5a8B6"
  },
  {
    pair: "CRV / USD",
    base: "CRV",
    quote: "USD",
    deviation: 50,
    heartbeat: 300,
    dec: 8,
    address: "0x336584C8E6Dc19637A5b36206B1c79923111b405"
  },
  {
    pair: "AXS / USD",
    base: "AXS",
    quote: "USD",
    deviation: 50,
    heartbeat: 300,
    dec: 8,
    address: "0x9c371aE34509590E10aB98205d2dF5936A1aD875"
  },
  {
    pair: "ALCX / USD",
    base: "ALCX",
    quote: "USD",
    deviation: 50,
    heartbeat: 300,
    dec: 8,
    address: "0x5DB6e61B6159B20F068dc15A47dF2E5931b14f29"
  },
  {
    pair: "PLA / USD",
    base: "PLA",
    quote: "USD",
    deviation: 200,
    heartbeat: 43200,
    dec: 8,
    address: "0x24C0e0FC8cCb21e2fb3e1A8A4eC4b29458664f79"
  },
  {
    pair: "WOO / USD",
    base: "WOO",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x6a99EC84819FB7007dd5D032068742604E755c56"
  },
  {
    pair: "TSLA / USD",
    base: "TSLA",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x567E67f456c7453c583B6eFA6F18452cDee1F5a8"
  },
  {
    pair: "THB / USD",
    base: "THB",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0x5164Ad28fb12a5e55946090Ec3eE1B748AFb3785"
  },
  {
    pair: "SUSHI / USD",
    base: "SUSHI",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x49B0c695039243BBfEb8EcD054EB70061fd54aa0"
  },
  {
    pair: "STORJ / USD",
    base: "STORJ",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x0F1d5Bd7be9B30Fc09E110cd6504Bd450e53cb0E"
  },
  {
    pair: "SHIB / USD",
    base: "SHIB",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x3710abeb1A0Fc7C2EC59C26c8DAA7a448ff6125A"
  },
  {
    pair: "SEK / USD",
    base: "SEK",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xbd92B4919ae82be8473859295dEF0e778A626302"
  },
  {
    pair: "SE / USD",
    base: "SE",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xcc73e00db7a6FD589a30BbE2E957086b8d7D3331"
  },
  {
    pair: "SAND / USD",
    base: "SAND",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x3D49406EDd4D52Fb7FFd25485f32E073b529C924"
  },
  {
    pair: "RAI / USD",
    base: "RAI",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x7f45273fD7C644714825345670414Ea649b50b16"
  },
  {
    pair: "QUICK / USD",
    base: "QUICK",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xa058689f4bCa95208bba3F265674AE95dED75B6D"
  },
  {
    pair: "QNT / USD",
    base: "QNT",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xF7F291042F6Cbc4deC0Ad75c17786511a530dbe8"
  },
  {
    pair: "PLN / USD",
    base: "PLN",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xB34BCE11040702f71c11529D00179B2959BcE6C0"
  },
  {
    pair: "PHP / USD",
    base: "PHP",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0x218231089Bebb2A31970c3b77E96eCfb3BA006D1"
  },
  {
    pair: "OM / USD",
    base: "OM",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xc86105DccF9BD629Cea7Fd41f94c6050bF96D57F"
  },
  {
    pair: "OGN / USD",
    base: "OGN",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x8Ec0eC2e0F26D8253ABf39Db4B1793D76B49C6D5"
  },
  {
    pair: "NZD / USD",
    base: "NZD",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xa302a0B8a499fD0f00449df0a490DedE21105955"
  },
  {
    pair: "MXN / USD",
    base: "MXN",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x171b16562EA3476F5C61d1b8dad031DbA0768545"
  },
  {
    pair: "MSFT / USD",
    base: "MSFT",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xC43081d9EA6d1c53f1F0e525504d47Dd60de12da"
  },
  {
    pair: "MAI / USD",
    base: "MAI",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0xd8d483d813547CfB624b8Dc33a00F2fcbCd2D428"
  },
  {
    pair: "MIM / USD",
    base: "MIM",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xd133F916e04ed5D67b231183d85Be12eAA018320"
  },
  {
    pair: "KRW / USD",
    base: "KRW",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x24B820870F726dA9B0D83B0B28a93885061dbF50"
  },
  {
    pair: "KLAY / USD",
    base: "KLAY",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x86F87CB74238a6f24606534A2fCc05469Eb2bcF5"
  },
  {
    pair: "KAVA / USD",
    base: "KAVA",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x7899dd75C329eFe63e35b02bC7d60D3739FB23c5"
  },
  {
    pair: "JPY / USD",
    base: "JPY",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xD647a6fC9BC6402301583C91decC5989d8Bc382D"
  },
  {
    pair: "INR / USD",
    base: "INR",
    quote: "USD",
    deviation: 100,
    heartbeat: 86400,
    dec: 8,
    address: "0xDA0F8Df6F5dB15b346f4B8D1156722027E194E60"
  },
  {
    pair: "ILS / USD",
    base: "ILS",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x8d5eB34C509261533235b91350d359EdcB969D33"
  },
  {
    pair: "HBAR / USD",
    base: "HBAR",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xC5878bDf8a89FA3bF0DC8389ae8EE6DE601D01bC"
  },
  {
    pair: "GOOGL / USD",
    base: "GOOGL",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x1b32682C033b2DD7EFdC615FA82d353e254F39b5"
  },
  {
    pair: "GHST / USD",
    base: "GHST",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xDD229Ce42f11D8Ee7fFf29bDB71C7b81352e11be"
  },
  {
    pair: "FXS / USD",
    base: "FXS",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x6C0fe985D3cAcbCdE428b84fc9431792694d0f51"
  },
  {
    pair: "FTT / USD",
    base: "FTT",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x817A7D43f0277Ca480AE03Ec76Fc63A2EC7114bA"
  },
  {
    pair: "FTM / USD",
    base: "FTM",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x58326c0F831b2Dbf7234A4204F28Bba79AA06d5f"
  },
  {
    pair: "FRAX / USD",
    base: "FRAX",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x00DBeB1e45485d53DF7C2F0dF1Aa0b6Dc30311d3"
  },
  {
    pair: "FIS / USD",
    base: "FIS",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x18617D05eE1692Ad7EAFee9839459da16097AFd8"
  },
  {
    pair: "FB / USD",
    base: "FB",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x5b4586C911144A947D7814Fd71fe0872b8334748"
  },
  {
    pair: "FARM / USD",
    base: "FARM",
    quote: "USD",
    deviation: 200,
    heartbeat: 86400,
    dec: 8,
    address: "0xDFb138ba3A6CCe675A6F5961323Be31eE42E40ff"
  },
  {
    pair: "DGB / USD",
    base: "DGB",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x4205eC5fd179A843caa7B0860a8eC7D980013359"
  },
  {
    pair: "DFI / USD",
    base: "DFI",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x3CD95aB66D27736d09994c0555Ef488E496a81b2"
  },
  {
    pair: "CVX / USD",
    base: "CVX",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x5ec151834040B4D453A1eA46aA634C1773b36084"
  },
  {
    pair: "CNY / USD",
    base: "CNY",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x04bB437Aa63E098236FA47365f0268547f6EAB32"
  },
  {
    pair: "CHF / USD",
    base: "CHF",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0xc76f762CedF0F78a439727861628E0fdfE1e70c2"
  },
  {
    pair: "BRL / USD",
    base: "BRL",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xB90DA3ff54C3ED09115abf6FbA0Ff4645586af2c"
  },
  {
    pair: "BOND / USD",
    base: "BOND",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x58527C2dCC755297bB81f9334b80b2B6032d8524"
  },
  {
    pair: "BAL / USD",
    base: "BAL",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xD106B538F2A868c28Ca1Ec7E298C3325E0251d66"
  },
  {
    pair: "BADGER / USD",
    base: "BADGER",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xF626964Ba5e81405f47e8004F0b276Bb974742B5"
  },
  {
    pair: "AVAX / USD",
    base: "AVAX",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0xe01eA2fbd8D76ee323FbEd03eB9a8625EC981A10"
  },
  {
    pair: "APE / USD",
    base: "APE",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x2Ac3F3Bfac8fC9094BC3f0F9041a51375235B992"
  },
  {
    pair: "ANT / USD",
    base: "ANT",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x213b030E24C906ee3b98EC7538Cc6D3D3C82aF55"
  },
  {
    pair: "AMZN / USD",
    base: "AMZN",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0xf9184b8E5da48C19fA4E06f83f77742e748cca96"
  },
  {
    pair: "ALPHA / USD",
    base: "ALPHA",
    quote: "USD",
    deviation: 50,
    heartbeat: 86400,
    dec: 8,
    address: "0x289833F252eaB98582D62db94Bd75aB48AD9CF0D"
  },
  {
    pair: "AGEUR / USD",
    base: "AGEUR",
    quote: "USD",
    deviation: 10,
    heartbeat: 86400,
    dec: 8,
    address: "0x9b88d07B2354eF5f4579690356818e07371c7BeD"
  },
  {
    pair: "AAPL / USD",
    base: "AAPL",
    quote: "USD",
    deviation: 30,
    heartbeat: 86400,
    dec: 8,
    address: "0x7E7B45b08F68EC69A99AAb12e42FcCB078e10094"
  },
  {
    pair: "WSTETH / WETH",
    base: "WSTETH",
    quote: "WETH",
    deviation: 50,
    heartbeat: 86400,
    dec: 18,
    address: "0x10f964234cae09cB6a9854B56FF7D4F38Cda5E6a"
  },
  {
    pair: "MLN / WETH",
    base: "MLN",
    quote: "WETH",
    deviation: 50,
    heartbeat: 86400,
    dec: 18,
    address: "0xB89D583B72aBF9C3a7e6e093251C2fCad3365312"
  },
  {
    pair: "DPI / WETH",
    base: "DPI",
    quote: "WETH",
    deviation: 50,
    heartbeat: 86400,
    dec: 18,
    address: "0xC70aAF9092De3a4E5000956E672cDf5E996B4610"
  },
  {
    pair: "CBETH / WETH",
    base: "CBETH",
    quote: "WETH",
    deviation: 50,
    heartbeat: 86400,
    dec: 18,
    address: "0x0a6a03CdF7d0b48d4e4BA8e362A4FfC3aAC4f3c0"
  },
  {
    pair: "TRUMATIC / WMATIC",
    base: "TRUMATIC",
    quote: "WMATIC",
    deviation: 50,
    heartbeat: 86400,
    dec: 18,
    address: "0x30BadC453d20b520E0Ed98fce6Ba1AC5876cF1e5"
  }
];
var polygonGraph = new CurrencyGraph();
chainlinkFeeds3.forEach(({ base, quote }) => polygonGraph.addPair(base, quote));
var polygonPairs = Object.fromEntries(Object.values(chainlinkFeeds3).map((x) => [x.pair, x]));

// src/price-tracker/feeds/common.ts
var CHAINS_ARRAY = ["arbitrum", "polygon", "mainnet"];
function getPathForPair(chain, base, quote, failOnNoPath = true) {
  const [graph, pairMap] = chainlink(chain);
  const path = graph.findPath(base, quote) || [];
  const pairs = [];
  for (let i = 0; i < path.length - 1; i++) {
    let pair = `${path[i]} / ${path[i + 1]}`;
    if (pairMap[pair]) {
      pairs.push(pairMap[pair]);
      continue;
    }
    pair = `${path[i + 1]} / ${path[i]}`;
    if (pairMap[pair]) {
      pairs.push(pairMap[pair]);
      continue;
    }
    if (failOnNoPath)
      throw new Error(`No valid pair found for ${path[i]} and ${path[i + 1]}`);
  }
  return pairs;
}
var chainlink = (chain) => {
  switch (chain) {
    case "arbitrum":
      return [arbitrumGraph, arbitrumPairs];
    case "polygon":
      return [polygonGraph, polygonPairs];
    case "mainnet":
      return [mainnetGraph, mainnetPairs];
  }
};
var getBestPathForPair = (base, quote) => {
  const normalize = (value, min2, max2) => {
    return (value - min2) / (max2 - min2);
  };
  const scorePath = (path) => {
    const normalizedHeartbeat = 1 - normalize(path.heartbeat, 0, 3 * 24 * 60 * 60);
    const normalizedDeviation = 1 - normalize(path.deviation, 5, 500);
    const score = normalizedHeartbeat * 0.4 + normalizedDeviation * 0.6;
    return score;
  };
  const paths = CHAINS_ARRAY.map((chain) => {
    const path = getPathForPair(chain, base, quote, false);
    return { path, chain };
  }).filter((path) => path.path.length > 0).map(({ path, chain }) => {
    const heartbeat = path.length > 0 ? path.reduce((acc, item) => acc + item.heartbeat, 0) : Number.MAX_SAFE_INTEGER;
    const deviation = path.length > 0 ? path.reduce((acc, item) => acc + item.deviation, 0) : Number.MAX_SAFE_INTEGER;
    return { chain, path, heartbeat, deviation };
  }).sort((path1, path2) => scorePath(path2) - scorePath(path1));
  if (paths.length === 0)
    throw new Error(`No valid path found for ${base} and ${quote}`);
  return paths[0];
};

// src/price-tracker/helpers.ts
function derivePrice(pair1, pair2) {
  const baseUnit = BigInt(10 ** pair1.dec);
  const quoteUnit = BigInt(10 ** pair2.dec);
  if (pair1.quote === pair2.base) {
    return {
      base: pair1.base,
      quote: pair2.quote,
      latestPrice: mulDiv(pair1.latestPrice, pair2.latestPrice, quoteUnit),
      dec: pair1.dec
    };
  }
  if (pair1.base === pair2.quote) {
    return {
      base: pair1.quote,
      quote: pair2.base,
      latestPrice: mulDiv(baseUnit, quoteUnit, mulDiv(pair1.latestPrice, pair2.latestPrice, quoteUnit)),
      dec: pair2.dec
    };
  }
  if (pair1.base === pair2.base) {
    return {
      base: pair1.quote,
      quote: pair2.quote,
      latestPrice: mulDiv(baseUnit, quoteUnit, mulDiv(pair1.latestPrice, quoteUnit, pair2.latestPrice)),
      dec: pair2.dec
    };
  }
  if (pair1.quote === pair2.quote) {
    return {
      base: pair1.base,
      quote: pair2.base,
      latestPrice: mulDiv(pair1.latestPrice, quoteUnit, pair2.latestPrice),
      dec: pair1.dec
    };
  }
  throw new Error(`Cannot combine ${pair1.base}/${pair1.quote} and ${pair2.base}/${pair2.quote}`);
}
var modifyPrecision = (value, from, to) => {
  return value * 10n ** to / 10n ** from;
};

// src/price-tracker/main.ts
var queryMarkPrices = async (publicClientFn, base, quote, { fromBlock, toBlock = MAX_INT256, toDecimals }, chain) => {
  const { path, chain: _chain } = chain ? { path: getPathForPair(chain, base, quote), chain } : getBestPathForPair(base, quote);
  const publicClient = publicClientFn(_chain);
  const initial = await Promise.all(
    path.map(async ({ address, dec, base: base2, quote: quote2 }) => {
      const chainlink2 = getContract({
        abi: aggregatorV2V3InterfaceABI,
        publicClient,
        address
      });
      const aggregator = (await chainlink2.read.aggregator({ blockNumber: fromBlock }).catch((err) => {
        err.additionalInfo = `blockNumber: ${fromBlock}`;
        throw err;
      })).toLowerCase();
      const [, latestPrice, , updatedAt] = await chainlink2.read.latestRoundData({ blockNumber: fromBlock }).catch((err) => {
        err.additionalInfo = `blockNumber: ${fromBlock}`;
        throw err;
      });
      return { aggregator, latestPrice, updatedAt, dec, base: base2, quote: quote2 };
    })
  );
  const [{ updatedAt: startingTimestamp }] = [...initial].sort((a, b) => Number(b.updatedAt) - Number(a.updatedAt));
  const currentBlock = await publicClient.getBlockNumber();
  const maxBlock = min(currentBlock, toBlock);
  const logs = await publicClient.getContractEvents({
    abi: aggregatorV2V3InterfaceABI,
    address: initial.map((x) => x.aggregator),
    eventName: "AnswerUpdated",
    fromBlock: min(fromBlock, currentBlock),
    toBlock: maxBlock,
    strict: true
  });
  const latestMap = Object.fromEntries(initial.map((x) => [x.aggregator, { ...x, blockNumber: 0n }]));
  const arr = logs.map((x) => {
    const { current, updatedAt } = x.args;
    return { latestPrice: current, updatedAt, aggregator: x.address.toLowerCase(), blockNumber: x.blockNumber };
  }).filter((x) => x.updatedAt >= startingTimestamp);
  const prices = {};
  for (const item of arr) {
    const existingItem = latestMap[item.aggregator];
    if (existingItem) {
      latestMap[item.aggregator] = { ...existingItem, latestPrice: item.latestPrice };
      const [first, ...rest] = Object.values(latestMap);
      const price = rest.reduce((acc, curr) => derivePrice(acc, curr), first);
      const blockNumber = Number(item.blockNumber);
      const timestamp = Number(item.updatedAt);
      const newPriceEntry = {
        blockNumber,
        timestamp,
        instrument: `${base}${quote}`,
        markPrice: modifyPrecision(price.latestPrice, BigInt(price.dec), toDecimals),
        dec: toDecimals
      };
      prices[timestamp] = newPriceEntry;
    } else
      throw new Error(`got unexpected aggregator address: ${item.aggregator}`);
  }
  return Object.values(prices);
};
export {
  CashflowCurrency,
  ContangoSDK,
  MoneyMarket,
  Side,
  absolute,
  aggregatorV2V3InterfaceABI,
  applySlippage,
  asHex,
  calculateAPR,
  calculateClosingFee,
  calculateCollateralAndDebtValuesByCashflow,
  calculateCollateralAndDebtValuesByDebtDelta,
  calculateCollateralAndDebtValuesByLeverage,
  calculateEquity,
  calculateFee,
  calculateLeverage,
  calculateLiquidationPrice,
  calculateMarginLeverage,
  calculateMarkPrice,
  calculateMinEquity,
  calculateSwapAmount,
  calculateValue,
  chainlinkAggregatorV2V3MockABI,
  contangoABI,
  createLiquidityBuffer,
  defaultLeverage,
  deriveQuoteValuesQtyCashflowPure,
  deriveQuoteValuesQtyLeveragePure,
  deriveSwap,
  exactlyReverseLookupABI,
  exactlyReverseLookupEventsABI,
  fixedFeeModelABI,
  getBestPathForPair,
  getContangoProxy,
  getDisplayMoneyMarketName,
  getMaestroProxy,
  getMoneyMarketName,
  iAaveOracleABI,
  iExactlyMarketABI,
  iExactlyPreviewerABI,
  iFlashBorrowProviderABI,
  iMoneyMarketABI,
  iMoneyMarketViewABI,
  iOrderManagerABI,
  iOrderManagerErrorsABI,
  iOrderManagerEventsABI,
  iPermit2ABI,
  iPoolAddressesProviderABI,
  iSwapRouterABI,
  iUnderlyingPositionFactoryABI,
  iUnderlyingPositionFactoryEventsABI,
  iUniswapQuoterABI,
  iUniswapV3SwapCallbackABI,
  ierc20MetadataABI,
  ierc20PermitABI,
  ierc7399ABI,
  isBase,
  isPerp,
  isWrappedNative,
  loadAddress,
  maestroABI,
  mapArgs,
  max,
  min,
  mulDiv,
  ordersAdded$,
  ordersRemoved$,
  positionActionsABI,
  positionIdMapper,
  positionStatusPure,
  positionUpsert$,
  queryMarkPrices,
  quoteSwap,
  rewardsClaimed$,
  swapRouter02ABI,
  toBaseOrQuote,
  tsQuoterABI,
  uniswapPoolStubABI,
  uniswapV3FactoryABI,
  uniswapV3PoolABI
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
/** @preserve
 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
 * derived from CryptoJS.mode.CTR
 * Jan Hruby jhruby.web@gmail.com
 */
//# sourceMappingURL=contango-sdk.js.map
